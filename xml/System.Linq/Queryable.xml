<Type Name="Queryable" FullName="System.Linq.Queryable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fbdcf4cf9c5738a869ff7c8e13d2562640a97eb1" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65006725" /></Metadata><TypeSignature Language="C#" Value="public static class Queryable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Queryable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Queryable" />
  <TypeSignature Language="VB.NET" Value="Public Module Queryable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Queryable abstract sealed" />
  <TypeSignature Language="F#" Value="type Queryable = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Queryable</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit un ensemble de <see langword="static" /> (<see langword="Shared" /> en Visual Basic) méthodes permettant d’interroger des structures de données qui implémentent <see cref="T:System.Linq.IQueryable`1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ensemble de méthodes déclarées dans le <xref:System.Linq.Queryable> classe fournit une implémentation des opérateurs de requête standard pour interroger des données sources qui implémentent <xref:System.Linq.IQueryable%601>. Les opérateurs de requête standard sont des méthodes à usage général qui suivent le [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] de modèle et vous permettent d’exprimer des opérations de parcours, de filtre et de projection sur les données dans les. Langage de programmation NET.  
  
 La plupart des méthodes dans cette classe sont définies en tant que méthodes d’extension qui étendent le <xref:System.Linq.IQueryable%601> type. Cela signifie qu’ils peuvent être appelées comme une méthode d’instance sur n’importe quel objet qui implémente <xref:System.Linq.IQueryable%601>. Ces méthodes qui étendent <xref:System.Linq.IQueryable%601> n’effectuent pas d’interrogations directement. Au lieu de cela, leur fonctionnalité consiste à créer un <xref:System.Linq.Expressions.Expression> objet, qui est une arborescence d’expression qui représente la requête cumulative. Les méthodes passent ensuite la nouvelle arborescence d’expression soit le <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode ou le <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de l’entrée <xref:System.Linq.IQueryable%601>. La méthode est appelée varie selon que le <xref:System.Linq.Queryable> méthode retourne une valeur singleton, auquel cas <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> est appelée, ou a des résultats énumérables, auquel cas <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> est appelée.  
  
 L’exécution de la requête réelle sur les données cibles est effectuée par une classe qui implémente <xref:System.Linq.IQueryable%601>. L’attente de n’importe quel <xref:System.Linq.IQueryable%601> implémentation qui est le résultat de l’exécution d’une arborescence d’expression qui a été construite par un <xref:System.Linq.Queryable> méthode d’opérateur de requête standard est équivalente au résultat de l’appel de la méthode correspondante dans la <xref:System.Linq.Enumerable> classe, si la source de données ont été une <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Outre les méthodes d’opérateur de requête standard qui opèrent sur <xref:System.Linq.IQueryable%601> objets, cette classe contient également une méthode, <xref:System.Linq.Queryable.AsQueryable%2A>, les types <xref:System.Collections.IEnumerable> objets en tant que <xref:System.Linq.IQueryable> objets.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/a73c4aec-5d15-4e98-b962-1274021ea93d">LINQ (Language Integrated Query)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/24cda21e-8af8-4632-b519-c404a839b9b2">Vue d’ensemble des opérateurs de requête standard</related>
    <related type="Article" href="https://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b">Arborescences de l’expression</related>
    <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ to SQL</related>
  </Docs>
  <Members>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TSource,TSource&gt;&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt;&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Aggregate``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``0,``0}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource) (source As IQueryable(Of TSource), func As Expression(Of Func(Of TSource, TSource, TSource))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Aggregate(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TSource, TSource&gt; ^&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Source, 'Source&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Aggregate (source, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TSource,TSource&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Séquence à regrouper.</param>
        <param name="func">Fonction d’accumulation à appliquer à chaque élément.</param>
        <summary>Applique une fonction d’accumulation sur une séquence.</summary>
        <returns>Valeur d'accumulation finale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est que la fonction spécifiée, `func`, est appliqué à chaque valeur dans la séquence source et le cumul valeur est retournée. La première valeur dans `source` est utilisé en tant que la valeur de départ pour la valeur cumulée, qui correspond au premier paramètre dans `func`.  
  
 Pour simplifier les opérations d’agrégation courantes, le jeu d’opérateurs de requête standard inclut également deux méthodes de comptage, <xref:System.Linq.Queryable.Count%2A> et <xref:System.Linq.Queryable.LongCount%2A>et quatre méthodes d’agrégation numériques, à savoir <xref:System.Linq.Queryable.Max%2A>, <xref:System.Linq.Queryable.Min%2A>, <xref:System.Linq.Queryable.Sum%2A>et <xref:System.Linq.Queryable.Average%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> pour générer une phrase à partir d’un tableau de chaînes.  
  
 [!code-csharp[System.Linq.Queryable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#1)]
 [!code-vb[System.Linq.Queryable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="func" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> ne contient aucun élément.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TAccumulate seed, System.Linq.Expressions.Expression&lt;Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt;&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Aggregate``2(System.Linq.IQueryable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate) (source As IQueryable(Of TSource), seed As TAccumulate, func As Expression(Of Func(Of TAccumulate, TSource, TAccumulate))) As TAccumulate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TAccumulate Aggregate(System::Linq::IQueryable&lt;TSource&gt; ^ source, TAccumulate seed, System::Linq::Expressions::Expression&lt;Func&lt;TAccumulate, TSource, TAccumulate&gt; ^&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.IQueryable&lt;'Source&gt; * 'Accumulate * System.Linq.Expressions.Expression&lt;Func&lt;'Accumulate, 'Source, 'Accumulate&gt;&gt; -&gt; 'Accumulate" Usage="System.Linq.Queryable.Aggregate (source, seed, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Type de la valeur d'accumulation.</typeparam>
        <param name="source">Séquence à regrouper.</param>
        <param name="seed">Valeur d'accumulation initiale.</param>
        <param name="func">Fonction d’accumulation à appeler sur chaque élément.</param>
        <summary>Applique une fonction d’accumulation sur une séquence. La valeur initiale spécifiée est utilisée comme valeur d'accumulation initiale.</summary>
        <returns>Valeur d'accumulation finale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est que la fonction spécifiée, `func`, est appliqué à chaque valeur dans la séquence source et le cumul valeur est retournée. Le `seed` paramètre est utilisé en tant que la valeur de départ pour la valeur cumulée, qui correspond au premier paramètre dans `func`.  
  
 Pour simplifier les opérations d’agrégation courantes, le jeu d’opérateurs de requête standard inclut également deux méthodes de comptage, <xref:System.Linq.Queryable.Count%2A> et <xref:System.Linq.Queryable.LongCount%2A>et quatre méthodes d’agrégation numériques, à savoir <xref:System.Linq.Queryable.Max%2A>, <xref:System.Linq.Queryable.Min%2A>, <xref:System.Linq.Queryable.Sum%2A>et <xref:System.Linq.Queryable.Average%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> pour appliquer une fonction d’accumulation lorsqu’une valeur de départ est fournie à la fonction.  
  
 [!code-csharp[System.Linq.Queryable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#2)]
 [!code-vb[System.Linq.Queryable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="func" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TAccumulate seed, System.Linq.Expressions.Expression&lt;Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt; func, System.Linq.Expressions.Expression&lt;Func&lt;TAccumulate,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt;&gt; func, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TAccumulate, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Aggregate``3(System.Linq.IQueryable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As IQueryable(Of TSource), seed As TAccumulate, func As Expression(Of Func(Of TAccumulate, TSource, TAccumulate)), selector As Expression(Of Func(Of TAccumulate, TResult))) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Linq::IQueryable&lt;TSource&gt; ^ source, TAccumulate seed, System::Linq::Expressions::Expression&lt;Func&lt;TAccumulate, TSource, TAccumulate&gt; ^&gt; ^ func, System::Linq::Expressions::Expression&lt;Func&lt;TAccumulate, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.IQueryable&lt;'Source&gt; * 'Accumulate * System.Linq.Expressions.Expression&lt;Func&lt;'Accumulate, 'Source, 'Accumulate&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Accumulate, 'Result&gt;&gt; -&gt; 'Result" Usage="System.Linq.Queryable.Aggregate (source, seed, func, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt;" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TAccumulate,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Type de la valeur d'accumulation.</typeparam>
        <typeparam name="TResult">Type de la valeur résultante.</typeparam>
        <param name="source">Séquence à regrouper.</param>
        <param name="seed">Valeur d'accumulation initiale.</param>
        <param name="func">Fonction d’accumulation à appeler sur chaque élément.</param>
        <param name="selector">Fonction permettant de transformer la valeur d'accumulation finale en valeur de résultat.</param>
        <summary>Applique une fonction d’accumulation sur une séquence. La valeur initiale spécifiée est utilisée comme valeur d'accumulation initiale et la fonction spécifiée permet de sélectionner la valeur de résultat.</summary>
        <returns>Valeur d'accumulation finale transformée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est que la fonction spécifiée, `func`, est appliqué à chaque valeur dans la séquence source et le cumul valeur est retournée. Le `seed` paramètre est utilisé en tant que la valeur de départ pour la valeur cumulée, qui correspond au premier paramètre dans `func`. La dernière valeur cumulée est passée à `selector` pour obtenir la valeur de résultat.  
  
 Pour simplifier les opérations d’agrégation courantes, le jeu d’opérateurs de requête standard inclut également deux méthodes de comptage, <xref:System.Linq.Queryable.Count%2A> et <xref:System.Linq.Queryable.LongCount%2A>et quatre méthodes d’agrégation numériques, à savoir <xref:System.Linq.Queryable.Max%2A>, <xref:System.Linq.Queryable.Min%2A>, <xref:System.Linq.Queryable.Sum%2A>et <xref:System.Linq.Queryable.Average%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> pour appliquer une fonction d’accumulation et un sélecteur de résultat.  
  
 [!code-csharp[System.Linq.Queryable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#3)]
 [!code-vb[System.Linq.Queryable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="func" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.All``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool All(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member All : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; bool" Usage="System.Linq.Queryable.All (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Séquence dont les éléments pour tester une condition.</param>
        <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
        <summary>Détermine si tous les éléments d’une séquence remplissent une condition.</summary>
        <returns><see langword="true" /> Si tous les éléments de la séquence source réussissent le test dans le prédicat spécifié, ou si la séquence est vide. Sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> dépend de l’implémentation de la `source` type du paramètre. Le comportement attendu est qu’il détermine si tous les éléments de `source` satisfont la condition dans `predicate`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> pour déterminer si tous les éléments d’une séquence remplissent une condition.  
  
 [!code-csharp[System.Linq.Queryable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#4)]
 [!code-vb[System.Linq.Queryable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#4)]  
  
 La valeur booléenne qui le <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> méthode retourne est généralement utilisée dans le prédicat d’une `where` clause (`Where` clause en Visual Basic) ou un appel direct à la <xref:System.Linq.Queryable.Where%2A> (méthode). L’exemple suivant illustre cette utilisation de la `All` (méthode).  
  
 [!code-csharp[System.Linq.Queryable#134](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#134)]
 [!code-vb[System.Linq.Queryable#134](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#134)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Any&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si un élément d’un <see cref="T:System.Linq.IQueryable`1" /> séquence existent ou satisfont à une condition.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Any``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IQueryable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Any : System.Linq.IQueryable&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.Any source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Séquence à vérifier pour y détecter vide.</param>
        <summary>Détermine si une séquence contient des éléments.</summary>
        <returns><see langword="true" /> Si la séquence source contient des éléments ; Sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il détermine si `source` contient des éléments.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> pour déterminer si une séquence contient des éléments.  
  
 [!code-csharp[System.Linq.Queryable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#5)]
 [!code-vb[System.Linq.Queryable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#5)]  
  
 La valeur booléenne qui le <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode retourne est généralement utilisée dans le prédicat d’une `where` clause (`Where` clause en Visual Basic) ou un appel direct à la <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> (méthode). L’exemple suivant illustre cette utilisation de la `Any` (méthode).  
  
 [!code-csharp[System.Linq.Queryable#135](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#135)]
 [!code-vb[System.Linq.Queryable#135](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#135)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Any``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Any : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; bool" Usage="System.Linq.Queryable.Any (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Séquence dont les éléments pour tester une condition.</param>
        <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
        <summary>Détermine si des éléments d’une séquence satisfont à une condition.</summary>
        <returns><see langword="true" /> Si tous les éléments dans la séquence source réussissent le test dans le prédicat spécifié ; Sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il détermine si un des éléments de `source` satisfont la condition spécifiée par `predicate`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> pour déterminer si des éléments d’une séquence satisfont à une condition.  
  
 [!code-csharp[System.Linq.Queryable#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#6)]
 [!code-vb[System.Linq.Queryable#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Append&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Append&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Append``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource) (source As IQueryable(Of TSource), element As TSource) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Append(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Append : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Append (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="element" Type="TSource" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsQueryable">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable AsQueryable (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable AsQueryable(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.AsQueryable(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsQueryable (source As IEnumerable) As IQueryable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable ^ AsQueryable(System::Collections::IEnumerable ^ source);" />
      <MemberSignature Language="F#" Value="static member AsQueryable : System.Collections.IEnumerable -&gt; System.Linq.IQueryable" Usage="System.Linq.Queryable.AsQueryable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Séquence à convertir.</param>
        <summary>Convertit un <see cref="T:System.Collections.IEnumerable" /> à un <see cref="T:System.Linq.IQueryable" />.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable" /> qui représente la séquence d’entrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le type de `source` implémente <xref:System.Linq.IQueryable%601>, <xref:System.Linq.Queryable.AsQueryable%28System.Collections.IEnumerable%29> retourne directement. Sinon, elle retourne un <xref:System.Linq.IQueryable%601> qui exécute des requêtes en appelant des méthodes d’opérateur dans la requête équivalente <xref:System.Linq.Enumerable> au lieu de celles dans <xref:System.Linq.Queryable>.  
  
 Cette méthode suppose que `source` implémente <xref:System.Collections.Generic.IEnumerable%601> pour certaines `T`. Lors de l’exécution, le résultat est de type <xref:System.Linq.IQueryable%601> pour le même `T`. Cette méthode est utile dans les scénarios dynamiques lorsque vous ne connaissez pas statiquement le type de `T`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> n’implémente pas <see cref="T:System.Collections.Generic.IEnumerable`1" /> pour certaines <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsQueryable&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TElement&gt; AsQueryable&lt;TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TElement&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TElement&gt; AsQueryable&lt;TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.AsQueryable``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsQueryable(Of TElement) (source As IEnumerable(Of TElement)) As IQueryable(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TElement&gt; ^ AsQueryable(System::Collections::Generic::IEnumerable&lt;TElement&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsQueryable : seq&lt;'Element&gt; -&gt; System.Linq.IQueryable&lt;'Element&gt;" Usage="System.Linq.Queryable.AsQueryable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TElement&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TElement">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Séquence à convertir.</param>
        <summary>Convertit un générique <see cref="T:System.Collections.Generic.IEnumerable`1" /> générique <see cref="T:System.Linq.IQueryable`1" />.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui représente la séquence d’entrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le type de `source` implémente <xref:System.Linq.IQueryable%601>, <xref:System.Linq.Queryable.AsQueryable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> retourne directement. Sinon, elle retourne un <xref:System.Linq.IQueryable%601> qui exécute des requêtes en appelant des méthodes d’opérateur dans la requête équivalente <xref:System.Linq.Enumerable> au lieu de celles dans <xref:System.Linq.Queryable>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.AsQueryable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> pour convertir un <xref:System.Collections.Generic.IEnumerable%601> à un <xref:System.Linq.IQueryable%601>.  
  
 [!code-csharp[System.Linq.Queryable#125](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#125)]
 [!code-vb[System.Linq.Queryable#125](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#125)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Average">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcule la moyenne d'une séquence de valeurs numériques.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Linq.IQueryable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Linq.IQueryable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Linq::IQueryable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de <see cref="T:System.Decimal" /> valeurs pour calculer la moyenne de.</param>
        <summary>Calcule la moyenne d’une séquence de <see cref="T:System.Decimal" /> valeurs.</summary>
        <returns>Moyenne de la séquence de valeurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> lui-même. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> pour calculer la moyenne d’une séquence de valeurs.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> ne contient aucun élément.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.IQueryable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.IQueryable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;double&gt; -&gt; double" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de <see cref="T:System.Double" /> valeurs pour calculer la moyenne de.</param>
        <summary>Calcule la moyenne d’une séquence de <see cref="T:System.Double" /> valeurs.</summary>
        <returns>Moyenne de la séquence de valeurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Double%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Double%7D%29> lui-même. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Double%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> pour calculer la moyenne d’une séquence de valeurs.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> ne contient aucun élément.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.IQueryable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.IQueryable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;int&gt; -&gt; double" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de <see cref="T:System.Int32" /> valeurs pour calculer la moyenne de.</param>
        <summary>Calcule la moyenne d’une séquence de <see cref="T:System.Int32" /> valeurs.</summary>
        <returns>Moyenne de la séquence de valeurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> lui-même. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> pour calculer la moyenne d’une séquence de valeurs.  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> ne contient aucun élément.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.IQueryable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.IQueryable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;int64&gt; -&gt; double" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de <see cref="T:System.Int64" /> valeurs pour calculer la moyenne de.</param>
        <summary>Calcule la moyenne d’une séquence de <see cref="T:System.Int64" /> valeurs.</summary>
        <returns>Moyenne de la séquence de valeurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int64%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int64%7D%29> lui-même. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int64%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> pour calculer la moyenne d’une séquence de valeurs.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> ne contient aucun élément.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de valeurs <see cref="T:System.Decimal" /> de type Null dont il faut calculer la moyenne.</param>
        <summary>Calcule la moyenne d’une séquence de valeurs <see cref="T:System.Decimal" /> de type Null.</summary>
        <returns>La moyenne de la séquence de valeurs, ou <see langword="null" /> si la séquence source est vide ou contient uniquement des valeurs <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> lui-même. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> pour calculer la moyenne d’une séquence de valeurs.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de valeurs <see cref="T:System.Double" /> de type Null dont il faut calculer la moyenne.</param>
        <summary>Calcule la moyenne d’une séquence de valeurs <see cref="T:System.Double" /> de type Null.</summary>
        <returns>La moyenne de la séquence de valeurs, ou <see langword="null" /> si la séquence source est vide ou contient uniquement des valeurs <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> lui-même. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> pour calculer la moyenne d’une séquence de valeurs.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de valeurs <see cref="T:System.Int32" /> de type Null dont il faut calculer la moyenne.</param>
        <summary>Calcule la moyenne d’une séquence de valeurs <see cref="T:System.Int32" /> de type Null.</summary>
        <returns>La moyenne de la séquence de valeurs, ou <see langword="null" /> si la séquence source est vide ou contient uniquement des valeurs <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> lui-même. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> pour calculer la moyenne d’une séquence de valeurs.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de valeurs <see cref="T:System.Int64" /> de type Null dont il faut calculer la moyenne.</param>
        <summary>Calcule la moyenne d’une séquence de valeurs <see cref="T:System.Int64" /> de type Null.</summary>
        <returns>La moyenne de la séquence de valeurs, ou <see langword="null" /> si la séquence source est vide ou contient uniquement des valeurs <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> lui-même. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> pour calculer la moyenne d’une séquence de valeurs.  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de valeurs <see cref="T:System.Single" /> de type Null dont il faut calculer la moyenne.</param>
        <summary>Calcule la moyenne d’une séquence de valeurs <see cref="T:System.Single" /> de type Null.</summary>
        <returns>La moyenne de la séquence de valeurs, ou <see langword="null" /> si la séquence source est vide ou contient uniquement des valeurs <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> lui-même. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> pour calculer la moyenne d’une séquence de valeurs.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Linq.IQueryable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Linq.IQueryable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Linq::IQueryable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;single&gt; -&gt; single" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de <see cref="T:System.Single" /> valeurs pour calculer la moyenne de.</param>
        <summary>Calcule la moyenne d’une séquence de <see cref="T:System.Single" /> valeurs.</summary>
        <returns>Moyenne de la séquence de valeurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Single%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Single%7D%29> lui-même. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Single%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> pour calculer la moyenne d’une séquence de valeurs.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> ne contient aucun élément.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Decimal))) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Decimal&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, decimal&gt;&gt; -&gt; decimal" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Séquence de valeurs utilisées pour calculer une moyenne.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la moyenne d’une séquence de <see cref="T:System.Decimal" /> les valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>Moyenne de la séquence de valeurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source` après avoir appelé `selector` sur chaque valeur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> pour calculer la moyenne <xref:System.String> longueur d’une séquence de valeurs de type <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> ne contient aucun élément.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Double))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, double&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, double&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs pour calculer la moyenne de.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la moyenne d’une séquence de <see cref="T:System.Double" /> les valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>Moyenne de la séquence de valeurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source` après avoir appelé `selector` sur chaque valeur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> pour calculer la moyenne <xref:System.String> longueur d’une séquence de valeurs de type <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> ne contient aucun élément.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs pour calculer la moyenne de.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la moyenne d’une séquence de <see cref="T:System.Int32" /> les valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>Moyenne de la séquence de valeurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source` après avoir appelé `selector` sur chaque valeur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> pour calculer la moyenne <xref:System.String> longueur d’une séquence de valeurs de type <xref:System.String>.  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> ne contient aucun élément.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Long))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, long&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int64&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs pour calculer la moyenne de.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la moyenne d’une séquence de <see cref="T:System.Int64" /> les valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>Moyenne de la séquence de valeurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source` après avoir appelé `selector` sur chaque valeur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> pour calculer la moyenne <xref:System.String> longueur d’une séquence de valeurs de type <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> ne contient aucun élément.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;decimal&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Decimal)))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;decimal&gt;&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs pour calculer la moyenne de.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la moyenne d’une séquence de nullable <see cref="T:System.Decimal" /> valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>La moyenne de la séquence de valeurs, ou <see langword="null" /> si le <paramref name="source" /> séquence est vide ou contient uniquement <see langword="null" /> valeurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source` après avoir appelé `selector` sur chaque valeur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> pour calculer la moyenne <xref:System.String> longueur d’une séquence de valeurs de type <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;double&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Double)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;double&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;double&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs pour calculer la moyenne de.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la moyenne d’une séquence de nullable <see cref="T:System.Double" /> valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>La moyenne de la séquence de valeurs, ou <see langword="null" /> si le <paramref name="source" /> séquence est vide ou contient uniquement <see langword="null" /> valeurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source` après avoir appelé `selector` sur chaque valeur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> pour calculer la moyenne <xref:System.String> longueur d’une séquence de valeurs de type <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;int&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Integer)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;int&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs pour calculer la moyenne de.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la moyenne d’une séquence de nullable <see cref="T:System.Int32" /> valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>La moyenne de la séquence de valeurs, ou <see langword="null" /> si le <paramref name="source" /> séquence est vide ou contient uniquement <see langword="null" /> valeurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source` après avoir appelé `selector` sur chaque valeur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> pour calculer la moyenne <xref:System.String> longueur d’une séquence de valeurs de type <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;long&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Long)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;long&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int64&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs pour calculer la moyenne de.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la moyenne d’une séquence de nullable <see cref="T:System.Int64" /> valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>La moyenne de la séquence de valeurs, ou <see langword="null" /> si le <paramref name="source" /> séquence est vide ou contient uniquement <see langword="null" /> valeurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source` après avoir appelé `selector` sur chaque valeur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> pour calculer la moyenne <xref:System.String> longueur d’une séquence de valeurs de type <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;float&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Single)))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;float&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;single&gt;&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs pour calculer la moyenne de.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la moyenne d’une séquence de nullable <see cref="T:System.Single" /> valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>La moyenne de la séquence de valeurs, ou <see langword="null" /> si le <paramref name="source" /> séquence est vide ou contient uniquement <see langword="null" /> valeurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source` après avoir appelé `selector` sur chaque valeur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> pour calculer la moyenne <xref:System.String> longueur d’une séquence de valeurs de type <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Single))) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, float&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, single&gt;&gt; -&gt; single" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs pour calculer la moyenne de.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la moyenne d’une séquence de <see cref="T:System.Single" /> les valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>Moyenne de la séquence de valeurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il calcule la moyenne des valeurs dans `source` après avoir appelé `selector` sur chaque valeur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> pour calculer la moyenne <xref:System.String> longueur d’une séquence de valeurs de type <xref:System.String>.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> ne contient aucun élément.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Linq.IQueryable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Linq.IQueryable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Cast``1(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Cast(Of TResult) (source As IQueryable) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Cast(System::Linq::IQueryable ^ source);" />
      <MemberSignature Language="F#" Value="static member Cast : System.Linq.IQueryable -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Cast source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Le type vers lequel convertir les éléments de <paramref name="source" /> à.</typeparam>
        <param name="source">Le <see cref="T:System.Linq.IQueryable" /> qui contient les éléments à convertir.</param>
        <summary>Convertit les éléments d’un objet <see cref="T:System.Linq.IQueryable" /> vers le type spécifié.</summary>
        <returns>Objet <see cref="T:System.Linq.IQueryable`1" /> qui contient chaque élément de la séquence source convertie vers le type spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il convertit les valeurs dans `source` à taper `TResult`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> pour convertir des objets dans une séquence en type <xref:System.String>.  
  
 [!code-csharp[System.Linq.Queryable#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#19)]
 [!code-vb[System.Linq.Queryable#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Un élément dans la séquence ne peut pas être casté en type <paramref name="TResult" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Concat``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concat(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Concat(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Concat : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Concat (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
        <param name="source1">Première séquence à concaténer.</param>
        <param name="source2">Séquence à concaténer à la première séquence.</param>
        <summary>Concatène deux séquences.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments concaténés des deux séquences d’entrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source1` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source1` paramètre. Le comportement attendu est que les éléments de `source2` sont concaténés à ceux de `source1` pour créer une nouvelle séquence.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> pour concaténer deux séquences.  
  
 [!code-csharp[System.Linq.Queryable#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#20)]
 [!code-vb[System.Linq.Queryable#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> ou <paramref name="source2" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si un <see cref="T:System.Linq.IQueryable`1" /> contient un élément spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Contains``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IQueryable(Of TSource), item As TSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource item);" />
      <MemberSignature Language="F#" Value="static member Contains : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; bool" Usage="System.Linq.Queryable.Contains (source, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="item" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> où trouver <paramref name="item" />.</param>
        <param name="item">Objet à localiser dans la séquence.</param>
        <summary>Détermine si une séquence contient un élément spécifié à l’aide du comparateur d’égalité par défaut.</summary>
        <returns><see langword="true" /> Si la séquence d’entrée contient un élément qui a la valeur spécifiée ; Sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il détermine si `source` contient `item`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> pour déterminer si une séquence contient un élément spécifique.  
  
 [!code-csharp[System.Linq.Queryable#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#21)]
 [!code-vb[System.Linq.Queryable#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource item, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource item, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Contains``1(System.Linq.IQueryable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IQueryable(Of TSource), item As TSource, comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource item, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Contains : System.Linq.IQueryable&lt;'Source&gt; * 'Source * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.Contains (source, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="item" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> où trouver <paramref name="item" />.</param>
        <param name="item">Objet à localiser dans la séquence.</param>
        <param name="comparer">Un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer des valeurs.</param>
        <summary>Détermine si une séquence contient un élément spécifié en utilisant un <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <returns><see langword="true" /> Si la séquence d’entrée contient un élément qui a la valeur spécifiée ; Sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il détermine si `source` contient `item` à l’aide de `comparer` pour comparer des valeurs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Count&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne le nombre d’éléments dans une séquence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Count``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IQueryable(Of TSource)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Count : System.Linq.IQueryable&lt;'Source&gt; -&gt; int" Usage="System.Linq.Queryable.Count source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Le <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments à compter.</param>
        <summary>Retourne le nombre d’éléments dans une séquence.</summary>
        <returns>Nombre total d'éléments dans la séquence d'entrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il compte le nombre d’éléments dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> pour compter les éléments dans une séquence.  
  
 [!code-csharp[System.Linq.Queryable#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#22)]
 [!code-vb[System.Linq.Queryable#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Le nombre d’éléments dans <paramref name="source" /> est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Count``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Count : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; int" Usage="System.Linq.Queryable.Count (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments à compter.</param>
        <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
        <summary>Retourne le nombre d’éléments dans la séquence spécifiée qui satisfont à une condition.</summary>
        <returns>Le nombre d’éléments de la séquence qui satisfait la condition dans la fonction de prédicat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il compte le nombre d’éléments dans `source` qui satisfont la condition spécifiée par `predicate`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> pour compter les éléments dans une séquence qui satisfont à une condition.  
  
 [!code-csharp[System.Linq.Queryable#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#23)]
 [!code-vb[System.Linq.Queryable#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Le nombre d’éléments dans <paramref name="source" /> est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne les éléments dans une séquence ou une collection de singletons par défaut si la séquence est vide.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.DefaultIfEmpty``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IQueryable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ DefaultIfEmpty(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : System.Linq.IQueryable&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.DefaultIfEmpty source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Le <see cref="T:System.Linq.IQueryable`1" /> pour retourner une valeur par défaut si elle est vide.</param>
        <summary>Retourne les éléments de la séquence spécifiée ou la valeur par défaut du paramètre de type dans une collection de singletons si la séquence est vide.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> contenant <see langword="default" />(<paramref name="TSource" />) si <paramref name="source" /> est vide ; sinon, <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne `source` s’il n’est pas vide. Sinon, elle retourne un <xref:System.Linq.IQueryable%601> contenant `default(TSource)`.  
  
   
  
## Examples  
 Les exemples de code suivants montrent comment utiliser <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> pour fournir une valeur par défaut au cas où la séquence source est vide.  
  
 [!code-csharp[System.Linq.Queryable#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#24)]
 [!code-vb[System.Linq.Queryable#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.DefaultIfEmpty``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IQueryable(Of TSource), defaultValue As TSource) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ DefaultIfEmpty(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource defaultValue);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.DefaultIfEmpty (source, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Le <see cref="T:System.Linq.IQueryable`1" /> pour retourner la valeur spécifiée pour si elle est vide.</param>
        <param name="defaultValue">Valeur à retourner si la séquence est vide.</param>
        <summary>Retourne les éléments de la séquence spécifiée ou la valeur spécifiée dans une collection de singletons si la séquence est vide.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> contenant <paramref name="defaultValue" /> si <paramref name="source" /> est vide ; sinon, <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne `source` s’il n’est pas vide. Sinon, elle retourne un <xref:System.Linq.IQueryable%601> contenant `defaultValue`.  
  
   
  
## Examples  
 L’exemple de code suivant montre une situation dans laquelle il est utile d’appeler <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> dans un [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] requête. Une valeur par défaut est passée à <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> dans cet exemple.  
  
 [!code-csharp[System.Linq.Queryable#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#25)]
 [!code-vb[System.Linq.Queryable#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Distinct&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne des éléments distincts d’une séquence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Distinct``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IQueryable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Distinct(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Linq.IQueryable&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Distinct source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Le <see cref="T:System.Linq.IQueryable`1" /> pour supprimer les doublons.</param>
        <summary>Retourne des éléments distincts d’une séquence à l’aide du comparateur d’égalité par défaut pour comparer les valeurs.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient des éléments distincts de <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne une séquence non ordonnée des éléments uniques dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> pour retourner des éléments distincts d’une séquence.  
  
 [!code-csharp[System.Linq.Queryable#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#27)]
 [!code-vb[System.Linq.Queryable#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Distinct``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IQueryable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Distinct(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Linq.IQueryable&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Distinct (source, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Le <see cref="T:System.Linq.IQueryable`1" /> pour supprimer les doublons.</param>
        <param name="comparer">Un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer des valeurs.</param>
        <summary>Retourne des éléments distincts d’une séquence en utilisant un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer des valeurs.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient des éléments distincts de <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne une séquence non ordonnée des éléments uniques dans `source` à l’aide de `comparer` pour comparer des valeurs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="comparer" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ElementAt``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAt(Of TSource) (source As IQueryable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAt(System::Linq::IQueryable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAt : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Queryable.ElementAt (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> pour retourner un élément.</param>
        <param name="index">Index de base zéro de l'élément à récupérer.</param>
        <summary>Retourne l’élément à l’index spécifié dans une séquence.</summary>
        <returns>L’élément à la position spécifiée dans <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne l’élément à la position `index` dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> pour retourner un élément à une position spécifique dans une séquence.  
  
 [!code-csharp[System.Linq.Queryable#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#28)]
 [!code-vb[System.Linq.Queryable#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ElementAtOrDefault``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAtOrDefault(Of TSource) (source As IQueryable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAtOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAtOrDefault : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Queryable.ElementAtOrDefault (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> pour retourner un élément.</param>
        <param name="index">Index de base zéro de l'élément à récupérer.</param>
        <summary>Retourne l’élément situé à un index spécifié dans une séquence ou une valeur par défaut si l’index est hors limites.</summary>
        <returns><c>default</c>(<paramref name="TSource" />) si <paramref name="index" /> est en dehors des limites de <paramref name="source" /> ; sinon, l’élément à la position spécifiée dans <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne l’élément à la position `index` dans `source`, ou `default(TSource)` si `index` est en dehors des limites de `source`.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29>. Cet exemple utilise une valeur pour `index` qui est en dehors des limites de la séquence source.  
  
 [!code-csharp[System.Linq.Queryable#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#29)]
 [!code-vb[System.Linq.Queryable#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Except&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Produit la différence définie entre deux séquences.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Except``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Except(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Except (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
        <param name="source1">Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments qui ne se trouvent pas également dans <paramref name="source2" /> sera retourné.</param>
        <param name="source2">Un <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments qui figurent également dans la première séquence n’apparaîtra pas dans la séquence retournée.</param>
        <summary>Produit la différence définie entre deux séquences à l’aide du comparateur d’égalité par défaut pour comparer les valeurs.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient la différence entre les deux séquences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le`source1` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source1` paramètre. Le comportement attendu est que tous les éléments `source1` sont retournés à l’exception de ceux qui se trouvent également dans `source2`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> pour retourner les éléments qui apparaissent uniquement dans la première séquence source.  
  
 [!code-csharp[System.Linq.Queryable#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#34)]
 [!code-vb[System.Linq.Queryable#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> ou <paramref name="source2" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Except``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Except(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Except (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
        <param name="source1">Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments qui ne se trouvent pas également dans <paramref name="source2" /> sera retourné.</param>
        <param name="source2">Un <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments qui figurent également dans la première séquence n’apparaîtra pas dans la séquence retournée.</param>
        <param name="comparer">Un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer des valeurs.</param>
        <summary>Produit la différence définie entre deux séquences à l’aide spécifié <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer des valeurs.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient la différence entre les deux séquences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le`source1` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> dépend de l’implémentation du type de le `source1` paramètre. Le comportement attendu est que tous les éléments `source1` sont retournés à l’exception de ceux qui se trouvent également dans `source2`, et `comparer` est utilisé pour comparer des valeurs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> ou <paramref name="source2" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="First&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne le premier élément d’une séquence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.First``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member First : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.First source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Le <see cref="T:System.Linq.IQueryable`1" /> pour retourner le premier élément.</param>
        <summary>Retourne le premier élément d’une séquence.</summary>
        <returns>Le premier élément dans <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne le premier élément dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> pour retourner le premier élément dans une séquence.  
  
 [!code-csharp[System.Linq.Queryable#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#35)]
 [!code-vb[System.Linq.Queryable#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La séquence source est vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.First``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member First : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.First (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> pour retourner un élément.</param>
        <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
        <summary>Retourne le premier élément d’une séquence qui satisfait à une condition spécifiée.</summary>
        <returns>Le premier élément dans <paramref name="source" /> qui réussit le test dans <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne le premier élément dans `source` qui satisfait la condition spécifiée par `predicate`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> pour retourner le premier élément d’une séquence qui satisfait à une condition.  
  
 [!code-csharp[System.Linq.Queryable#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#36)]
 [!code-vb[System.Linq.Queryable#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Aucun élément ne satisfait la condition dans <paramref name="predicate" />.  
  
ou 
La séquence source est vide.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FirstOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne le premier élément d’une séquence ou une valeur par défaut si aucun élément n’est trouvé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.FirstOrDefault``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.FirstOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Le <see cref="T:System.Linq.IQueryable`1" /> pour retourner le premier élément.</param>
        <summary>Retourne le premier élément d’une séquence ou une valeur par défaut si la séquence ne contient aucun élément.</summary>
        <returns><c>default</c>(<paramref name="TSource" />) si <paramref name="source" /> est vide ; sinon, premier élément de <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne le premier élément dans `source`, ou une valeur par défaut si `source` est vide.  
  
 Le <xref:System.Linq.Queryable.FirstOrDefault%2A> méthode ne fournit pas un moyen de spécifier la valeur par défaut à retourner si `source` est vide. Si vous souhaitez spécifier une valeur par défaut autre que `default(TSource)`, utilisez le <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> méthode comme décrit dans la section exemple.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sur une séquence vide.  
  
 [!code-csharp[System.Linq.Queryable#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#37)]
 [!code-vb[System.Linq.Queryable#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#37)]  
  
 Parfois, la valeur de `default(TSource)` n’est pas la valeur par défaut que vous souhaitez utiliser si la collection ne contient aucun élément. Au lieu de vérifier le résultat de la valeur par défaut indésirables, puis de la modifier si nécessaire, vous pouvez utiliser la <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> méthode pour spécifier la valeur par défaut que vous souhaitez utiliser si la collection est vide. Ensuite, appelez <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> pour obtenir le premier élément. L’exemple de code suivant utilise ces deux techniques pour obtenir une valeur par défaut de 1 si une collection de mois numériques est vide. Étant donné que la valeur par défaut pour un entier est 0, ce qui ne correspond pas à un mois, la valeur par défaut doit être spécifiée comme 1. La première variable de résultat est vérifiée pour la valeur par défaut indésirables une fois la requête est terminée. La deuxième variable de résultat est obtenue en appelant <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> pour spécifier une valeur par défaut de 1.  
  
 [!code-csharp[System.Linq.Queryable#131](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#131)]
 [!code-vb[System.Linq.Queryable#131](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#131)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.FirstOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.FirstOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> pour retourner un élément.</param>
        <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
        <summary>Retourne le premier élément d’une séquence qui satisfait à une condition spécifiée ou une valeur par défaut si aucun élément n’est trouvé.</summary>
        <returns><c>default</c>(<paramref name="TSource" />) si <paramref name="source" /> est vide ou si aucun élément ne réussit le test spécifié par <paramref name="predicate" /> ; sinon, premier élément de <paramref name="source" /> qui réussit le test spécifié par <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne le premier élément dans `source` qui satisfait la condition dans `predicate`, ou une valeur par défaut si aucun élément ne satisfait la condition.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> en passant un prédicat. Dans la deuxième requête, aucun élément n’existe dans la séquence qui satisfait la condition.  
  
 [!code-csharp[System.Linq.Queryable#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#38)]
 [!code-vb[System.Linq.Queryable#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Regroupe les éléments d’une séquence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IQueryable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments à regrouper.</param>
        <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
        <summary>Regroupe les éléments d’une séquence selon une fonction de sélection de clé spécifiée.</summary>
        <returns><c>IQueryable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</c> en C# ou <c>IQueryable(Of IGrouping(Of TKey, TSource))</c> en Visual Basic où chaque objet <see cref="T:System.Linq.IGrouping`2" /> contient une séquence d’objets et une clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il regroupe les éléments de `source` par une valeur de clé est obtenue en appelant `keySelector` sur chaque élément.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> pour regrouper les éléments d’une séquence.  
  
 [!code-csharp[System.Linq.Queryable#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#14)]
 [!code-vb[System.Linq.Queryable#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments à regrouper.</param>
        <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
        <summary>Regroupe les éléments d’une séquence selon une fonction de sélection de clé spécifiée et compare les clés à l’aide du comparateur spécifié.</summary>
        <returns><c>IQueryable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</c> en C# ou <c>IQueryable(Of IGrouping(Of TKey, TSource))</c> en Visual Basic où chaque <see cref="T:System.Linq.IGrouping`2" /> contient une séquence d’objets et une clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il regroupe les éléments de `source` par une valeur de clé. La valeur de clé est obtenue en appelant `keySelector` sur chaque élément, et les valeurs de clés sont comparées à l’aide de `comparer`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> ou <paramref name="comparer" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement))) As IQueryable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Le type des éléments dans chaque <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments à regrouper.</param>
        <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
        <param name="elementSelector">Fonction permettant de mapper chaque élément source à un élément dans un <see cref="T:System.Linq.IGrouping`2" />.</param>
        <summary>Regroupe les éléments d’une séquence selon une fonction de sélection de clé spécifiée et projette les éléments de chaque groupe à l’aide d’une fonction spécifiée.</summary>
        <returns><c>IQueryable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</c> en C# ou <c>IQueryable(Of IGrouping(Of TKey, TElement))</c> en Visual Basic ou chaque <see cref="T:System.Linq.IGrouping`2" /> contient une séquence d’objets de type <paramref name="TElement" /> et une clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il regroupe les éléments de `source` par une valeur de clé est obtenue en appelant `keySelector` sur chaque élément. Elle appelle `elementSelector` sur chaque élément pour obtenir un élément de résultat.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> pour regrouper les éléments d’une séquence.  
  
 [!code-csharp[System.Linq.Queryable#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#39)]
 [!code-vb[System.Linq.Queryable#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> ou <paramref name="elementSelector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Le type des éléments dans chaque <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments à regrouper.</param>
        <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
        <param name="elementSelector">Fonction permettant de mapper chaque élément source à un élément dans un <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
        <summary>Regroupe les éléments d’une séquence et projette les éléments pour chaque groupe à l’aide d’une fonction spécifiée. Valeurs de clés sont comparées à l’aide d’un comparateur spécifié.</summary>
        <returns><c>IQueryable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</c> en C# ou <c>IQueryable(Of IGrouping(Of TKey, TElement))</c> en Visual Basic ou chaque <see cref="T:System.Linq.IGrouping`2" /> contient une séquence d’objets de type <paramref name="TElement" /> et une clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il regroupe les éléments de `source` par une valeur de clé est obtenue en appelant `keySelector` sur chaque élément. Valeurs de clés sont comparées à l’aide de `comparer`. Le `elementSelector` paramètre est appelé sur chaque élément pour obtenir un élément de résultat.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> ou <paramref name="elementSelector" /> ou <paramref name="comparer" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TSource), TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
        <typeparam name="TResult">Le type de la valeur de résultat retournée par <paramref name="resultSelector" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments à regrouper.</param>
        <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
        <param name="resultSelector">Fonction permettant de créer une valeur de résultat à partir de chaque groupe.</param>
        <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et crée une valeur de résultat à partir de chaque groupe et de la clé correspondante.</summary>
        <returns><c>T:System.Linq.IQueryable`1</c> qui dispose de l’argument de type <paramref name="TResult" /> et où chaque élément représente une projection sur un groupe et sa clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il regroupe les éléments de `source` par une valeur de clé est obtenue en appelant `keySelector` sur chaque élément. Le `resultSelector` paramètre est utilisé pour obtenir une valeur de résultat à partir de chaque groupe et sa clé.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> pour regrouper les éléments d’une séquence et une séquence de résultats de type de projet `TResult`.  
  
 [!code-csharp[System.Linq.Queryable#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#15)]
 [!code-vb[System.Linq.Queryable#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> ou <paramref name="resultSelector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TSource), TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
        <typeparam name="TResult">Le type de la valeur de résultat retournée par <paramref name="resultSelector" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments à regrouper.</param>
        <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
        <param name="resultSelector">Fonction permettant de créer une valeur de résultat à partir de chaque groupe.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
        <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et crée une valeur de résultat à partir de chaque groupe et de la clé correspondante. Les clés sont comparées à l’aide d’un comparateur spécifié.</summary>
        <returns><c>T:System.Linq.IQueryable`1</c> qui dispose de l’argument de type <paramref name="TResult" /> et où chaque élément représente une projection sur un groupe et sa clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il regroupe les éléments de `source` par les valeurs de clés qui sont obtenues en appelant `keySelector` sur chaque élément. Le `comparer` paramètre est utilisé pour comparer les clés et les `resultSelector` paramètre est utilisé pour obtenir une valeur de résultat à partir de chaque groupe et sa clé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> ou <paramref name="resultSelector" /> ou <paramref name="comparer" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``4(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TElement), TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Le type des éléments dans chaque <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Le type de la valeur de résultat retournée par <paramref name="resultSelector" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments à regrouper.</param>
        <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
        <param name="elementSelector">Fonction permettant de mapper chaque élément source à un élément dans un <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="resultSelector">Fonction permettant de créer une valeur de résultat à partir de chaque groupe.</param>
        <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et crée une valeur de résultat à partir de chaque groupe et de la clé correspondante. Les éléments de chaque groupe sont projetés à l'aide d'une fonction spécifique.</summary>
        <returns><c>T:System.Linq.IQueryable`1</c> qui dispose de l’argument de type <paramref name="TResult" /> et où chaque élément représente une projection sur un groupe et sa clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il regroupe les éléments de `source` par les valeurs de clés qui sont obtenues en appelant `keySelector` sur chaque élément. Le `elementSelector` paramètre est utilisé pour projeter les éléments de chaque groupe et le `resultSelector` paramètre est utilisé pour obtenir une valeur de résultat à partir de chaque groupe et sa clé.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> pour regrouper les éléments d’une séquence et une séquence de résultats de type de projet `TResult`.  
  
 [!code-csharp[System.Linq.Queryable#130](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#130)]
 [!code-vb[System.Linq.Queryable#130](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#130)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> ou <paramref name="elementSelector" /> ou <paramref name="resultSelector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``4(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TElement), TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Le type des éléments dans chaque <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Le type de la valeur de résultat retournée par <paramref name="resultSelector" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments à regrouper.</param>
        <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
        <param name="elementSelector">Fonction permettant de mapper chaque élément source à un élément dans un <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="resultSelector">Fonction permettant de créer une valeur de résultat à partir de chaque groupe.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
        <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et crée une valeur de résultat à partir de chaque groupe et de la clé correspondante. Les clés sont comparées à l’aide d’un comparateur spécifié et les éléments de chaque groupe sont projetés à l’aide d’une fonction spécifiée.</summary>
        <returns><c>T:System.Linq.IQueryable`1</c> qui dispose de l’argument de type <paramref name="TResult" /> et où chaque élément représente une projection sur un groupe et sa clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il regroupe les éléments de `source` par les valeurs de clés qui sont obtenues en appelant `keySelector` sur chaque élément. Le `comparer` paramètre est utilisé pour comparer des valeurs de clé. Le `elementSelector` paramètre est utilisé pour projeter les éléments de chaque groupe et le `resultSelector` paramètre est utilisé pour obtenir une valeur de résultat à partir de chaque groupe et sa clé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> ou <paramref name="elementSelector" /> ou <paramref name="resultSelector" /> ou <paramref name="comparer" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Met en corrélation les éléments de deux séquences en fonction de l’égalité des clés et regroupe les résultats.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupJoin``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, IEnumerable(Of TInner), TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupJoin(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Type des éléments de la première séquence.</typeparam>
        <typeparam name="TInner">Type des éléments de la deuxième séquence.</typeparam>
        <typeparam name="TKey">Type des clés retournées par les fonctions de sélecteur de clé.</typeparam>
        <typeparam name="TResult">Type des éléments de résultat.</typeparam>
        <param name="outer">Première séquence à joindre.</param>
        <param name="inner">Séquence à joindre à la première séquence.</param>
        <param name="outerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la première séquence.</param>
        <param name="innerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la deuxième séquence.</param>
        <param name="resultSelector">Fonction permettant de créer un élément de résultat à partir d’un élément de la première séquence, ainsi qu’une collection d’éléments correspondants à partir de la deuxième séquence.</param>
        <summary>Met en corrélation les éléments de deux séquences en fonction de l’égalité des clés et regroupe les résultats. Le comparateur d'égalité par défaut est utilisé pour comparer les clés.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient des éléments de type <paramref name="TResult" /> obtenus à la suite d’une jointure groupée de deux séquences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `outer` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> dépend de l’implémentation du type de le `outer` paramètre. Le comportement attendu est que le `outerKeySelector` et `innerKeySelector` fonctions sont utilisées pour extraire des clés de `outer` et `inner`, respectivement. Ces clés sont comparées pour l’égalité correspondre à chaque élément dans `outer` avec zéro ou plusieurs éléments à partir de `inner`. Le `resultSelector` fonction est appelée pour un objet de résultat de chaque groupe d’éléments corrélés de projet.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> pour effectuer une jointure groupée de deux séquences.  
  
 [!code-csharp[System.Linq.Queryable#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#40)]
 [!code-vb[System.Linq.Queryable#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" /> ou <paramref name="inner" /> ou <paramref name="outerKeySelector" /> ou <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupJoin``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, IEnumerable(Of TInner), TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupJoin(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Type des éléments de la première séquence.</typeparam>
        <typeparam name="TInner">Type des éléments de la deuxième séquence.</typeparam>
        <typeparam name="TKey">Type des clés retournées par les fonctions de sélecteur de clé.</typeparam>
        <typeparam name="TResult">Type des éléments de résultat.</typeparam>
        <param name="outer">Première séquence à joindre.</param>
        <param name="inner">Séquence à joindre à la première séquence.</param>
        <param name="outerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la première séquence.</param>
        <param name="innerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la deuxième séquence.</param>
        <param name="resultSelector">Fonction permettant de créer un élément de résultat à partir d’un élément de la première séquence, ainsi qu’une collection d’éléments correspondants à partir de la deuxième séquence.</param>
        <param name="comparer">Comparateur pour hacher et comparer des clés.</param>
        <summary>Met en corrélation les éléments de deux séquences en fonction de l’égalité des clés et regroupe les résultats. Une certaine <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> est utilisé pour comparer les clés.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient des éléments de type <paramref name="TResult" /> obtenus à la suite d’une jointure groupée de deux séquences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `outer` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> dépend de l’implémentation du type de le `outer` paramètre. Le comportement attendu est que le `outerKeySelector` et `innerKeySelector` fonctions sont utilisées pour extraire des clés de `outer` et `inner`, respectivement. Ces clés sont comparées pour l’égalité à l’aide de `comparer`. Le résultat des comparaisons est utilisé pour faire correspondre chaque élément dans `outer` avec zéro ou plusieurs éléments à partir de `inner`. Le `resultSelector` fonction est appelée pour un objet de résultat de chaque groupe d’éléments corrélés de projet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" /> ou <paramref name="inner" /> ou <paramref name="outerKeySelector" /> ou <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Intersect&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Produit l’intersection définie de deux séquences.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Intersect``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Intersect(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Intersect (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
        <param name="source1">Séquence dont les éléments distincts qui apparaissent également dans <paramref name="source2" /> sont retournés.</param>
        <param name="source2">Séquence dont les éléments distincts qui apparaissent également dans la première séquence sont retournés.</param>
        <summary>Produit l’intersection définie de deux séquences à l’aide du comparateur d’égalité par défaut pour comparer les valeurs.</summary>
        <returns>Séquence qui contient l’intersection définie des deux séquences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source1` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source1` paramètre. Le comportement attendu est que tous les éléments `source1` qui se trouvent également dans `source2` sont retournés.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> pour retourner les éléments qui apparaissent dans les deux séquences.  
  
 [!code-csharp[System.Linq.Queryable#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#41)]
 [!code-vb[System.Linq.Queryable#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> ou <paramref name="source2" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Intersect``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Intersect(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Intersect (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
        <param name="source1">Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments distincts qui apparaissent également dans <paramref name="source2" /> sont retournés.</param>
        <param name="source2">Un <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments distincts qui apparaissent également dans la première séquence sont retournés.</param>
        <param name="comparer">Un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer des valeurs.</param>
        <summary>Produit l’intersection de deux séquences en utilisant le <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer des valeurs.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient l’intersection définie des deux séquences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source1` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> dépend de l’implémentation du type de le `source1` paramètre. Le comportement attendu est que tous les éléments `source1` qui se trouvent également dans `source2` sont retournés. Le `comparer` paramètre est utilisé pour comparer les éléments.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> ou <paramref name="source2" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Met en corrélation les éléments de deux séquences en fonction des clés correspondantes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TInner,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Join``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, TInner, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Join(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TInner, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Inner, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TInner,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Type des éléments de la première séquence.</typeparam>
        <typeparam name="TInner">Type des éléments de la deuxième séquence.</typeparam>
        <typeparam name="TKey">Type des clés retournées par les fonctions de sélecteur de clé.</typeparam>
        <typeparam name="TResult">Type des éléments de résultat.</typeparam>
        <param name="outer">Première séquence à joindre.</param>
        <param name="inner">Séquence à joindre à la première séquence.</param>
        <param name="outerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la première séquence.</param>
        <param name="innerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la deuxième séquence.</param>
        <param name="resultSelector">Fonction permettant de créer un élément de résultat à partir de deux éléments correspondants.</param>
        <summary>Met en corrélation les éléments de deux séquences en fonction des clés correspondantes. Le comparateur d'égalité par défaut est utilisé pour comparer les clés.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient des éléments de type <paramref name="TResult" /> obtenus à la suite d’une jointure interne de deux séquences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `outer` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> dépend de l’implémentation du type de le `outer` paramètre. Le comportement attendu est celle d’une jointure interne. Le `outerKeySelector` et `innerKeySelector` fonctions sont utilisées pour extraire des clés de `outer` et `inner`, respectivement. Ces clés sont comparées pour l’égalité en correspondance les éléments de chaque séquence. Une paire d’éléments est stockée pour chaque élément dans `inner` qui correspond à un élément dans `outer`. Le `resultSelector` fonction est appelée pour un objet de résultat à partir de chaque paire d’éléments correspondants du projet.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> pour effectuer une jointure interne de deux séquences selon une clé commune.  
  
 [!code-csharp[System.Linq.Queryable#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#42)]
 [!code-vb[System.Linq.Queryable#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" /> ou <paramref name="inner" /> ou <paramref name="outerKeySelector" /> ou <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TInner,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Join``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, TInner, TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Join(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TInner, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Inner, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TInner,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Type des éléments de la première séquence.</typeparam>
        <typeparam name="TInner">Type des éléments de la deuxième séquence.</typeparam>
        <typeparam name="TKey">Type des clés retournées par les fonctions de sélecteur de clé.</typeparam>
        <typeparam name="TResult">Type des éléments de résultat.</typeparam>
        <param name="outer">Première séquence à joindre.</param>
        <param name="inner">Séquence à joindre à la première séquence.</param>
        <param name="outerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la première séquence.</param>
        <param name="innerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la deuxième séquence.</param>
        <param name="resultSelector">Fonction permettant de créer un élément de résultat à partir de deux éléments correspondants.</param>
        <param name="comparer">Un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour hacher et comparer les clés.</param>
        <summary>Met en corrélation les éléments de deux séquences en fonction des clés correspondantes. Une certaine <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> est utilisé pour comparer les clés.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient des éléments de type <paramref name="TResult" /> obtenus à la suite d’une jointure interne de deux séquences.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `outer` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> dépend de l’implémentation du type de le `outer` paramètre. Le comportement attendu est celle d’une jointure interne. Le `outerKeySelector` et `innerKeySelector` fonctions sont utilisées pour extraire des clés de `outer` et `inner`, respectivement. Ces clés sont comparées pour l’égalité à l’aide de `comparer`. Le résultat des comparaisons est utilisé pour créer une paire correspondante pour chaque élément dans `inner` qui correspond à un élément dans `outer`. Le `resultSelector` fonction est appelée pour un objet de résultat à partir de chaque paire d’éléments correspondants du projet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" /> ou <paramref name="inner" /> ou <paramref name="outerKeySelector" /> ou <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Last&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne le dernier élément dans une séquence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Last``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Last : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Last source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> pour retourner le dernier élément.</param>
        <summary>Retourne le dernier élément dans une séquence.</summary>
        <returns>La valeur à la dernière position dans <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne le dernier élément dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> pour retourner le dernier élément d’un tableau.  
  
 [!code-csharp[System.Linq.Queryable#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#43)]
 [!code-vb[System.Linq.Queryable#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La séquence source est vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Last``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Last : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Last (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> pour retourner un élément.</param>
        <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
        <summary>Retourne le dernier élément d’une séquence à satisfaire à la condition spécifiée.</summary>
        <returns>Le dernier élément de <paramref name="source" /> qui réussit le test spécifié par <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne le dernier élément de `source` qui satisfait la condition spécifiée par `predicate`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> pour retourner le dernier élément d’un tableau qui remplit une condition.  
  
 [!code-csharp[System.Linq.Queryable#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#44)]
 [!code-vb[System.Linq.Queryable#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Aucun élément ne satisfait la condition dans <paramref name="predicate" />.  
  
ou 
La séquence source est vide.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne le dernier élément d’une séquence ou une valeur par défaut si aucun élément n’est trouvé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LastOrDefault``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.LastOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> pour retourner le dernier élément.</param>
        <summary>Retourne le dernier élément dans une séquence ou une valeur par défaut si la séquence ne contient aucun élément.</summary>
        <returns><c>default</c>(<paramref name="TSource" />) si <paramref name="source" /> est vide ; sinon, dernier élément de <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne le dernier élément de `source`, ou une valeur par défaut si `source` est vide.  
  
 Le <xref:System.Linq.Queryable.LastOrDefault%2A> méthode ne fournit pas un moyen de spécifier une valeur par défaut. Si vous souhaitez spécifier une valeur par défaut autre que `default(TSource)`, utilisez le <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> méthode comme décrit dans la section exemple.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> sur un tableau vide.  
  
 [!code-csharp[System.Linq.Queryable#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#45)]
 [!code-vb[System.Linq.Queryable#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#45)]  
  
 Parfois, la valeur de `default(TSource)` n’est pas la valeur par défaut que vous souhaitez utiliser si la collection ne contient aucun élément. Au lieu de vérifier le résultat de la valeur par défaut indésirables, puis de la modifier si nécessaire, vous pouvez utiliser la <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> méthode pour spécifier la valeur par défaut que vous souhaitez utiliser si la collection est vide. Ensuite, appelez <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> pour obtenir le dernier élément. L’exemple de code suivant utilise ces deux techniques pour obtenir une valeur par défaut de 1 si une collection de numériques jours du mois est vide. Étant donné que la valeur par défaut pour un entier est 0, ce qui ne correspond pas à n’importe quel jour du mois, la valeur par défaut doit être spécifiée comme 1. La première variable de résultat est vérifiée pour la valeur par défaut indésirables une fois la requête est terminée. La deuxième variable de résultat est obtenue en appelant <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> pour spécifier une valeur par défaut de 1.  
  
 [!code-csharp[System.Linq.Queryable#132](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#132)]
 [!code-vb[System.Linq.Queryable#132](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#132)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LastOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.LastOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> pour retourner un élément.</param>
        <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
        <summary>Retourne le dernier élément d’une séquence à satisfaire à une condition ou une valeur par défaut si aucun élément correspondant n’est trouvé.</summary>
        <returns><c>default</c>(<paramref name="TSource" />) si <paramref name="source" /> est vide ou si aucun élément ne réussit le test de la fonction de prédicat ; sinon, dernier élément de <paramref name="source" /> qui réussit le test de cette fonction.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne le dernier élément de `source` qui satisfait la condition spécifiée par `predicate`. Elle retourne une valeur par défaut s’il n’existe pas d’élément de `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> en passant un prédicat. Dans le deuxième appel à la méthode, aucun élément n’existe dans la séquence qui satisfait la condition.  
  
 [!code-csharp[System.Linq.Queryable#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#46)]
 [!code-vb[System.Linq.Queryable#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LongCount&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un <see cref="T:System.Int64" /> qui représente le nombre d’éléments dans une séquence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LongCount``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IQueryable(Of TSource)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LongCount : System.Linq.IQueryable&lt;'Source&gt; -&gt; int64" Usage="System.Linq.Queryable.LongCount source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments à compter.</param>
        <summary>Retourne un <see cref="T:System.Int64" /> qui représente le nombre total d’éléments dans une séquence.</summary>
        <returns>Nombre d'éléments de <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il compte le nombre d’éléments dans `source` et retourne un <xref:System.Int64>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> pour compter les éléments dans un tableau.  
  
 [!code-csharp[System.Linq.Queryable#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#47)]
 [!code-vb[System.Linq.Queryable#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Le nombre d’éléments dépasse <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LongCount``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LongCount : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; int64" Usage="System.Linq.Queryable.LongCount (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments à compter.</param>
        <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
        <summary>Retourne un <see cref="T:System.Int64" /> qui représente le nombre d’éléments dans une séquence qui satisfont à une condition.</summary>
        <returns>Le nombre d’éléments dans <paramref name="source" /> qui satisfont la condition dans la fonction de prédicat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il compte le nombre d’éléments dans `source` qui satisfont la condition spécifiée par `predicate` et retourne un <xref:System.Int64>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> pour compter les éléments dans un tableau qui remplissent une condition.  
  
 [!code-csharp[System.Linq.Queryable#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#48)]
 [!code-vb[System.Linq.Queryable#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Le nombre d’éléments correspondants dépasse <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Max``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Max(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs pour déterminer le nombre maximal de.</param>
        <summary>Retourne la valeur maximale dans un générique <see cref="T:System.Linq.IQueryable`1" />.</summary>
        <returns>Valeur maximale dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne la valeur maximale de `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> pour déterminer la valeur maximale dans une séquence.  
  
 [!code-csharp[System.Linq.Queryable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#52)]
 [!code-vb[System.Linq.Queryable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Max``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, TResult))) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Max(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Result&gt;&gt; -&gt; 'Result" Usage="System.Linq.Queryable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Le type de la valeur retournée par la fonction représentée par <paramref name="selector" />.</typeparam>
        <param name="source">Une séquence de valeurs pour déterminer le nombre maximal de.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Appelle une fonction de projection sur chaque élément d’un générique <see cref="T:System.Linq.IQueryable`1" /> et retourne la valeur résultante maximale.</summary>
        <returns>Valeur maximale dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément dans `source` et retourne la valeur maximale.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> pour déterminer la valeur maximale dans une séquence de valeurs projetées.  
  
 [!code-csharp[System.Linq.Queryable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#58)]
 [!code-vb[System.Linq.Queryable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Min``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Min(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs pour déterminer la valeur minimale de.</param>
        <summary>Retourne la valeur minimale d’un générique <see cref="T:System.Linq.IQueryable`1" />.</summary>
        <returns>Valeur minimale dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne la valeur minimale de `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> pour déterminer la valeur minimale dans une séquence.  
  
 [!code-csharp[System.Linq.Queryable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#60)]
 [!code-vb[System.Linq.Queryable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Min``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, TResult))) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Min(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Result&gt;&gt; -&gt; 'Result" Usage="System.Linq.Queryable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Le type de la valeur retournée par la fonction représentée par <paramref name="selector" />.</typeparam>
        <param name="source">Une séquence de valeurs pour déterminer la valeur minimale de.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Appelle une fonction de projection sur chaque élément d’un générique <see cref="T:System.Linq.IQueryable`1" /> et retourne la valeur résultante minimale.</summary>
        <returns>Valeur minimale dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément dans `source` et retourne la valeur minimale.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> pour déterminer la valeur minimale dans une séquence de valeurs projetées.  
  
 [!code-csharp[System.Linq.Queryable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#68)]
 [!code-vb[System.Linq.Queryable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Linq.IQueryable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Linq.IQueryable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OfType``1(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfType(Of TResult) (source As IQueryable) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ OfType(System::Linq::IQueryable ^ source);" />
      <MemberSignature Language="F#" Value="static member OfType : System.Linq.IQueryable -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.OfType source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type en fonction duquel filtrer les éléments de la séquence.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable" /> dont les éléments à filtrer.</param>
        <summary>Filtre les éléments d’un <see cref="T:System.Linq.IQueryable" /> basée sur un type spécifié.</summary>
        <returns>Une collection qui contient les éléments de <paramref name="source" /> qui ont le type <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `OfType` méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel `OfType` lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel `OfType` dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il élimine par filtrage tous les éléments de `source` qui ne sont pas de type `TResult`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser `OfType` pour filtrer les éléments qui ne sont pas de type <xref:System.Reflection.PropertyInfo> à partir d’une liste d’éléments de type <xref:System.Reflection.MemberInfo>.  
  
 [!code-csharp[System.Linq.Queryable#69](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#69)]
 [!code-vb[System.Linq.Queryable#69](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Trie les éléments d’une séquence dans l’ordre croissant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la fonction qui est représentée par <paramref name="keySelector" />.</typeparam>
        <param name="source">Séquence de valeurs à classer.</param>
        <param name="keySelector">Fonction permettant d'extraire une clé d'un élément.</param>
        <summary>Trie les éléments d’une séquence dans l’ordre croissant selon une clé.</summary>
        <returns>Un <see cref="T:System.Linq.IOrderedQueryable`1" /> dont les éléments sont triés selon une clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre. Le résultat de l’appel <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> est casté en type <xref:System.Linq.IOrderedQueryable%601> et retourné.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il trie les éléments de `source` selon la clé obtenue en appelant `keySelector` sur chaque élément de `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> pour trier les éléments d’une séquence.  
  
 [!code-csharp[System.Linq.Queryable#70](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#70)]
 [!code-vb[System.Linq.Queryable#70](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la fonction qui est représentée par <paramref name="keySelector" />.</typeparam>
        <param name="source">Séquence de valeurs à classer.</param>
        <param name="keySelector">Fonction permettant d'extraire une clé d'un élément.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> pour comparer les clés.</param>
        <summary>Trie les éléments d’une séquence dans l’ordre croissant à l’aide du comparateur spécifié.</summary>
        <returns>Un <see cref="T:System.Linq.IOrderedQueryable`1" /> dont les éléments sont triés selon une clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre. Le résultat de l’appel <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> est casté en type <xref:System.Linq.IOrderedQueryable%601> et retourné.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il trie les éléments de `source` selon la clé obtenue en appelant `keySelector` sur chaque élément de `source`. Le `comparer` paramètre est utilisé pour comparer les clés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> ou <paramref name="comparer" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Trie les éléments d'une séquence dans l'ordre décroissant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderByDescending``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderByDescending(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la fonction qui est représentée par <paramref name="keySelector" />.</typeparam>
        <param name="source">Séquence de valeurs à classer.</param>
        <param name="keySelector">Fonction permettant d'extraire une clé d'un élément.</param>
        <summary>Trie les éléments d’une séquence dans l’ordre décroissant selon une clé.</summary>
        <returns>Un <see cref="T:System.Linq.IOrderedQueryable`1" /> dont les éléments sont triés par ordre décroissant selon une clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre. Le résultat de l’appel <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> est casté en type <xref:System.Linq.IOrderedQueryable%601> et retourné.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il trie les éléments de `source` dans l’ordre décroissant, en fonction de la clé obtenue en appelant `keySelector` sur chaque élément de `source`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderByDescending``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderByDescending(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la fonction qui est représentée par <paramref name="keySelector" />.</typeparam>
        <param name="source">Séquence de valeurs à classer.</param>
        <param name="keySelector">Fonction permettant d'extraire une clé d'un élément.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> pour comparer les clés.</param>
        <summary>Trie les éléments d'une séquence dans l'ordre décroissant à l'aide d'un comparateur spécifié.</summary>
        <returns>Un <see cref="T:System.Linq.IOrderedQueryable`1" /> dont les éléments sont triés par ordre décroissant selon une clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre. Le résultat de l’appel <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> est casté en type <xref:System.Linq.IOrderedQueryable%601> et retourné.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il trie les éléments de `source` dans l’ordre décroissant, en fonction de la clé obtenue en appelant `keySelector` sur chaque élément de `source`. Le `comparer` paramètre est utilisé pour comparer les clés.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> pour trier les éléments d’une séquence dans l’ordre décroissant à l’aide d’un comparateur personnalisé.  
  
 [!code-csharp[System.Linq.Queryable#71](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#71)]
 [!code-vb[System.Linq.Queryable#71](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> ou <paramref name="comparer" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Prepend&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Prepend&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Prepend&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Prepend``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Prepend(Of TSource) (source As IQueryable(Of TSource), element As TSource) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Prepend(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Prepend : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Prepend (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="element" Type="TSource" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Reverse``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reverse(Of TSource) (source As IQueryable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Reverse(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Reverse : System.Linq.IQueryable&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Reverse source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Séquence de valeurs à inverser.</param>
        <summary>Inverse l’ordre des éléments dans une séquence.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments correspondent à ceux de la séquence d’entrée dans l’ordre inverse.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il inverse l’ordre des éléments dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> pour inverser l’ordre des éléments dans un tableau.  
  
 [!code-csharp[System.Linq.Queryable#74](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#74)]
 [!code-vb[System.Linq.Queryable#74](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projette chaque élément d’une séquence dans un nouveau formulaire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Select``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Select(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Le type de la valeur retournée par la fonction représentée par <paramref name="selector" />.</typeparam>
        <param name="source">Séquence de valeurs à projeter.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Projette chaque élément d’une séquence dans un nouveau formulaire en incorporant l’index de l’élément.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments sont le résultat de l’appel d’une fonction de projection sur chaque élément de <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> dépendent de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément de `source` à projeter dans une autre forme.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> sur une séquence de valeurs de projet et l’utilisation de l’index de chaque élément dans le formulaire projeté.  
  
 [!code-csharp[System.Linq.Queryable#76](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#76)]
 [!code-vb[System.Linq.Queryable#76](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Select``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Select(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Le type de la valeur retournée par la fonction représentée par <paramref name="selector" />.</typeparam>
        <param name="source">Séquence de valeurs à projeter.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Projette chaque élément d’une séquence dans un nouveau formulaire.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments sont le résultat de l’appel d’une fonction de projection sur chaque élément de <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément de `source` à projeter dans une autre forme.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> à projeter sur une séquence de valeurs.  
  
 [!code-csharp[System.Linq.Queryable#75](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#75)]
 [!code-vb[System.Linq.Queryable#75](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectMany&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projette chaque élément d’une séquence sur un <see cref="T:System.Collections.Generic.IEnumerable`1" /> et combine les séquences résultantes en une séquence de type <see cref="T:System.Linq.IQueryable`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, IEnumerable(Of TResult)))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, seq&lt;'Result&gt;&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Le type des éléments de la séquence retournée par la fonction représentée par <paramref name="selector" />.</typeparam>
        <param name="source">Séquence de valeurs à projeter.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Projette chaque élément d’une séquence sur un <see cref="T:System.Collections.Generic.IEnumerable`1" /> et combine les séquences résultantes en une seule séquence.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments sont le résultat de l’appel d’une fonction de projection de type un-à-plusieurs sur chaque élément de la séquence d’entrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément de `source` à projeter dans un formulaire énumérable. Il concatène ensuite les résultats énumérables en une séquence unique, unidimensionnelle.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> pour effectuer une projection de type un-à-plusieurs sur un tableau.  
  
 [!code-csharp[System.Linq.Queryable#77](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#77)]
 [!code-vb[System.Linq.Queryable#77](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer, IEnumerable(Of TResult)))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, seq&lt;'Result&gt;&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Le type des éléments de la séquence retournée par la fonction représentée par <paramref name="selector" />.</typeparam>
        <param name="source">Séquence de valeurs à projeter.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément ; le deuxième paramètre de cette fonction représente l’index de l’élément source.</param>
        <summary>Projette chaque élément d’une séquence sur un <see cref="T:System.Collections.Generic.IEnumerable`1" /> et combine les séquences résultantes en une seule séquence. L'index de chaque élément source est utilisé dans le formulaire projeté de l'élément.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments sont le résultat de l’appel d’une fonction de projection de type un-à-plusieurs sur chaque élément de la séquence d’entrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément de `source` à projeter dans un formulaire énumérable. Chaque résultat énumérable incorpore l’index de l’élément source. Il concatène ensuite les résultats énumérables en une séquence unique, unidimensionnelle.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> pour effectuer une projection de type un-à-plusieurs sur un tableau et utiliser l’index de chaque élément source.  
  
 [!code-csharp[System.Linq.Queryable#78](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#78)]
 [!code-vb[System.Linq.Queryable#78](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt; collectionSelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TCollection,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt;&gt; collectionSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IQueryable(Of TSource), collectionSelector As Expression(Of Func(Of TSource, IEnumerable(Of TCollection))), resultSelector As Expression(Of Func(Of TSource, TCollection, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^&gt; ^ collectionSelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TCollection, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, seq&lt;'Collection&gt;&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Collection, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TCollection,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TCollection">Type des éléments intermédiaires collectés par la fonction représentée par <paramref name="collectionSelector" />.</typeparam>
        <typeparam name="TResult">Le type des éléments de la séquence résultante.</typeparam>
        <param name="source">Séquence de valeurs à projeter.</param>
        <param name="collectionSelector">Une fonction de projection à appliquer à chaque élément de la séquence d’entrée.</param>
        <param name="resultSelector">Une fonction de projection à appliquer à chaque élément de chaque séquence intermédiaire.</param>
        <summary>Projette chaque élément d’une séquence sur un <see cref="T:System.Collections.Generic.IEnumerable`1" /> et appelle une fonction de sélecteur de résultat sur chaque élément inclus. Les valeurs résultantes de chaque séquence intermédiaire sont combinées en une séquence unique, unidimensionnelle et retournées.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments sont le résultat de l’appel de la fonction de projection de type un-à-plusieurs <paramref name="collectionSelector" /> sur chaque élément de <paramref name="source" /> et mappage de chacun de ces éléments de séquence et leur correspondant <paramref name="source" /> élément à un élément de résultat .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `collectionSelector` sur chaque élément de `source` à projeter dans un formulaire énumérable. Puis la fonction représentée par `resultSelector` est appelée sur chaque élément de chaque séquence intermédiaire. Les valeurs résultantes sont concaténées en une séquence unique, unidimensionnelle.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> pour effectuer une projection de type un-à-plusieurs sur un tableau. Cet exemple utilise une fonction de sélection de résultat pour conserver l’élément source qui correspond à chaque séquence intermédiaire dans la portée de l’appel final à `Select`.  
  
 [!code-csharp[System.Linq.Queryable#124](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#124)]
 [!code-vb[System.Linq.Queryable#124](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#124)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="collectionSelector" /> ou <paramref name="resultSelector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt; collectionSelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TCollection,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt;&gt; collectionSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IQueryable(Of TSource), collectionSelector As Expression(Of Func(Of TSource, Integer, IEnumerable(Of TCollection))), resultSelector As Expression(Of Func(Of TSource, TCollection, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^&gt; ^ collectionSelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TCollection, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, seq&lt;'Collection&gt;&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Collection, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TCollection,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TCollection">Type des éléments intermédiaires collectés par la fonction représentée par <paramref name="collectionSelector" />.</typeparam>
        <typeparam name="TResult">Le type des éléments de la séquence résultante.</typeparam>
        <param name="source">Séquence de valeurs à projeter.</param>
        <param name="collectionSelector">Une fonction de projection à appliquer à chaque élément de la séquence d’entrée ; le deuxième paramètre de cette fonction représente l’index de l’élément source.</param>
        <param name="resultSelector">Une fonction de projection à appliquer à chaque élément de chaque séquence intermédiaire.</param>
        <summary>Projette chaque élément d’une séquence sur un <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui incorpore l’index de l’élément source qui l’a produit. Une fonction de sélecteur de résultat est appelée sur chaque élément de chaque séquence intermédiaire, et les valeurs résultantes sont combinées en une séquence unique, unidimensionnelle et retournées.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments sont le résultat de l’appel de la fonction de projection de type un-à-plusieurs <paramref name="collectionSelector" /> sur chaque élément de <paramref name="source" /> et mappage de chacun de ces éléments de séquence et leur correspondant <paramref name="source" /> élément à un élément de résultat .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `collectionSelector` sur chaque élément de `source` à projeter dans un formulaire énumérable. Chaque résultat énumérable incorpore l’index de l’élément source. Puis la fonction représentée par `resultSelector` est appelée sur chaque élément de chaque séquence intermédiaire. Les valeurs résultantes sont concaténées en une séquence unique, unidimensionnelle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="collectionSelector" /> ou <paramref name="resultSelector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SequenceEqual&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si deux séquences sont égales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SequenceEqual``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.SequenceEqual (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
        <param name="source1">Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments à comparer à ceux de <paramref name="source2" />.</param>
        <param name="source2">Un <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments à comparer à ceux de la première séquence.</param>
        <summary>Détermine si deux séquences sont égales à l’aide du comparateur d’égalité par défaut pour comparer les éléments.</summary>
        <returns><see langword="true" /> Si les deux séquences source sont de longueur égale et que leurs éléments correspondants sont égaux ; Sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source1` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source1` paramètre. Le comportement attendu est qu’il détermine si les deux séquences source sont égaux.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> pour déterminer si deux séquences sont égales. Dans cet exemple, les séquences sont égales.  
  
 [!code-csharp[System.Linq.Queryable#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#32)]
 [!code-vb[System.Linq.Queryable#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#32)]  
  
 L’exemple de code suivant compare deux séquences qui ne sont pas égaux.  
  
 [!code-csharp[System.Linq.Queryable#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#33)]
 [!code-vb[System.Linq.Queryable#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> ou <paramref name="source2" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SequenceEqual``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.SequenceEqual (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
        <param name="source1">Un <see cref="T:System.Linq.IQueryable`1" /> dont les éléments à comparer à ceux de <paramref name="source2" />.</param>
        <param name="source2">Un <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments à comparer à ceux de la première séquence.</param>
        <param name="comparer">Un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> à utiliser pour comparer les éléments.</param>
        <summary>Détermine si deux séquences sont égales en utilisant un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les éléments.</summary>
        <returns><see langword="true" /> Si les deux séquences source sont de longueur égale et que leurs éléments correspondants sont égaux ; Sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source1` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> dépend de l’implémentation du type de le `source1` paramètre. Le comportement attendu est qu’il détermine si la source de deux séquences sont égales à l’aide de `comparer` pour comparer les éléments.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> ou <paramref name="source2" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Single&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un élément spécifique unique d’une séquence.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Single``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Single : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Single source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> pour retourner le seul élément.</param>
        <summary>Retourne l’élément unique d’une séquence ou lève une exception si cette séquence ne contient pas un seul élément.</summary>
        <returns>Seul élément de la séquence d'entrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne le seul élément dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> pour sélectionner le seul élément d’un tableau.  
  
 [!code-csharp[System.Linq.Queryable#79](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#79)]
 [!code-vb[System.Linq.Queryable#79](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#79)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> a plusieurs éléments.</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Single``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Single : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Single (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> pour retourner un seul élément.</param>
        <param name="predicate">Fonction permettant de tester un élément pour une condition.</param>
        <summary>Retourne le seul élément d’une séquence qui satisfait à une condition spécifique ou lève une exception si cette séquence contient plusieurs éléments respectant cette condition.</summary>
        <returns>L’élément unique de la séquence d’entrée qui satisfait la condition dans <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne le seul élément dans `source` qui satisfait la condition spécifiée par `predicate`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> pour sélectionner le seul élément d’un tableau qui remplit une condition.  
  
 [!code-csharp[System.Linq.Queryable#81](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#81)]
 [!code-vb[System.Linq.Queryable#81](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#81)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Aucun élément ne satisfait la condition dans <paramref name="predicate" />.  
  
ou 
Plusieurs éléments remplissent la condition dans <paramref name="predicate" />.  
  
ou 
La séquence source est vide.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SingleOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un élément spécifique unique d’une séquence ou une valeur par défaut si aucun élément n’est trouvé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SingleOrDefault``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.SingleOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> pour retourner le seul élément.</param>
        <summary>Retourne le seul élément d’une séquence ou une valeur par défaut si la séquence est vide. Cette méthode lève une exception s’il existe plusieurs éléments dans la séquence.</summary>
        <returns>Élément unique de la séquence d’entrée ou <c>default</c>(<paramref name="TSource" />) si la séquence ne contient aucun élément.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne le seul élément dans `source`, ou une valeur par défaut si `source` est vide.  
  
 Le <xref:System.Linq.Queryable.SingleOrDefault%2A> méthode ne fournit pas un moyen de spécifier une valeur par défaut. Si vous souhaitez spécifier une valeur par défaut autre que `default(TSource)`, utilisez le <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> méthode comme décrit dans la section exemple.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> pour sélectionner le seul élément d’un tableau. La deuxième requête montre que <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> retourne une valeur par défaut lorsque la séquence ne contient pas exactement un élément.  
  
 [!code-csharp[System.Linq.Queryable#83](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#83)]
 [!code-vb[System.Linq.Queryable#83](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#83)]  
  
 Parfois, la valeur de `default(TSource)` n’est pas la valeur par défaut que vous souhaitez utiliser si la collection ne contient aucun élément. Au lieu de vérifier le résultat de la valeur par défaut indésirables, puis de la modifier si nécessaire, vous pouvez utiliser la <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> méthode pour spécifier la valeur par défaut que vous souhaitez utiliser si la collection est vide. Ensuite, appelez <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> pour obtenir l’élément. L’exemple de code suivant utilise ces deux techniques pour obtenir une valeur par défaut de 1 si une collection de numéros de page est vide. Étant donné que la valeur par défaut pour un entier est 0, ce qui n’est pas généralement un numéro de page valide, la valeur par défaut doit être spécifiée comme 1. La première variable de résultat est vérifiée pour la valeur par défaut indésirables une fois la requête est terminée. La deuxième variable de résultat est obtenue en appelant <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> pour spécifier une valeur par défaut de 1.  
  
 [!code-csharp[System.Linq.Queryable#133](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#133)]
 [!code-vb[System.Linq.Queryable#133](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#133)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> a plusieurs éléments.</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SingleOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.SingleOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> pour retourner un seul élément.</param>
        <param name="predicate">Fonction permettant de tester un élément pour une condition.</param>
        <summary>Retourne l’élément unique d’une séquence ou une valeur par défaut si cette séquence ne contient pas d’élément respectant cette condition. Cette méthode lève une exception si cette séquence contient plusieurs éléments satisfaisant à cette condition.</summary>
        <returns>Élément unique de la séquence d’entrée qui satisfait la condition dans <paramref name="predicate" />, ou <c>default</c>(<paramref name="TSource" />) si aucun élément de ce type n’est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne le seul élément dans `source` qui satisfait la condition spécifiée par `predicate`, ou une valeur par défaut si aucun élément n’existe.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> pour sélectionner le seul élément d’un tableau qui remplit une condition. La deuxième requête montre que <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> retourne une valeur par défaut lorsque la séquence ne contient pas exactement un élément qui satisfait la condition.  
  
 [!code-csharp[System.Linq.Queryable#85](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#85)]
 [!code-vb[System.Linq.Queryable#85](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#85)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Plusieurs éléments remplissent la condition dans <paramref name="predicate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Skip``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Skip(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Skip : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Skip (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> pour retourner des éléments à partir de.</param>
        <param name="count">Nombre d'éléments à ignorer avant de retourner les éléments restants.</param>
        <summary>Ignore un nombre spécifié d’éléments dans une séquence et retourne ensuite les éléments restants.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments se trouvant après l’index spécifié dans la séquence d’entrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il ignore le premier `count` éléments dans `source` et retourne les éléments restants.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> pour ignorer un nombre spécifié d’éléments dans un tableau trié et retourner les éléments restants.  
  
 [!code-csharp[System.Linq.Queryable#87](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#87)]
 [!code-vb[System.Linq.Queryable#87](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; SkipLast&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; SkipLast&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SkipLast``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipLast(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ SkipLast(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member SkipLast : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.SkipLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ignore les éléments d’une séquence tant qu’une condition spécifiée a la valeur true et puis retourne les éléments restants.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SkipWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ SkipWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> pour retourner des éléments à partir de.</param>
        <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
        <summary>Ignore les éléments d’une séquence tant qu’une condition spécifiée a la valeur true et puis retourne les éléments restants.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments de <paramref name="source" /> à partir du premier élément de la série linéaire à ne pas réussir le test spécifié par <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’elle s’applique `predicate` à chaque élément dans `source` jusqu'à ce qu’il trouve un élément pour lequel `predicate` retourne la valeur false. Cet élément et tous les éléments restants sont retournés.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> pour ignorer des éléments d’un tableau tant qu’une condition est vraie.  
  
 [!code-csharp[System.Linq.Queryable#88](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#88)]
 [!code-vb[System.Linq.Queryable#88](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SkipWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Integer, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ SkipWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> pour retourner des éléments à partir de.</param>
        <param name="predicate">Fonction permettant de tester chaque élément pour une condition ; le deuxième paramètre de cette fonction représente l’index de l’élément source.</param>
        <summary>Ignore les éléments d’une séquence tant qu’une condition spécifiée a la valeur true et puis retourne les éléments restants. L’index de l’élément est utilisé dans la logique de la fonction de prédicat.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments de <paramref name="source" /> à partir du premier élément de la série linéaire à ne pas réussir le test spécifié par <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’elle s’applique `predicate` à chaque élément dans `source` jusqu'à ce qu’il trouve un élément pour lequel `predicate` retourne la valeur false. Cet élément et tous les éléments restants sont retournés. L’index de chaque élément source est fourni comme deuxième argument à `predicate`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> pour ignorer des éléments d’un tableau tant qu’une condition qui varie selon l’index de l’élément a la valeur true.  
  
 [!code-csharp[System.Linq.Queryable#89](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#89)]
 [!code-vb[System.Linq.Queryable#89](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sum">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcule la somme d'une séquence de valeurs numériques.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Linq.IQueryable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Linq.IQueryable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Linq::IQueryable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de <see cref="T:System.Decimal" /> valeurs pour calculer la somme de.</param>
        <summary>Calcule la somme d’une séquence de <see cref="T:System.Decimal" /> valeurs.</summary>
        <returns>La somme des valeurs dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne la somme des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> pour additionner les valeurs d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Linq.IQueryable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Linq.IQueryable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Linq::IQueryable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;double&gt; -&gt; double" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de <see cref="T:System.Double" /> valeurs pour calculer la somme de.</param>
        <summary>Calcule la somme d’une séquence de <see cref="T:System.Double" /> valeurs.</summary>
        <returns>La somme des valeurs dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Double%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Double%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Double%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne la somme des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> pour additionner les valeurs d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Linq.IQueryable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Linq.IQueryable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Linq::IQueryable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;int&gt; -&gt; int" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de <see cref="T:System.Int32" /> valeurs pour calculer la somme de.</param>
        <summary>Calcule la somme d’une séquence de <see cref="T:System.Int32" /> valeurs.</summary>
        <returns>La somme des valeurs dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int32%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int32%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int32%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne la somme des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> pour additionner les valeurs d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Linq.IQueryable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Linq.IQueryable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Linq::IQueryable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;int64&gt; -&gt; int64" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de <see cref="T:System.Int64" /> valeurs pour calculer la somme de.</param>
        <summary>Calcule la somme d’une séquence de <see cref="T:System.Int64" /> valeurs.</summary>
        <returns>La somme des valeurs dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int64%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int64%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int64%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne la somme des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> pour additionner les valeurs d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de nullable <see cref="T:System.Decimal" /> valeurs pour calculer la somme de.</param>
        <summary>Calcule la somme d’une séquence de nullable <see cref="T:System.Decimal" /> valeurs.</summary>
        <returns>La somme des valeurs dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne la somme des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> pour additionner les valeurs d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de nullable <see cref="T:System.Double" /> valeurs pour calculer la somme de.</param>
        <summary>Calcule la somme d’une séquence de nullable <see cref="T:System.Double" /> valeurs.</summary>
        <returns>La somme des valeurs dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne la somme des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> pour additionner les valeurs d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de nullable <see cref="T:System.Int32" /> valeurs pour calculer la somme de.</param>
        <summary>Calcule la somme d’une séquence de nullable <see cref="T:System.Int32" /> valeurs.</summary>
        <returns>La somme des valeurs dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne la somme des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> pour additionner les valeurs d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de nullable <see cref="T:System.Int64" /> valeurs pour calculer la somme de.</param>
        <summary>Calcule la somme d’une séquence de nullable <see cref="T:System.Int64" /> valeurs.</summary>
        <returns>La somme des valeurs dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne la somme des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> pour additionner les valeurs d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de nullable <see cref="T:System.Single" /> valeurs pour calculer la somme de.</param>
        <summary>Calcule la somme d’une séquence de nullable <see cref="T:System.Single" /> valeurs.</summary>
        <returns>La somme des valeurs dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne la somme des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> pour additionner les valeurs d’une séquence.  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Linq.IQueryable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Linq.IQueryable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Linq::IQueryable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;single&gt; -&gt; single" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Une séquence de <see cref="T:System.Single" /> valeurs pour calculer la somme de.</param>
        <summary>Calcule la somme d’une séquence de <see cref="T:System.Single" /> valeurs.</summary>
        <returns>La somme des valeurs dans la séquence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne la somme des valeurs dans `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> pour additionner les valeurs d’une séquence.  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Decimal))) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Decimal&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, decimal&gt;&gt; -&gt; decimal" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs de type <paramref name="TSource" />.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la somme de la séquence de <see cref="T:System.Decimal" /> les valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>La somme des valeurs projetées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément de `source` et retourne la somme des valeurs résultantes.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> pour additionner les valeurs projetées d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Double))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, double&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, double&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs de type <paramref name="TSource" />.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la somme de la séquence de <see cref="T:System.Double" /> les valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>La somme des valeurs projetées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> dépend de l’implémentation du type de l’il `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément de `source` et retourne la somme des valeurs résultantes.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> pour additionner les valeurs projetées d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int&gt;&gt; -&gt; int" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs de type <paramref name="TSource" />.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la somme de la séquence de <see cref="T:System.Int32" /> les valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>La somme des valeurs projetées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément de `source` et retourne la somme des valeurs résultantes.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> pour additionner les valeurs projetées d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Long))) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, long&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int64&gt;&gt; -&gt; int64" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs de type <paramref name="TSource" />.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la somme de la séquence de <see cref="T:System.Int64" /> les valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>La somme des valeurs projetées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément de `source` et retourne la somme des valeurs résultantes.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> pour additionner les valeurs projetées d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;decimal&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Decimal)))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;decimal&gt;&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs de type <paramref name="TSource" />.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la somme de la séquence de nullable <see cref="T:System.Decimal" /> valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>La somme des valeurs projetées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément de `source` et retourne la somme des valeurs résultantes.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> pour additionner les valeurs projetées d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;double&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Double)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;double&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;double&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs de type <paramref name="TSource" />.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la somme de la séquence de nullable <see cref="T:System.Double" /> valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>La somme des valeurs projetées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément de `source` et retourne la somme des valeurs résultantes.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> pour additionner les valeurs projetées d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;int&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Integer)))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;int&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int&gt;&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs de type <paramref name="TSource" />.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la somme de la séquence de nullable <see cref="T:System.Int32" /> valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>La somme des valeurs projetées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément de `source` et retourne la somme des valeurs résultantes.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> pour additionner les valeurs projetées d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;long&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Long)))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;long&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int64&gt;&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs de type <paramref name="TSource" />.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la somme de la séquence de nullable <see cref="T:System.Int64" /> valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>La somme des valeurs projetées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément de `source` et retourne la somme des valeurs résultantes.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> pour additionner les valeurs projetées d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;float&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Single)))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;float&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;single&gt;&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs de type <paramref name="TSource" />.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la somme de la séquence de nullable <see cref="T:System.Single" /> valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>La somme des valeurs projetées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément de `source` et retourne la somme des valeurs résultantes.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> pour additionner les valeurs projetées d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Single))) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, float&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, single&gt;&gt; -&gt; single" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Une séquence de valeurs de type <paramref name="TSource" />.</param>
        <param name="selector">Une fonction de projection à appliquer à chaque élément.</param>
        <summary>Calcule la somme de la séquence de <see cref="T:System.Single" /> les valeurs obtenues en appelant une fonction de projection sur chaque élément de la séquence d’entrée.</summary>
        <returns>La somme des valeurs projetées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il appelle `selector` sur chaque élément de `source` et retourne la somme des valeurs résultantes.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> pour additionner les valeurs projetées d’une séquence.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="selector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Take&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Take``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Take(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Take(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Take : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Take (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Séquence à partir de laquelle retourner les éléments.</param>
        <param name="count">Nombre d'éléments à retourner.</param>
        <summary>Retourne un nombre spécifié d’éléments contigus à partir du début d’une séquence.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient le nombre spécifié d’éléments à partir du début de <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il prend le premier `count` éléments à partir du début de `source`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> pour retourner des éléments à partir du début d’une séquence.  
  
 [!code-csharp[System.Linq.Queryable#99](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#99)]
 [!code-vb[System.Linq.Queryable#99](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; TakeLast&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; TakeLast&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.TakeLast``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeLast(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ TakeLast(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member TakeLast : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.TakeLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne des éléments d’une séquence tant que la condition spécifiée a la valeur true, puis ignore les éléments restants.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.TakeWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ TakeWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Séquence à partir de laquelle retourner les éléments.</param>
        <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
        <summary>Retourne des éléments d’une séquence tant qu’une condition spécifiée a la valeur true.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments de la séquence d’entrée placés avant l’élément à partir duquel le test spécifié par <paramref name="predicate" /> n’est plus réussi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’elle s’applique `predicate` à chaque élément dans `source` jusqu'à ce qu’il trouve un élément pour lequel `predicate` retourne `false`. Elle retourne tous les éléments jusqu'à ce point.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> pour retourner des éléments à partir du début d’une séquence tant qu’une condition est vraie.  
  
 [!code-csharp[System.Linq.Queryable#100](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#100)]
 [!code-vb[System.Linq.Queryable#100](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.TakeWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Integer, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ TakeWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Séquence à partir de laquelle retourner les éléments.</param>
        <param name="predicate">Fonction permettant de tester chaque élément pour une condition ; le deuxième paramètre de la fonction représente l’index de l’élément dans la séquence source.</param>
        <summary>Retourne des éléments d’une séquence tant qu’une condition spécifiée a la valeur true. L’index de l’élément est utilisé dans la logique de la fonction de prédicat.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments de la séquence d’entrée placés avant l’élément à partir duquel le test spécifié par <paramref name="predicate" /> n’est plus réussi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’elle s’applique `predicate` à chaque élément dans `source` jusqu'à ce qu’il trouve un élément pour lequel `predicate` retourne `false`. Elle retourne tous les éléments jusqu'à ce point. L’index de chaque élément source est fourni comme deuxième argument à `predicate`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> pour retourner des éléments à partir du début d’une séquence tant qu’une condition qui utilise l’index de l’élément a la valeur true.  
  
 [!code-csharp[System.Linq.Queryable#101](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#101)]
 [!code-vb[System.Linq.Queryable#101](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Réalise un classement des éléments d’une séquence dans l’ordre croissant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenBy``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la fonction représentée par <paramref name="keySelector" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IOrderedQueryable`1" /> qui contient les éléments à trier.</param>
        <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
        <summary>Réalise un classement des éléments d’une séquence dans l’ordre croissant selon une clé.</summary>
        <returns>Un <see cref="T:System.Linq.IOrderedQueryable`1" /> dont les éléments sont triés selon une clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre. Le résultat de l’appel <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> est casté en type <xref:System.Linq.IOrderedQueryable%601> et retourné.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il effectue un tri secondaire des éléments de `source` selon la clé obtenue en appelant `keySelector` sur chaque élément de `source`. Tous les précédemment établie d’ordres de tri sont conservées.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> pour effectuer un classement secondaire des éléments dans une séquence.  
  
 [!code-csharp[System.Linq.Queryable#102](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#102)]
 [!code-vb[System.Linq.Queryable#102](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenBy``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la fonction représentée par <paramref name="keySelector" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IOrderedQueryable`1" /> qui contient les éléments à trier.</param>
        <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> pour comparer les clés.</param>
        <summary>Réalise un classement des éléments d’une séquence dans l’ordre croissant à l’aide du comparateur spécifié.</summary>
        <returns>Un <see cref="T:System.Linq.IOrderedQueryable`1" /> dont les éléments sont triés selon une clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre. Le résultat de l’appel <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> est casté en type <xref:System.Linq.IOrderedQueryable%601> et retourné.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il effectue un tri secondaire des éléments de `source` selon la clé obtenue en appelant `keySelector` sur chaque élément de `source`. Tous les précédemment établie d’ordres de tri sont conservées. Le `comparer` paramètre est utilisé pour comparer des valeurs de clé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> ou <paramref name="comparer" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Réalise un classement des éléments d’une séquence dans l’ordre décroissant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenByDescending``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la fonction représentée par <paramref name="keySelector" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IOrderedQueryable`1" /> qui contient les éléments à trier.</param>
        <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
        <summary>Réalise un classement des éléments d’une séquence dans l’ordre décroissant selon une clé.</summary>
        <returns>Un <see cref="T:System.Linq.IOrderedQueryable`1" /> dont les éléments sont triés par ordre décroissant selon une clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre. Le résultat de l’appel <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> est casté en type <xref:System.Linq.IOrderedQueryable%601> et retourné.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il effectue un tri secondaire des éléments de `source` dans l’ordre décroissant, en fonction de la clé obtenue en appelant `keySelector` sur chaque élément de `source`. Tous les précédemment établie d’ordres de tri sont conservées.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenByDescending``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Le type de la clé retournée par la <paramref name="keySelector" /> (fonction).</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IOrderedQueryable`1" /> qui contient les éléments à trier.</param>
        <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> pour comparer les clés.</param>
        <summary>Réalise un classement des éléments d’une séquence dans l’ordre décroissant à l’aide d’un comparateur spécifié.</summary>
        <returns>Collection dont les éléments sont triés par ordre décroissant selon une clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre. Le résultat de l’appel <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> est casté en type <xref:System.Linq.IOrderedQueryable%601> et retourné.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il effectue un tri secondaire des éléments de `source` dans l’ordre décroissant, en fonction de la clé obtenue en appelant `keySelector` sur chaque élément de `source`. Tous les précédemment établie d’ordres de tri sont conservées. Le `comparer` paramètre est utilisé pour comparer des valeurs de clé.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> pour effectuer un classement secondaire des éléments d’une séquence dans l’ordre décroissant à l’aide d’un comparateur personnalisé.  
  
 [!code-csharp[System.Linq.Queryable#103](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#103)]
 [!code-vb[System.Linq.Queryable#103](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="keySelector" /> ou <paramref name="comparer" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Union&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Produit l’union définie de deux séquences.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Union``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Union(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Union (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
        <param name="source1">Séquence dont les éléments distincts constituent le premier jeu pour l’opération d’union.</param>
        <param name="source2">Séquence dont les éléments distincts forment le second jeu pour l’opération d’union.</param>
        <summary>Produit l’union définie de deux séquences à l’aide du comparateur d’égalité par défaut.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments de deux séquences d’entrée, exclure les doublons.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source1` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> dépend de l’implémentation du type de le `source1` paramètre. Le comportement attendu est que l’union définie des éléments dans `source1` et `source2` est retourné.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> pour obtenir de l’union définie de deux séquences.  
  
 [!code-csharp[System.Linq.Queryable#109](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#109)]
 [!code-vb[System.Linq.Queryable#109](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#109)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> ou <paramref name="source2" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Union``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Union(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Union (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
        <param name="source1">Séquence dont les éléments distincts constituent le premier jeu pour l’opération d’union.</param>
        <param name="source2">Séquence dont les éléments distincts forment le second jeu pour l’opération d’union.</param>
        <param name="comparer">Un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer des valeurs.</param>
        <summary>Produit l’union définie de deux séquences en utilisant un <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments de deux séquences d’entrée, exclure les doublons.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source1` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> dépend de l’implémentation du type de le `source1` paramètre. Le comportement attendu est que l’union définie des éléments dans `source1` et `source2` est retourné. Le `comparer` paramètre est utilisé pour comparer des valeurs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> ou <paramref name="source2" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Where&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Filtre une séquence de valeurs selon un prédicat.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Where``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Where(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> à filtrer.</param>
        <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
        <summary>Filtre une séquence de valeurs selon un prédicat.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments de la séquence d’entrée qui satisfont la condition spécifiée par <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne les éléments de `source` qui satisfont la condition spécifiée par `predicate`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> pour filtrer une séquence.  
  
 [!code-csharp[System.Linq.Queryable#110](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#110)]
 [!code-vb[System.Linq.Queryable#110](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Where``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Integer, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Where(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Le type des éléments de <paramref name="source" />.</typeparam>
        <param name="source">Un <see cref="T:System.Linq.IQueryable`1" /> à filtrer.</param>
        <param name="predicate">Fonction permettant de tester chaque élément pour une condition ; le deuxième paramètre de la fonction représente l’index de l’élément dans la séquence source.</param>
        <summary>Filtre une séquence de valeurs selon un prédicat. L'index de chaque élément est utilisé dans la logique de la fonction de prédicat.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments de la séquence d’entrée qui satisfont la condition spécifiée par <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode a au moins un paramètre de type <xref:System.Linq.Expressions.Expression%601> dont l’argument de type est un de la <xref:System.Func%602> types. Pour ces paramètres, vous pouvez passer dans une expression lambda, et il est compilé en un <xref:System.Linq.Expressions.Expression%601>.  
  
 Le <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source` paramètre.  
  
 Le comportement de la requête qui se produit suite à l’exécution d’une arborescence d’expression qui représente l’appel <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> dépend de l’implémentation du type de le `source` paramètre. Le comportement attendu est qu’il retourne les éléments de `source` qui satisfont la condition spécifiée par `predicate`. L’index de chaque élément source est fourni comme deuxième argument à `predicate`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> pour filtrer une séquence selon un prédicat qui incorpore l’index de chaque élément.  
  
 [!code-csharp[System.Linq.Queryable#111](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#111)]
 [!code-vb[System.Linq.Queryable#111](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ou <paramref name="predicate" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;ValueTuple&lt;TFirst,TSecond&gt;&gt; Zip&lt;TFirst,TSecond&gt; (this System.Linq.IQueryable&lt;TFirst&gt; source1, System.Collections.Generic.IEnumerable&lt;TSecond&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;valuetype System.ValueTuple`2&lt;!!TFirst, !!TSecond&gt;&gt; Zip&lt;TFirst, TSecond&gt;(class System.Linq.IQueryable`1&lt;!!TFirst&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Zip``2(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond) (source1 As IQueryable(Of TFirst), source2 As IEnumerable(Of TSecond)) As IQueryable(Of ValueTuple(Of TFirst, TSecond))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;ValueTuple&lt;TFirst, TSecond&gt;&gt; ^ Zip(System::Linq::IQueryable&lt;TFirst&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSecond&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Zip : System.Linq.IQueryable&lt;'First&gt; * seq&lt;'Second&gt; -&gt; System.Linq.IQueryable&lt;ValueTuple&lt;'First, 'Second&gt;&gt;" Usage="System.Linq.Queryable.Zip (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.ValueTuple&lt;TFirst,TSecond&gt;&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="netcore-3.0">
            <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "First", "Second" })</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TFirst&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">To be added.</typeparam>
        <typeparam name="TSecond">To be added.</typeparam>
        <param name="source1">To be added.</param>
        <param name="source2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Linq.IQueryable&lt;TFirst&gt; source1, System.Collections.Generic.IEnumerable&lt;TSecond&gt; source2, System.Linq.Expressions.Expression&lt;Func&lt;TFirst,TSecond,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TFirst&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; source2, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Zip``3(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond, TResult) (source1 As IQueryable(Of TFirst), source2 As IEnumerable(Of TSecond), resultSelector As Expression(Of Func(Of TFirst, TSecond, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Zip(System::Linq::IQueryable&lt;TFirst&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSecond&gt; ^ source2, System::Linq::Expressions::Expression&lt;Func&lt;TFirst, TSecond, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Zip : System.Linq.IQueryable&lt;'First&gt; * seq&lt;'Second&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'First, 'Second, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Zip (source1, source2, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TFirst&gt;" RefType="this" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TFirst,TSecond,TResult&gt;&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Le type des éléments de la première séquence d’entrée.</typeparam>
        <typeparam name="TSecond">Le type des éléments de la seconde séquence d’entrée.</typeparam>
        <typeparam name="TResult">Le type des éléments de la séquence de résultat.</typeparam>
        <param name="source1">La première séquence à fusionner.</param>
        <param name="source2">La deuxième séquence à fusionner.</param>
        <param name="resultSelector">Une fonction qui spécifie comment fusionner les éléments des deux séquences.</param>
        <summary>Fusionne deux séquences à l’aide de la fonction de prédicat spécifiée.</summary>
        <returns>Un <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments fusionnés des deux séquences d’entrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Linq.Queryable.Zip%2A> méthode génère une <xref:System.Linq.Expressions.MethodCallExpression> qui représente l’appel <xref:System.Linq.Queryable.Zip%2A> lui-même en tant qu’une méthode générique construite. Il passe ensuite le <xref:System.Linq.Expressions.MethodCallExpression> à la <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> méthode de la <xref:System.Linq.IQueryProvider> représenté par le <xref:System.Linq.IQueryable.Provider%2A> propriété de le `source1` paramètre.  
  
 La méthode fusionne chaque élément de la première séquence avec un élément qui a le même index dans la deuxième séquence. Si les séquences n’ont pas le même nombre d’éléments, la méthode fusionne des séquences jusqu'à ce qu’il atteigne la fin d’un d’eux. Par exemple, si une séquence a trois éléments et l’autre en a quatre, la séquence résultante aura uniquement trois éléments.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Linq.Queryable.Zip%2A> méthode pour fusionner deux séquences.  
  
 [!code-csharp[System.Linq.Queryable#200](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#200)]
 [!code-vb[System.Linq.Queryable#200](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#200)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> ou <paramref name="source2" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>