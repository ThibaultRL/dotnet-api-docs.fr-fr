<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2a2c38199f65c61be323dc197dcecf58e28e371a" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52740543" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <TypeSignature Language="F#" Value="type HttpResponse = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Encapsule les informations de réponse HTTP issues d'une opération ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les méthodes et propriétés de la <xref:System.Web.HttpResponse> classe sont exposées via la <xref:System.Web.HttpApplication.Response%2A> propriété de la <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, et <xref:System.Web.UI.UserControl> classes.  
  
 Les méthodes suivantes de la <xref:System.Web.HttpResponse> classe sont pris en charge uniquement dans les scénarios de publication et pas dans les publications asynchrones assortir scénarios :  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 Mises à jour de page partielle sont activées lorsque vous utilisez <xref:System.Web.UI.UpdatePanel> contrôles pour mettre à jour des régions sélectionnées d’une page au lieu de la mise à jour de la page entière avec une publication. Pour plus d’informations, consultez [vue d’ensemble du contrôle UpdatePanel](https://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a) et [vue d’ensemble du rendu de Page partielle](https://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49).  
  
   
  
## Examples  
 L’exemple suivant dessine trois rectangles qui se chevauchent lorsque la page est demandée. Le code commence en définissant le <xref:System.Web.HttpResponse.ContentType%2A> propriété image/JPEG, afin que toute la page s’affichera sous la forme d’une image JPEG. Le code appelle ensuite la <xref:System.Web.HttpResponse.Clear%2A> méthode pour vous assurer qu’aucun contenu étranger n’est envoyé avec cette réponse. Ensuite, le code définit le <xref:System.Web.HttpResponse.BufferOutput%2A> propriété sur true afin que la page est complètement traitée avant d’être envoyé au client demandeur. Deux objets utilisés pour dessiner les rectangles sont alors créés : un <xref:System.Drawing.Bitmap> et un <xref:System.Drawing.Graphics> objet. Les variables créées dans la page sont utilisés en tant que coordonnées pour dessiner les rectangles et une chaîne qui apparaît à l’intérieur du plus grand rectangle.  
  
 Lorsque les trois rectangles et la chaîne qui apparaît qu’ils contiennent sont dessinés, le <xref:System.Drawing.Bitmap> est enregistré dans le <xref:System.IO.Stream> objet auquel est associé le <xref:System.Web.HttpResponse.OutputStream%2A> propriété et son format est défini au format JPEG. Le code appelle la <xref:System.Drawing.Image.Dispose%2A> et <xref:System.Drawing.Graphics.Dispose%2A> méthodes pour libérer les ressources utilisées par les deux objets de dessins. Enfin, le code appelle la <xref:System.Web.HttpResponse.Flush%2A> méthode pour envoyer la réponse mise en mémoire tampon au client demandeur.  
  
> [!NOTE]
>  Dans le code, le <xref:System.Web.HttpResponse> objet est référencé par le mot clé `Response`. Par exemple, `Response.Clear()` fait référence à la <xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType> (méthode). Le <xref:System.Web.UI.Page> classe possède une propriété nommée <xref:System.Web.UI.Page.Response%2A> qui expose l’instance actuelle de <xref:System.Web.HttpResponse>.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpResponse : System.IO.TextWriter -&gt; System.Web.HttpResponse" Usage="new System.Web.HttpResponse writer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objet <see cref="T:System.IO.TextWriter" /> qui autorise une sortie HTTP personnalisée.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Web.HttpResponse" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre prend en charge l'infrastructure .NET Framework et n'est pas destiné à être utilisé directement à partir de votre code.  
  
 Les méthodes et propriétés de la <xref:System.Web.HttpResponse> classe sont exposées via la fonction intrinsèque <xref:System.Web.HttpContext.Response%2A> objet dans ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberSignature Language="F#" Value="member this.AddCacheDependency : System.Web.Caching.CacheDependency[] -&gt; unit" Usage="httpResponse.AddCacheDependency dependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">Fichier, clé de cache ou <see cref="T:System.Web.Caching.CacheDependency" /> à ajouter à la liste de dépendances d'application.</param>
        <summary>Associe un jeu de dépendances de cache à la réponse pour faciliter l'invalidation de cette dernière si elle est stockée dans le cache de sortie et si les dépendances spécifiées sont modifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.AddCacheDependency%2A> méthode permet de dépendances doit être créé entre les réponses mises en cache et un <xref:System.Web.Caching.CacheDependency> objet.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une dépendance de cache à l’aide de la <xref:System.Web.HttpResponse.AddCacheDependency%2A> (méthode) et un <xref:System.Web.Caching.CacheDependency> objet.  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="dependencies" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Cette méthode a été appelée trop tard dans le pipeline du traitement du cache, une fois la réponse mise en cache créée.</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">La mise en cache de Pages ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rend la validité d'une réponse mise en cache dépendante d'autres éléments présents dans le cache.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys"><see cref="T:System.Collections.ArrayList" /> qui contient les clés des éléments dont dépend la réponse mise en cache actuelle.</param>
        <summary>Rend la validité d'une réponse mise en cache dépendante d'autres éléments présents dans le cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque les éléments référencés dans le `cacheKeys` paramètre sont supprimés du cache, la réponse mise en cache de l’élément actuel n’est pas valide.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser une page ASP.NET qui est mis en cache de sortie. Le code de la page crée une <xref:System.Collections.ArrayList> objet de clés qui sont associés à des éléments qui sont stockés dans le <xref:System.Web.Caching.Cache> objet. Ensuite, le code passe la <xref:System.Collections.ArrayList> comme paramètre dans un appel à la <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A> (méthode). Ainsi, la réponse de cache de sortie non valide, si un des fichiers spécifiés dans le <xref:System.Collections.ArrayList> modifier.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">La mise en cache de Pages ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : string[] -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Tableau de clés d'élément dont dépend la réponse mise en cache.</param>
        <summary>Rend la validité d'un élément mis en cache dépendante d'un autre élément du cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un de le `cacheKey`s sont supprimés du cache, la réponse mise en cache de l’élément actuel n’est pas valide.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">La mise en cache de Pages ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependency : string -&gt; unit" Usage="httpResponse.AddCacheItemDependency cacheKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">Clé de l'élément dont dépend la réponse mise en cache.</param>
        <summary>Rend la validité d'une réponse mise en cache dépendante d'un autre élément du cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’élément correspondant à la `cacheKey` paramètre est supprimé du cache, la réponse mise en cache de l’élément actuel n’est pas valide.  
  
   
  
## Examples  
 L’exemple suivant est un contrôle utilisateur ASP.NET qui est mis en cache de sortie. Le code pour les appels de contrôle le <xref:System.Web.HttpResponse.AddCacheItemDependency%2A> méthode avec la clé d’un élément stocké dans le <xref:System.Web.Caching.Cache> objet passé comme paramètre. Si l’élément n’existe pas dans le cache, la réponse du contrôle qui a été stockée dans le cache de sortie est invalidée. Cela signifie que pour la requête suivante, une nouvelle version de la réponse du contrôle sera ajoutée au cache de sortie.  
  
 Ensuite, le code vérifie si un élément associé à un `bookData` clé est stockée dans le `Cache` de l’objet et affiche l’un des deux lignes de texte en fonction du résultat. Puis, le code définit le <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> propriété d’un <xref:System.Web.UI.WebControls.DataGrid> contrôle, qui est nommé `dgBooks`, avec un appel à un personnalisé `DataHelper` classe partagée `GetBookData` (méthode) et remplit la <xref:System.Web.UI.WebControls.DataGrid> avec la <xref:System.Web.UI.Control.DataBind%2A> (méthode).  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">La mise en cache de Pages ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute un groupe de noms de fichier à la collection de noms de fichier dont dépend la réponse actuelle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">Collection de fichiers à ajouter.</param>
        <summary>Ajoute un groupe de noms de fichier à la collection de noms de fichier dont dépend la réponse actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant est une page ASP.NET qui est mis en cache de sortie. Le code de la page crée une <xref:System.Collections.ArrayList> de chemins d’accès de fichier, puis passe le <xref:System.Collections.ArrayList> comme paramètre dans un appel à la <xref:System.Web.HttpResponse.AddFileDependencies%2A> (méthode). Cela rend la sortie mise en cache réponse non valide si un des fichiers spécifiés dans le <xref:System.Collections.ArrayList> modifications.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">La mise en cache de Pages ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : string[] -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="filenames">Tableau de fichiers à ajouter.</param>
        <summary>Ajoute un tableau de noms de fichiers à la collection de noms de fichiers dont dépend la réponse actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant ajoute un tableau de noms de fichiers pour le <xref:System.Web.HttpResponse.AddFileDependencies%2A> liste de dépendances de fichier. Si les fichiers change, la réponse mise en cache est invalidée.  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">La mise en cache de Pages ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependency : string -&gt; unit" Usage="httpResponse.AddFileDependency filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nom du fichier à ajouter.</param>
        <summary>Ajoute un seul nom de fichier à la collection de noms de fichiers dont dépend la réponse actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez la <xref:System.Web.HttpResponse.AddFileDependency%2A> méthode pour ajouter une dépendance de fichier, vous devez également spécifier la mise en cache de sortie par programme ou de façon déclarative. Par exemple, pour spécifier la sortie mise en cache de façon déclarative, utilisez la directive. Pour plus d’informations, consultez [Comment : sortie de Page du Cache avec des dépendances de fichier](https://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db).  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter un nom de fichier unique dans le <xref:System.Web.HttpResponse.AddFileDependency%2A> liste de dépendances de fichier. Si le fichier est modifié, la réponse mise en cache est invalidée.  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">La mise en cache de Pages ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHeader : string * string -&gt; unit" Usage="httpResponse.AddHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l'en-tête HTTP auquel ajouter <paramref name="value" />.</param>
        <param name="value">Chaîne à ajouter à l'en-tête.</param>
        <summary>Ajoute un en-tête HTTP au flux de sortie. <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> est fourni pour des raisons de compatibilité avec les versions précédentes d'ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A> est identique à <xref:System.Web.HttpResponse.AppendHeader%2A> et est fournie uniquement pour la compatibilité avec les versions antérieures d’ASP. Avec ASP.NET, utilisez <xref:System.Web.HttpResponse.AppendHeader%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnSendingHeaders : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpResponse.AddOnSendingHeaders callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">Méthode de rappel.</param>
        <summary>[Pris en charge dans .NET Framework 4.5.2 et ultérieur] 
Inscrit un rappel que le runtime ASP.NET appelle immédiatement avant l'envoi des en-têtes de réponse correspondant à cette requête.</summary>
        <returns>Objet <see cref="T:System.Web.ISubscriptionToken" /> qui représente l'abonnement au pseudo-événement OnSendingHeaders.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  La méthode AddOnSendingHeaders n’est pas appelée si le module natif vide la réponse tout d’abord.  
  
 Le pseudo-événement onsendingheaders diffère de l’événement de pipeline IHttpModule : c’est un abonnement par demande plutôt que d’un abonnement par application. L’objectif est que le rappel peut modifier le code d’état de réponse ou peut définir un en-tête ou un cookie de réponse. Autres remarques sur l’utilisation et les mises en garde :  
  
-   Cette méthode est effective uniquement lorsque IIS s’exécute dans le pipeline de mode pipeline intégré et uniquement si les en-têtes de réponse n’ont pas encore été envoyés pour la requête actuelle.  
  
-   Le runtime ASP.NET ne garantit pas quoi que ce soit sur le thread qui le rappel est appelé sur. Par exemple, le rappel peut être appelé de façon synchrone dans un thread d’arrière-plan si un vidage d’arrière-plan est en cours d’exécution. <xref:System.Web.HttpContext.Current%2A> n’est pas garanti pour être disponible dans un thread de ce type.  
  
-   Le rappel ne doit pas appeler toute méthode qui manipule le corps d’entité de réponse ou qui entraîne un vidage. Par exemple, le rappel ne doit pas appeler <xref:System.Web.HttpResponse.Redirect%2A>, comme cette méthode peut manipuler le corps d’entité de réponse.  
  
-   Le rappel doit contenir uniquement du code synchrone courte. Tente d’appeler une opération asynchrone ou attendre une telle opération peut provoquer un interblocage.  
  
-   Le rappel ne doit pas lever d’exception ; Sinon, le comportement est indéfini.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.AppendCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.AppendCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie"><see cref="T:System.Web.HttpCookie" /> à ajouter au flux de sortie.</param>
        <summary>Ajoute un cookie HTTP à la collection de cookies intrinsèque.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un nouveau cookie nommé `LastVisit`, définit la valeur du cookie à la date et heure actuelles et ajoute à la collection de cookies en cours. Tous les cookies dans la collection de cookies sont envoyés au client dans le `Set-Cookie` flux de sortie de l’en-tête avec le protocole HTTP.  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Un cookie est ajouté après l'envoi des en-têtes HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendHeader : string * string -&gt; unit" Usage="httpResponse.AppendHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l'en-tête HTTP à ajouter au flux de sortie.</param>
        <param name="value">Chaîne à ajouter à l'en-tête.</param>
        <summary>Ajoute un en-tête HTTP au flux de sortie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous utilisez le <xref:System.Web.HttpResponse.AppendHeader%2A> méthode pour envoyer des en-têtes spécifiques au cache et en même temps, utilisez le modèle objet de cache (<xref:System.Web.HttpResponse.Cache%2A>) pour définir la stratégie de cache, les en-têtes de réponse HTTP qui se rapportent à la mise en cache (`Cache-Control`, `Expires`, `Last-Modified`, `Pragma`, et `Vary`) peut être supprimé lorsque le modèle objet de cache est utilisé. Ce comportement permet à ASP.NET de mettre à jour les paramètres les plus restrictifs. Par exemple, considérez une page qui inclut des contrôles utilisateur. Si ces contrôles ont des stratégies de cache en conflit, la stratégie de cache la plus restrictive est utilisée. Si un contrôle utilisateur définit l’en-tête «`Cache-Control: Public`« et un autre contrôle utilisateur définit l’en-tête plus restrictif »`Cache-Control: Private`» via des appels à <xref:System.Web.HttpCachePolicy.SetCacheability%2A>, le «`Cache-Control: Private`« en-tête sera envoyé avec la réponse.  
  
 Pour obtenir la liste d’en-têtes HTTP/1.1 standard, consultez la section 14, « Définitions de champ d’en-tête », dans le [Hypertext Transfer Protocol--HTTP/1.1](https://go.microsoft.com/fwlink/?LinkID=73147) spécification sur le site Web de World Wide Web Consortium (W3C).  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Web.HttpResponse.AppendHeader%2A> méthode pour ajouter un en-tête personnalisé pour le <xref:System.Web.HttpResponse> objet envoyé au client demandeur.  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L'en-tête est ajouté une fois que les en-têtes HTTP ont été envoyés.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberSignature Language="F#" Value="member this.AppendToLog : string -&gt; unit" Usage="httpResponse.AppendToLog param" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">Texte à ajouter au fichier journal.</param>
        <summary>Ajoute des informations personnalisées au fichier journal IIS (Internet Information Services).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour permettre la chaîne spécifiée à enregistrer dans le fichier journal, vous devez d’abord activer le **requête URI** possibilité du **propriétés de journalisation étendues** boîte de dialogue pour le site que vous souhaitez enregistrer l’activité dans IIS .  
  
 Pour personnaliser la journalisation étendue dans IIS 6.0, procédez comme suit :  
  
1.  Dans le Gestionnaire des services Internet, développez le nœud ordinateur local, développez le dossier Web ou Sites FTP, cliquez sur le site Web ou FTP et puis cliquez sur **propriétés**.  
  
2.  Cliquez sur le **Site Web ou FTP** onglet, puis sélectionnez le **activer la journalisation** case (si ce n’est pas déjà fait).  
  
3.  Dans le **format de journal actif** , cliquez sur **au Format de fichier journal étendu W3C**.  
  
4.  Cliquez sur **propriétés**.  
  
5.  Cliquez sur le **avancé** onglet, sélectionnez les propriétés que vous souhaitez ouvrir une session, puis cliquez sur **OK**.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter une chaîne dans le journal.  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=36829">Aide du produit Windows Server 2003</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.ApplyAppPathModifier : string -&gt; string" Usage="httpResponse.ApplyAppPathModifier virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Chemin d’accès virtuel d’une ressource.</param>
        <summary>Ajoute un ID de session au chemin d'accès virtuel si la session utilise un état de session <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> et retourne le chemin combiné. Si l'état de session <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> n'est pas utilisé, <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> retourne le chemin d'accès virtuel d'origine.</summary>
        <returns><paramref name="virtualPath" /> avec l'ID de session inséré.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> est utilisé uniquement avec les sessions sans cookies pour générer des href absolus.  
  
   
  
## Examples  
 L’exemple suivant déclare une variable chaîne nommée `urlConverted`et lui affecte le résultat d’une <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> appel de méthode. Le code passe ensuite la valeur de la variable à un <xref:System.Web.UI.WebControls.HyperLink> du contrôle <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A> propriété.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginFlush : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpResponse.BeginFlush (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Objet de rappel.</param>
        <param name="state">État de réponse.</param>
        <summary>Envoie la réponse actuellement en mémoire tampon au client.</summary>
        <returns>Objet du résultat asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si sous-jacent <xref:System.Web.HttpWorkerRequest> objet prend en charge les opérations de vidage asynchrones et cette méthode est appelée à partir d’un événement de module asynchrone ou d’un gestionnaire asynchrone, l’opération de vidage est exécutée de façon asynchrone. Sinon, l’opération de vidage est effectuée de façon synchrone. Vidage asynchrone est prise en charge pour IIS 6.0 et versions ultérieures.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La réponse est déjà terminée.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.BinaryWrite : byte[] -&gt; unit" Usage="httpResponse.BinaryWrite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Octets à écrire dans le flux de sortie.</param>
        <summary>Écrit une chaîne de caractères binaires dans le flux de sortie HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant lit un fichier texte dans une mémoire tampon et écrit la mémoire tampon dans le flux de sortie HTTP.  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.HttpResponse.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si la sortie doit être placée en mémoire tampon et envoyée une fois que la réponse a été complètement traitée.</summary>
        <value><see langword="true" /> si la sortie destinée au client est placée en mémoire tampon ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.Buffer%2A> propriété a été déconseillée en faveur de la <xref:System.Web.HttpResponse.BufferOutput%2A> propriété et n’est fourni uniquement pour la compatibilité avec les versions antérieures d’ASP. Avec ASP.NET, utilisez <xref:System.Web.HttpResponse.BufferOutput%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BufferOutput : bool with get, set" Usage="System.Web.HttpResponse.BufferOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si la sortie doit être placée en mémoire tampon et envoyée une fois que la page entière a été traitée.</summary>
        <value><see langword="true" /> si la sortie destinée au client est placée en mémoire tampon ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant définit la <xref:System.Web.HttpResponse.ContentType%2A> propriété pour la réponse sur image/jpeg, appelle le <xref:System.Web.HttpResponse.Clear%2A> méthode pour supprimer les autres contenus qui peut être associé à la réponse, puis définit la <xref:System.Web.HttpResponse.BufferOutput%2A> propriété sur true afin que la page entière traité avant que n’importe quel contenu est envoyé au client demandeur.  
  
 Pour obtenir un exemple complet, consultez la <xref:System.Web.HttpResponse> classe.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.HttpCachePolicy" Usage="System.Web.HttpResponse.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la stratégie de mise en cache d’une page web (délai d’expiration, paramètres de confidentialité, clauses diverses).</summary>
        <value>Objet <see cref="T:System.Web.HttpCachePolicy" /> qui contient les informations sur la stratégie de mise en cache de la réponse actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant écrit les propriétés de la stratégie de cache actuelle dans le flux de sortie HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheControl : string with get, set" Usage="System.Web.HttpResponse.CacheControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'en-tête HTTP <see langword="Cache-Control" /> qui correspond à l'une des valeurs d'énumération<see cref="T:System.Web.HttpCacheability" /></summary>
        <value>Représentation sous forme de chaîne de la valeur d'énumération <see cref="T:System.Web.HttpCacheability" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les valeurs de `Private`, `Public`, et `No-Cache` sont des chaînes et doit être entourée de guillemets ( » «). Si le <xref:System.Web.HttpResponse.CacheControl%2A> propriété est définie sur une valeur qui ne correspond pas à un de la <xref:System.Web.HttpCacheability> valeurs d’énumération, puis un <xref:System.ArgumentException> est levée. Si le <xref:System.Web.HttpResponse.CacheControl%2A> propriété n’est pas définie, la capacité de la réponse est définie sur <xref:System.Web.HttpCacheability.NoCache>.  
  
 Le `CacheControl`, <xref:System.Web.HttpResponse.Expires%2A>, et <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> propriétés ont été déconseillées. Au lieu de cela, les méthodes de la <xref:System.Web.HttpCachePolicy> classe sont disponibles via le <xref:System.Web.HttpResponse.Cache%2A> objet intrinsèque pour contrôler les Internet Information Services (IIS) cache de sortie et les caches de client.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur définie pour la chaîne ne correspond pas à l'une des valeurs d'énumération <see cref="T:System.Web.HttpCacheability" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Charset : string with get, set" Usage="System.Web.HttpResponse.Charset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le jeu de caractères HTTP du flux de sortie.</summary>
        <value>Jeu de caractères HTTP du flux de sortie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Charset` propriété peut être définie sur `null` pour supprimer le HTTP `Content-Type` en-tête.  
  
   
  
## Examples  
 L’exemple suivant vérifie si le jeu de caractères du flux de sortie est Europe centrale (ISO).  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La propriété <see langword="Charset" /> a été définie après l'envoi d'en-têtes.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="httpResponse.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface le contenu de sortie du flux de la mémoire tampon.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.Clear%2A> méthode n’efface pas les informations d’en-tête.  
  
   
  
## Examples  
 L’exemple suivant définit la <xref:System.Web.HttpResponse.ContentType%2A> propriété pour la réponse sur image/jpeg, appelle le <xref:System.Web.HttpResponse.Clear%2A> méthode pour supprimer les autres contenus qui peut être associé à la réponse, puis définit la <xref:System.Web.HttpResponse.BufferOutput%2A> propriété sur true afin que la page terminé traité avant que n’importe quel contenu est envoyé au client demandeur.  
  
 Pour obtenir un exemple complet, consultez la <xref:System.Web.HttpResponse> classe.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberSignature Language="F#" Value="member this.ClearContent : unit -&gt; unit" Usage="httpResponse.ClearContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface le contenu de sortie du flux de la mémoire tampon.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.ClearContent%2A> méthode n’efface pas les informations d’en-tête.  
  
   
  
## Examples  
 L’exemple suivant efface tout le contenu à partir du flux de mémoire tampon.  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberSignature Language="F#" Value="member this.ClearHeaders : unit -&gt; unit" Usage="httpResponse.ClearHeaders " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface tous les en-têtes dans le flux de la mémoire tampon.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant appelle la <xref:System.Web.HttpResponse.ClearHeaders%2A> méthode pour vérifier qu’aucun en-tête n’est envoyées avec la réponse actuelle. Cette technique peut être particulièrement importante si la réponse ASP.NET génère une image, tel qu’un fichier JPEG. Dans cet exemple le <xref:System.Web.HttpResponse.ContentType%2A> propriété a la valeur image/jpeg.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Les en-têtes sont effacés après l'envoi des en-têtes HTTP.</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientDisconnectedToken : System.Threading.CancellationToken" Usage="System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Threading.CancellationToken" /> dépassé lors de la déconnexion du client.</summary>
        <value>Jeton d'annulation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette API est thread-safe. Toutefois, il existe certaines restrictions sur l’utilisation le jeton d’annulation. À l’aide de manière incorrecte peut entraîner des conditions de concurrence, blocages ou tout autre comportement inattendu. Gardez à l’esprit les recommandations suivantes :  
  
-   Assurez-vous que vous n’appelez pas dans cette API en dehors des limites d’une demande unique, car ASP.NET supprime le jeton d’annulation à la fin de la demande. Il n’existe aucune garantie que le jeton jamais passera à un état annulé avant sa suppression. Par exemple, si la demande se termine sans le client ayant déconnecté, le jeton sera supprimé sans tout d’abord avoir été annulée.  
  
-   N’attendez pas la <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>, comme cela annule l’effet d’une notification asynchrone et peut provoquer des interblocages.  
  
-   N’appelez pas la <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> surcharges qui appellera le rappel sur l’original <xref:System.Threading.SynchronizationContext> objet.  
  
-   N’utilisez pas le <xref:System.Web.HttpContext> objet ou autres non thread-safe objets intrinsèques ASP.NET à partir du rappel fourni à la <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> (méthode). Le rappel peut être en cours d’exécution en même temps que les autres ASP.NET ou code d’application.  
  
-   Conservez les méthodes de rappel courte et non bloquante.  
  
-   S’efforcer afin d’éviter la levée d’exceptions de dans les méthodes de rappel.  
  
 Cette propriété n’est possible que dans Internet Information Services (IIS) 7.5 ou une version ultérieure en mode intégré. Si vous l’appelez sans le droit IIS version ou un pipeline mode, un <xref:System.PlatformNotSupportedException> est levée. Pour déterminer la version d’IIS, utilisez <xref:System.Web.HttpRuntime.IISVersion%2A>. Pour déterminer le mode de pipeline, utilisez <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpResponse.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme la connexion du socket à un client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode termine la connexion au client de manière brusque et ne vise pas pour le traitement de la demande HTTP normal. La méthode envoie un paquet de réinitialisation au client, ce qui peut entraîner des données de réponse qui sont mis en mémoire tampon sur le serveur, le client ou quelque part entre les deux à supprimer.  
  
 Toutefois, en général, vous devez appeler <xref:System.Web.HttpApplication.CompleteRequest%2A> au lieu de cela si vous souhaitez passer directement à la <xref:System.Web.HttpApplication.EndRequest> événements et envoyer une réponse au client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le jeu de caractères HTTP du flux de sortie.</summary>
        <value>Objet <see cref="T:System.Text.Encoding" /> qui contient les informations sur le jeu de caractères de la réponse actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut `ContentEncoding` peut être spécifié dans un fichier de configuration ASP.NET dans le [globalization, élément (schéma des paramètres ASP.NET)](https://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) section. Si <xref:System.Web.HttpResponse.ContentEncoding%2A> est spécifié par le client, les paramètres de configuration par défaut sont remplacées.  
  
   
  
## Examples  
 L’exemple suivant écrit une description explicite du caractère définir l’encodage sur le flux de sortie.  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Tentative d’affectation de la valeur <see langword="null" /> à <see cref="P:System.Web.HttpResponse.ContentEncoding" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le type MIME HTTP du flux de sortie.</summary>
        <value>Type MIME HTTP du flux de sortie. La valeur par défaut est « <see langword="text/html" /> ».</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant définit la <xref:System.Web.HttpResponse.ContentType%2A> propriété pour la réponse sur image/jpeg, appelle le <xref:System.Web.HttpResponse.Clear%2A> méthode pour supprimer les autres contenus qui peut être associé à la réponse, puis définit la <xref:System.Web.HttpResponse.BufferOutput%2A> propriété sur true afin que la page terminé traité avant que n’importe quel contenu est envoyé au client demandeur.  
  
 Pour obtenir un exemple complet, consultez la <xref:System.Web.HttpResponse> classe.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La propriété <see cref="P:System.Web.HttpResponse.ContentType" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection de cookies constituant la réponse.</summary>
        <value>Collection de cookies constituant la réponse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET inclut deux collections de cookies intrinsèque. La collection accédée via la <xref:System.Web.HttpRequest.Cookies%2A> collection de <xref:System.Web.HttpRequest> contient des cookies transmis par le client au serveur dans le `Cookie` en-tête. La collection accédée via la <xref:System.Web.HttpResponse.Cookies%2A> collection de <xref:System.Web.HttpResponse> contient de nouveaux cookies créés sur le serveur et transmis au client dans le `Set-Cookie` en-tête.  
  
 Après avoir ajouté un cookie à l’aide de la <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> collection, le cookie est immédiatement disponible dans le <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> collection, même si la réponse n’a pas été envoyée au client.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau cookie nommé `LastVisit`, définit la valeur du cookie à la date et heure actuelles et ajoute le cookie à la collection de cookies en cours. Tous les cookies dans la collection de cookies sont envoyés au client dans le `Set-Cookie` flux de sortie de l’en-tête avec le protocole HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberSignature Language="F#" Value="member this.DisableKernelCache : unit -&gt; unit" Usage="httpResponse.DisableKernelCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Désactive la mise en cache de noyau pour la réponse actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la mise en cache de noyau n’est pas pris en charge, cette méthode n’a aucun effet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberSignature Language="F#" Value="member this.DisableUserCache : unit -&gt; unit" Usage="httpResponse.DisableUserCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Désactive la mise en cache en mode utilisateur IIS pour cette réponse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la mise en cache du mode utilisateur IIS n’est pas pris en charge, cette méthode retourne sans exécuter d’action.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberSignature Language="F#" Value="member this.End : unit -&gt; unit" Usage="httpResponse.End " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Envoie l'ensemble de la sortie actuellement en mémoire tampon au client, arrête l'exécution de la page et déclenche l'événement <see cref="E:System.Web.HttpApplication.EndRequest" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie uniquement pour la compatibilité avec ASP, autrement dit, pour assurer la compatibilité avec la technologie de programmation Web COM qui a précédé ASP.NET. Si vous souhaitez passer directement à la <xref:System.Web.HttpApplication.EndRequest> événements et envoyer une réponse au client, il est généralement préférable d’appeler <xref:System.Web.HttpApplication.CompleteRequest%2A> à la place.  
  
 Pour reproduire le comportement de la `End` méthode dans ASP, cette méthode essaie de déclencher un <xref:System.Threading.ThreadAbortException> exception. Si cette tentative réussite, le thread appelant est abandonné, c'est-à-dire nuire aux performances de votre site. Dans ce cas, aucun code après l’appel à la <xref:System.Web.HttpResponse.End%2A> méthode est exécutée.  
  
 Si le <xref:System.Web.HttpResponse.End%2A> méthode n’est pas en mesure de déclencher un <xref:System.Threading.ThreadAbortException>, il vide à la place les octets de réponse au client. Pour cela de façon synchrone, ce qui peut être également nuit aux performances de votre site.  
  
 Dans les deux cas (ou non un <xref:System.Threading.ThreadAbortException> exception est levée avec succès), le pipeline de réponse passe directement à la <xref:System.Web.HttpApplication.EndRequest> événement.  
  
 Le <xref:System.Web.HttpApplication.CompleteRequest%2A> méthode sans lever une exception et de code après l’appel à la <xref:System.Web.HttpApplication.CompleteRequest%2A> méthode peut être exécutée. Si votre intention est d’éviter l’exécution de code suivante et si la baisse des performances de <xref:System.Web.HttpResponse.End%2A> est acceptable, vous pouvez appeler <xref:System.Web.HttpResponse.End%2A> au lieu de <xref:System.Web.HttpApplication.CompleteRequest%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">L’appel à <see cref="M:System.Web.HttpResponse.End" /> a mis fin à la requête active.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndFlush : IAsyncResult -&gt; unit" Usage="httpResponse.EndFlush asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Objet du résultat asynchrone.</param>
        <summary>Termine une opération de vidage asynchrone.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le vidage asynchrone n'est pas pris en charge et le paramètre <paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le vidage asynchrone n’est pas pris en charge et le paramètre <paramref name="asyncResult" /> ne peut pas être casté en objet <c>FlushAsyncResult</c>.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Expires : int with get, set" Usage="System.Web.HttpResponse.Expires" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre de minutes avant l'expiration d'une page mise en cache dans un navigateur. Si l'utilisateur retourne à la même page avant qu'elle n'expire, la version mise en cache est affichée. <see cref="P:System.Web.HttpResponse.Expires" /> est fourni pour des raisons de compatibilité avec les versions précédentes d'ASP.</summary>
        <value>Nombre de minutes avant l'expiration de la page.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Expires`, <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> et <xref:System.Web.HttpResponse.CacheControl%2A> propriétés ont été déconseillées au profit des méthodes de la <xref:System.Web.HttpCachePolicy> disponibles par le biais de la classe la <xref:System.Web.HttpResponse.Cache%2A> cache de sortie de l’objet intrinsèque pour contrôler les Internet Information Services (IIS) et met en cache du client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ExpiresAbsolute : DateTime with get, set" Usage="System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la date et l'heure absolues auxquelles supprimer des informations du cache. <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> est fourni pour des raisons de compatibilité avec les versions précédentes d'ASP.</summary>
        <value>Date et heure auxquelles la page expire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ExpiresAbsolute`, <xref:System.Web.HttpResponse.Expires%2A>, et <xref:System.Web.HttpResponse.CacheControl%2A> propriétés ont été déconseillées au profit des méthodes de la <xref:System.Web.HttpCachePolicy> disponibles par le biais de la classe la <xref:System.Web.HttpResponse.Cache%2A> cache de sortie de l’objet intrinsèque pour contrôler les Internet Information Services (IIS) et met en cache du client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpResponse.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un objet de filtre de retour à la ligne utilisé pour modifier le corps d'une entité HTTP avant la transmission.</summary>
        <value>Objet <see cref="T:System.IO.Stream" /> qui fait office de filtre de sortie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous créez un `Stream` de l’objet et définir le <xref:System.Web.HttpResponse.Filter%2A> propriété le `Stream` objet, tous les HTTP sortie envoyé par <xref:System.Web.HttpResponse.Write%2A> traverse le filtre.  
  
   
  
## Examples  
 L’exemple suivant est une page ASP.NET qui définit le <xref:System.Web.HttpResponse.Filter%2A> propriété vers une nouvelle instance de la `UpperCaseFilter` classe personnalisé <xref:System.IO.Stream> classe qui convertit tout texte qui le traverse en majuscules. Les informations sur la demande sont enregistrées dans un fichier texte, puis le <xref:System.Web.HttpResponse.Filter%2A> propriété est définie. Une fois que le filtre de réponse est en place, le code appelle la <xref:System.Web.HttpRequest.MapPath%2A> méthode pour obtenir le chemin d’accès absolu à un fichier texte nommé `TestFile.txt` qui sert de source pour le contenu de la réponse. Le code crée ensuite un nouveau <xref:System.IO.StreamReader> objet à lire le fichier de texte du début à la fin, puis appelle la <xref:System.Web.HttpResponse.Write%2A> méthode pour afficher le contenu du fichier sur la page.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le filtrage n'est pas autorisé avec cette entité.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="httpResponse.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Envoie au client l'ensemble de la sortie actuellement en mémoire tampon.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Force mis tous actuellement en mémoire tampon de sortie à envoyer au client. Le <xref:System.Web.HttpResponse.Flush%2A> méthode peut être appelée plusieurs fois au cours du traitement de la demande.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Drawing.Graphics.Save%2A> méthode pour enregistrer un <xref:System.Drawing.Bitmap> de l’objet à le <xref:System.Web.HttpResponse.OutputStream%2A> propriété convertit l’image sur le JPEG de format et. Le code appelle ensuite la `Dispose` méthode sur le <xref:System.Drawing.Bitmap> objet et un <xref:System.Drawing.Graphics> objet libérer les ressources qu’ils utilisaient. Il appelle ensuite la <xref:System.Web.HttpResponse.Flush%2A> méthode envoyer le contenu de la réponse au client demandeur.  
  
 Pour obtenir un exemple complet, consultez la <xref:System.Web.HttpResponse> classe.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le cache est vidé une fois la réponse envoyée.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="httpResponse.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Envoie de façon asynchrone l'ensemble de la sortie actuellement en mémoire tampon au client.</summary>
        <returns><see cref="T:System.Threading.Tasks.Task" /> qui représente l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.HeaderEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un objet <see cref="T:System.Text.Encoding" /> qui représente l'encodage du flux de sortie d'en-tête actuel.</summary>
        <value><see cref="T:System.Text.Encoding" /> qui contient des informations sur le jeu de caractères de l'en-tête actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.HeaderEncoding%2A> propriété vous donne la possibilité de désactiver ou de modifier le <xref:System.Text.Encoding> objet sur un en-tête de réponse à l’aide de la <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF7Encoding>, ou <xref:System.Text.UTF8Encoding> objet. Le codage de valeur par défaut est le <xref:System.Text.UTF8Encoding> classe.  
  
 En modifiant le type de la <xref:System.Web.HttpResponse.HeaderEncoding%2A> propriété, vous pouvez éventuellement augmenter le risque de certaines attaques malveillantes ou la cause des données sensibles d’être envoyées via l’en-tête de réponse. Les attaques par injection d’en-tête peuvent être évitées, en partie, en laissant le <xref:System.Web.HttpResponse.HeaderEncoding%2A> propriété d’une réponse pour le paramètre par défaut. Une attaque contre une application vulnérable pourrait renvoyer le retour de données approuvées dans le cadre d’un en-tête de réponse. Si le <xref:System.Web.HttpResponse.HeaderEncoding%2A> est désactivée en raison d’une exigence pour les lignes de continuation dans un en-tête ou si tout en-tête est construit en fonction du résultat de données non approuvées, les données d’en-tête doivent être validées avant envoi au flux de réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur d’encodage est <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">La valeur d’encodage est <see cref="P:System.Text.Encoding.Unicode" />.  
  
\- ou - 
Les en-têtes ont déjà été envoyés.</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection d'en-têtes de réponse.</summary>
        <value>Collection <see cref="T:System.Collections.Specialized.NameValueCollection" /> d'en-têtes de réponse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.Headers%2A> propriété est uniquement prise en charge avec la [!INCLUDE[iisver](~/includes/iisver-md.md)] mode pipeline intégré et au moins le .NET Framework 3.0. Lorsque vous essayez d’accéder à la <xref:System.Web.HttpResponse.Headers%2A> propriété et l’autre de ces deux conditions n’est pas remplie, un <xref:System.PlatformNotSupportedException> est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">L’opération exige le mode pipeline intégré d’[!INCLUDE[iisver](~/includes/iisver-md.md)] et au moins le .NET Framework version 3.0.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=86952">La mise à niveau des Applications ASP.NET d’IIS 7.0 : différences entre le Mode intégré IIS 7.0 et le mode classique</related>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HeadersWritten : bool" Usage="System.Web.HttpResponse.HeadersWritten" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Pris en charge dans .NET Framework 4.5.2 et ultérieur] 
Obtient une valeur indiquant si les en-têtes de réponse ont été écrits.</summary>
        <value><see langword="true" /> si les en-têtes de réponse ont été écrits ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClientConnected : bool" Usage="System.Web.HttpResponse.IsClientConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le client est encore connecté au serveur.</summary>
        <value><see langword="true" /> si le client est actuellement connecté ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.IsClientConnected%2A> retourne de la propriété `false` lorsque les conditions suivantes sont remplies :  
  
-   Fin de la connexion au client. Cela peut se produire si le <xref:System.Web.HttpResponse.Close%2A> méthode a été appelée, ou si le client a arrêté l’exécution de la page Web ou d’Explorer vers une autre page.  
  
-   Le <xref:System.Web.HttpWorkerRequest> objet qui gère la requête est `null` ou <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> retourne de la méthode `false`. Si un personnalisé <xref:System.Web.HttpWorkerRequest> objet gère la demande, puis le <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> méthode peut définie en fonction de critères personnalisés. Par exemple, la demande de travail personnalisé peut forcer un délai d’attente après une période de temps.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Web.HttpResponse.IsClientConnected%2A> propriété pour vérifier si le client qui demande la page reste connecté au serveur. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> a la valeur true, le code appelle la <xref:System.Web.HttpResponse.Redirect%2A> (méthode) et le client afficheront une autre page. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> est false, le code appelle la <xref:System.Web.HttpResponse.End%2A> (méthode) et le traitement de la page se termine.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRequestBeingRedirected : bool" Usage="System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur booléenne qui indique si le client est transféré vers un nouvel emplacement.</summary>
        <value><see langword="true" /> si la valeur de l'en-tête de réponse d'emplacement est différente de l'emplacement actuel ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A> propriété avec le <xref:System.Web.HttpResponse.RedirectLocation%2A> propriété pour tester et déterminer si l’URI absolu qui est transmis au client dans le protocole HTTP `Location` en-tête est différent de URI en cours et du nouvel URI prévu est en cours transféré vers sera.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter with get, set" Usage="System.Web.HttpResponse.Output" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Permet la sortie du texte dans le flux de réponse HTTP sortant.</summary>
        <value>Objet <see cref="T:System.IO.TextWriter" /> qui permet une sortie personnalisée vers le client.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant est une page ASP.NET qui contient un <xref:System.Web.UI.WebControls.TextBox> contrôle qui a son <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> propriété définie sur <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>. Code de la page prend le texte qu’un utilisateur entre dans le <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>, utilise le <xref:System.Web.HttpServerUtility.HtmlEncode%2A> encoder de méthode au format HTML et le <xref:System.Web.HttpResponse.Output%2A> propriété pour afficher la chaîne encodée sur la page.  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputStream : System.IO.Stream" Usage="System.Web.HttpResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Permet une sortie binaire vers le corps du contenu HTTP sortant.</summary>
        <value><see cref="T:System.IO.Stream" /> d'E/S représentant le contenu brut du corps du contenu HTTP sortant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En commençant par le .NET Framework version 2.0, lorsque vous utilisez le <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> méthode du flux d’e/s retourné par la <xref:System.Web.HttpResponse.OutputStream%2A> propriété, les exceptions suivantes peuvent être levées :  
  
-   <xref:System.ArgumentOutOfRangeException>, si le `offset` ou `count` paramètre est négatif ou si le `buffer` longueur du paramètre moins le `offset` paramètre est inférieur ou égal à zéro.  
  
-   <xref:System.ArgumentNullException>, si le `buffer` paramètre est `null`.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Drawing.Image.Save%2A> méthode pour enregistrer un <xref:System.Drawing.Bitmap> de l’objet à le <xref:System.Web.HttpResponse.OutputStream%2A> propriété et convertit l’image au format JPEG. Le code appelle ensuite la méthode Dispose sur le <xref:System.Drawing.Bitmap> objet et un <xref:System.Drawing.Graphics> objet libérer les ressources qu’ils utilisaient. Enfin, le code appelle la <xref:System.Web.HttpResponse.Flush%2A> méthode envoyer le contenu de la réponse au client demandeur.  
  
 Pour obtenir un exemple complet, consultez la <xref:System.Web.HttpResponse> classe.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="OutputStream" /> n’est pas disponible.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Pics : string -&gt; unit" Usage="httpResponse.Pics value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à ajouter à l'en-tête <see langword="PICS-Label" />.</param>
        <summary>Ajoute un en-tête <see langword="PICS-Label" /> HTTP au flux de sortie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plateforme de sélection de contenu Internet (PICS) est une norme World Wide Web Consortium (W3C) pour l’étiquetage de contenu. PICS est essentiellement un langage pour la création d’un système de contrôle d’accès.  
  
 N’importe quelle valeur peut être une étiquette PICS ; ASP.NET ne valide pas l’étiquette. La longueur maximale de la chaîne est de 255 caractères. Pour plus d’informations sur la syntaxe et des normes de PICS, consultez le [World Wide Web Consortium](https://go.microsoft.com/fwlink/?LinkID=37125) site Web.  
  
   
  
## Examples  
 L’exemple suivant est une page ASP.NET qui affiche une image. Le code de page appelle le <xref:System.Web.HttpResponse.Pics%2A> méthode pour définir le protocole HTTP `PICS-Label` en-tête pour la réponse. La chaîne est passée comme paramètre à la <xref:System.Web.HttpResponse.Pics%2A> méthode représente une étiquette de contrôle d’accès générée à partir du site Web de contenu notation Association ICRA (Internet).  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Promeut un objet promis.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string -&gt; unit" Usage="httpResponse.PushPromise path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">URL de la demande d'opération push. Cela doit être le chemin d’accès virtuel de la ressource relative que le serveur souhaite envoyer au client en mode Push.</param>
        <summary>Cette API permet de prendre en charge les applications qui envoient des promesses push aux clients HTTP 2.0. Vous trouverez plus de détails concernant le mode Server Push Http2 dans <see href="https://http2.github.io/http2-spec/#PushResources">HTTP/2 Specification Section 8.2: Server Push</see>.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise est non déterministe et applications ne doivent pas avoir une logique qui en dépend. Son seul but est parti de performances dans certains cas. Il existe de nombreuses conditions (protocole et l’implémentation) qui peuvent ignorer les demandes de notifications push complètement. L’attente est basé sur « fire-et-forget ».  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpResponse.PushPromise (path, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">URL de la demande d'opération push. Cela doit être le chemin d’accès virtuel de la ressource relative que le serveur souhaite envoyer au client en mode Push.</param>
        <param name="method">Méthode de demande HTTP utilisée par la demande d'opération push.</param>
        <param name="headers">En-tête de demande HTTP utilisé par la demande d'opération push.</param>
        <summary>Cette API permet de prendre en charge les applications qui envoient des promesses push aux clients HTTP 2.0. Vous trouverez plus de détails concernant le mode Server Push Http2 dans <see href="https://http2.github.io/http2-spec/#PushResources">HTTP/2 Specification Section 8.2: Server Push</see>.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise est non déterministe et applications ne doivent pas avoir une logique qui en dépend. Son seul but est parti de performances dans certains cas. Il existe de nombreuses conditions (protocole et l’implémentation) qui peuvent ignorer les demandes de notifications push complètement. L’attente est basé sur « fire-et-forget ».  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Redirige un client vers une nouvelle URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string -&gt; unit" Usage="httpResponse.Redirect url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Emplacement cible. Cela peut être un chemin virtuel relatif à l’application.</param>
        <summary>Redirige une requête vers une nouvelle URL en spécifiant celle-ci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Web.HttpResponse.Redirect%2A> équivaut à appeler <xref:System.Web.HttpResponse.Redirect%2A> avec le deuxième paramètre défini sur `true`.  
  
 <xref:System.Web.HttpResponse.Redirect%2A> appels <xref:System.Web.HttpResponse.End%2A> qui lève un <xref:System.Threading.ThreadAbortException> exception à l’achèvement. Cette exception a un effet négatif sur les performances des applications Web. Par conséquent, nous vous recommandons d’au lieu de cette surcharge utiliser le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> surcharge et le passer `false` pour le `endResponse` paramètre, puis appelez le <xref:System.Web.HttpApplication.CompleteRequest%2A> (méthode). Pour plus d'informations, voir la méthode <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Pour les pages mobiles uniquement, si votre application s’appuie sur les sessions sans cookies, ou il peut recevoir des demandes provenant des appareils mobiles qui nécessitent des sessions sans cookies, à l’aide un tilde (\~) dans un chemin d’accès peut entraîner la création d’une nouvelle session et la perte potentielle de session données. Pour définir une propriété sur un contrôle mobile avec un chemin d’accès tel que «\~/Path », résoudre le chemin d’accès à l’aide <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> « \~ /Path » avant de l’assigner à la propriété.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 302. Une autre façon de transférer le contrôle vers une autre page est le <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode). Le <xref:System.Web.HttpServerUtility.Transfer%2A> méthode est généralement plus efficace, car elle n’entraîne pas un aller-retour vers le client. Pour plus d’informations, consultez [Comment : Rediriger les utilisateurs vers une autre Page](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 L’exemple suivant force une redirection inconditionnelle vers un autre site Web.  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Une redirection a été tentée après l’envoi des en-têtes HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string * bool -&gt; unit" Usage="httpResponse.Redirect (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Emplacement cible.</param>
        <param name="endResponse">Indique si l'exécution de la page active doit s'arrêter.</param>
        <summary>Redirige un client vers une nouvelle URL. Spécifie la nouvelle URL et indique si l'exécution de la page active doit s'arrêter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une URL absolue (par exemple, http://www.contoso.com/default.aspx) ou une URL relative (par exemple, Default.aspx) peut être spécifiée pour l’emplacement cible, mais certains navigateurs peuvent refuser une URL relative.  
  
 Lorsque vous utilisez cette méthode dans un gestionnaire de page pour terminer une requête pour une page et démarrer une nouvelle demande pour une autre page, définissez `endResponse` à `false` , puis appelez le <xref:System.Web.HttpApplication.CompleteRequest%2A> (méthode). Si vous spécifiez `true` pour le `endResponse` paramètre, cette méthode appelle la <xref:System.Web.HttpResponse.End%2A> méthode pour la demande d’origine, qui lève une <xref:System.Threading.ThreadAbortException> exception lorsqu’elle est terminée. Cette exception a un effet négatif sur les performances des applications Web, c’est pourquoi en passant `false` pour le `endResponse` paramètre est recommandé. Pour plus d'informations, voir la méthode <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Pour les pages mobiles, si votre application s’appuie sur les sessions sans cookies, ou il peut recevoir des demandes provenant des appareils mobiles qui nécessitent des sessions sans cookies, à l’aide un tilde (\~) dans un chemin d’accès peut créer une nouvelle session et de perdre des données de session. Pour définir une propriété sur un contrôle mobile avec un chemin d’accès tel que «\~/Path », résoudre le chemin d’accès à l’aide <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> « \~ /Path » avant de l’assigner à la propriété.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 302. Une autre façon de transférer le contrôle vers une autre page est le <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode). Le <xref:System.Web.HttpServerUtility.Transfer%2A> méthode est généralement plus efficace, car elle n’entraîne pas un aller-retour vers le client. Pour plus d’informations, consultez [Comment : Rediriger les utilisateurs vers une autre Page](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Web.HttpResponse.IsClientConnected%2A> propriété pour vérifier si le client qui demande la page reste connecté au serveur. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> a la valeur true, le code appelle la <xref:System.Web.HttpResponse.Redirect%2A> (méthode) et le client afficheront une autre page. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> est false, le code appelle la <xref:System.Web.HttpResponse.End%2A> (méthode) et le traitement de la page se termine.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> contient un caractère de saut de ligne.</exception>
        <exception cref="T:System.Web.HttpException">Une redirection a été tentée après l’envoi des en-têtes HTTP.</exception>
        <exception cref="T:System.ApplicationException">La demande de page est le résultat d’un rappel.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectLocation : string with get, set" Usage="System.Web.HttpResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur de l'en-tête HTTP <see langword="Location" />.</summary>
        <value>URI absolu transmis au client dans l'en-tête HTTP <see langword="Location" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment utiliser cette propriété pour spécifier l’URL de redirection lorsque vous codez une redirection permanente en utilisant le code de réponse HTTP 301.  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Les en-têtes HTTP ont déjà été écrits.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute une redirection permanente d'une URL demandée vers une URL spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string -&gt; unit" Usage="httpResponse.RedirectPermanent url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Emplacement vers lequel la requête est redirigée.</param>
        <summary>Exécute une redirection permanente de l'URL demandée vers l'URL spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> surcharge de méthode fournit un code d’état HTTP 301 dans la réponse et inclut l’URL pour lequel la requête est redirigée. Un code d’état HTTP 301 est un code standard dans une réponse HTTP. Il indique qu’une redirection permanente existe, et il fournit l’emplacement de redirection.  
  
 Appelant le <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> surcharge de méthode met fin à la réponse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> inclut un caractère de saut de ligne (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string * bool -&gt; unit" Usage="httpResponse.RedirectPermanent (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Emplacement vers lequel la requête est redirigée.</param>
        <param name="endResponse"><see langword="true" /> pour terminer la réponse ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</param>
        <summary>Exécute une redirection permanente de l'URL demandée vers l'URL spécifiée et permet de compléter la réponse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> surcharge de méthode fournit un code d’état HTTP 301 dans la réponse et inclut l’URL pour lequel la requête est redirigée. Cette surcharge de méthode fournit également l’option pour spécifier s’il faut terminer ou compléter la réponse après que la redirection a été effectuée. Un code d’état HTTP 301 est un code standard dans une réponse HTTP. Il indique qu’une redirection permanente existe, et il fournit l’emplacement de redirection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> inclut un caractère de saut de ligne (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Redirige une requête vers une nouvelle URL en utilisant des valeurs de paramètres d'itinéraire, un nom d'itinéraire ou les deux.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : obj -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Redirige une requête vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode convertit l’objet qui est passé dans `routeValues` à un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objet à l’aide de la <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructeur. Le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode est ensuite appelée pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 302.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string -&gt; unit" Usage="httpResponse.RedirectToRoute routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <summary>Redirige une requête vers une nouvelle URL en utilisant un nom d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode convertit le nom d’itinéraire qui est passé dans `routeName` vers une URL à l’aide de la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> (méthode).  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 302.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui est nommé `Products`.  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Redirige une requête vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode appelle la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 302.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Redirige une requête vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire et un nom d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode convertit l’objet qui est passé dans `routeValues` à un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objet à l’aide de la <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructeur. Le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode est ensuite appelée pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 302.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire nommé `Product` et qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Redirige une requête vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire et un nom d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode est appelée pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 302.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire nommé `Product` et qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Effectue une redirection permanente d'une URL demandée vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire, un nom d'itinéraire, ou les deux.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Effectue une redirection permanente d'une URL demandée vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode convertit l’objet qui est passé dans `routeValues` à un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objet à l’aide de la <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructeur. Le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode est ensuite appelée pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 301.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <summary>Effectue une redirection permanente d'une URL demandée vers une nouvelle URL en utilisant un nom d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode convertit le nom d’itinéraire qui est passé dans `routeName` vers une URL à l’aide de la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> (méthode).  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 301.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui est nommé `Products`.  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Effectue une redirection permanente d'une URL demandée vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode appelle la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 301.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Effectue une redirection permanente d'une URL demandée vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire et le nom d'itinéraire qui correspondent à la nouvelle URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.HttpResponse.RedirectPermanent%2A> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode convertit l’objet qui est passé dans `routeValues` à un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objet à l’aide de la <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructeur. Le <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode est ensuite appelée pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 301.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire nommé `Product` et qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nom de l'itinéraire.</param>
        <param name="routeValues">Valeurs des paramètres d'itinéraire.</param>
        <summary>Effectue une redirection permanente d'une URL demandée vers une nouvelle URL en utilisant les valeurs des paramètres d'itinéraire et un nom d'itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour faciliter le codage. Il équivaut à appeler le <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> méthode avec le deuxième paramètre défini sur `false`.  
  
 Cette méthode appelle la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> méthode pour déterminer l’URL.  
  
 ASP.NET effectue la redirection en retournant un code d’état HTTP 301.  
  
   
  
## Examples  
 L’exemple suivant montre comment appeler cette méthode pour rediriger vers un itinéraire nommé `Product` et qui a des paramètres nommés `productid` et `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aucun itinéraire ne correspond aux paramètres d'itinéraire spécifiés.</exception>
        <exception cref="T:System.Web.HttpException">Une tentative de redirection a eu lieu après l'envoi des en-têtes HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime des éléments du cache de sortie à l'aide du fournisseur de cache de sortie par défaut.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès absolu virtuel des éléments retirés du cache.</param>
        <summary>Supprime du cache tous les éléments associés au fournisseur de cache de sortie par défaut. Cette méthode est statique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode pour supprimer des éléments de cache de sortie qui sont associés avec le fournisseur de cache de sortie par défaut. Appelez le <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A> méthode pour supprimer des éléments de cache de sortie qui sont associés à des fournisseurs de cache de sortie personnalisés qui sont spécifiés dans le fichier de configuration de site Web.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> n'est pas un chemin d'accès virtuel absolu.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string * string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem (path, providerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="providerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès virtuel des éléments retirés du cache.</param>
        <param name="providerName">Fournisseur utilisé pour supprimer les artefacts de cache de sortie associés au chemin d’accès spécifié.</param>
        <summary>Utilise le fournisseur de cache de sortie spécifié pour supprimer tous les éléments de cache de sortie associés au chemin d’accès spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode pour supprimer des éléments de cache de sortie qui sont associés avec les fournisseurs de cache de sortie personnalisés qui sont spécifiés dans le fichier de configuration de site Web. Pour supprimer des éléments de cache de sortie qui sont associés avec le fournisseur de cache de sortie par défaut, appelez le <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29> surcharge de méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> n'est pas un chemin d'accès valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.SetCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.SetCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Cookie à mettre à jour dans la collection.</param>
        <summary>Dans la mesure où la méthode <b>HttpResponse.SetCookie</b> est exclusivement réservée à un usage interne, vous ne devez pas l’appeler dans votre code. Appelez plutôt la méthode <b>HttpResponse.Cookies.Set</b>, comme le montre l’exemple suivant.<br /> Met à jour un cookie existant dans la collection de cookies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant met à jour la valeur d’un cookie existant.  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Tentative de définir le cookie après l'envoi des en-têtes HTTP.</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Status : string with get, set" Usage="System.Web.HttpResponse.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Définit la ligne <see langword="Status" /> retournée au client.</summary>
        <value>Le fait de définir le code d'état provoque le retour au client d'une chaîne décrivant l'état de la sortie HTTP. La valeur par défaut est 200 (OK).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A> a été déconseillé en faveur de <xref:System.Web.HttpResponse.StatusDescription%2A> et n’est fourni uniquement pour la compatibilité avec les versions antérieures d’ASP. Avec ASP.NET, utilisez <xref:System.Web.HttpResponse.StatusDescription%2A> à la place.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le code d'état spécifié n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.StatusCode : int with get, set" Usage="System.Web.HttpResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le code d'état HTTP du résultat retourné au client.</summary>
        <value>Entier représentant l'état de la sortie HTTP retournée au client. La valeur par défaut est 200 (OK). Pour obtenir la liste des codes d’état valides, consultez [Codes d’état Http](https://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie le code d’état du flux de sortie. Si le code d’état n’est pas égal à 200, le code supplémentaire est exécuté.  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><see cref="P:System.Web.HttpResponse.StatusCode" /> est défini une fois les en-têtes HTTP envoyés.</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusDescription : string with get, set" Usage="System.Web.HttpResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la chaîne d'état HTTP de la sortie retournée au client.</summary>
        <value>Chaîne qui décrit l'état de la sortie HTTP retournée au client. La valeur par défaut est « OK ». Pour obtenir la liste des codes d’état valides, consultez [Codes d’état Http](https://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie la chaîne d’état du flux de sortie. Si l’état n’est pas égal à « OK », le code supplémentaire est exécuté.  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="StatusDescription" /> est défini une fois les en-têtes HTTP envoyés.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur sélectionnée a une longueur supérieure à 512.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SubStatusCode : int with get, set" Usage="System.Web.HttpResponse.SubStatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui qualifie le code d'état de la réponse.</summary>
        <value>Valeur entière qui représente le code de sous-état [!INCLUDE[iisver](~/includes/iisver-md.md)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.SubStatusCode%2A> propriété est uniquement pris en charge avec le mode pipeline intégré dans [!INCLUDE[iisver](~/includes/iisver-md.md)] et au moins le .NET Framework version 3.0. Lorsque vous définissez la <xref:System.Web.HttpResponse.SubStatusCode%2A> propriété, l’état est enregistré [!INCLUDE[iisver](~/includes/iisver-md.md)] si le suivi des demandes ayant échoué est configuré. Indépendamment de si le traçage est configuré, le code n’est jamais envoyé dans le cadre de la réponse finale à la demande. Pour plus d’informations, consultez [dépannage Échec de demandes à l’aide de Failed Request Tracing dans IIS 7.0](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1).  
  
   
  
## Examples  
 L’exemple suivant définit la <xref:System.Web.HttpResponse.SubStatusCode%2A> propriété dans un gestionnaire d’événements pour le <xref:System.Web.HttpApplication> instance de la <xref:System.Web.HttpApplication.PostAuthenticateRequest> événement. Placez le fichier de code dans le dossier App_Code de votre application Web et configurer le fichier Web.config pour inscrire le module. Pour plus d’informations, consultez [procédure pas à pas : création et enregistrement d’un Module d’HTTP personnalisé](https://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453).  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">L’opération exige le mode pipeline intégré d’[!INCLUDE[iisver](~/includes/iisver-md.md)] et au moins le .NET Framework version 3.0.</exception>
        <exception cref="T:System.Web.HttpException">Le code d'état est défini une fois que tous les en-têtes HTTP ont été envoyés.</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAsyncFlush : bool" Usage="System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la connexion prend en charge les opérations de vidage asynchrones.</summary>
        <value><see langword="true" /> si la connexion prend en charge les opérations de vidage asynchrones ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne la valeur de la <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressContent : bool with get, set" Usage="System.Web.HttpResponse.SuppressContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le contenu HTTP doit être envoyé au client.</summary>
        <value><see langword="true" /> pour supprimer la sortie, sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie si le <xref:System.Web.HttpRequest.IsSecureConnection%2A> propriété est définie sur false. Dans le cas, le <xref:System.Web.HttpResponse.SuppressContent%2A> propriété est définie sur true pour arrêter l’envoi de réponse en cours.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressDefaultCacheControlHeader : bool with get, set" Usage="System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Pris en charge dans .NET Framework 4.5.2 et ultérieur] 
Obtient ou définit une valeur indiquant s’il faut supprimer l’en-tête <c>Cache Control: private</c> par défaut de la réponse HTTP actuelle.</summary>
        <value><see langword="true" /> Pour supprimer la valeur par défaut <c>Cache Control : private</c> en-tête pour la réponse HTTP actuelle ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, ASP.NET envoie un `Cache-Control: private` en-tête de réponse, sauf si une stratégie de cache explicite a été spécifiée pour cette réponse. Cette propriété autorise la suppression de cet en-tête de réponse par défaut sur une base par demande. L’en-tête peut toujours être supprimée pour l’application entière en définissant <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> dans [httpRuntime, élément (schéma des paramètres ASP.NET)](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) ou [outputCache, élément de caching (schéma des paramètres ASP.NET)](https://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 Soyez prudent lors de la suppression de la valeur par défaut `Cache-Control: private` en-tête, en tant que proxy et autres intermédiaires peuvent traiter des réponses sans cet en-tête comme mis en cache par défaut. Ce traitement peut entraîner la mise en cache par inadvertance des informations sensibles. Consultez [le document RFC 2616, s. 13.4](http://tools.ietf.org/html/rfc2616) pour plus d’informations.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressFormsAuthenticationRedirect : bool with get, set" Usage="System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la redirection d'authentification par formulaire à la page de connexion doit être supprimée.</summary>
        <value><see langword="true" /> si la redirection d'authentification par formulaire doit être supprimée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, l’authentification par formulaire convertit les codes d’état HTTP 401 302 afin de rediriger vers la page de connexion. Ce n’est pas approprié pour certaines classes d’erreurs, telles que lorsque l’authentification réussit, mais l’autorisation échoue, ou lorsque la requête actuelle est une demande de service web ou AJAX. Cette propriété fournit un moyen de supprimer le comportement de redirection et d’envoyer le code d’état d’origine au client.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit le fichier spécifié directement dans un flux de sortie de réponse HTTP sans le placer en mémoire tampon.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string -&gt; unit" Usage="httpResponse.TransmitFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nom du fichier à écrire dans la sortie HTTP.</param>
        <summary>Écrit le fichier spécifié directement dans un flux de sortie de réponse HTTP sans le placer en mémoire tampon.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="filename" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.TransmitFile (filename, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Nom du fichier à écrire dans la sortie HTTP.</param>
        <param name="offset">Position dans le fichier d'où commence l'écriture vers la sortie HTTP.</param>
        <param name="length">Nombre d'octets à transmettre.</param>
        <summary>Écrit la partie spécifiée d'un fichier directement dans un flux de sortie de réponse HTTP sans la placer en mémoire tampon.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous spécifiez 0 comme le `offset` paramètre et -1 en tant que le `length` paramètre, la totalité du fichier est envoyé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="offset" /> est inférieur à zéro.  
  
\- ou - 
Le paramètre <paramref name="length" /> est inférieur à -1.  
  
\- ou - 
Le paramètre <paramref name="length" /> spécifie un nombre d'octets supérieur au nombre d'octets que le fichier contient (moins la valeur offset).</exception>
        <exception cref="T:System.PlatformNotSupportedException">La demande de travail hors processus n’est pas prise en charge.  
  
\- ou - 
La réponse n'utilise pas d'objet <see cref="T:System.Web.HttpWriter" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="offset" /> est inférieur à zéro ou supérieur à la taille du fichier.  
  
\- ou - 
Le paramètre <paramref name="length" /> est inférieur à -1 ou supérieur à la valeur du paramètre <paramref name="offset" /> plus la taille du fichier.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrySkipIisCustomErrors : bool with get, set" Usage="System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les erreurs personnalisées d'[!INCLUDE[iisver](~/includes/iisver-md.md)] sont désactivées.</summary>
        <value><see langword="true" /> pour des erreurs personnalisées IIS désactivées ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> propriété est utilisée uniquement lorsque votre application est hébergée dans IIS 7.0 et versions ultérieures. Lors de l’exécution en mode classique, le <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> valeur de propriété par défaut est `true`. Lors de l’exécution en mode intégré, le <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> valeur de propriété par défaut est `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit les informations dans un flux de sortie de réponse HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberSignature Language="F#" Value="member this.Write : char -&gt; unit" Usage="httpResponse.Write ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">Caractère à écrire dans le flux de sortie HTTP.</param>
        <summary>Écrit un caractère dans un flux de sortie de réponse HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée une série de constantes qui sont écrits dans une page ASP.NET à l’aide de la méthode Write. Le code appelle cette version de la méthode Write pour écrire des constantes de caractère individuel dans la page.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Write : obj -&gt; unit" Usage="httpResponse.Write obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.Object" /> à écrire dans le flux de sortie HTTP.</param>
        <summary>Écrit un <see cref="T:System.Object" /> dans un flux de réponse HTTP.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="httpResponse.Write s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne à écrire dans le flux de sortie HTTP.</param>
        <summary>Écrit une chaîne dans un flux de sortie de réponse HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pages HTML générées dynamiquement peuvent introduire des risques de sécurité si l’entrée reçue à partir de clients Web n’est pas validée lorsqu’elle est reçue depuis un client ou lorsqu’il est transmis à un client. Un script malveillant qui est incorporé dans l’entrée envoyée à un site Web et réécrite sur un client peut sembler être provenant d’une source approuvée. Ce risque de sécurité est appelé une attaque de script entre sites. Vous devez toujours valider les données reçues à partir d’un client quand elles sont transmises à partir de votre site pour les navigateurs clients.  
  
 En outre, chaque fois que vous envoyez au format HTML des données qui a été reçues en tant qu’entrée, vous devez les encoder à l’aide d’une technique comme <xref:System.Web.HttpServerUtility.HtmlEncode%2A> ou <xref:System.Web.HttpServerUtility.UrlEncode%2A> pour empêcher un script malveillant de l’exécution. Cette technique est utile pour les données qui n’a pas été validées lorsqu’elle a été reçue.  
  
 Lorsque vous codez ou filtrez les données, vous devez spécifier un jeu de caractères pour vos pages Web afin que votre filtre peut identifier et supprimer toute séquence d’octets qui n’appartiennent pas à définie (par exemple, les séquences non alphanumériques) et sont susceptibles d’avoir un script malveillant incorporé dans les.  
  
 Pour plus d’informations sur les attaques de script entre sites, consultez l’article Q252985, « Comment pour empêcher Cross-Site Scripting problèmes de sécurité » sur le [Base de connaissances Microsoft](https://go.microsoft.com/fwlink/?LinkID=37115) site Web.  
  
   
  
## Examples  
 L’exemple suivant renvoie le nom du client au navigateur du client. Le <xref:System.Web.HttpServerUtility.HtmlEncode%2A> méthode supprime n’importe quel script malveillant et les caractères non valides qui auraient pu être envoyés dans le `UserName` champ d’entrée.  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="httpResponse.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de caractères à écrire.</param>
        <param name="index">Emplacement dans le tableau de caractères où débute l'écriture.</param>
        <param name="count">Nombre de caractères à écrire, à partir de <paramref name="index" />.</param>
        <summary>Écrit un tableau de caractères dans un flux de sortie de réponse HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée une série de constantes qui sont écrits dans une page ASP.NET à l’aide de la méthode Write. Le code appelle cette version de la méthode Write pour écrire des constantes de caractère individuel dans la page.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit le fichier spécifié directement dans un flux de sortie de réponse HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string -&gt; unit" Usage="httpResponse.WriteFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nom du fichier à écrire dans la sortie HTTP.</param>
        <summary>Écrit le contenu du fichier spécifié directement dans un flux de sortie de réponse HTTP sous forme de bloc de fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette méthode est utilisée avec des fichiers volumineux, l’appel de la méthode peut lever une exception. La taille du fichier qui peut être utilisé avec cette méthode dépend de la configuration matérielle du serveur Web. Pour plus d’informations, consultez l’article 812406, « PRB : Response.WriteFile ne peut pas télécharger de fichier volumineux » sur le [Base de connaissances Microsoft](https://go.microsoft.com/fwlink/?linkid=149903) site Web.  
  
   
  
## Examples  
 L’exemple suivant écrit le contenu d’un fichier texte nommé `Login.txt` (qui peut contenir les contrôles d’entrée et de texte littéral HTML) directement dans le flux de sortie.  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="filename" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * bool -&gt; unit" Usage="httpResponse.WriteFile (filename, readIntoMemory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Nom du fichier à écrire dans un bloc de mémoire.</param>
        <param name="readIntoMemory">Indique si le fichier sera écrit dans un bloc de mémoire.</param>
        <summary>Écrit le contenu du fichier spécifié directement dans un flux de sortie de réponse HTTP sous forme de bloc de mémoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette méthode est utilisée avec des fichiers volumineux, l’appel de la méthode peut lever une exception. La taille du fichier qui peut être utilisé avec cette méthode dépend de la configuration matérielle du serveur Web. Pour plus d’informations, consultez l’article 812406, « PRB : Response.WriteFile ne peut pas télécharger de fichier volumineux » sur le [Base de connaissances Microsoft](https://go.microsoft.com/fwlink/?linkid=149903) site Web.  
  
   
  
## Examples  
 L’exemple suivant écrit un fichier dans la mémoire.  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="filename" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : nativeint * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (fileHandle, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">Handle du fichier à écrire dans le flux de sortie HTTP.</param>
        <param name="offset">Position de l'octet où l'écriture va commencer dans le fichier.</param>
        <param name="size">Nombre d'octets à écrire dans le flux de sortie.</param>
        <summary>Écrit le fichier spécifié directement dans un flux de sortie de réponse HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette méthode est utilisée avec des fichiers volumineux, l’appel de la méthode peut lever une exception. La taille du fichier qui peut être utilisé avec cette méthode dépend de la configuration matérielle du serveur Web. Pour plus d’informations, consultez l’article 812406, « PRB : Response.WriteFile ne peut pas télécharger de fichier volumineux » sur le [Base de connaissances Microsoft](https://go.microsoft.com/fwlink/?linkid=149903) site Web.  
  
   
  
## Examples  
 L’exemple suivant écrit le contenu d’un fichier texte nommé `Login.txt` (qui peut contenir les contrôles d’entrée et de texte littéral HTML) directement dans le flux de sortie.  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileHandler" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="offset" /> est inférieur à 0.  
  
\- ou - 
 <paramref name="size" /> est supérieur à la taille du fichier moins <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (filename, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Nom du fichier à écrire dans le flux de sortie HTTP.</param>
        <param name="offset">Position de l'octet où commencer l'écriture dans le fichier.</param>
        <param name="size">Nombre d'octets à écrire dans le flux de sortie.</param>
        <summary>Écrit le fichier spécifié directement dans un flux de sortie de réponse HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette méthode est utilisée avec des fichiers volumineux, l’appel de la méthode peut lever une exception. La taille du fichier qui peut être utilisé avec cette méthode dépend de la configuration matérielle du serveur Web. Pour plus d’informations, consultez l’article 812406, « PRB : Response.WriteFile ne peut pas télécharger de fichier volumineux » sur le [Base de connaissances Microsoft](https://go.microsoft.com/fwlink/?linkid=149903) site Web.  
  
   
  
## Examples  
 L’exemple suivant écrit le contenu d’un fichier texte nommé `Login.txt` (qui peut contenir le texte littéral et HTML des contrôles d’entrée) directement dans le flux de sortie.  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="offset" /> est inférieur à 0.  
  
\- ou - 
 <paramref name="size" /> est supérieur à la taille du fichier moins <paramref name="offset" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="filename" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.WriteSubstitution : System.Web.HttpResponseSubstitutionCallback -&gt; unit" Usage="httpResponse.WriteSubstitution callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Méthode, contrôle utilisateur ou objet à substituer.</param>
        <summary>Autorise l'insertion de blocs de substitution de réponse dans la réponse ; cette technique permet la génération dynamique de régions de réponse spécifiées pour les réponses de sortie mises en cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la <xref:System.Web.HttpResponse.WriteSubstitution%2A> méthode pour la substitution post-cache dans vos pages mises en cache de sortie. En passant un <xref:System.Web.HttpContext> objet à une méthode de rappel avec un prescrit <xref:System.Web.HttpResponseSubstitutionCallback> signature, vous pouvez remplacer mis en cache de sortie contenu à tout emplacement donné dans le cache de page. Pour initialiser le remplacement, appelez le <xref:System.Web.HttpResponse.WriteSubstitution%2A> méthode, en lui passant la méthode de rappel qui doit être thread-safe et peut être une des opérations suivantes :  
  
-   Une méthode statique sur le contrôle de page ou un utilisateur du conteneur.  
  
-   Statique ou méthode d’instance sur un autre objet arbitraire.  
  
 Sur la première demande à la page, le <xref:System.Web.HttpResponse.WriteSubstitution%2A> appelle le <xref:System.Web.HttpResponseSubstitutionCallback> délégué pour produire le résultat. Ensuite, il ajoute une mémoire tampon de substitution à la réponse, ce qui conserve le délégué à appeler sur de futures demandes. Enfin, il diminue la capacité de côté client publique en serveur uniquement, garantissant des futures requêtes consistant à la page nouveau appeler le délégué en cache sur le client.  
  
> [!NOTE]
>  Post-cache n’est pas pris en charge pour un contrôle utilisateur mis en cache où la mise en cache de sortie est appliqué au niveau de contrôle de l’utilisateur. Il s’agit également en tant que la mise en cache de fragment. Pour plus d’informations, consultez [la mise en cache des parties d’une Page ASP.NET](https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La cible du paramètre <paramref name="callback" /> est de type <see cref="T:System.Web.UI.Control" />.</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
        <related type="Article" href="https://msdn.microsoft.com/library/d5fbd79f-972d-4557-9a39-f90684b3dcd3">Définition de la capacité d’une Page</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e">La mise en cache des parties d’une Page ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/09c9bd9a-0d68-4a5c-aa6f-1b461c208795">Mise à jour dynamique des parties d’une Page mise en cache</related>
      </Docs>
    </Member>
  </Members>
</Type>