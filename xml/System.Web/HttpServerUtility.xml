<Type Name="HttpServerUtility" FullName="System.Web.HttpServerUtility">
  <Metadata><Meta Name="ms.openlocfilehash" Value="de9ef1415ef4c2ca6c31b7dcf99a0c0fab37cc19" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57933454" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpServerUtility" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpServerUtility extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpServerUtility" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpServerUtility" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpServerUtility sealed" />
  <TypeSignature Language="F#" Value="type HttpServerUtility = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit des méthodes d'assistance pour le traitement des requêtes web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les méthodes et propriétés de la <xref:System.Web.HttpServerUtility> classe sont exposées via la fonction intrinsèque <xref:System.Web.HttpContext.Server%2A> objet fourni par ASP.NET.  
  
   
  
## Examples  
 Un projet de site Web Visual Studio avec code source est disponible pour accompagner cette rubrique : [Télécharger](https://go.microsoft.com/fwlink/?LinkId=192870).  
  
 L’exemple suivant montre comment utiliser le <xref:System.Web.HttpServerUtility.HtmlEncode%2A> (méthode) et le <xref:System.Web.HttpServerUtility.UrlEncode%2A> méthode de la <xref:System.Web.HttpServerUtility> classe. Le <xref:System.Web.HttpServerUtility.HtmlEncode%2A> méthode permet de garantir que n’importe quelle chaîne fournie par l’utilisateur d’entrée sera restitué sous forme de texte statique dans les navigateurs au lieu de script exécutable ou d’éléments HTML. Le <xref:System.Web.HttpServerUtility.UrlEncode%2A> méthode encode les URL afin qu’elles soient transmises correctement dans le flux HTTP.  
  
 [!code-aspx-csharp[System.Web.HttpServerUtility1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpServerUtility1/cs/HttpServerUtilityCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpServerUtility1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpServerUtility1/vb/HttpServerUtilityVB.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.HttpContext" />
  </Docs>
  <Members>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpServerUtility.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface l'exception précédente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant efface la dernière exception qui a été levée.  
  
 [!code-csharp[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.GetLastError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance serveur d'un objet COM.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : string -&gt; obj" Usage="httpServerUtility.CreateObject progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Classe ou type d'objet dont une instance sera créée.</param>
        <summary>Crée une instance serveur d'un objet COM identifiée par l'identificateur programmatique (ProgID) de l'objet.</summary>
        <returns>Nouvel objet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un objet à l’aide de son identificateur ProgID.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Une instance de l’objet n’a pas pu être créée.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : Type -&gt; obj" Usage="httpServerUtility.CreateObject type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> représentant l'objet à créer.</param>
        <summary>Crée une instance serveur d'un objet COM identifiée par le type de l'objet.</summary>
        <returns>Nouvel objet.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectFromClsid">
      <MemberSignature Language="C#" Value="public object CreateObjectFromClsid (string clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObjectFromClsid(string clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectFromClsid (clsid As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObjectFromClsid(System::String ^ clsid);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectFromClsid : string -&gt; obj" Usage="httpServerUtility.CreateObjectFromClsid clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">Identificateur de classe de l'objet dont une instance sera créée.</param>
        <summary>Crée une instance serveur d'un objet COM identifiée par l'identificateur de classe (CLSID) de l'objet.</summary>
        <returns>Nouvel objet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Web.HttpServerUtility.CreateObjectFromClsid%2A> pour créer une instance de serveur d’un objet COM (méthode).  
  
 [!code-csharp[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Une instance de l’objet n’a pas pu être créée.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Execute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute le gestionnaire d'une ressource spécifiée dans le contexte de la requête actuelle, puis relance l'exécution à la page qui l'a appelée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Execute : string -&gt; unit" Usage="httpServerUtility.Execute path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès d'URL à exécuter.</param>
        <summary>Exécute le gestionnaire du chemin d'accès virtuel spécifié dans le contexte de la requête actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpServerUtility.Execute%2A> méthode poursuit l’exécution de la page d’origine une fois terminée l’exécution de la nouvelle page. Le <xref:System.Web.HttpServerUtility.Transfer%2A> méthode transfère sans condition l’exécution à un autre gestionnaire.  
  
 ASP.NET ne vérifie pas que l’utilisateur actuel est autorisé à consulter la ressource fournie par le <xref:System.Web.HttpServerUtility.Execute%2A> (méthode). Bien que la logique d’authentification et d’autorisation ASP.NET s’exécute avant que le Gestionnaire de ressources d’origine est appelé, ASP.NET appelle directement le gestionnaire indiqué par la <xref:System.Web.HttpServerUtility.Execute%2A> (méthode) et ne réexécute pas la logique d’authentification et d’autorisation pour le nouveau ressource. Si la stratégie de sécurité de votre application exige des clients une autorisation appropriée pour accéder à la ressource, l’application doit forcer une nouvelle autorisation ou fournir un mécanisme de contrôle d’accès personnalisé.  
  
 Vous pouvez forcer une nouvelle autorisation à l’aide de la <xref:System.Web.HttpResponse.Redirect%2A> méthode au lieu du <xref:System.Web.HttpServerUtility.Execute%2A> (méthode). <xref:System.Web.HttpResponse.Redirect%2A> effectue une redirection côté client dans laquelle le navigateur demande la nouvelle ressource. Comme cette redirection constitue une nouvelle demande entrant dans le système, il est soumis à toute la logique d’authentification et l’autorisation de stratégie de sécurité d’Internet Information Services (IIS) et ASP.NET.  
  
 Vous pouvez vérifier que l’utilisateur est autorisé à afficher la ressource en incorporant une méthode d’autorisation personnalisée qui utilise le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> méthode avant l’application appelle le <xref:System.Web.HttpServerUtility.Execute%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant affiche la page .aspx « Updateinfo.aspx » dans le répertoire actif. L’exécution du programme retourne à la page de démarrage une fois la page Updateinfo.aspx s’affiche.  
  
 [!code-csharp[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le <see cref="T:System.Web.HttpContext" /> en cours est <see langword="null" />.  
  
ou 
Une erreur s'est produite lors de l'exécution du gestionnaire spécifié par <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.  
  
ou 
 <paramref name="path" /> n'est pas un chemin virtuel.</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * bool -&gt; unit" Usage="httpServerUtility.Execute (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès d'URL à exécuter.</param>
        <param name="preserveForm"><see langword="true" /> pour conserver les collections <see cref="P:System.Web.HttpRequest.QueryString" /> et <see cref="P:System.Web.HttpRequest.Form" /> ; <see langword="false" /> pour effacer les collections <see cref="P:System.Web.HttpRequest.QueryString" /> et <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Exécute le gestionnaire du chemin d'accès virtuel spécifié dans le contexte de la requête actuelle, et spécifie s'il faut ou non effacer les collections <see cref="P:System.Web.HttpRequest.QueryString" /> et <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment exécuter la page .aspx `Updateinfo.aspx` dans la requête actuelle et conserver la <xref:System.Web.HttpRequest.QueryString%2A> et <xref:System.Web.HttpRequest.Form%2A> collections. L’exécution du programme retourne à la page de démarrage après `Updateinfo.aspx` s’affiche.  
  
 [!code-csharp[HttpServerUtility.Execute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute/CS/httpserverutility.execute_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute/VB/httpserverutility.execute_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le <see cref="T:System.Web.HttpContext" /> en cours est <see langword="null" />.  
  
ou 
Une erreur s'est produite lors de l'exécution du gestionnaire spécifié par <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.  
  
ou 
 <paramref name="path" /> n'est pas un chemin virtuel.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.Execute (path, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès d'URL à exécuter.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> à utiliser pour capturer la sortie.</param>
        <summary>Exécute le gestionnaire du chemin d'accès virtuel spécifié dans le contexte de la requête actuelle. <see cref="T:System.IO.TextWriter" /> intercepte la sortie du gestionnaire exécuté.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpServerUtility.Execute%2A> méthode poursuit l’exécution de la demande d’origine une fois terminée l’exécution du chemin virtuel spécifié. Le <xref:System.Web.HttpServerUtility.Transfer%2A> méthode transfère sans condition l’exécution à un autre gestionnaire.  
  
 ASP.NET ne vérifie pas que l’utilisateur actuel est autorisé à consulter la ressource fournie par le <xref:System.Web.HttpServerUtility.Execute%2A> (méthode). Bien que la logique d’authentification et d’autorisation ASP.NET s’exécute avant que le Gestionnaire de ressources d’origine est appelé, ASP.NET appelle directement le gestionnaire indiqué par la <xref:System.Web.HttpServerUtility.Execute%2A> (méthode) et ne réexécute pas la logique d’authentification et d’autorisation pour le nouveau ressource. Si la stratégie de sécurité de votre application exige des clients une autorisation appropriée pour accéder à la ressource, l’application doit forcer une nouvelle autorisation ou fournir un mécanisme de contrôle d’accès personnalisé.  
  
 Vous pouvez forcer une nouvelle autorisation à l’aide de la <xref:System.Web.HttpResponse.Redirect%2A> méthode au lieu du <xref:System.Web.HttpServerUtility.Execute%2A> (méthode). <xref:System.Web.HttpResponse.Redirect%2A> effectue une redirection côté client dans laquelle le navigateur demande la nouvelle ressource. Comme cette redirection constitue une nouvelle demande entrant dans le système, il est soumis à toute la logique d’authentification et l’autorisation de stratégie de sécurité d’Internet Information Services (IIS) et ASP.NET.  
  
 Vous pouvez vérifier que l’utilisateur est autorisé à afficher la ressource en incorporant une méthode d’autorisation personnalisée qui utilise le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> méthode avant l’application appelle le <xref:System.Web.HttpServerUtility.Execute%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant exécute la `Login.aspx` page sur le serveur dans le répertoire actif et reçoit la sortie de la page via la <xref:System.IO.StringWriter> objet `writer`. Il écrit le flux HTML reçu de `writer` flux de sortie pour le protocole HTTP.  
  
 [!code-csharp[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le <see cref="T:System.Web.HttpContext" /> en cours est <see langword="null" />.  
  
ou 
Une erreur s'est produite lors de l'exécution du gestionnaire spécifié par <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.  
  
ou 
 <paramref name="path" /> n'est pas un chemin virtuel.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (path, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès d'URL à exécuter.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> à utiliser pour capturer la sortie.</param>
        <param name="preserveForm"><see langword="true" /> pour conserver les collections <see cref="P:System.Web.HttpRequest.QueryString" /> et <see cref="P:System.Web.HttpRequest.Form" /> ; <see langword="false" /> pour effacer les collections <see cref="P:System.Web.HttpRequest.QueryString" /> et <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Exécute le gestionnaire du chemin d'accès virtuel spécifié dans le contexte de la requête actuelle. Un <see cref="T:System.IO.TextWriter" /> intercepte la sortie de la page, et un paramètre Boolean spécifie s'il faut ou non effacer les collections <see cref="P:System.Web.HttpRequest.QueryString" /> et <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpServerUtility.Execute%2A> méthode poursuit l’exécution de la demande d’origine une fois terminée l’exécution du chemin d’accès virtuel spécifié. Le <xref:System.Web.HttpServerUtility.Transfer%2A> méthode transfère sans condition l’exécution à un autre gestionnaire.  
  
 ASP.NET ne vérifie pas que l’utilisateur actuel est autorisé à consulter la ressource fournie par le <xref:System.Web.HttpServerUtility.Execute%2A> (méthode). Bien que la logique d’authentification et d’autorisation ASP.NET s’exécute avant que le Gestionnaire de ressources d’origine est appelé, ASP.NET appelle directement le gestionnaire indiqué par la <xref:System.Web.HttpServerUtility.Execute%2A> (méthode) et ne réexécute pas la logique d’authentification et d’autorisation pour le nouveau ressource. Si la stratégie de sécurité de votre application exige des clients une autorisation appropriée pour accéder à la ressource, l’application doit forcer une nouvelle autorisation ou fournir un mécanisme de contrôle d’accès personnalisé.  
  
 Vous pouvez forcer une nouvelle autorisation à l’aide de la <xref:System.Web.HttpResponse.Redirect%2A> méthode au lieu du <xref:System.Web.HttpServerUtility.Execute%2A> (méthode). <xref:System.Web.HttpResponse.Redirect%2A> effectue une redirection côté client dans laquelle le navigateur demande la nouvelle ressource. Comme cette redirection constitue une nouvelle demande entrant dans le système, il est soumis à toute la logique d’authentification et l’autorisation de stratégie de sécurité d’Internet Information Services (IIS) et ASP.NET.  
  
 Vous pouvez vérifier que l’utilisateur est autorisé à afficher la ressource en incorporant une méthode d’autorisation personnalisée qui utilise le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> méthode avant l’application appelle le <xref:System.Web.HttpServerUtility.Execute%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant exécute la `Login.aspx` page sur le serveur dans le répertoire actif et reçoit la sortie de la page via la <xref:System.IO.StringWriter> objet `writer`. Il écrit le flux HTML reçu de `writer` flux de sortie pour le protocole HTTP. Le contenu de la <xref:System.Web.HttpRequest.Form%2A> et <xref:System.Web.HttpRequest.QueryString%2A> collections sont conservées.  
  
 [!code-csharp[HttpServerUtility.Execute02#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute02/CS/httpserverutility.execute02_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute02#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute02/VB/httpserverutility.execute02_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le <see cref="T:System.Web.HttpContext" /> actuel est une référence null (<see langword="Nothing" /> en Visual Basic).  
  
ou 
 <paramref name="path" /> se termine par un point (.).  
  
ou 
Une erreur s'est produite lors de l'exécution du gestionnaire spécifié par <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> n'est pas un chemin virtuel.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Web.IHttpHandler handler, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (handler As IHttpHandler, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Web::IHttpHandler ^ handler, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : System.Web.IHttpHandler * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (handler, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">Le gestionnaire HTTP qui implémente le <see cref="T:System.Web.IHttpHandler" /> auquel transférer la requête actuelle.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> à utiliser pour capturer la sortie.</param>
        <param name="preserveForm"><see langword="true" /> pour conserver les collections <see cref="P:System.Web.HttpRequest.QueryString" /> et <see cref="P:System.Web.HttpRequest.Form" /> ; <see langword="false" /> pour effacer les collections <see cref="P:System.Web.HttpRequest.QueryString" /> et <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Exécute le gestionnaire du chemin d'accès virtuel spécifié dans le contexte de la requête actuelle. Un <see cref="T:System.IO.TextWriter" /> intercepte la sortie du gestionnaire exécuté, et un paramètre Boolean spécifie s'il faut ou non effacer les collections <see cref="P:System.Web.HttpRequest.QueryString" /> et <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez écrire des gestionnaires HTTP personnalisés pour traiter des types spécifiques et prédéfinis de demandes HTTP dans n’importe quel langage compatible avec le Common Language Specification (CLS). Le code exécutable qui est défini dans les classes de gestionnaire HTTP au lieu des pages ASP (également appelé ASP classique) classiques ou les pages ASP.NET répond à ces demandes spécifiques. Les gestionnaires HTTP permettent l’interaction avec les services de réponse d’un serveur Web qui exécute Internet Information Services (IIS) et de requête de bas niveau, et ils fournissent des fonctionnalités qui sont semblables aux extensions ISAPI, mais avec un modèle de programmation plus simple.  
  
 ASP.NET ne vérifie pas que l’utilisateur actuel est autorisé à consulter la ressource qui est fournie par le <xref:System.Web.HttpServerUtility.Execute%2A> (méthode). Bien que la logique d’authentification et d’autorisation ASP.NET s’exécute avant que le Gestionnaire de ressources d’origine est appelé, ASP.NET appelle directement le gestionnaire indiqué par la <xref:System.Web.HttpServerUtility.Execute%2A> (méthode) et ne réexécute pas la logique d’authentification et d’autorisation pour le nouvelle ressource. Si la stratégie de sécurité pour votre application exige des clients une autorisation appropriée pour accéder à la ressource, l’application doit forcer une nouvelle autorisation ou fournir un mécanisme de contrôle d’accès personnalisé.  
  
 Vous pouvez forcer une nouvelle autorisation à l’aide de la <xref:System.Web.HttpResponse.Redirect%2A> méthode au lieu du <xref:System.Web.HttpServerUtility.Execute%2A> (méthode). Le <xref:System.Web.HttpResponse.Redirect%2A> effectue une redirection côté client dans laquelle le navigateur demande la nouvelle ressource. Comme cette redirection constitue une nouvelle demande entrant dans le système, il est soumis à toute la logique d’authentification et l’autorisation de stratégie de sécurité IIS et ASP.NET.  
  
 Vous pouvez vérifier que l’utilisateur est autorisé à afficher la ressource en incorporant une méthode d’autorisation personnalisée qui utilise le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> méthode avant l’application appelle le <xref:System.Web.HttpServerUtility.Execute%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Une erreur s'est produite lors de l'exécution du gestionnaire spécifié par <paramref name="handler" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="handler" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public Exception GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception GetLastError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.GetLastError" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastError () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception ^ GetLastError();" />
      <MemberSignature Language="F#" Value="member this.GetLastError : unit -&gt; Exception" Usage="httpServerUtility.GetLastError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne l'exception précédente.</summary>
        <returns>Dernière exception levée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant imprime une description de la dernière erreur de l’application dans le flux de sortie HTTP. Il imprime « No Errors » si aucune erreur.  
  
 [!code-csharp[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.ClearError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Décode une chaîne qui a été encodée pour éliminer les caractères HTML non valides.  
  
Pour coder ou décoder les valeurs en dehors d’une application web, utilisez la classe <see cref="T:System.Net.WebUtility" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public string HtmlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string -&gt; string" Usage="httpServerUtility.HtmlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne HTML à décoder.</param>
        <summary>Décode une chaîne codée en HTML et retourne la chaîne décodée.</summary>
        <returns>Texte décodé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’encodage HTML permet de s’assurer que le texte est affiché correctement dans le navigateur et non interprété par le navigateur au format HTML. Par exemple, si une chaîne de texte contient un signe inférieur à (\<) ou supérieur signe supérieur à (>), le navigateur interprète ces caractères en tant que l’ouverture ou le crochet fermant d’une balise HTML. Lorsque les caractères sont encodées en HTML, ils sont convertis en chaînes `&lt;` et `&gt;`, ce qui entraîne le navigateur d’afficher les inférieur à et supérieur à correctement. <xref:System.Web.HttpServerUtility.HtmlDecode%2A> décode le texte qui a été transmis au serveur.  
  
 Cette méthode est un moyen pratique d’accéder à la <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> méthode au moment de l’exécution d’une application ASP.NET. En interne, cette méthode utilise <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> pour décoder des chaînes.  
  
 Dans le fichier code-behind pour une page web ASP.NET, accéder à une instance de la <xref:System.Web.HttpServerUtility> classe via la `Server` propriété. Dans une classe qui n’est pas dans un fichier code-behind, utiliser `HttpContext.Current.Server` pour accéder à une instance de la <xref:System.Web.HttpServerUtility> classe.  
  
 En dehors d’une application web, utilisez la <xref:System.Net.WebUtility> classe coder ou décoder les valeurs.  
  
   
  
## Examples  
 L’exemple suivant contient la fonction `LoadDecodedFile`, qui décode les données à partir d’un fichier et le copie dans une seule chaîne.  
  
 [!code-aspx-csharp[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/CS/sourcecs.aspx#1)]
 [!code-aspx-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public void HtmlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne HTML à décoder.</param>
        <param name="output">Flux de sortie <see cref="T:System.IO.TextWriter" /> qui contient la chaîne décodée.</param>
        <summary>Décode une chaîne encodée en HTML et envoie le résultat vers un flux de sortie <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’encodage HTML permet de s’assurer que le texte est affiché correctement dans le navigateur et non interprété par le navigateur au format HTML. Par exemple, si une chaîne de texte contient un signe inférieur à (\<) ou supérieur signe supérieur à (>), le navigateur interprète ces caractères en tant que l’ouverture ou le crochet fermant d’une balise HTML. Lorsque les caractères sont encodées en HTML, ils sont convertis en chaînes `&lt;` et `&gt;`, ce qui entraîne le navigateur d’afficher les inférieur à et supérieur à correctement.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> décode le texte qui a été transmis au serveur.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> est un moyen pratique d’accéder à la <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> méthode au moment de l’exécution d’une application ASP.NET. En interne, <xref:System.Web.HttpServerUtility.HtmlDecode%2A> utilise <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> pour décoder des chaînes.  
  
 Pour coder ou décoder les valeurs en dehors d’une application web, utilisez la classe <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 L’exemple suivant décode une chaîne qui a été encodée en HTML pour la transmission via HTTP. Il décode la chaîne fournie, nommée `EncodedString` qui contient le texte « il s’agit d’un &lt;Test String&gt;. » et le copie dans la chaîne nommée `DecodedString` en tant que » il s’agit d’un \<Test String >. ».  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Encode une chaîne pour l'afficher dans un navigateur.  
  
Pour coder ou décoder les valeurs en dehors d’une application web, utilisez la classe <see cref="T:System.Net.WebUtility" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public string HtmlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string -&gt; string" Usage="httpServerUtility.HtmlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne de texte à encoder.</param>
        <summary>Encode une chaîne au format HTML et retourne la chaîne encodée.</summary>
        <returns>Texte encodé au format HTML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’encodage HTML permet de s’assurer que le texte est affiché correctement dans le navigateur et non interprété par le navigateur au format HTML. Par exemple, si une chaîne de texte contient un signe inférieur à (\<) ou supérieur signe supérieur à (>), le navigateur interprète ces caractères en tant que l’ouverture ou le crochet fermant d’une balise HTML. Lorsque les caractères sont encodées en HTML, ils sont convertis en chaînes `&lt;` et `&gt;`, ce qui entraîne le navigateur d’afficher les inférieur à et supérieur à correctement.  
  
 Cette méthode est un moyen pratique d’accéder à la <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> méthode au moment de l’exécution d’une application ASP.NET. En interne, cette méthode utilise <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> pour encoder des chaînes.  
  
 Dans le fichier code-behind pour une page web ASP.NET, accéder à une instance de la <xref:System.Web.HttpServerUtility> classe via la `Server` propriété. Dans une classe qui n’est pas dans un fichier code-behind, utiliser `HttpContext.Current.Server` pour accéder à une instance de la <xref:System.Web.HttpServerUtility> classe.  
  
 En dehors d’une application web, utilisez la <xref:System.Net.WebUtility> classe coder ou décoder les valeurs.  
  
   
  
## Examples  
 L’exemple suivant montre comment encoder en HTML une valeur qui potentiellement les codes de code unsafe. Le code réside dans le fichier code-behind pour une page web. La valeur à encoder est codé en dur dans cet exemple uniquement pour simplifier l’exemple et afficher le type de valeur que vous pouvez encoder en HTML. En règle générale, vous le feriez pour encoder en HTML une valeur que vous avez reçu à partir de l’utilisateur ou de la demande. `Result` fait référence à un `Literal` contrôle.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/default.aspx.vb#1)]  
  
 L’exemple suivant est similaire à l’exemple précédent, à ceci près qu’il montre comment encoder en HTML une valeur à partir d’une classe qui n’est pas dans le fichier code-behind.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public void HtmlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne à encoder.</param>
        <param name="output">Flux de sortie <see cref="T:System.IO.TextWriter" /> qui contient la chaîne encodée.</param>
        <summary>Encode une chaîne au format HTML et envoie le résultat vers un flux de sortie <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’encodage HTML garantit que le texte s’affichera correctement dans le navigateur, non interprété par le navigateur au format HTML. Par exemple, si une chaîne de texte contient un signe inférieur à (\<) ou supérieur signe supérieur à (>), le navigateur interprète ces caractères comme un crochet d’ouverture ou fermeture d’une balise HTML. L’encodage HTML de ces deux caractères est `&lt;` et `&gt;`, respectivement, ce qui entraîne le navigateur d’afficher les inférieur à et supérieur à correctement.  
  
 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> est un moyen pratique d’accéder à la <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> méthode au moment de l’exécution d’une application ASP.NET. En interne, <xref:System.Web.HttpServerUtility.HtmlEncode%2A> utilise <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> pour encoder des chaînes.  
  
 Pour coder ou décoder les valeurs en dehors d’une application web, utilisez la classe <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 L’exemple suivant encode une chaîne pour la transmission par HTTP. Il encode la chaîne nommée `TestString`, qui contient le texte « il s’agit d’un \<Test String >. » et le copie dans la chaîne nommée `EncodedString` en tant que » il s’agit d’un &lt;Test String&gt;. ».  
  
 [!code-csharp[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Web.HttpServerUtility.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom d'ordinateur du serveur.</summary>
        <value>Nom de l'ordinateur local.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant stocke le nom de l’ordinateur du serveur comme une variable de chaîne.  
  
 [!code-csharp[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le nom de l'ordinateur est introuvable.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpServerUtility.MapPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès virtuel dans l’application web.</param>
        <summary>Retourne le chemin d’accès au fichier physique qui correspond au chemin d’accès virtuel spécifié.</summary>
        <returns>Chemin du fichier physique sur le serveur web correspondant à <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `path` est `null`, le <xref:System.Web.HttpServerUtility.MapPath%2A> méthode retourne le chemin d’accès physique complet du répertoire qui contient la requête actuelle pour le chemin d’accès. Le chemin d’accès relatif n’a pas besoin de spécifier un fichier ou dossier existant pour cette méthode retourner une valeur. Toutefois, vous ne pouvez pas spécifier un chemin d’accès en dehors de l’application Web.  
  
> [!IMPORTANT]
>  Le <xref:System.Web.HttpServerUtility.MapPath%2A> méthode contient potentiellement des informations sensibles sur l’environnement d’hébergement. La valeur de retour ne doit pas être affichée aux utilisateurs.  
  
 Une application Web qui se situe à `C:\ExampleSites\TestMapPath` retournerait les résultats suivants :  
  
|Demander à partir de|`path`|Valeur retournée|  
|------------------|------------|--------------------|  
|RootLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath|  
|RootLevelPage.aspx|"/DownOneLevel/DownLevelPage.aspx"|C:\ExampleSites\TestMapPath\DownOneLevel\DownLevelPage.aspx|  
|RootLevelPage.aspx|"/NotRealFolder"|C:\ExampleSites\TestMapPath\NotRealFolder|  
|RootLevelPage.aspx|".. / OutsideApplication »|<xref:System.Web.HttpException>|  
|/DownOneLevel/DownLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath\DownOneLevel|  
|/DownOneLevel/DownLevelPage.aspx|"../RootLevelPage.aspx"|C:\ExampleSites\TestMapPath\RootLevelPage.aspx|  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer le fichier physique d’un chemin d’accès virtuel relatif. Le code réside dans le fichier code-behind pour une page web et utilise la valeur par défaut `Server` objet.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/default.aspx.vb#1)]  
  
 L’exemple suivant est similaire à l’exemple précédent, à ceci près qu’il montre comment récupérer un chemin d’accès physique à partir d’une classe qui n’est pas dans le fichier code-behind.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le <see cref="T:System.Web.HttpContext" /> en cours est <see langword="null" />.
        
ou 
<paramref name="path" /> est un chemin physique, mais un chemin virtuel était attendu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScriptTimeout">
      <MemberSignature Language="C#" Value="public int ScriptTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScriptTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScriptTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptTimeout : int with get, set" Usage="System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur du délai d'attente de la requête, exprimée en secondes.</summary>
        <value>Définition de la valeur du délai de réponse aux requêtes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> propriété peut être définie dans le fichier Web.config en définissant le `executionTimeout` attribut de l’élément. Définir le délai d’attente par programme avec le <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> propriété est prioritaire sur le paramètre Web.config.  
  
> [!NOTE]
>  Si vous définissez la `debug` attribut de l’élément à `true` dans le fichier Web.config, la valeur de <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> sera ignoré.  
  
   
  
## Examples  
 L’exemple suivant définit le délai d’attente de demande de 60 secondes.  
  
 [!code-csharp[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Le <see cref="T:System.Web.HttpContext" /> en cours est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le délai d'attente est <see langword="null" /> ou n'a pas pu être défini.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transfer">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Termine l'exécution de la page en cours et commence l'exécution d'une nouvelle page pour la requête en cours.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string -&gt; unit" Usage="httpServerUtility.Transfer path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès de l'URL de la nouvelle page du serveur à exécuter.</param>
        <summary>Pour la requête en cours, termine l'exécution de la page en cours et commence l'exécution d'une nouvelle page en utilisant le chemin d'accès de l'URL spécifié pour accéder à la page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La page transférée vers doit être une autre page .aspx. Par exemple, un transfert vers une page .asp ou .asmx n’est pas valide. Le <xref:System.Web.HttpServerUtility.Transfer%2A> méthode conserve le <xref:System.Web.HttpRequest.QueryString%2A> et <xref:System.Web.HttpRequest.Form%2A> collections.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> appels <xref:System.Web.HttpResponse.End%2A>, qui lève une <xref:System.Threading.ThreadAbortException> exception à l’achèvement.  
  
 ASP.NET ne vérifie pas que l’utilisateur actuel est autorisé à consulter la ressource fournie par le <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode). Bien que la logique d’authentification et d’autorisation ASP.NET s’exécute avant que le Gestionnaire de ressources d’origine est appelé, ASP.NET appelle directement le gestionnaire indiqué par la <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode) et ne réexécute pas la logique d’authentification et d’autorisation pour le nouveau ressource. Si la stratégie de sécurité de votre application exige des clients une autorisation appropriée pour accéder à la ressource, l’application doit forcer une nouvelle autorisation ou fournir un mécanisme de contrôle d’accès personnalisé.  
  
 Vous pouvez forcer une nouvelle autorisation à l’aide de la <xref:System.Web.HttpResponse.Redirect%2A> méthode au lieu du <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode). Le <xref:System.Web.HttpResponse.Redirect%2A> méthode effectue une redirection côté client dans laquelle le navigateur demande la nouvelle ressource. Comme cette redirection constitue une nouvelle demande entrant dans le système, il est soumis à toute la logique d’authentification et l’autorisation de stratégie de sécurité d’Internet Information Services (IIS) et ASP.NET.  
  
 Vous pouvez vérifier que l’utilisateur est autorisé à afficher la ressource en incorporant une méthode d’autorisation personnalisée qui utilise le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> méthode avant l’application appelle le <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string * bool -&gt; unit" Usage="httpServerUtility.Transfer (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès de l'URL de la nouvelle page du serveur à exécuter.</param>
        <param name="preserveForm"><see langword="true" /> pour conserver les collections <see cref="P:System.Web.HttpRequest.QueryString" /> et <see cref="P:System.Web.HttpRequest.Form" /> ; <see langword="false" /> pour effacer les collections <see cref="P:System.Web.HttpRequest.QueryString" /> et <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Termine l'exécution de la page en cours et commence l'exécution d'une nouvelle page en utilisant le chemin d'accès de l'URL spécifié pour accéder à la page. Spécifie s'il faut effacer les collections <see cref="P:System.Web.HttpRequest.QueryString" /> et <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La page transférée vers doit être une autre page .aspx. Par exemple, un transfert vers une page .asp ou .asmx n’est pas valide.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> appels <xref:System.Web.HttpResponse.End%2A>, qui lève une <xref:System.Threading.ThreadAbortException> exception à l’achèvement.  
  
 Si vous définissez la `preserveForm` paramètre `true`, la page cible sera en mesure d’accéder à l’état d’affichage de la page précédente en utilisant le <xref:System.Web.UI.Page.PreviousPage%2A> propriété.  
  
 Pour des raisons de sécurité, vous devez conserver le `enableViewStateMac` attribut la valeur `true`. ASP.NET ne vérifie pas que l’utilisateur actuel est autorisé à consulter la ressource fournie par le <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode). Bien que la logique d’authentification et d’autorisation ASP.NET s’exécute avant que le Gestionnaire de ressources d’origine est appelé, ASP.NET appelle directement le gestionnaire indiqué par la <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode) et ne réexécute pas la logique d’authentification et d’autorisation pour le nouveau ressource. Si la stratégie de sécurité de votre application exige des clients une autorisation appropriée pour accéder à la ressource, l’application doit forcer une nouvelle autorisation ou fournir un mécanisme de contrôle d’accès personnalisé.  
  
 Vous pouvez forcer une nouvelle autorisation à l’aide de la <xref:System.Web.HttpResponse.Redirect%2A> méthode au lieu du <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode). Le <xref:System.Web.HttpResponse.Redirect%2A> méthode effectue une redirection côté client dans laquelle le navigateur demande la nouvelle ressource. Comme cette redirection constitue une nouvelle demande entrant dans le système, il est soumis à toute la logique d’authentification et l’autorisation de stratégie de sécurité d’Internet Information Services (IIS) et ASP.NET.  
  
 Vous pouvez vérifier que l’utilisateur est autorisé à afficher la ressource en incorporant une méthode d’autorisation personnalisée qui utilise le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> méthode avant l’application appelle le <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant exécute une nouvelle page dans le même répertoire que la page actuelle.  
  
 [!code-csharp[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">La requête de page actuelle est un rappel.</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(class System.Web.IHttpHandler handler, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (handler As IHttpHandler, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::Web::IHttpHandler ^ handler, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : System.Web.IHttpHandler * bool -&gt; unit" Usage="httpServerUtility.Transfer (handler, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">Le gestionnaire HTTP qui implémente le <see cref="T:System.Web.IHttpHandler" /> auquel transférer la requête actuelle.</param>
        <param name="preserveForm"><see langword="true" /> pour conserver les collections <see cref="P:System.Web.HttpRequest.QueryString" /> et <see cref="P:System.Web.HttpRequest.Form" /> ; <see langword="false" /> pour effacer les collections <see cref="P:System.Web.HttpRequest.QueryString" /> et <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Termine l'exécution de la page actuelle et commence celle d'une nouvelle requête en utilisant un gestionnaire HTTP personnalisé qui implémente l'interface <see cref="T:System.Web.IHttpHandler" /> et spécifie s'il faut ou non effacer les collections <see cref="P:System.Web.HttpRequest.QueryString" /> et <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez écrire des gestionnaires HTTP personnalisés pour traiter des types spécifiques et prédéfinis de demandes HTTP dans n’importe quel langage compatible avec le Common Language Specification (CLS). Le code exécutable qui est défini dans les classes de gestionnaire HTTP au lieu des pages ASP (également appelé ASP classique) classiques ou les pages ASP.NET répond à ces demandes spécifiques. Les gestionnaires HTTP permettent l’interaction avec les services de réponse d’un serveur Web qui exécute Internet Information Services (IIS) et de requête de bas niveau, et ils fournissent des fonctionnalités qui sont semblables aux extensions ISAPI, mais avec un modèle de programmation plus simple.  
  
 Si vous définissez la `preserveForm` paramètre `true`, la page cible sera en mesure d’accéder à l’état d’affichage de la page précédente en utilisant le <xref:System.Web.UI.Page.PreviousPage%2A> propriété.  
  
 Pour des raisons de sécurité, vous devez conserver le `enableViewStateMac` attribut la valeur `true`. ASP.NET ne vérifie pas que l’utilisateur actuel est autorisé à consulter la ressource fournie par le <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode). Bien que la logique d’authentification et d’autorisation ASP.NET s’exécute avant que le Gestionnaire de ressources d’origine est appelé, ASP.NET appelle directement le gestionnaire indiqué par la <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode) et la logique de l’authentification et l’autorisation ne réexécute ne pas pour le nouveau ressource. Si la stratégie de sécurité pour votre application exige des clients une autorisation appropriée pour accéder à la ressource, l’application doit forcer une nouvelle autorisation ou fournir un mécanisme de contrôle d’accès personnalisé.  
  
 Vous pouvez forcer une nouvelle autorisation à l’aide de la <xref:System.Web.HttpResponse.Redirect%2A> méthode au lieu du <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode). Le <xref:System.Web.HttpResponse.Redirect%2A> méthode effectue une redirection côté client dans laquelle le navigateur demande la nouvelle ressource. Comme cette redirection constitue une nouvelle demande entrant dans le système, il est soumis à toute la logique d’authentification et l’autorisation de stratégie de sécurité IIS et ASP.NET.  
  
 Vous pouvez vérifier que l’utilisateur est autorisé à afficher la ressource en incorporant une méthode d’autorisation personnalisée qui utilise le <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> méthode avant l’application appelle le <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">La requête de page actuelle est un rappel.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransferRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Réalise une exécution asynchrone de l'URL spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> a été introduit dans le .NET Framework version 3.5. Pour obtenir des informations récapitulatives sur le .NET Framework, consultez [Versions et dépendances](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string -&gt; unit" Usage="httpServerUtility.TransferRequest path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès de l'URL de la nouvelle page du serveur à exécuter.</param>
        <summary>Réalise une exécution asynchrone de l'URL spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de méthode appelle la <xref:System.Web.HttpServerUtility.TransferRequest%2A> surcharge avec le `preserveForm` paramètre défini sur `false`, le `method` paramètre défini sur `null`, le `headers` paramètre défini sur `null`et le `preserveUser` paramètre défini sur `true`. Pour plus d’informations, consultez la section « Notes » dans <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29> de surcharge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La requête requiert le mode pipeline intégré de [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Le serveur n'est pas disponible pour gérer la requête.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="path" /> n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès de l'URL de la nouvelle page du serveur à exécuter.</param>
        <param name="preserveForm"><see langword="true" />  pour conserver la collection <see cref="P:System.Web.HttpRequest.Form" /> ; <see langword="false" /> pour effacer la collection <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Exécute une exécution asynchrone de l'URL spécifiée et conserve les paramètres de chaînes de requête.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge appelle la <xref:System.Web.HttpServerUtility.TransferRequest%2A> surcharge avec le `preserveForm` paramètre défini sur la valeur passée, la `method` paramètre défini sur `null`, le `headers` paramètre défini sur `null`et le `preserveUser` jeu de paramètres à `true`. Pour plus d’informations, consultez la section « Notes » dans <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> est introduit dans le .NET Framework version 3.5.  Pour plus d’informations, consultez [Versions et dépendances](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La requête requiert le mode pipeline intégré de [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Le serveur n'est pas disponible pour gérer la requête.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="path" /> n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès de l'URL de la nouvelle page du serveur à exécuter.</param>
        <param name="preserveForm"><see langword="true" />  pour conserver la collection <see cref="P:System.Web.HttpRequest.Form" /> ; <see langword="false" /> pour effacer la collection <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <param name="method">La méthode HTTP à utiliser dans l'exécution de la nouvelle requête.</param>
        <param name="headers">Une <see cref="T:System.Collections.Specialized.NameValueCollection" /> d'en-têtes de requête pour la nouvelle requête.</param>
        <summary>Exécute une exécution asynchrone de l'URL spécifiée à l'aide de la méthode et des en-têtes HTTP spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée lors de l’exécution avec le mode pipeline intégré dans [!INCLUDE[iisver](~/includes/iisver-md.md)] pour permettre le traitement de la requête doit être transféré à partir d’un type de ressource à un autre lors de l’exécution de la requête cible avec le contexte de requête correct. Par exemple, vous pouvez utiliser la <xref:System.Web.HttpServerUtility.TransferRequest%2A> méthode pour transférer une demande pour une page ASPX à une demande pour une page XML.  
  
 Le <xref:System.Web.HttpServerUtility.TransferRequest%2A> méthode effectue une exécution enfant asynchrone de l’URL spécifiée avec les conditions suivantes :  
  
-   Si le `path` paramètre spécifie une chaîne de requête, il sera utilisé comme nouvelle chaîne de requête. Si aucune chaîne de requête n’est inclus, la chaîne de requête de la demande sera utilisée à nouveau.  
  
-   Si le `method` paramètre est spécifié, il sera utilisé. S’il s’agit `null`, la méthode HTTP de la demande d’origine sera être utilisée.  
  
-   Si le `preserveForm` paramètre est `true`, le corps d’entité en cours de la demande sera disponible à la demande cible. Cela permet des publications de formulaire et télécharge pour être transféré.  
  
-   Si l’identité de l’utilisateur est actuellement définie sur la demande d’origine, l’identité est transférée à la nouvelle demande. Ainsi, les demandes authentifiées à réutiliser le résultat de l’authentification pour la nouvelle requête. Si vous ne souhaitez pas que l’utilisateur à transférer, la valeur est l’utilisateur `null` sur la demande d’origine avant de le transférer.  
  
-   Si le `headers` paramètre est spécifié, la nouvelle requête s’exécute avec les en-têtes spécifiés. Cela peut être utilisé pour modifier les en-têtes de requête et les cookies pour la nouvelle requête, ou ajouter un en-tête spécial qui spécifie où la demande d’origine a été reçue.  
  
     Cette méthode appelle la <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29> surcharge de méthode avec le `preserveUser` paramètre défini sur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La requête requiert que [!INCLUDE[iisver](~/includes/iisver-md.md)] exécute en mode intégré.</exception>
        <exception cref="T:System.Web.HttpException">Le serveur n'est pas disponible pour gérer la requête.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="path" /> n'est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers, bool preserveUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection, preserveUser As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers, bool preserveUser);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers, preserveUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveUser" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès.</param>
        <param name="preserveForm"><see langword="true" />  pour conserver la collection <see cref="P:System.Web.HttpRequest.Form" /> ; <see langword="false" /> pour effacer la collection <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <param name="method">Méthode HTTP à utiliser dans la nouvelle requête.</param>
        <param name="headers">Objet de <see cref="T:System.Collections.Specialized.NameValueCollection" /> qui contient des en-têtes de requête pour la nouvelle demande.</param>
        <param name="preserveUser"><see langword="true" /> pour conserver l'identité de l'utilisateur ; sinon, <see langword="false" />. Les autres surcharges de méthode de cette méthode appellent cette surcharge avec ce paramètre dont la valeur est <see langword="true" />.</param>
        <summary>Exécute de façon asynchrone l'URL spécifiée à l'aide de la méthode HTTP, des en-têtes, et du chemin d'accès spécifiés, et conserve éventuellement les valeurs de formulaire et l'identité de l'utilisateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez la section « Notes » dans <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La requête requiert le mode pipeline intégré de [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">Le serveur n'est pas disponible pour gérer la requête.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="path" /> n'est pas valide.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Décode une chaîne encodée en vue de sa transmission sur  HTTP et envoyée au serveur dans une URL.  
  
Pour coder ou décoder les valeurs en dehors d’une application web, utilisez la classe <see cref="T:System.Net.WebUtility" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public string UrlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string -&gt; string" Usage="httpServerUtility.UrlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne de texte à décoder.</param>
        <summary>Décode une chaîne URL et retourne la chaîne décodée.</summary>
        <returns>Texte décodé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’encodage des URL garantit que tous les navigateurs transmettront correctement le texte dans des chaînes d’URL. Caractères tels que le point d’interrogation ( ?), esperluette (&), barre oblique (/) de marquer et espaces peuvent être tronquées ou endommagés par certains navigateurs. Par conséquent, ces caractères doivent être encodés dans `<a>` balises ou dans la requête de chaînes où les chaînes peuvent être renvoyées par un navigateur dans une chaîne de requête.  
  
 Cette méthode est un moyen pratique d’accéder à la <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> méthode au moment de l’exécution d’une application ASP.NET. En interne, cette méthode utilise <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> pour décoder des chaînes.  
  
 Dans le fichier code-behind pour une page web ASP.NET, accéder à une instance de la <xref:System.Web.HttpServerUtility> classe via la `Server` propriété. Dans une classe qui n’est pas dans un fichier code-behind, utiliser `HttpContext.Current.Server` pour accéder à une instance de la <xref:System.Web.HttpServerUtility> classe.  
  
 En dehors d’une application web, utilisez la <xref:System.Net.WebUtility> classe coder ou décoder les valeurs.  
  
   
  
## Examples  
 L’exemple suivant montre comment décoder URL une valeur qui est récupéré à partir de la chaîne de requête. Le code réside dans le fichier code-behind pour une page web. `ReturnPage` fait référence à un `HyperLink` contrôle.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/default.aspx.vb#1)]  
  
 L’exemple suivant est similaire à l’exemple précédent, à ceci près qu’il montre comment décoder en URL une valeur à partir d’une classe qui n’est pas dans le fichier code-behind.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public void UrlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne HTML à décoder.</param>
        <param name="output">Flux de sortie <see cref="T:System.IO.TextWriter" /> qui contient la chaîne décodée.</param>
        <summary>Décode une chaîne HTML reçue dans une URL et envoie le résultat vers un flux de sortie <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’encodage des URL garantit que tous les navigateurs transmettront correctement le texte dans des chaînes d’URL. Caractères tels que le point d’interrogation ( ?), esperluette (&), barre oblique (/) de marquer et espaces peuvent être tronquées ou endommagés par certains navigateurs. Par conséquent, ces caractères doivent être encodés dans `<a>` balises ou dans la requête de chaînes où les chaînes peuvent être renvoyées par un navigateur dans une chaîne de requête.  
  
 <xref:System.Web.HttpServerUtility.UrlDecode%2A> est un moyen pratique d’accéder à la <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> méthode au moment de l’exécution d’une application ASP.NET. En interne, <xref:System.Web.HttpServerUtility.UrlDecode%2A> utilise <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> pour décoder des chaînes.  
  
 Pour coder ou décoder les valeurs en dehors d’une application web, utilisez la classe <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 L’exemple suivant décode la chaîne nommée `EncodedString` (reçue dans une URL) dans la chaîne nommée `DecodedString`.  
  
 [!code-csharp[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Code une chaîne en vue de sa transmission HTTP fiable du serveur Web à un client par le biais de l'URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> est un moyen pratique d’accéder à la <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> méthode au moment de l’exécution d’une application ASP.NET. En interne, <xref:System.Web.HttpServerUtility.UrlEncode%2A> utilise <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> pour encoder des chaînes.  
  
 Pour coder ou décoder les valeurs en dehors d’une application web, utilisez la classe <xref:System.Net.WebUtility>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public string UrlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string -&gt; string" Usage="httpServerUtility.UrlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Texte à encoder en URL.</param>
        <summary>Code une chaîne en URL et retourne la chaîne codée.</summary>
        <returns>Texte encodé URL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’encodage des URL garantit que tous les navigateurs transmettront correctement le texte dans des chaînes d’URL. Caractères tels que le point d’interrogation ( ?), esperluette (&), barre oblique (/) de marquer et espaces peuvent être tronquées ou endommagés par certains navigateurs. Par conséquent, ces caractères doivent être encodés dans `<a>` balises ou dans la requête de chaînes où les chaînes peuvent être renvoyées par un navigateur dans une chaîne de requête.  
  
 Cette méthode est un moyen pratique d’accéder à la <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> méthode au moment de l’exécution d’une application ASP.NET. En interne, cette méthode utilise <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> pour encoder des chaînes.  
  
 Dans le fichier code-behind pour une page web ASP.NET, accéder à une instance de la <xref:System.Web.HttpServerUtility> classe via la `Server` propriété. Dans une classe qui n’est pas dans un fichier code-behind, utiliser `HttpContext.Current.Server` pour accéder à une instance de la <xref:System.Web.HttpServerUtility> classe.  
  
 En dehors d’une application web, utilisez la <xref:System.Net.WebUtility> classe coder ou décoder les valeurs.  
  
   
  
## Examples  
 L’exemple suivant montre comment l’encoder une valeur qui est utilisé comme valeur de chaîne de requête d’un lien hypertexte. Le code réside dans le fichier code-behind pour une page web. La valeur à encoder est codé en dur dans cet exemple uniquement pour simplifier l’exemple et afficher le type de valeur que vous pouvez encoder par URL. En règle générale, vous le feriez pour encoder en URL une valeur que vous avez reçu à partir de l’utilisateur ou de la demande. `NextPage` fait référence à un `HyperLink` contrôle.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/default.aspx.vb#1)]  
  
 L’exemple suivant est similaire à l’exemple précédent, à ceci près qu’il montre comment l’encoder une valeur à partir d’une classe qui n’est pas dans le fichier code-behind.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public void UrlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne de texte à encoder.</param>
        <param name="output">Flux de sortie <see cref="T:System.IO.TextWriter" /> qui contient la chaîne encodée.</param>
        <summary>Code une chaîne au format URL et envoie le résultat vers un flux de sortie <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’encodage des URL garantit que tous les navigateurs transmettront correctement le texte dans des chaînes d’URL. Caractères tels que le point d’interrogation ( ?), esperluette (&), barre oblique (/) de marquer et espaces peuvent être tronquées ou endommagés par certains navigateurs. Par conséquent, ces caractères doivent être encodés dans `<a>` balises ou dans la requête de chaînes où les chaînes peuvent être renvoyées par un navigateur dans une chaîne de requête.  
  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> est un moyen pratique d’accéder à la <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> méthode au moment de l’exécution d’une application ASP.NET. En interne, <xref:System.Web.HttpServerUtility.UrlEncode%2A> utilise <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> pour encoder des chaînes.  
  
 Pour coder ou décoder les valeurs en dehors d’une application web, utilisez la classe <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 L’exemple suivant encode une chaîne pour la transmission par HTTP. Il encode la chaîne nommée `TestString`, qui contient le texte « il s’agit d’un \<Test String >. » et le copie dans la chaîne nommée `EncodedString` en tant que « ce + est + a + % 3cTest + String % 3e. ».  
  
 [!code-csharp[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="public string UrlPathEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlPathEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlPathEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlPathEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlPathEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlPathEncode : string -&gt; string" Usage="httpServerUtility.UrlPathEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Texte à encoder en URL.</param>
        <summary>À ne pas utiliser ; conçu uniquement pour la compatibilité avec le navigateur. Utilisez <see cref="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />.</summary>
        <returns>Texte encodé de l'URL.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenDecode">
      <MemberSignature Language="C#" Value="public static byte[] UrlTokenDecode (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] UrlTokenDecode(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenDecode (input As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ UrlTokenDecode(System::String ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenDecode : string -&gt; byte[]" Usage="System.Web.HttpServerUtility.UrlTokenDecode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="input">Le jeton de chaîne d'URL à décoder.</param>
        <summary>Décode un jeton de chaîne d'URL selon une base numérique 64 pour le convertir en tableau d'octets équivalent.</summary>
        <returns>Le tableau d'octets qui contient le jeton de chaîne d'URL décodé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> méthode convertit un jeton de chaîne d’URL qui encode les données binaires en chiffres en base 64, en sa représentation de tableau d’octets équivalent. Utilisez le <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> méthode à décoder des jetons transmis sur l’URL et encodés à l’aide de la <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>.  
  
 Le <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> méthode retourne un tableau d’octets vide si le `input` paramètre a une longueur de moins de 1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur du paramètre <paramref name="input" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="UrlTokenEncode">
      <MemberSignature Language="C#" Value="public static string UrlTokenEncode (byte[] input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UrlTokenEncode(unsigned int8[] input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenEncode (input As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UrlTokenEncode(cli::array &lt;System::Byte&gt; ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenEncode : byte[] -&gt; string" Usage="System.Web.HttpServerUtility.UrlTokenEncode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="input">Tableau d'octets à encoder.</param>
        <summary>Code un tableau d'octets dans une représentation de type chaîne équivalente, selon une base numérique 64 et un format approprié à la transmission sur l'URL.</summary>
        <returns>Chaîne contenant le jeton encodé si la *longueur* du tableau d’octets est supérieure à un ; sinon, une chaîne vide ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> méthode convertit un tableau d’octets en une représentation sous forme de chaîne équivalente encodée en chiffres en base 64. Le jeton de chaîne résultant peut être transmis sur l’URL.  
  
 Le <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> renvoie une chaîne vide si le `input` paramètre a une longueur de moins de 1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur du paramètre <paramref name="input" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.ToBase64String(System.Byte[])" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>