<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="88ce829c03bac395dfe6f356b7bcc460919ba553" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66008121" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <TypeSignature Language="F#" Value="type HttpContext = class&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Encapsule toutes les informations spécifiques au protocole HTTP relatives à une requête HTTP individuelle.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes qui héritent le <xref:System.Web.IHttpModule> et <xref:System.Web.IHttpHandler> interfaces reçoivent une référence à un <xref:System.Web.HttpContext> objet pour la requête HTTP actuelle. L’objet fournit l’accès à la fonction intrinsèque <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A>, et <xref:System.Web.HttpContext.Server%2A> propriétés de la demande.  
  
> [!IMPORTANT] 
> Cet objet est prêt pour le garbage collection lorsque le <xref:System.Web.HttpRequest> est terminée. Son utilisation une fois terminée la demande peut entraîner un comportement non défini, comme un <xref:System.NullReferenceException>.
>
> Cet objet est uniquement disponible dans le thread de contrôle par ASP.NET. L’utilisation de threads d’arrière-plan peut entraîner un comportement non défini.

## Examples  
 L’exemple suivant montre comment accéder à et afficher les propriétés de la <xref:System.Web.HttpContext> objet. Le contexte de la requête HTTP actuelle est accessible à l’aide de la <xref:System.Web.UI.Page.Context%2A> propriété de la <xref:System.Web.UI.Page> objet.  
  
 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=196730">Une question de contexte</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Web.HttpContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpWorkerRequest -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext wr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">Objet <see cref="T:System.Web.HttpWorkerRequest" /> pour la requête HTTP actuelle.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Web.HttpContext" /> qui utilise l'objet de requête de tâche spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpRequest * System.Web.HttpResponse -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext (request, response)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">Objet <see cref="T:System.Web.HttpRequest" /> pour la requête HTTP actuelle.</param>
        <param name="response">Objet <see cref="T:System.Web.HttpResponse" /> pour la requête HTTP actuelle.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Web.HttpContext" /> avec des objets de requête et de réponse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Accepte une demande <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit" Usage="httpContext.AcceptWebSocketRequest userFunc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="userFunc">Fonction d'utilisateur.</param>
        <summary>Accepte une demande de <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> à l'aide de la fonction utilisateur spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette méthode équivaut à appeler le <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A> surcharge de méthode et en passant `null` pour le `options` paramètre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="userFunc" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La requête n'est pas une requête <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit" Usage="httpContext.AcceptWebSocketRequest (userFunc, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="userFunc">Fonction d'utilisateur.</param>
        <param name="options">Objet d'options.</param>
        <summary>Accepte une demande de <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> à l'aide de la fonction utilisateur et de l'objet d'options spécifiés.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="userFunc" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La requête n'est pas une requête <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberSignature Language="F#" Value="member this.AddError : Exception -&gt; unit" Usage="httpContext.AddError errorInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo"><see cref="T:System.Exception" /> à ajouter à la collection d'exceptions.</param>
        <summary>Ajoute une exception à la collection d'exceptions pour la requête HTTP actuelle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnRequestCompleted : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpContext.AddOnRequestCompleted callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Objet de contexte HTTP.</param>
        <summary>Déclenche un événement virtuel qui se produit lorsque le composant HTTP de la requête se termine.</summary>
        <returns>Jeton d'abonnement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement se produit avant la <xref:System.Web.WebSockets.AspNetWebSocket> connexion commence.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="callback" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllErrors : Exception[]" Usage="System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un tableau d'erreurs accumulées pendant le traitement d'une requête HTTP.</summary>
        <value>Tableau d'objets <see cref="T:System.Exception" /> pour la requête HTTP actuelle.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAsyncDuringSyncStages : bool with get, set" Usage="System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les opérations asynchrones sont autorisées pendant le traitement de requête ASP.NET alors qu'elles ne sont pas attendues.</summary>
        <value><see langword="false" /> si ASP.NET lève une exception lorsque l'API asynchrone est utilisée alors qu'elle ne devrait pas l'être ; sinon, <see langword="true" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cet indicateur n’est pas défini `true`, ASP.NET lève une exception lorsqu’il détecte l’application de mauvaise utilisation de l’API asynchrone. Cela peut se produire si vous essayez d’appeler une méthode asynchrone pendant une partie de la demande de pipeline de traitement où les opérations asynchrones ne sont pas attendues ou s’il reste toujours en attente asynchrone lorsqu’un module asynchrone ou un gestionnaire signale l’achèvement. Ce comportement est conçu comme un filet de sécurité pour vous avertir au début si vous écrivez du code asynchrone qui ne tient pas prévu de modèles et peut avoir des effets négatifs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Web.HttpApplicationState" /> pour la requête HTTP actuelle.</summary>
        <value><see cref="T:System.Web.HttpApplicationState" /> pour la requête HTTP actuelle.  
  
Pour obtenir l'objet <see cref="T:System.Web.HttpApplication" /> pour la requête HTTP actuelle, utilisez <see cref="P:System.Web.HttpContext.ApplicationInstance" />. (ASP.NET utilise <see langword="ApplicationInstance" /> au lieu de <see langword="Application" /> comme nom de propriété pour faire référence à l'instance de <see cref="T:System.Web.HttpApplication" /> actuelle afin d'éviter un conflit entre ASP.NET et ASP classique. Dans ASP classique, <see langword="Application" /> fait référence au dictionnaire des états de l'application global.)</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationInstance : System.Web.HttpApplication with get, set" Usage="System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet <see cref="T:System.Web.HttpApplication" /> pour la requête HTTP actuelle.</summary>
        <value><see cref="T:System.Web.HttpApplication" /> pour la requête HTTP actuelle.  
  
ASP.NET utilise <see langword="ApplicationInstance" /> au lieu de <see langword="Application" /> comme nom de propriété pour faire référence à l'instance de <see cref="T:System.Web.HttpApplication" /> actuelle afin d'éviter un conflit entre ASP.NET et ASP classique. Dans ASP classique, <see langword="Application" /> fait référence au dictionnaire des états de l'application global.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">L’application web s’exécute dans IIS 7.0 en mode Intégré et une tentative a été effectuée pour changer la valeur de propriété d’une valeur non Null en <see langword="null" />.</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPreloadMode : System.Web.Configuration.AsyncPreloadModeFlags with get, set" Usage="System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un objet qui contient les indicateurs qui concernent le mode de préchargement asynchrone.</summary>
        <value>Objet qui contient les indicateurs qui concernent le mode de pré chargement asynchrone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La première fois que cette propriété est accessible, l’objet qui contient des indicateurs pour le mode de préchargement asynchrone est chargé à partir de la <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> dans le fichier de configuration.  
  
 Bien que cette propriété peut être définie par programme, modifier la valeur de propriété n'a d'effet que si la propriété est définie avant que l'étape de `ExecuteRequestHandler` dans le pipeline de requête ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Web.Caching.Cache" /> pour le domaine d'application actuel.</summary>
        <value><see cref="T:System.Web.Caching.Cache" /> pour le domaine d'application actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il existe une instance de la <xref:System.Web.Caching.Cache> classe par domaine d’application. Par conséquent, le <xref:System.Web.Caching.Cache> objet qui est retourné par la <xref:System.Web.HttpContext.Cache%2A> propriété est le <xref:System.Web.Caching.Cache> objet pour toutes les demandes dans le domaine d’application.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpContext.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface toutes les erreurs pour la requête HTTP actuelle.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Web.HttpContext with get, set" Usage="System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet <see cref="T:System.Web.HttpContext" /> pour la requête HTTP actuelle.</summary>
        <value>Instance <see cref="T:System.Web.HttpContext" /> pour la requête HTTP actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est une propriété statique de la <xref:System.Web.HttpContext> classe. Les magasins de propriété le <xref:System.Web.HttpContext> instance qui s’applique à la demande actuelle. Les propriétés de cette instance sont les propriétés non statiques de la <xref:System.Web.HttpContext> classe.  
  
 Vous pouvez également utiliser le <xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType> propriété pour accéder à la <xref:System.Web.HttpContext> objet pour la requête HTTP actuelle.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Web.HttpContext.Current%2A> propriété pour accéder à la <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> et <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> méthodes et les <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> propriété. L’exemple crée trois exceptions personnalisées à l’aide de la <xref:System.Web.HttpContext.AddError%2A> (méthode) et utilise le <xref:System.Web.HttpContext.AllErrors%2A> propriété pour charger ces exceptions dans un tableau. Il écrit le tableau dans la page conteneur, puis utilise le <xref:System.Web.HttpContext.ClearError%2A> méthode pour effacer toutes les erreurs de la <xref:System.Web.UI.Page.Context%2A> propriété.  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Web.IHttpHandler" /> qui représente le gestionnaire en cours.</summary>
        <value><see cref="T:System.Web.IHttpHandler" /> qui représente le gestionnaire en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le gestionnaire en cours d’exécution qui est référencé par le <xref:System.Web.HttpContext.CurrentHandler%2A> propriété peut être différente du gestionnaire qui est référencé par le <xref:System.Web.HttpContext.Handler%2A> propriété. Cela peut se produire lorsqu’un autre gestionnaire a été demandé à l’aide de la <xref:System.Web.HttpServerUtility.Execute%2A> méthode ou le <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode). Lorsque le gestionnaire en cours d’exécution termine le traitement, le gestionnaire défini précédemment est restauré.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Vue d’ensemble des Modules HTTP et les gestionnaires HTTP</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentNotification : System.Web.RequestNotification" Usage="System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur <see cref="T:System.Web.RequestNotification" /> qui indique quel événement <see cref="T:System.Web.HttpApplication" /> est en cours de traitement.</summary>
        <value>Une des valeurs de <see cref="T:System.Web.RequestNotification" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpContext.CurrentNotification%2A> propriété requiert le mode pipeline intégré dans [!INCLUDE[iisver](~/includes/iisver-md.md)] et au moins le .NET Framework version 3.0. Lorsqu’il est disponible, la propriété retourne un <xref:System.Web.RequestNotification> valeur. La valeur de la <xref:System.Web.HttpContext.CurrentNotification%2A> propriété indique quel événement dans le <xref:System.Web.HttpApplication> instance traite actuellement la requête.  
  
 Le <xref:System.Web.HttpContext.CurrentNotification%2A> propriété n’est pas destinée à être définie. Au lieu de cela, il est défini par [!INCLUDE[iisver](~/includes/iisver-md.md)] pendant le traitement de la demande dans le pipeline ASP.NET. Définition de la <xref:System.Web.HttpContext.CurrentNotification%2A> propriété entraîne une erreur de compilation.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> est introduit dans le .NET Framework version 3.5.  Pour plus d’informations, consultez [Versions et dépendances](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Web.HttpContext.CurrentNotification%2A> propriété afin de déterminer quel événement de le <xref:System.Web.HttpApplication> objet qui gère la requête actuelle est en cours de traitement. Dans l’exemple, le Gestionnaire d’événements gère plusieurs événements de la <xref:System.Web.HttpApplication> objet et le <xref:System.Web.HttpContext.CurrentNotification%2A> propriété détermine quel code est appelé pour chaque événement géré.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">L’opération exige le mode pipeline intégré d’[!INCLUDE[iisver](~/includes/iisver-md.md)] et au moins le .NET Framework version 3.0.</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberSignature Language="F#" Value="member this.DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken" Usage="httpContext.DisposeOnPipelineCompleted target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="target">Objet dont la méthode <see cref="M:System.IDisposable.Dispose" /> doit être appelée lorsque l'élément de connexion <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> de la demande est terminé.</param>
        <summary>Active la méthode <see cref="M:System.IDisposable.Dispose" /> d'un objet à appeler lorsque la partie de connexion <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> de cette demande est terminée.</summary>
        <returns>Jeton d'abonnement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IDisposable.Dispose%2A> de l’objet cible est appelée après les deux le composant HTTP de la demande et la <xref:System.Web.WebSockets.AspNetWebSocket> connexion a pris fin. Le <xref:System.Web.HttpContext> objet n’est pas disponible pour inspection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : Exception" Usage="System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la première erreur (éventuelle) accumulée pendant le traitement de la requête HTTP.</summary>
        <value>La première <see cref="T:System.Exception" /> pour le processus de requête/réponse HTTP actuel ; sinon, <see langword="null" /> si aucune erreur n'a été accumulée pendant le traitement de la requête HTTP. La valeur par défaut est <see langword="null" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetAppConfig : string -&gt; obj" Usage="System.Web.HttpContext.GetAppConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Balise de configuration de l'application pour laquelle des informations sont demandées.</param>
        <summary>Retourne les informations de configuration demandées pour l'application actuelle.</summary>
        <returns>Objet contenant des informations de configuration. (Effectuez un transtypage de la section de configuration retournée au type de configuration approprié avant utilisation).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.Web.HttpContext.GetAppConfig%2A> est déconseillée. Utilisez le <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A> méthode de la <xref:System.Web.Configuration.WebConfigurationManager> classe pour obtenir des informations de configuration de l’application actuelle.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetConfig : string -&gt; obj" Usage="httpContext.GetConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Balise de configuration pour laquelle les informations sont demandées.</param>
        <summary>Retourne les informations de configuration demandées pour la requête HTTP actuelle.</summary>
        <returns><see cref="T:System.Configuration.ConfigurationSection" /> spécifié, <see langword="null" /> si la section n'existe pas ou un objet interne si la section n'est pas accessible au moment de l'exécution. (Effectuez un transtypage de l'objet retourné au type de configuration approprié avant utilisation).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.Web.HttpContext.GetConfig%2A> est déconseillée. Utilisez le <xref:System.Web.HttpContext.GetSection%2A> méthode pour obtenir des informations de configuration pour la requête HTTP actuelle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient une ressource au niveau de l'application.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ressources dans les Applications</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Mise en page du Site Web ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="classKey">Chaîne qui représente la propriété <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> de l'objet de ressource demandé.</param>
        <param name="resourceKey">Chaîne qui représente la propriété <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> de l'objet de ressource demandé.</param>
        <summary>Obtient un objet ressource au niveau de l'application selon les propriétés <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> et <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> spécifiées.</summary>
        <returns><see cref="T:System.Object" /> qui représente l'objet de ressource au niveau de l'application demandé ; autrement, null si un objet de ressource est introuvable ou si un objet de ressource est trouvé mais n'a pas la propriété demandée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpContext.GetGlobalResourceObject%2A> méthode retourne une ressource globale à l’aide de la culture qui est spécifiée dans le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> propriété.  
  
> [!NOTE]
>  Dans certains environnements d’édition, tel que [!INCLUDE[vwprvw](~/includes/vwprvw-md.md)], l’éditeur peut lever une conception <xref:System.Resources.MissingManifestResourceException> exception si vous utilisez un point (.) dans le nom de clé de ressource globale. Toutefois, cela n’affecte pas votre capacité à modifier ou d’enregistrer le fichier, et vous pouvez ignorer l’erreur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Un objet ressource avec le paramètre <paramref name="classKey" /> spécifié n'a pas été trouvé.  
  
ou 
L'assembly principal ne contient pas les ressources pour la culture neutre, et ces ressources sont requises parce que l'assembly satellite approprié fait défaut.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ressources dans les Applications</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Mise en page du Site Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetage et déploiement de ressources</related>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="classKey">Chaîne qui représente la propriété <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> de l'objet de ressource demandé.</param>
        <param name="resourceKey">Chaîne qui représente une propriété <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> de l'objet de ressource demandé.</param>
        <param name="culture">Chaîne qui représente l'objet <see cref="T:System.Globalization.CultureInfo" /> de la ressource demandée.</param>
        <summary>Obtient un objet ressource au niveau de l'application selon les propriétés <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> et <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> spécifiées et selon l'objet <see cref="T:System.Globalization.CultureInfo" />.</summary>
        <returns><see cref="T:System.Object" /> qui représente l'objet de ressource au niveau de l'application demandé, qui est localisé pour la culture spécifiée ; autrement, <see langword="null" /> si un objet de ressource est introuvable ou si un objet de ressource est trouvé mais n'a pas la propriété demandée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Globalization.CultureInfo> objet représente la culture pour laquelle la ressource a été localisée. Si la ressource n’est pas localisée pour cette culture, la recherche suit un processus de secours pour localiser une ressource appropriée. Pour plus d’informations, consultez [Empaquetage et déploiement de ressources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
> [!NOTE]
>  Dans certains environnements d’édition, tels que Visual Web Developer, l’éditeur peut lever une conception <xref:System.Resources.MissingManifestResourceException> exception si vous utilisez un point (.) dans le nom de clé de ressource globale. Toutefois, cela n’affecte pas votre capacité à modifier ou d’enregistrer le fichier, et vous pouvez ignorer l’erreur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Objet ressource dont le paramètre <paramref name="classKey" /> spécifié n'a pas été trouvé.  
  
ou 
L'assembly principal ne contient pas les ressources pour la culture neutre, et ces ressources sont requises parce que l'assembly satellite approprié fait défaut.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ressources dans les Applications</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetage et déploiement de ressources</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient une ressource au niveau de la page.</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ressources dans les Applications</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Mise en page du Site Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetage et déploiement de ressources</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Propriété <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> de l'objet ressource local.</param>
        <param name="resourceKey">Chaîne qui représente une propriété <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> de l'objet de ressource demandé.</param>
        <summary>Obtient un objet ressource au niveau de la page selon les propriétés <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> et <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> spécifiées.</summary>
        <returns>Un <see cref="T:System.Object" /> qui représente l'objet ressource au niveau de la page demandé ; sinon, <see langword="null" /> si un objet ressource correspondant est trouvé mais pas un paramètre <paramref name="resourceKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpContext.GetLocalResourceObject%2A> méthode retourne une ressource locale à l’aide de la culture qui est spécifiée dans le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Un objet ressource n'a pas été trouvé pour le paramètre <paramref name="virtualPath" /> spécifié.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="virtualPath" /> spécifié n'est pas dans le répertoire racine de l'application actuelle.</exception>
        <exception cref="T:System.InvalidOperationException">La classe de ressource de la page n'a pas été trouvée.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ressources dans les Applications</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Mise en page du Site Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetage et déploiement de ressources</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">Procédure : Récupérer des valeurs de ressources par programme</related>
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Propriété <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> de l'objet ressource local.</param>
        <param name="resourceKey">Chaîne qui représente une propriété <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> de l'objet de ressource demandé.</param>
        <param name="culture">Chaîne qui représente l'objet <see cref="T:System.Globalization.CultureInfo" /> de l'objet de ressource demandé.</param>
        <summary>Obtient un objet ressource au niveau de la page selon les propriétés <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> et <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> spécifiées et selon l'objet <see cref="T:System.Globalization.CultureInfo" />.</summary>
        <returns>Un <see cref="T:System.Object" /> qui représente l'objet ressource local demandé qui est localisé pour la culture spécifiée ; sinon <see langword="null" /> si un objet ressource correspondant est trouvé mais pas un paramètre <paramref name="resourceKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la ressource n’est pas localisée pour cette culture, la recherche suit un processus de secours pour localiser une ressource appropriée. Pour plus d’informations, consultez [Empaquetage et déploiement de ressources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Un objet ressource n'a pas été trouvé pour le paramètre <paramref name="virtualPath" /> spécifié.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="virtualPath" /> spécifié n'est pas dans le répertoire racine de l'application actuelle.</exception>
        <exception cref="T:System.InvalidOperationException">La classe de ressource de la page n'a pas été trouvée.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ressources dans les Applications</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Mise en page du Site Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetage et déploiement de ressources</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">Procédure : Récupérer des valeurs de ressources par programme</related>
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="member this.GetSection : string -&gt; obj" Usage="httpContext.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sectionName">Chemin d'accès de section de configuration (au format XPath) et nom de l'élément de configuration.</param>
        <summary>Obtient une section de configuration spécifiée pour la configuration par défaut de l'application actuelle.</summary>
        <returns><see cref="T:System.Configuration.ConfigurationSection" /> spécifié, <see langword="null" /> si la section n'existe pas ou un objet interne si la section n'est pas accessible au moment de l'exécution.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Handler : System.Web.IHttpHandler with get, set" Usage="System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet <see cref="T:System.Web.IHttpHandler" /> chargé de traiter la requête HTTP actuelle.</summary>
        <value><see cref="T:System.Web.IHttpHandler" /> chargé de traiter la requête HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpContext.Handler%2A> propriété contient une référence au gestionnaire qui traite la requête HTTP. Le gestionnaire peut être spécifié à l’aide de la [httpHandlers](https://msdn.microsoft.com/library/24ca01f3-7141-4fdc-acac-71c0733cf6c2) élément, ou à l’aide d’un gestionnaire personnalisé défini dans le code utilisateur. Pour plus d’informations sur les gestionnaires, consultez [vue d’ensemble des Modules HTTP et les gestionnaires HTTP](https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b).  
  
 La référence à la <xref:System.Web.HttpContext.Handler%2A> propriété restent les mêmes même après la page actuelle a été modifiée par une méthode côté serveur, telles que la <xref:System.Web.HttpServerUtility.Execute%2A> méthode ou le <xref:System.Web.HttpServerUtility.Transfer%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Vue d’ensemble des Modules HTTP et les gestionnaires HTTP</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomErrorEnabled : bool" Usage="System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si les erreurs personnalisées sont autorisées pour la requête HTTP actuelle.</summary>
        <value><see langword="true" /> si les erreurs personnalisées sont autorisées ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la requête HTTP actuelle est en mode débogage.</summary>
        <value><see langword="true" /> si la requête est en mode débogage ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostNotification : bool" Usage="System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui est le point de traitement actuel dans le pipeline ASP.NET juste après qu'un événement <see cref="T:System.Web.HttpApplication" /> termine le traitement.</summary>
        <value><see langword="true" /> si les erreurs personnalisées sont autorisées ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpContext.IsPostNotification%2A> propriété est uniquement pris en charge avec le mode intégré dans [!INCLUDE[iisver](~/includes/iisver-md.md)] et au moins le .NET Framework 3.0. Lorsqu’il est disponible, la propriété retourne une valeur booléenne qui indique si un événement dans le <xref:System.Web.HttpApplication> objet a terminé le traitement.  
  
 Le <xref:System.Web.HttpContext.IsPostNotification%2A> propriété n’est pas destinée à être définie. Au lieu de cela, il est fourni par [!INCLUDE[iisver](~/includes/iisver-md.md)] au runtime ASP.NET pour chaque notification. Définition de la <xref:System.Web.HttpContext.IsPostNotification%2A> propriété entraîne une erreur de compilation.  
  
 Dans les scénarios où plusieurs événements de la <xref:System.Web.HttpApplication> objet sont gérées par un gestionnaire d’événements, vous pouvez utiliser la <xref:System.Web.HttpContext.IsPostNotification%2A> propriété en combinaison avec le <xref:System.Web.RequestNotification> énumération pour déterminer précisément où dans le cycle de vie d’application en cours la demande est.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> est introduit dans le .NET Framework version 3.5.  Pour plus d’informations, consultez [Versions et dépendances](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Web.HttpContext.IsPostNotification%2A> propriété afin de déterminer quand un événement de la <xref:System.Web.HttpApplication> objet a fini de traiter tous les gestionnaires d’événements associés. Le Gestionnaire d’événements personnalisé dans cet exemple gère plusieurs événements de la <xref:System.Web.HttpApplication> objet et le <xref:System.Web.HttpContext.IsPostNotification%2A> propriété est utilisée pour déterminer quel code est appelé une fois qu’un événement spécifique est traité.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">L’opération exige le mode pipeline intégré d’[!INCLUDE[iisver](~/includes/iisver-md.md)] et au moins .NET Framework 3.0.</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la requête possède une demande <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value><see langword="true" /> si la requête est une requête <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne `true` si la demande contient initial <xref:System.Web.WebSockets.AspNetWebSocket> protocole de transfert et le `WebSocket` module d’IIS est actif.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequestUpgrading : bool" Usage="System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la connexion effectue une mise à niveau d'une connexion HTTP vers une connexion <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value><see langword="true" /> si la connexion est mise à niveau ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection clé/valeur qui peut être utilisée pour organiser et partager les données entre une interface <see cref="T:System.Web.IHttpModule" /> et une interface <see cref="T:System.Web.IHttpHandler" /> pendant une requête HTTP.</summary>
        <value>Collection clé/valeur <see cref="T:System.Collections.IDictionary" /> qui fournit un accès à une valeur individuelle de la collection par une clé spécifiée.</value>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms972109.aspx">Une question de contexte</related>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageInstrumentation : System.Web.Instrumentation.PageInstrumentationService" Usage="System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à l'instance du service d'instrumentation de page pour cette requête.</summary>
        <value>Instance du service d'instrumentation de page pour cette requête.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Web.IHttpHandler" /> pour le gestionnaire parent.</summary>
        <value>Instance de <see cref="T:System.Web.IHttpHandler" />, ou <see langword="null" /> si aucun gestionnaire précédent n'a été trouvé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpContext.PreviousHandler%2A> propriété correspond au dernier gestionnaire avant l’exécution de la requête actuelle.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Vue d’ensemble des Modules HTTP et les gestionnaires HTTP</related>
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Profile : System.Web.Profile.ProfileBase" Usage="System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Web.Profile.ProfileBase" /> pour le profil utilisateur actuel.</summary>
        <value><see cref="T:System.Web.Profile.ProfileBase" /> si le fichier de configuration de l'application contient une définition pour les propriétés du profil ; sinon, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Web.HttpContext.Profile%2A> propriété est utilisée pour le stockage persistant des données structurées à l’aide d’une API de type sécurisé. Quand un <xref:System.Web.HttpContext.Profile%2A> propriété est accessible, mais aucune valeur n’est présente, une instance vide est retournée ; `null` n’est pas retournée.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberSignature Language="F#" Value="member this.RemapHandler : System.Web.IHttpHandler -&gt; unit" Usage="httpContext.RemapHandler handler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">Objet qui doit traiter la requête.</param>
        <summary>Vous permet de spécifier un gestionnaire pour la requête.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous définissez `handler` à `null`, le gestionnaire par défaut est utilisé pour traiter la demande. Vous pouvez définir `handler` à soit un gestionnaire asynchrone ou à un gestionnaire synchrone. Le gestionnaire doit implémenter le <xref:System.Web.IHttpHandler> interface.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La méthode <see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /> a été appelée après la survenue de l'événement <see cref="E:System.Web.HttpApplication.MapRequestHandler" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Web.HttpRequest" /> pour la requête HTTP actuelle.</summary>
        <value><see cref="T:System.Web.HttpRequest" /> pour la requête HTTP actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpContext.Request%2A> propriété fournit l’accès par programmation aux propriétés et méthodes de la <xref:System.Web.HttpRequest> classe. Étant donné que les pages ASP.NET contiennent une référence par défaut à la <xref:System.Web> espace de noms (qui contient le <xref:System.Web.HttpContext> classe), vous pouvez référencer les membres de <xref:System.Web.HttpRequest> sur une page .aspx sans utiliser la référence de classe qualifié complet à <xref:System.Web.HttpContext>. Par exemple, vous pouvez utiliser `Request.Browser` pour obtenir les fonctionnalités du navigateur client. Toutefois, si vous souhaitez utiliser les membres de <xref:System.Web.HttpRequest> à partir d’un module de code-behind ASP.NET, vous devez inclure une référence à la <xref:System.Web> espace de noms dans le module et une référence qualifiée complète pour les deux le contexte de demande/réponse actuellement actif et le classe <xref:System.Web> que vous souhaitez utiliser. Par exemple, dans une page code-behind, vous devez spécifier le nom qualifié complet `HttpContext.Current.Request.Browser`.  
  
> [!NOTE]
>  ASP.NET lève une exception si vous essayez d’utiliser cette propriété lorsque la <xref:System.Web.HttpRequest> objet n’est pas disponible. Par exemple, ce serait vrai dans la méthode Application_Start du fichier Global.asax, ou dans une méthode qui est appelée à partir de la méthode Application_Start. À ce moment-là aucune requête HTTP n’a encore été créé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L’application web s’exécute dans IIS 7 en mode intégré.</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Web.HttpResponse" /> pour la réponse HTTP actuelle.</summary>
        <value><see cref="T:System.Web.HttpResponse" /> pour la réponse HTTP actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpContext.Response%2A> propriété fournit l’accès par programmation aux propriétés et méthodes de la <xref:System.Web.HttpResponse> classe. Étant donné que les pages ASP.NET contiennent une référence par défaut à la <xref:System.Web> espace de noms (qui contient le <xref:System.Web.HttpContext> classe), vous pouvez référencer les membres de <xref:System.Web.HttpContext> sur une page .aspx sans utiliser la référence de classe qualifié complet à <xref:System.Web.HttpContext>. Par exemple, vous pouvez utiliser `Response.Write("some output")` pour écrire la sortie dans un flux de sortie HTTP. Toutefois, si vous souhaitez utiliser les membres de <xref:System.Web.HttpResponse> à partir d’un module de code-behind ASP.NET, vous devez inclure une référence à la <xref:System.Web> espace de noms dans le module et une référence qualifiée complète pour le contexte de demande/réponse actuellement active et la classe dans <xref:System.Web> que vous souhaitez utiliser. Par exemple, dans une page code-behind, vous devez spécifier le nom qualifié complet `HttpContext.Current.Response.Write("some output")`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">L’application web s’exécute dans IIS 7 en mode intégré.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Redirige une requête pour une ressource vers un chemin d'accès différent de celui indiqué par l'URL requise. <see cref="Overload:System.Web.HttpContext.RewritePath" /> est utilisé dans l'état de session sans cookie pour supprimer les ID de session des URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string -&gt; unit" Usage="httpContext.RewritePath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès de réécriture interne.</param>
        <summary>Réécrit l'URL à l'aide du chemin d'accès donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpContext.RewritePath%28System.String%29> méthode redirige une requête pour une ressource vers un autre chemin d’accès que celui qui est indiqué par l’URL demandée. Si vous devez réinitialiser le chemin d’accès virtuel afin de résolvent correctement les demandes du client pour les ressources de serveur, utilisez la surcharge de cette méthode qui accepte le `rebaseClientPath` paramètre et définissez le paramètre sur `false`.  
  
 Réécriture d’URL est utile lorsque vous souhaitez restructurer les pages de votre application Web, et vous souhaitez vous assurer que les personnes qui ont créé un signet les anciennes URL peuvent toujours les utiliser après avoir déplacé les pages. Réécriture d’URL vous permet de transférer en toute transparence les demandes vers le nouvel emplacement de la page.  
  
 Si vous souhaitez autoriser un site à utiliser des URL qui sont plus conviviales et sont optimisées pour les moteurs de recherche, une alternative plus robuste consiste à utiliser le routage ASP.NET. Pour plus d’informations, consultez [routage ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Web.HttpContext.RewritePath%2A> méthode pour permettre à un site Web de répondre aux URL qui ne reflètent pas la structure de fichiers dans le site Web. Le premier bloc de code est une page Web ASP.NET nommée RewritePath.aspx. Elle nécessite une chaîne de requête. Si le nom de votre site est WebSite1, l’URL `http://localhost/WebSite1/RewritePath.aspx?page=1` affiche « Page 1 » dans le navigateur. Le bloc de code qui suit la page Web est le `Application_BeginRequest` Gestionnaire d’événements dans le fichier Global.asax. Ce code intercepte les demandes d’URL comme `http://localhost/WebSite1/page1` et les convertit au formulaire qui est requis par RewritePath.aspx avant leur traitement. Par conséquent, l’URL `http://localhost/WebSite1/page1` appelle RewritePath.aspx avec le paramètre de chaîne de requête qui affiche « Page 1 » dans le navigateur. Si une URL comme `http://localhost/WebSite1/page1` est reçue, une surcharge de <xref:System.Web.HttpContext.RewritePath%2A> est appelé qui vous permet de fournir une valeur pour le <xref:System.Web.HttpRequest.PathInfo%2A> propriété ainsi que d’une requête de paramètre de chaîne.  
  
 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Le paramètre <paramref name="path" /> ne se trouve pas dans le répertoire racine de l'application actuelle.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Procédure pas à pas : Utilisation du routage dans une Application Web Forms ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * bool -&gt; unit" Usage="httpContext.RewritePath (path, rebaseClientPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès de réécriture interne.</param>
        <param name="rebaseClientPath"><see langword="true" /> pour reconfigurer le chemin d'accès virtuel ; <see langword="false" /> pour garder le chemin d'accès virtuel intact.</param>
        <summary>Réécrit l'URL à l'aide du chemin d'accès donné et d'une valeur Boolean qui spécifie si le chemin d'accès virtuel pour les ressources de serveur est modifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> méthode est appelée par le <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType> méthode avec le `rebaseClientPath` paramètre défini sur `true`. Pour vous assurer que le chemin d’accès virtuel qui est utilisé pour construire des chemins d’accès aux ressources n’est pas modifié, affectez la `rebaseClientPath` paramètre `false`. Un scénario courant dans lequel vous souhaitez peut-être définir `rebaseClientPath` à `false` est lorsque vous avez besoin de réécrire l’URL, et vous êtes à l’aide de thèmes et redirigez l’URL vers une ressource située dans un dossier autre que celui de la ressource demandée.  
  
 Réécriture d’URL est utile lorsque vous souhaitez restructurer les pages de votre application Web, et vous souhaitez vous assurer que les personnes qui ont créé un signet les anciennes URL peuvent toujours les utiliser après avoir déplacé les pages. Réécriture d’URL vous permet de transférer en toute transparence les demandes vers le nouvel emplacement de la page.  
  
 Si vous souhaitez autoriser un site à utiliser des URL qui sont plus conviviales et sont optimisées pour les moteurs de recherche, une alternative plus robuste consiste à utiliser le routage ASP.NET. Pour plus d’informations, consultez [routage ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Pour obtenir un exemple de code, consultez le <xref:System.Web.HttpContext.RewritePath%28System.String%29> surcharge de méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Le paramètre <paramref name="path" /> ne se trouve pas dans le répertoire racine de l'application actuelle.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Procédure pas à pas : Utilisation du routage dans une Application Web Forms ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">Chemin d'accès de réécriture interne.</param>
        <param name="pathInfo">Informations supplémentaires sur le chemin d'accès pour une ressource. Pour plus d'informations, consultez <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Chaîne de requête de la demande.</param>
        <summary>Réécrit l'URL en utilisant le chemin d'accès, les informations relatives au chemin d'accès et les informations de la chaîne de requête donnés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpContext.RewritePath%2A> méthode redirige une requête pour une ressource à une autre ressource sans modifier l’URL.  
  
 Le `filePath` paramètre n’inclut pas le `pathInfo` contenu du paramètre. Pour l’URL http://www.microsoft.com/virdir/page.html/tail, le `filePath` paramètre est http://www.microsoft.com/virdir/page.htmlet le `pathInfo` paramètre est à la fin du.  
  
 Réécriture d’URL est utile lorsque vous souhaitez restructurer les pages de votre application Web, et vous souhaitez vous assurer que les personnes qui ont créé un signet les anciennes URL peuvent toujours les utiliser après avoir déplacé les pages. Réécriture d’URL vous permet de transférer en toute transparence les demandes vers le nouvel emplacement de la page.  
  
 Si vous souhaitez autoriser un site à utiliser des URL qui sont plus conviviales et sont optimisées pour les moteurs de recherche, une alternative plus robuste consiste à utiliser le routage ASP.NET. Pour plus d’informations, consultez [routage ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Pour obtenir un exemple de code, y compris un exemple de cette surcharge de méthode, consultez la <xref:System.Web.HttpContext.RewritePath%28System.String%29> surcharge de méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> ne se trouve pas dans le répertoire racine de l'application actuelle.</exception>
        <exception cref="T:System.Web.HttpException">Le paramètre <paramref name="filePath" /> ne se trouve pas dans le répertoire racine de l'application actuelle.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Procédure pas à pas : Utilisation du routage dans une Application Web Forms ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string * bool -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString, setClientFilePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="pathInfo" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="queryString" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filePath">Le chemin d'accès virtuel à la ressource qui traite la requête.</param>
        <param name="pathInfo">Les informations supplémentaires relatives au chemin d'accès à utiliser pour rediriger l'URL. Pour plus d'informations, consultez <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">La chaîne de requête à utiliser pour rediriger l'URL.</param>
        <param name="setClientFilePath"><see langword="true" /> pour définir le chemin d'accès du fichier ressources client à la valeur du paramètre <paramref name="filePath" /> ; sinon, <see langword="false" />.</param>
        <summary>Réécrit l'URL à l'aide du chemin d'accès virtuel donné, des informations relatives au chemin d'accès, des informations de chaîne de requête et d'une valeur Boolean qui spécifie si le chemin d'accès client a pour valeur le chemin d'accès de réécriture.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `filePath` paramètre n’inclut pas le contenu de la `pathInfo` paramètre. Pour l’URL http://www.microsoft.com/virdir/page.html/tail, le `filePath` paramètre est http://www.microsoft.com/virdir/page.htmlet le `pathInfo` paramètre est à la fin du.  
  
 Pour vous assurer que le chemin d’accès virtuel qui est utilisé pour construire des chemins d’accès aux ressources n’est pas modifié, affectez la `setClientFilePath` paramètre `false`. Un scénario courant dans lequel vous souhaitez peut-être définir `setClientFilePath` à `false` est lorsque vous avez besoin de réécrire l’URL, et vous êtes à l’aide de thèmes et redirigez l’URL vers une ressource située dans un dossier autre que celui de la ressource demandée.  
  
 Réécriture d’URL est utile lorsque vous souhaitez restructurer les pages de votre application Web, et vous souhaitez vous assurer que les personnes qui ont créé un signet les anciennes URL peuvent toujours les utiliser après avoir déplacé les pages. Réécriture d’URL vous permet de transférer en toute transparence les demandes vers le nouvel emplacement de la page.  
  
 Si vous souhaitez autoriser un site à utiliser des URL qui sont plus conviviales et sont optimisées pour les moteurs de recherche, une alternative plus robuste consiste à utiliser le routage ASP.NET. Pour plus d’informations, consultez [routage ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Pour obtenir un exemple de code, consultez le <xref:System.Web.HttpContext.RewritePath%28System.String%29> surcharge de méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> ne se trouve pas dans le répertoire racine de l'application actuelle.</exception>
        <exception cref="T:System.Web.HttpException">Le paramètre <paramref name="filePath" /> ne se trouve pas dans le répertoire racine de l'application actuelle.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routage ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Procédure pas à pas : Utilisation du routage dans une Application Web Forms ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Web.HttpServerUtility" /> qui fournit les méthodes utilisées dans le traitement de requêtes Web.</summary>
        <value><see cref="T:System.Web.HttpServerUtility" /> pour la requête HTTP actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpContext.Server%2A> propriété fournit l’accès par programmation aux propriétés et méthodes de la <xref:System.Web.HttpServerUtility> classe. Étant donné que les pages ASP.NET contiennent une référence par défaut à la <xref:System.Web> espace de noms (qui contient le <xref:System.Web.HttpContext> classe), vous pouvez référencer les membres de <xref:System.Web.HttpContext> sur une page .aspx sans utiliser la référence de classe qualifié complet à <xref:System.Web.HttpContext>. Par exemple, vous pouvez utiliser `Server.CreateObject("MyCOMComponent")` pour créer une instance d’un objet COM sur le serveur. Toutefois, si vous souhaitez utiliser les membres de <xref:System.Web.HttpServerUtility> à partir d’un module de code-behind ASP.NET, vous devez inclure une référence à la <xref:System.Web> espace de noms dans le module et une référence qualifiée complète pour les deux le contexte de demande/réponse actuellement actif et le classe <xref:System.Web> que vous souhaitez utiliser. Par exemple, dans une page code-behind, vous devez spécifier le nom qualifié complet `HttpContext.Current.Server.CreateObject("MyCOMComponent")`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Web.SessionState.HttpSessionState" /> pour la requête HTTP actuelle.</summary>
        <value>Objet <see cref="T:System.Web.SessionState.HttpSessionState" /> pour la requête HTTP actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpContext.Session%2A> propriété fournit l’accès par programmation aux propriétés et méthodes de la <xref:System.Web.SessionState.HttpSessionState> classe.  
  
 Pour pouvoir utiliser l’état de session, vous devez l’activer. Pour plus d’informations sur l’activation de l’état de session, consultez **l’état de Session configuration** dans [ASP.NET Session State Overview](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
 Pour plus d’informations sur la façon d’enregistrer les valeurs dans l’état de session, consultez [Comment : Enregistrer les valeurs dans l’état de Session](https://msdn.microsoft.com/library/a6cb2e3a-df49-4b12-9d9a-eed45541c165). Pour plus d’informations sur la lecture des valeurs à partir de l’état de session, consultez [Comment : Lire les valeurs à partir de l’état de Session](https://msdn.microsoft.com/library/2ef449bc-5c17-4785-b7cf-378c601af8f5).  
  
   
  
## Examples  
 Les exemples suivants montrent comment enregistrer les valeurs dans l’état de session et comment lire des valeurs à partir de l’état de session.  
  
 Ces exemples nécessitent :  
  
-   Une application ASP.NET qui a l’état de session est activé.  
  
-   Une classe de page Web Forms qui a accès à la <xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType> propriété, ou toute classe qui a accès à la <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> propriété.  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="F#" Value="member this.SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit" Usage="httpContext.SetSessionStateBehavior sessionStateBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">L'une des valeurs d'énumération qui spécifie le type de comportement d'état de session requis.</param>
        <summary>Définit le type de comportement d'état de session requis afin de prendre en charge une requête HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans l’implémentation par défaut ASP.NET, un gestionnaire de demande HTTP indique s’il requiert l’état de session en implémentant la <xref:System.Web.SessionState.IRequiresSessionState> interface ou le <xref:System.Web.SessionState.IReadOnlySessionState> interface. Le <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> (méthode) et le <xref:System.Web.SessionState.SessionStateBehavior> énumération vous permettre de fournir plus de détails sur quel type de prise en charge des état de session est requis pour gérer une requête. Pour plus d’informations, consultez l’énumération <xref:System.Web.SessionState.SessionStateBehavior>.  
  
 Le <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> méthode doit être appelée avant la <xref:System.Web.HttpApplication.AcquireRequestState> les événements de pipeline. Les appels qui surviennent pendant ou après cet événement entraîne un <xref:System.InvalidOperationException> exception.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La méthode a été appelée après le déclenchement de l'événement <see cref="E:System.Web.HttpApplication.AcquireRequestState" />.</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipAuthorization : bool with get, set" Usage="System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui spécifie si l'objet <see cref="T:System.Web.Security.UrlAuthorizationModule" /> doit ignorer le contrôle d'autorisation pour la requête actuelle.</summary>
        <value><see langword="true" /> si le <see cref="T:System.Web.Security.UrlAuthorizationModule" /> doit ignorer le contrôle d'autorisation ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpContext.SkipAuthorization%2A> propriété est destinée à l’utilisation avancée par les modules d’authentification qui doivent rediriger vers une page qui autorise les connexions anonymes. Le module d’authentification de formulaires et le module d’authentification Passport toutes deux définies <xref:System.Web.HttpContext.SkipAuthorization%2A> lors de la redirection vers une page d’ouverture de session configuré. Paramètre <xref:System.Web.HttpContext.SkipAuthorization%2A> nécessite le `ControlPrincipal` indicateur à définir. Pour plus d’informations sur la `ControlPrincipal` indicateur, consultez <xref:System.Security.Permissions.SecurityPermissionFlag>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">Type du service <see cref="T:System.Web.HttpContext" /> sur lequel définir le fournisseur de services.</param>
        <summary>Retourne un objet pour le type de service actuel.</summary>
        <returns><see cref="T:System.Web.HttpContext" /> ; sinon, <see langword="null" /> si aucun service n'est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utile pour accéder aux sous-jacent <xref:System.Web.HttpWorkerRequest> objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThreadAbortOnTimeout : bool with get, set" Usage="System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui spécifie si le runtime ASP.NET doit appeler <see cref="M:System.Threading.Thread.Abort" /> sur le thread qui résout cette requête lorsque la requête a expiré.</summary>
        <value><see langword="true" /> si <see cref="M:System.Threading.Thread.Abort" /> est appelé lorsque le thread expire ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans les gestionnaires et des modules qui sont à l’aide de la <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> pour implémenter l’annulation coopérative, vous souhaitez peut-être désactiver la <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> comportement qu’ASP.NET exécute par défaut lorsqu’une demande arrive à expiration. Si cette propriété `false` peut vous aider à vous assurer que les routines d’annulation et de nettoyage seront exécute sans être interrompu par ASP.NET.  
  
 Si vous définissez cette propriété sur `false`, ASP.NET s’affiche pas automatiquement une page d’erreur « La demande dépassé » lorsqu’un délai d’expiration se produit. L’application est chargée de définir le contenu de la réponse en conséquence.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Timestamp : DateTime" Usage="System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'horodatage initial de la requête HTTP actuelle.</summary>
        <value>Horodatage de la requête HTTP actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’horodatage retourné par la <xref:System.Web.HttpContext.Timestamp%2A> propriété est l’heure locale du serveur et est définie lors de l’instanciation de le <xref:System.Web.HttpContext> objet. L’heure locale est égale à l’heure UTC plus l’offset UTC.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Web.TraceContext" /> pour la réponse HTTP actuelle.</summary>
        <value><see cref="T:System.Web.TraceContext" /> pour la réponse HTTP actuelle.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal with get, set" Usage="System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les informations de sécurité pour la requête HTTP actuelle.</summary>
        <value>Informations de sécurité pour la requête HTTP actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.HttpContext.User%2A> propriété fournit l’accès par programmation aux propriétés et méthodes de la <xref:System.Security.Principal.IPrincipal> interface.  
  
 Étant donné que les pages ASP.NET contiennent une référence par défaut à la <xref:System.Web> espace de noms (qui contient le <xref:System.Web.HttpContext> classe), vous pouvez référencer les membres de <xref:System.Web.HttpContext> sur une page .aspx sans utiliser la référence de classe qualifié complet à <xref:System.Web.HttpContext>. Par exemple, vous pouvez utiliser `User.Identity.Name` pour obtenir le nom de l’utilisateur au nom duquel le processus actuel est en cours d’exécution. Toutefois, si vous souhaitez utiliser les membres de <xref:System.Security.Principal.IPrincipal> à partir d’un module de code-behind ASP.NET, vous devez inclure une référence à la <xref:System.Web> espace de noms dans le module et une référence qualifiée complète pour les deux le contexte de demande/réponse actuellement actif et le classe <xref:System.Web> que vous souhaitez utiliser. Par exemple, dans une page code-behind, vous devez spécifier le nom qualifié complet `HttpContext.Current.User.Identity.Name`.  
  
   
  
## Examples  
 L’exemple suivant montre comment accéder aux propriétés de l’utilisateur actuel via le <xref:System.Web.HttpContext.User%2A> propriété. Ces propriétés sont utilisées pour définir le titre de la page Web.  
  
 Si l’application utilise l’authentification Windows, le nom d’utilisateur comprend le domaine. Par exemple, le titre de page serait « Page d’accueil de domaine\nom d’utilisateur ».  
  
 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions/using-oauth-providers-with-mvc">Utilisation de fournisseurs OAuth avec MVC 4</related>
        <related type="ExternalDocumentation" href="/aspnet/web-forms/overview/getting-started/getting-started-with-aspnet-45-web-forms/checkout-and-payment-with-paypal">Bien démarrer avec Web Forms ASP.NET 4.5 - commande et paiement avec PayPal</related>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions-1/nerddinner/secure-applications-using-authentication-and-authorization">NerdDinner - Applications sécurisées à l’aide de l’authentification et autorisation</related>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketNegotiatedProtocol : string" Usage="System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le protocole négocié qui a été envoyé du serveur au client pour une connexion du <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>Protocole négocié.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketRequestedProtocols : System.Collections.Generic.IList&lt;string&gt;" Usage="System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la liste ordonnée des protocoles demandés par le client.</summary>
        <value>Protocoles demandés, ou <see langword="null" /> s'il ne s'agit pas d'une requête <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> ou si aucune liste n'est présente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>