<Type Name="ControlDesigner" FullName="System.Windows.Forms.Design.ControlDesigner">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dca817abec774959baf373d445734a021760d141" /><Meta Name="ms.sourcegitcommit" Value="2982b8c4cce02c2542285fcaf172f7544d6b80bc" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="04/09/2019" /><Meta Name="ms.locfileid" Value="59355044" /></Metadata><TypeSignature Language="C#" Value="public class ControlDesigner : System.ComponentModel.Design.ComponentDesigner" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ControlDesigner extends System.ComponentModel.Design.ComponentDesigner" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Design.ControlDesigner" />
  <TypeSignature Language="VB.NET" Value="Public Class ControlDesigner&#xA;Inherits ComponentDesigner" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlDesigner : System::ComponentModel::Design::ComponentDesigner" />
  <TypeSignature Language="F#" Value="type ControlDesigner = class&#xA;    inherit ComponentDesigner" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms.Design</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Design.ComponentDesigner</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-3.0">
      <AttributeName>System.CLSCompliant(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Étend le comportement en mode design de <see cref="T:System.Windows.Forms.Control" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Design.ControlDesigner> Fournit une classe de base pour les concepteurs de composants qui dérivent de <xref:System.Windows.Forms.Control>. Outre les méthodes et les fonctionnalités héritées de la <xref:System.ComponentModel.Design.ComponentDesigner> (classe), <xref:System.Windows.Forms.Design.ControlDesigner> fournit des méthodes supplémentaires pour prendre en charge d’extension et la modification du comportement d’un <xref:System.Windows.Forms.Control> au moment du design.  
  
 Vous pouvez associer un concepteur à un type en utilisant un <xref:System.ComponentModel.DesignerAttribute>. Pour une vue d’ensemble de la personnalisation du comportement au moment du design, consultez [Extending Design-Time Support](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2010/37899azc(v=vs.100)).  
  
   
  
## Examples  
 L’exemple suivant <xref:System.Windows.Forms.Design.ControlDesigner> implémentation illustre la gestion `MouseEnter` et `MouseLeave` événements, sur un contrôle de dessin à partir de code du concepteur et à l’aide de la partie de la <xref:System.ComponentModel.Design.IDesignerFilter> interface pour ajouter une propriété pour le contrôle au moment du design. L’exemple de code suivant contient un concepteur et un exemple de contrôle utilisateur associé au concepteur. Pour générer cet exemple, compilez-le dans une bibliothèque de classes, ajoutez une référence à la bibliothèque à un projet Windows Forms, ajouter le contrôle à la boîte à outils et ajouter une instance du contrôle à votre formulaire. Lorsque vous pointez sur le contrôle, le contour interne du périmètre du contrôle est mis en surbrillance, et la couleur utilisée pour dessiner le contour correspond à la `OutlineColor` propriété le concepteur a ajouté aux propriétés répertoriées pour le contrôle.  
  
 Ajoutez une référence à l’assembly System.Design pour compiler l’exemple de code.  
  
 [!code-cpp[ControlDesignerExample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlDesignerExample/CPP/controldesignerexample.cpp#1)]
 [!code-csharp[ControlDesignerExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlDesignerExample/CS/controldesignerexample.cs#1)]
 [!code-vb[ControlDesignerExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlDesignerExample/VB/controldesignerexample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.Design.ComponentDesigner" />
    <altmember cref="T:System.ComponentModel.Design.IDesigner" />
    <altmember cref="T:System.ComponentModel.DesignerAttribute" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2010/37899azc(v=vs.100)">Extension de la prise en charge au moment du design</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ControlDesigner ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ControlDesigner();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Forms.Design.ControlDesigner" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="accessibilityObj">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.AccessibleObject accessibilityObj;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Windows.Forms.AccessibleObject accessibilityObj" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.Design.ControlDesigner.accessibilityObj" />
      <MemberSignature Language="VB.NET" Value="Protected accessibilityObj As AccessibleObject " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Windows::Forms::AccessibleObject ^ accessibilityObj;" />
      <MemberSignature Language="F#" Value="val mutable accessibilityObj : System.Windows.Forms.AccessibleObject" Usage="System.Windows.Forms.Design.ControlDesigner.accessibilityObj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie l'objet d'accessibilité pour le concepteur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur par défaut est `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="AccessibilityObject">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AccessibleObject AccessibilityObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AccessibleObject AccessibilityObject" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.AccessibilityObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AccessibilityObject As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AccessibleObject ^ AccessibilityObject { System::Windows::Forms::AccessibleObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessibilityObject : System.Windows.Forms.AccessibleObject" Usage="System.Windows.Forms.Design.ControlDesigner.AccessibilityObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Windows.Forms.AccessibleObject" /> assigné au contrôle.</summary>
        <value><see cref="T:System.Windows.Forms.AccessibleObject" /> assigné au contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations sur les objets accessibles, consultez la section Active Accessibility de MSDN Library.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="AssociatedComponents">
      <MemberSignature Language="C#" Value="public override System.Collections.ICollection AssociatedComponents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection AssociatedComponents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.AssociatedComponents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssociatedComponents As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ AssociatedComponents { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssociatedComponents : System.Collections.ICollection" Usage="System.Windows.Forms.Design.ControlDesigner.AssociatedComponents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection de composants associés au composant géré par le concepteur.</summary>
        <value>Composants associés au composant géré par le concepteur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété indique tous les composants pour copier ou déplacer, ainsi que le composant géré par le concepteur lors d’une copie, faites glisser, ou l’opération de déplacement.  
  
 Si cette collection contient des références à d’autres composants dans le document en mode design en cours, ces composants seront copiés en même temps que le composant géré par le concepteur durant une opération de copie.  
  
 Lorsque le composant géré par le concepteur est sélectionné, cette collection est remplie avec tous les contrôles imbriqués. Cette collection peut également inclure d’autres composants, tels que les boutons d’une barre d’outils.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoResizeHandles">
      <MemberSignature Language="C#" Value="public bool AutoResizeHandles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoResizeHandles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.AutoResizeHandles" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoResizeHandles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoResizeHandles { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoResizeHandles : bool with get, set" Usage="System.Windows.Forms.Design.ControlDesigner.AutoResizeHandles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si l'allocation de poignée de redimensionnement dépend de la valeur de la propriété <see cref="P:System.Windows.Forms.Control.AutoSize" />.</summary>
        <value><see langword="true" /> Si redimensionner allocation de poignée dépend de la valeur de la <see cref="P:System.Windows.Forms.Control.AutoSize" /> et <see langword="AutoSizeMode" /> propriétés ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseWndProc">
      <MemberSignature Language="C#" Value="protected void BaseWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BaseWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.BaseWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BaseWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BaseWndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="member this.BaseWndProc :  -&gt; unit" Usage="controlDesigner.BaseWndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m"><see cref="T:System.Windows.Forms.Message" /> à traiter.</param>
        <summary>Traite les messages Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode provoque le message soit traité par Windows, en ignorant le contrôle. Cela est utile si vous souhaitez bloquer le message du passage au contrôle, mais vous ne souhaitez pas que pour l’empêcher de familiarisation avec Windows lui-même, car cela peut provoquer la génération des autres messages.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BehaviorService">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.Design.Behavior.BehaviorService BehaviorService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Design.Behavior.BehaviorService BehaviorService" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.BehaviorService" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property BehaviorService As BehaviorService" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Forms::Design::Behavior::BehaviorService ^ BehaviorService { System::Windows::Forms::Design::Behavior::BehaviorService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BehaviorService : System.Windows.Forms.Design.Behavior.BehaviorService" Usage="System.Windows.Forms.Design.ControlDesigner.BehaviorService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Design.Behavior.BehaviorService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Windows.Forms.Design.Behavior.BehaviorService" /> de l'environnement de design.</summary>
        <value><see cref="T:System.Windows.Forms.Design.Behavior.BehaviorService" /> ou <see langword="null" /> si le service n'est pas disponible.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBeParentedTo">
      <MemberSignature Language="C#" Value="public virtual bool CanBeParentedTo (System.ComponentModel.Design.IDesigner parentDesigner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanBeParentedTo(class System.ComponentModel.Design.IDesigner parentDesigner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.CanBeParentedTo(System.ComponentModel.Design.IDesigner)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanBeParentedTo (parentDesigner As IDesigner) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanBeParentedTo(System::ComponentModel::Design::IDesigner ^ parentDesigner);" />
      <MemberSignature Language="F#" Value="abstract member CanBeParentedTo : System.ComponentModel.Design.IDesigner -&gt; bool&#xA;override this.CanBeParentedTo : System.ComponentModel.Design.IDesigner -&gt; bool" Usage="controlDesigner.CanBeParentedTo parentDesigner" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentDesigner" Type="System.ComponentModel.Design.IDesigner" />
      </Parameters>
      <Docs>
        <param name="parentDesigner"><see cref="T:System.ComponentModel.Design.IDesigner" /> qui gère le contrôle à vérifier.</param>
        <summary>Indique si le contrôle de ce concepteur peut être apparenté au contrôle du concepteur spécifié.</summary>
        <returns><see langword="true" /> si le contrôle géré par le concepteur spécifié peut être apparenté au contrôle géré par ce concepteur, sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utile pour vérifier si un contrôle peut être apparenté à un type particulier de parent. Par exemple, <xref:System.Windows.Forms.TabPage> contrôles peuvent uniquement être apparentés à <xref:System.Windows.Forms.TabControl> contrôles.  
  
> [!NOTE]
>  Cette méthode n’est pas appelée lorsqu’un élément est déplacé à partir de la **boîte à outils** sur l’aire de conception.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.Control" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Control ^ Control { System::Windows::Forms::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Windows.Forms.Control" Usage="System.Windows.Forms.Design.ControlDesigner.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le contrôle qui est créé par le concepteur.</summary>
        <value>Contrôle qui est créé par le concepteur.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="member this.DefWndProc :  -&gt; unit" Usage="controlDesigner.DefWndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m"><see cref="T:System.Windows.Forms.Message" /> à traiter.</param>
        <summary>Fournit le traitement par défaut pour les messages Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode provoque le message soit traité par le contrôle, plutôt que par le concepteur.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Design.ControlDesigner.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayError">
      <MemberSignature Language="C#" Value="protected void DisplayError (Exception e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DisplayError(class System.Exception e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.DisplayError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DisplayError (e As Exception)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DisplayError(Exception ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisplayError : Exception -&gt; unit" Usage="controlDesigner.DisplayError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Exception" /> à afficher.</param>
        <summary>Affiche des informations sur l'exception spécifiée pour l'utilisateur.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="controlDesigner.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.Windows.Forms.Design.ControlDesigner" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose()` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose()` appelle la méthode protégée `Dispose(Boolean)` méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` défini sur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.Windows.Forms.Design.ControlDesigner>. Cette méthode appelle la méthode `Dispose()` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d’autres objets. Lors de la substitution <see langword="Dispose(Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d’un précédent appel à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
      </Docs>
    </Member>
    <Member MemberName="EnableDesignMode">
      <MemberSignature Language="C#" Value="protected bool EnableDesignMode (System.Windows.Forms.Control child, string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool EnableDesignMode(class System.Windows.Forms.Control child, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.EnableDesignMode(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function EnableDesignMode (child As Control, name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool EnableDesignMode(System::Windows::Forms::Control ^ child, System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.EnableDesignMode : System.Windows.Forms.Control * string -&gt; bool" Usage="controlDesigner.EnableDesignMode (child, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.Forms.Control" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="child">Le contrôle enfant pour lequel le mode Design sera activé.</param>
        <param name="name">Le nom de <paramref name="child" /> tel qu'il est exposé à l'utilisateur final.</param>
        <summary>Active les fonctionnalités de design pour un contrôle enfant.</summary>
        <returns><see langword="true" /> si le contrôle enfant a pu être activé pour le design ; <see langword="false" /> si l’infrastructure d’hébergement ne le prend pas en charge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le contrôle enfant spécifié par `child` est un enfant de ce contrôle contrôle de concepteur. L’enfant ne participe pas directement dans la persistance, mais qu’elle soit si elle est exposée en tant que propriété du contrôle principal. Prenons un contrôle tel que le <xref:System.Windows.Forms.SplitContainer>: il a deux panneaux, `Panel1` et `Panel2`. Ces panneaux est exposés via en lecture seule <xref:System.Windows.Forms.SplitContainer.Panel1%2A> et <xref:System.Windows.Forms.SplitContainer.Panel2%2A> propriétés sur le <xref:System.Windows.Forms.SplitContainer> contrôle. Le <xref:System.Windows.Forms.SplitContainer> appels concepteur du contrôle <xref:System.Windows.Forms.Design.ControlDesigner.EnableDesignMode%2A> pour chaque panneau, ce qui permet d’autres composants à supprimer sur ces derniers. Mais, pour le contenu de <xref:System.Windows.Forms.SplitContainer.Panel1%2A> et <xref:System.Windows.Forms.SplitContainer.Panel2%2A> doit être enregistré, le <xref:System.Windows.Forms.SplitContainer> contrôle lui-même doit exposer les panneaux en tant que propriétés publiques.  
  
 Les noms de contrôle doivent être uniques au sein d’un concepteur de contrôles, mais ils ne sont pas nécessairement être unique parmi les enfants d’autres concepteurs de contrôles.  
  
 Pour prendre en charge cette fonctionnalité, l’infrastructure d’hébergement doit exposer la <xref:System.ComponentModel.INestedContainer> classe en tant que service via le site.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="child" /> ou <paramref name="name" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableDragDrop">
      <MemberSignature Language="C#" Value="protected void EnableDragDrop (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EnableDragDrop(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.EnableDragDrop(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EnableDragDrop (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EnableDragDrop(bool value);" />
      <MemberSignature Language="F#" Value="member this.EnableDragDrop : bool -&gt; unit" Usage="controlDesigner.EnableDragDrop value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value"><see langword="true" /> pour activer la prise en charge de la fonctionnalité glisser-déplacer pour le contrôle ; <see langword="false" /> si le contrôle ne doit pas prendre en charge la fonctionnalité glisser-déplacer. La valeur par défaut est <see langword="false" />.</param>
        <summary>Active ou désactive la prise en charge de la fonctionnalité glisser-déplacer pour le contrôle en cours de création.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur par défaut `false` Spécifie qu’un contrôle ne peut pas avoir d’enfants déplacés au moment du design. Pour permettre un contrôle vers le parent des autres contrôles au moment du design, associez-le à un concepteur qui dérive de <xref:System.Windows.Forms.Design.ParentControlDesigner>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableDragRect">
      <MemberSignature Language="C#" Value="protected virtual bool EnableDragRect { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableDragRect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.EnableDragRect" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property EnableDragRect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool EnableDragRect { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EnableDragRect : bool" Usage="System.Windows.Forms.Design.ControlDesigner.EnableDragRect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si des rectangles de déplacement peuvent être dessinés sur ce composant de concepteur.</summary>
        <value><see langword="true" /> Si rectangles de déplacement peuvent être dessinés ; Sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetControlGlyph">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Design.Behavior.ControlBodyGlyph GetControlGlyph (System.Windows.Forms.Design.Behavior.GlyphSelectionType selectionType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.Design.Behavior.ControlBodyGlyph GetControlGlyph(valuetype System.Windows.Forms.Design.Behavior.GlyphSelectionType selectionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.GetControlGlyph(System.Windows.Forms.Design.Behavior.GlyphSelectionType)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetControlGlyph (selectionType As GlyphSelectionType) As ControlBodyGlyph" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::Design::Behavior::ControlBodyGlyph ^ GetControlGlyph(System::Windows::Forms::Design::Behavior::GlyphSelectionType selectionType);" />
      <MemberSignature Language="F#" Value="abstract member GetControlGlyph : System.Windows.Forms.Design.Behavior.GlyphSelectionType -&gt; System.Windows.Forms.Design.Behavior.ControlBodyGlyph&#xA;override this.GetControlGlyph : System.Windows.Forms.Design.Behavior.GlyphSelectionType -&gt; System.Windows.Forms.Design.Behavior.ControlBodyGlyph" Usage="controlDesigner.GetControlGlyph selectionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Design.Behavior.ControlBodyGlyph</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selectionType" Type="System.Windows.Forms.Design.Behavior.GlyphSelectionType" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="selectionType">Valeur <see cref="T:System.Windows.Forms.Design.Behavior.GlyphSelectionType" /> qui spécifie l'état de sélection.</param>
        <summary>Retourne un <see cref="T:System.Windows.Forms.Design.Behavior.ControlBodyGlyph" /> représentant les limites de ce contrôle.</summary>
        <returns><see cref="T:System.Windows.Forms.Design.Behavior.ControlBodyGlyph" /> représentant les limites de ce contrôle.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGlyphs">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Design.Behavior.GlyphCollection GetGlyphs (System.Windows.Forms.Design.Behavior.GlyphSelectionType selectionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.Design.Behavior.GlyphCollection GetGlyphs(valuetype System.Windows.Forms.Design.Behavior.GlyphSelectionType selectionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.GetGlyphs(System.Windows.Forms.Design.Behavior.GlyphSelectionType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGlyphs (selectionType As GlyphSelectionType) As GlyphCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::Design::Behavior::GlyphCollection ^ GetGlyphs(System::Windows::Forms::Design::Behavior::GlyphSelectionType selectionType);" />
      <MemberSignature Language="F#" Value="abstract member GetGlyphs : System.Windows.Forms.Design.Behavior.GlyphSelectionType -&gt; System.Windows.Forms.Design.Behavior.GlyphCollection&#xA;override this.GetGlyphs : System.Windows.Forms.Design.Behavior.GlyphSelectionType -&gt; System.Windows.Forms.Design.Behavior.GlyphCollection" Usage="controlDesigner.GetGlyphs selectionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Design.Behavior.GlyphCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selectionType" Type="System.Windows.Forms.Design.Behavior.GlyphSelectionType" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="selectionType">Valeur <see cref="T:System.Windows.Forms.Design.Behavior.GlyphSelectionType" /> qui spécifie l'état de sélection.</param>
        <summary>Obtient une collection d'objets <see cref="T:System.Windows.Forms.Design.Behavior.Glyph" /> qui représentent les bordures de sélection et les poignées de manipulation d'un contrôle standard.</summary>
        <returns>Collection d'objets <see cref="T:System.Windows.Forms.Design.Behavior.Glyph" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que selon `selectionType`, le <xref:System.Windows.Forms.Design.Behavior.Glyph> objets retournés représentera un de ces États de sélection :  
  
-   Une bordure de sélection complètement redimensionnable avec poignées de manipulation ;  
  
-   Une bordure de sélection verrouillé ;  
  
-   Une seule sélection 'masquée' <xref:System.Windows.Forms.Design.Behavior.Glyph>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHitTest">
      <MemberSignature Language="C#" Value="protected virtual bool GetHitTest (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GetHitTest(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.GetHitTest(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool GetHitTest(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="abstract member GetHitTest : System.Drawing.Point -&gt; bool&#xA;override this.GetHitTest : System.Drawing.Point -&gt; bool" Usage="controlDesigner.GetHitTest point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point"><see cref="T:System.Drawing.Point" /> qui indique l'emplacement où un clic de souris a été effectué, en coordonnées d'écran.</param>
        <summary>Indique si le contrôle doit gérer un clic de souris à un emplacement spécifié.</summary>
        <returns><see langword="true" /> si le contrôle doit gérer un clic à un emplacement spécifié ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Design.ControlDesigner.GetHitTest%2A> méthode détermine si un clic au point spécifié doit être passé au contrôle, tandis que le contrôle est en mode design. Vous pouvez substituer et implémenter cette méthode pour permettre le contrôle de recevoir les clics dans l’environnement au moment du design.  
  
> [!NOTE]
>  Vous pouvez passer un point en coordonnées d’écran à la <xref:System.Windows.Forms.Control.PointToClient%2A> méthode de la <xref:System.Windows.Forms.Control> classe pour obtenir les coordonnées du point par rapport à l’angle supérieur gauche du contrôle.  
  
 Le <xref:System.Windows.Forms.Design.ControlDesigner.GetHitTest%2A> méthode est appelée en réponse au message WM_NCHITTEST, elle est appelée à chaque déplacement de la souris.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HookChildControls">
      <MemberSignature Language="C#" Value="protected void HookChildControls (System.Windows.Forms.Control firstChild);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void HookChildControls(class System.Windows.Forms.Control firstChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.HookChildControls(System.Windows.Forms.Control)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub HookChildControls (firstChild As Control)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void HookChildControls(System::Windows::Forms::Control ^ firstChild);" />
      <MemberSignature Language="F#" Value="member this.HookChildControls : System.Windows.Forms.Control -&gt; unit" Usage="controlDesigner.HookChildControls firstChild" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="firstChild" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="firstChild">Premier <see cref="T:System.Windows.Forms.Control" /> enfant à traiter. Cette méthode peut s'appeler elle-même de manière récursive pour les enfants du contrôle.</param>
        <summary>Achemine les messages à partir des contrôles enfants du contrôle spécifié vers le concepteur.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceAttribute">
      <MemberSignature Language="C#" Value="protected override System.ComponentModel.InheritanceAttribute InheritanceAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.InheritanceAttribute InheritanceAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.InheritanceAttribute" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property InheritanceAttribute As InheritanceAttribute" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::ComponentModel::InheritanceAttribute ^ InheritanceAttribute { System::ComponentModel::InheritanceAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InheritanceAttribute : System.ComponentModel.InheritanceAttribute" Usage="System.Windows.Forms.Design.ControlDesigner.InheritanceAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.InheritanceAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.ComponentModel.InheritanceAttribute" /> du concepteur.</summary>
        <value><see cref="F:System.ComponentModel.InheritanceAttribute.Inherited" /> Si le concepteur est un concepteur racine ; Sinon, la valeur du concepteur parent <see cref="P:System.ComponentModel.Design.ComponentDesigner.InheritanceAttribute" /> propriété.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public override void Initialize (System.ComponentModel.IComponent component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Initialize(class System.ComponentModel.IComponent component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.Initialize(System.ComponentModel.IComponent)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Initialize (component As IComponent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Initialize(System::ComponentModel::IComponent ^ component);" />
      <MemberSignature Language="F#" Value="override this.Initialize : System.ComponentModel.IComponent -&gt; unit" Usage="controlDesigner.Initialize component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
      </Parameters>
      <Docs>
        <param name="component"><see cref="T:System.ComponentModel.IComponent" /> à associer au concepteur. Ce composant doit toujours être une instance de <see cref="T:System.Windows.Forms.Control" />, ou en dériver.</param>
        <summary>Initialise le concepteur avec le composant spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par l’hôte du concepteur pour initialiser le concepteur.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
      </Docs>
    </Member>
    <Member MemberName="InitializeExistingComponent">
      <MemberSignature Language="C#" Value="public override void InitializeExistingComponent (System.Collections.IDictionary defaultValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void InitializeExistingComponent(class System.Collections.IDictionary defaultValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.InitializeExistingComponent(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub InitializeExistingComponent (defaultValues As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void InitializeExistingComponent(System::Collections::IDictionary ^ defaultValues);" />
      <MemberSignature Language="F#" Value="override this.InitializeExistingComponent : System.Collections.IDictionary -&gt; unit" Usage="controlDesigner.InitializeExistingComponent defaultValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValues" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="defaultValues">Dictionnaire nom/valeur de valeurs par défaut à appliquer aux propriétés. Peut être <see langword="null" /> si aucune valeur par défaut n'est spécifiée.</param>
        <summary>Réinitialise un composant existant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Design.ControlDesigner> classe substitue cette méthode pour gérer les cas après déplacement.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.Design.ComponentDesigner.InitializeExistingComponent(System.Collections.IDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="InitializeNewComponent">
      <MemberSignature Language="C#" Value="public override void InitializeNewComponent (System.Collections.IDictionary defaultValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void InitializeNewComponent(class System.Collections.IDictionary defaultValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.InitializeNewComponent(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub InitializeNewComponent (defaultValues As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void InitializeNewComponent(System::Collections::IDictionary ^ defaultValues);" />
      <MemberSignature Language="F#" Value="override this.InitializeNewComponent : System.Collections.IDictionary -&gt; unit" Usage="controlDesigner.InitializeNewComponent defaultValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValues" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="defaultValues">Dictionnaire nom/valeur de valeurs par défaut à appliquer aux propriétés. Peut être <see langword="null" /> si aucune valeur par défaut n'est spécifiée.</param>
        <summary>Initialise un composant qui vient d'être créé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Design.ControlDesigner> classe substitue cette méthode. Il examine la propriété par défaut pour le contrôle et, si elle est de type `string`, elle définit la valeur de cette propriété le nom du composant. Elle ne procède ainsi si le concepteur a été configuré avec cette option dans le service d’options. Cette méthode est également connecte le contrôle à son parent et il positionne. Si vous substituez cette méthode, vous devez toujours appeler base.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.Design.ComponentDesigner.InitializeNewComponent(System.Collections.IDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="InitializeNonDefault">
      <MemberSignature Language="C#" Value="public override void InitializeNonDefault ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void InitializeNonDefault() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.InitializeNonDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub InitializeNonDefault ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void InitializeNonDefault();" />
      <MemberSignature Language="F#" Value="override this.InitializeNonDefault : unit -&gt; unit" Usage="controlDesigner.InitializeNonDefault " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalControlDesigner">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Design.ControlDesigner InternalControlDesigner (int internalControlIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.Design.ControlDesigner InternalControlDesigner(int32 internalControlIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.InternalControlDesigner(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function InternalControlDesigner (internalControlIndex As Integer) As ControlDesigner" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::Design::ControlDesigner ^ InternalControlDesigner(int internalControlIndex);" />
      <MemberSignature Language="F#" Value="abstract member InternalControlDesigner : int -&gt; System.Windows.Forms.Design.ControlDesigner&#xA;override this.InternalControlDesigner : int -&gt; System.Windows.Forms.Design.ControlDesigner" Usage="controlDesigner.InternalControlDesigner internalControlIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Design.ControlDesigner</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="internalControlIndex" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="internalControlIndex">Index spécifié pour sélectionner le Concepteur de contrôles internes. Cet index est en base zéro.</param>
        <summary>Retourne le Concepteur de contrôles internes avec l'index spécifié dans <see cref="T:System.Windows.Forms.Design.ControlDesigner" />.</summary>
        <returns><see cref="T:System.Windows.Forms.Design.ControlDesigner" /> à l'index spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un contrôle interne est un contrôle qui n’est pas le <xref:System.ComponentModel.IContainer.Components%2A> collection de la <xref:System.ComponentModel.Design.IDesignerHost.Container%2A>. <xref:System.Windows.Forms.SplitterPanel> est un exemple d’un tel contrôle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidPoint">
      <MemberSignature Language="C#" Value="protected static readonly System.Drawing.Point InvalidPoint;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly valuetype System.Drawing.Point InvalidPoint" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.Design.ControlDesigner.InvalidPoint" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidPoint As Point " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly System::Drawing::Point InvalidPoint;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPoint : System.Drawing.Point" Usage="System.Windows.Forms.Design.ControlDesigner.InvalidPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Définit un objet <see cref="T:System.Drawing.Point" /> local qui représente les valeurs d'un objet <see cref="T:System.Drawing.Point" /> non valide.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Design.ControlDesigner.InvalidPoint> a un <xref:System.Drawing.Point.X%2A> et <xref:System.Drawing.Point.Y%2A> propriété définie sur la valeur minimale pour le type de données entier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NumberOfInternalControlDesigners">
      <MemberSignature Language="C#" Value="public virtual int NumberOfInternalControlDesigners ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 NumberOfInternalControlDesigners() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.NumberOfInternalControlDesigners" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NumberOfInternalControlDesigners () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int NumberOfInternalControlDesigners();" />
      <MemberSignature Language="F#" Value="abstract member NumberOfInternalControlDesigners : unit -&gt; int&#xA;override this.NumberOfInternalControlDesigners : unit -&gt; int" Usage="controlDesigner.NumberOfInternalControlDesigners " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le nombre de Concepteurs de contrôles internes dans <see cref="T:System.Windows.Forms.Design.ControlDesigner" />.</summary>
        <returns>Nombre de Concepteurs de contrôles internes dans <see cref="T:System.Windows.Forms.Design.ControlDesigner" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un contrôle interne est un contrôle qui n’est pas le <xref:System.ComponentModel.IContainer.Components%2A> collection de la <xref:System.ComponentModel.Design.IDesignerHost.Container%2A>. <xref:System.Windows.Forms.SplitterPanel> est un exemple d’un tel contrôle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenu">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenu (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenu(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnContextMenu(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenu (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenu(int x, int y);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenu : int * int -&gt; unit&#xA;override this.OnContextMenu : int * int -&gt; unit" Usage="controlDesigner.OnContextMenu (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Coordonnée x à laquelle le menu contextuel doit être affiché.</param>
        <param name="y">Coordonnée y à laquelle le menu contextuel doit être affiché.</param>
        <summary>Affiche le menu contextuel et fournit une possibilité de traitement supplémentaire lorsque le menu contextuel est sur le point d'être affiché.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateHandle">
      <MemberSignature Language="C#" Value="protected virtual void OnCreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnCreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCreateHandle();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateHandle : unit -&gt; unit&#xA;override this.OnCreateHandle : unit -&gt; unit" Usage="controlDesigner.OnCreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fournit une possibilité de traitement supplémentaire immédiatement après la création du handle du contrôle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnDragComplete (System.Windows.Forms.DragEventArgs de);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragComplete(class System.Windows.Forms.DragEventArgs de) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnDragComplete(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragComplete (de As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragComplete(System::Windows::Forms::DragEventArgs ^ de);" />
      <MemberSignature Language="F#" Value="abstract member OnDragComplete : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragComplete : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="controlDesigner.OnDragComplete de" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="de" Type="System.Windows.Forms.DragEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="de"><see cref="T:System.Windows.Forms.DragEventArgs" /> qui fournit des données pour l'événement.</param>
        <summary>Reçoit un appel pour nettoyer une opération glisser-déplacer.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDragDrop (System.Windows.Forms.DragEventArgs de);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragDrop(class System.Windows.Forms.DragEventArgs de) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragDrop (de As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragDrop(System::Windows::Forms::DragEventArgs ^ de);" />
      <MemberSignature Language="F#" Value="abstract member OnDragDrop : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragDrop : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="controlDesigner.OnDragDrop de" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="de" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="de"><see cref="T:System.Windows.Forms.DragEventArgs" /> qui fournit des données pour l'événement.</param>
        <summary>Reçoit un appel lorsqu'un objet glissé est déplacé sur la vue de Concepteur de contrôles.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.Forms.DragEventArgs de);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.Forms.DragEventArgs de) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragEnter (de As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragEnter(System::Windows::Forms::DragEventArgs ^ de);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="controlDesigner.OnDragEnter de" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="de" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="de"><see cref="T:System.Windows.Forms.DragEventArgs" /> qui fournit des données pour l'événement.</param>
        <summary>Reçoit un appel lorsqu'une opération glisser-déplacer entre dans la vue de Concepteur de contrôles.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : EventArgs -&gt; unit&#xA;override this.OnDragLeave : EventArgs -&gt; unit" Usage="controlDesigner.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui fournit des données pour l'événement.</param>
        <summary>Reçoit un appel lorsqu'une opération glisser-déplacer quitte la vue de Concepteur de contrôles.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.Forms.DragEventArgs de);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.Forms.DragEventArgs de) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragOver (de As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragOver(System::Windows::Forms::DragEventArgs ^ de);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="controlDesigner.OnDragOver de" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="de" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="de"><see cref="T:System.Windows.Forms.DragEventArgs" /> qui fournit des données pour l'événement.</param>
        <summary>Reçoit un appel lorsqu'un objet glissé est déplacé au-dessus de la vue de Concepteur de contrôles.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.Forms.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.Forms.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGiveFeedback(System::Windows::Forms::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.Forms.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.Forms.GiveFeedbackEventArgs -&gt; unit" Usage="controlDesigner.OnGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Forms.GiveFeedbackEventArgs" /> qui fournit des données pour l'événement.</param>
        <summary>Reçoit un appel durant une opération glisser-déplacer pour fournir des indications visuelles en fonction de la position du curseur de la souris tandis que l'opération glisser est en cours.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’hôte du concepteur appelle cette méthode lorsqu’un événement de glissement OLE se produit.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDragBegin">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDragBegin (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDragBegin(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnMouseDragBegin(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDragBegin (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDragBegin(int x, int y);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDragBegin : int * int -&gt; unit&#xA;override this.OnMouseDragBegin : int * int -&gt; unit" Usage="controlDesigner.OnMouseDragBegin (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Coordonnée x, en coordonnées d'écran, du pointeur de la souris.</param>
        <param name="y">Coordonnée y, en coordonnées d'écran, du pointeur de la souris.</param>
        <summary>Reçoit un appel lorsque le bouton gauche de la souris est maintenu enfoncé au-dessus du composant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée au début d’une opération de glisser-déplacer.  
  
> [!NOTE]
>  Vous pouvez passer un point en coordonnées d’écran à la <xref:System.Windows.Forms.Control.PointToClient%2A> méthode de la <xref:System.Windows.Forms.Control> classe pour obtenir les coordonnées du point par rapport à l’angle supérieur gauche du contrôle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDragEnd">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDragEnd (bool cancel);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDragEnd(bool cancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnMouseDragEnd(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDragEnd (cancel As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDragEnd(bool cancel);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDragEnd : bool -&gt; unit&#xA;override this.OnMouseDragEnd : bool -&gt; unit" Usage="controlDesigner.OnMouseDragEnd cancel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancel" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="cancel"><see langword="true" /> pour annuler l’opération glisser ; <see langword="false" /> pour la valider.</param>
        <summary>Reçoit un appel à la fin d'une opération glisser-déplacer pour terminer ou annuler l'opération.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDragMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDragMove (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDragMove(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnMouseDragMove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDragMove (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDragMove(int x, int y);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDragMove : int * int -&gt; unit&#xA;override this.OnMouseDragMove : int * int -&gt; unit" Usage="controlDesigner.OnMouseDragMove (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Coordonnée x, en coordonnées d'écran, du pointeur de la souris.</param>
        <param name="y">Coordonnée y, en coordonnées d'écran, du pointeur de la souris.</param>
        <summary>Reçoit un appel pour chaque mouvement de la souris pendant une opération glisser-déplacer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Vous pouvez passer un point en coordonnées d’écran à la <xref:System.Windows.Forms.Control.PointToClient%2A> méthode de la <xref:System.Windows.Forms.Control> classe pour obtenir les coordonnées du point par rapport à l’angle supérieur gauche du contrôle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnMouseEnter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseEnter ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseEnter();" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : unit -&gt; unit&#xA;override this.OnMouseEnter : unit -&gt; unit" Usage="controlDesigner.OnMouseEnter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reçoit un appel lorsque la souris entre initialement dans le contrôle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseHover">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseHover ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseHover() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnMouseHover" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseHover ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseHover();" />
      <MemberSignature Language="F#" Value="abstract member OnMouseHover : unit -&gt; unit&#xA;override this.OnMouseHover : unit -&gt; unit" Usage="controlDesigner.OnMouseHover " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reçoit un appel après que la souris pointe sur le contrôle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnMouseLeave" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeave ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeave();" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : unit -&gt; unit&#xA;override this.OnMouseLeave : unit -&gt; unit" Usage="controlDesigner.OnMouseLeave " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reçoit un appel lorsque la souris entre initialement dans le contrôle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPaintAdornments">
      <MemberSignature Language="C#" Value="protected virtual void OnPaintAdornments (System.Windows.Forms.PaintEventArgs pe);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaintAdornments(class System.Windows.Forms.PaintEventArgs pe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnPaintAdornments(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaintAdornments (pe As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaintAdornments(System::Windows::Forms::PaintEventArgs ^ pe);" />
      <MemberSignature Language="F#" Value="abstract member OnPaintAdornments : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPaintAdornments : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="controlDesigner.OnPaintAdornments pe" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pe" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="pe"><see cref="T:System.Windows.Forms.PaintEventArgs" /> que le concepteur peut utiliser pour dessiner sur le contrôle.</param>
        <summary>Reçoit un appel lorsque le contrôle que le concepteur manage a peint sa surface de sorte que le concepteur puisse peindre d'autres motifs par-dessus le contrôle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSetComponentDefaults">
      <MemberSignature Language="C#" Value="public override void OnSetComponentDefaults ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnSetComponentDefaults() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnSetComponentDefaults" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub OnSetComponentDefaults ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnSetComponentDefaults();" />
      <MemberSignature Language="F#" Value="override this.OnSetComponentDefaults : unit -&gt; unit" Usage="controlDesigner.OnSetComponentDefaults " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Use InitializeNewComponent instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appelée quand le concepteur est initialisé.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSetCursor">
      <MemberSignature Language="C#" Value="protected virtual void OnSetCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnSetCursor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetCursor ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetCursor();" />
      <MemberSignature Language="F#" Value="abstract member OnSetCursor : unit -&gt; unit&#xA;override this.OnSetCursor : unit -&gt; unit" Usage="controlDesigner.OnSetCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reçoit un appel chaque fois que le curseur doit être défini.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode gère la redirection et la gestion de l’événement de curseur de jeu. Si le service de boîte à outils a un outil sélectionné, cette méthode autorisera le service de boîte à outils afin de définir le curseur. Si la sélection du service de l’interface utilisateur de sélection est verrouillée, ou s’il n’existe aucune propriété d’emplacement sur le contrôle, le curseur en flèche par défaut est défini. Si un utilisateur fait glisser un composant, définira le curseur en croix. Sinon, un curseur flèche à quatre pointes est activé pour indiquer que le composant peut être cliqué et déplacé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentComponent">
      <MemberSignature Language="C#" Value="protected override System.ComponentModel.IComponent ParentComponent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.IComponent ParentComponent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.ParentComponent" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property ParentComponent As IComponent" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::ComponentModel::IComponent ^ ParentComponent { System::ComponentModel::IComponent ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentComponent : System.ComponentModel.IComponent" Usage="System.Windows.Forms.Design.ControlDesigner.ParentComponent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComponent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le composant parent de <see cref="T:System.Windows.Forms.Design.ControlDesigner" />.</summary>
        <value>Composant parent de <see cref="T:System.Windows.Forms.Design.ControlDesigner" /> ; sinon, <see langword="null" /> s'il n'y a aucun composant parent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut vérifie simplement si le composant en cours de conception est un contrôle et si c’est le cas, <xref:System.Windows.Forms.Design.ControlDesigner.ParentComponent%2A> retourne son parent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParticipatesWithSnapLines">
      <MemberSignature Language="C#" Value="public virtual bool ParticipatesWithSnapLines { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ParticipatesWithSnapLines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.ParticipatesWithSnapLines" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ParticipatesWithSnapLines As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ParticipatesWithSnapLines { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ParticipatesWithSnapLines : bool" Usage="System.Windows.Forms.Design.ControlDesigner.ParticipatesWithSnapLines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Windows.Forms.Design.ControlDesigner" /> doit autoriser l'alignement sur les lignes d'alignement (SnapLines) pendant une opération glisser.</summary>
        <value><see langword="true" /> Si le <see cref="T:System.Windows.Forms.Design.ControlDesigner" /> permettra d’alignement (SnapLines) pendant une opération glisser lorsque le contrôle de glissement principal se trouve sur ce concepteur ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>L'implémentation par défaut retourne toujours <see langword="true" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="PreFilterProperties">
      <MemberSignature Language="C#" Value="protected override void PreFilterProperties (System.Collections.IDictionary properties);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void PreFilterProperties(class System.Collections.IDictionary properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.PreFilterProperties(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub PreFilterProperties (properties As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void PreFilterProperties(System::Collections::IDictionary ^ properties);" />
      <MemberSignature Language="F#" Value="override this.PreFilterProperties : System.Collections.IDictionary -&gt; unit" Usage="controlDesigner.PreFilterProperties properties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="properties"><see cref="T:System.Collections.IDictionary" /> contenant les propriétés de la classe de composant.</param>
        <summary>Ajuste le jeu de propriétés exposées par le composant à l'aide de <see cref="T:System.ComponentModel.TypeDescriptor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cela <xref:System.ComponentModel.Design.IDesignerFilter> substitution de méthode d’interface ajoute un ensemble de propriétés pour le composant de ce concepteur au moment du design. Cette méthode ajoute les propriétés navigables suivantes : `Visible`, `Enabled`, `ContextMenu`, `AllowDrop`, `Location`, `Name`, `Controls`, et `Locked`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.IDesignerFilter" />
      </Docs>
    </Member>
    <Member MemberName="SelectionRules">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Design.SelectionRules SelectionRules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Design.SelectionRules SelectionRules" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.SelectionRules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SelectionRules As SelectionRules" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Design::SelectionRules SelectionRules { System::Windows::Forms::Design::SelectionRules get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectionRules : System.Windows.Forms.Design.SelectionRules" Usage="System.Windows.Forms.Design.ControlDesigner.SelectionRules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Design.SelectionRules</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les règles de sélection qui indiquent les possibilités de mouvement d'un composant.</summary>
        <value>Combinaison de bits de valeurs <see cref="T:System.Windows.Forms.Design.SelectionRules" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucun concepteur ne fournit des règles pour un composant, le composant n’obtiendra pas les services de l’interface utilisateur.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Design.SelectionRules" />
      </Docs>
    </Member>
    <Member MemberName="SnapLines">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList SnapLines { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList SnapLines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.SnapLines" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SnapLines As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IList ^ SnapLines { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SnapLines : System.Collections.IList" Usage="System.Windows.Forms.Design.ControlDesigner.SnapLines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une liste d'objets <see cref="T:System.Windows.Forms.Design.Behavior.SnapLine" /> qui représentent des points d'alignement significatifs pour ce contrôle.</summary>
        <value>Liste d'objets <see cref="T:System.Windows.Forms.Design.Behavior.SnapLine" /> qui représentent des points d'alignement significatifs pour ce contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le proposé <xref:System.Windows.Forms.Design.Behavior.SnapLine> objets pour aider à positionner le contrôle sur une aire de conception.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnhookChildControls">
      <MemberSignature Language="C#" Value="protected void UnhookChildControls (System.Windows.Forms.Control firstChild);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UnhookChildControls(class System.Windows.Forms.Control firstChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.UnhookChildControls(System.Windows.Forms.Control)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UnhookChildControls (firstChild As Control)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UnhookChildControls(System::Windows::Forms::Control ^ firstChild);" />
      <MemberSignature Language="F#" Value="member this.UnhookChildControls : System.Windows.Forms.Control -&gt; unit" Usage="controlDesigner.UnhookChildControls firstChild" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="firstChild" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="firstChild">Premier <see cref="T:System.Windows.Forms.Control" /> enfant à traiter. Cette méthode peut s'appeler elle-même de manière récursive pour les enfants du contrôle.</param>
        <summary>Achemine les messages pour les enfants du contrôle spécifié vers chaque contrôle plutôt que vers un concepteur parent.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected virtual void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member WndProc :  -&gt; unit&#xA;override this.WndProc :  -&gt; unit" Usage="controlDesigner.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m"><see cref="T:System.Windows.Forms.Message" /> à traiter.</param>
        <summary>Traite les messages Windows et les achemine éventuellement vers le contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée pour chaque message que habituellement reçu le contrôle. Cela permet au concepteur Prétraiter les messages avant de les acheminer éventuellement vers le contrôle.  
  
 Pour envoyer le message du contrôle <xref:System.Windows.Forms.Control.WndProc%2A?displayProperty=nameWithType> méthode, appelez <xref:System.Windows.Forms.Design.ControlDesigner.WndProc%2A> sur le concepteur du contrôle.  
  
> [!NOTE]
>  Le Concepteur de filtre les messages, certains messages ne seront pas envoyés au contrôle. Par exemple, les messages de la souris sont interceptés par le concepteur. Si ce n’est pas le comportement que vous souhaitez, appelez <xref:System.Windows.Forms.Design.ControlDesigner.DefWndProc%2A> à la place.  
  
 Passer `m` en tant que paramètre. Si vous le souhaitez, vous pouvez modifier ou créer un nouveau <xref:System.Windows.Forms.Message?displayProperty=nameWithType> à passer à la méthode du contrôle.  
  
 Le tableau suivant illustre le flux de messages.  
  
|Sans un concepteur|Avec un concepteur|  
|------------------------|---------------------|  
|USER32<br /><br /> <xref:System.Windows.Forms.Control.WndProc%2A?displayProperty=nameWithType><br /><br /> <xref:System.Windows.Forms.Control.DefWndProc%2A?displayProperty=nameWithType><br /><br /> USER32|USER32<br /><br /> `Control.Designer.` <xref:System.Windows.Forms.Design.ControlDesigner.WndProc%2A><br /><br /> <xref:System.Windows.Forms.Design.ControlDesigner.DefWndProc%2A><br /><br /> <xref:System.Windows.Forms.Control.WndProc%2A?displayProperty=nameWithType><br /><br /> <xref:System.Windows.Forms.Control.DefWndProc%2A?displayProperty=nameWithType><br /><br /> USER32|  
  
 Le concepteur intercepte des messages en remplaçant le <xref:System.Windows.Forms.Control.WindowTarget%2A?displayProperty=nameWithType> propriété sur le contrôle. En règle générale, <xref:System.Windows.Forms.Control.WindowTarget%2A> pointe vers le <xref:System.Windows.Forms.NativeWindow> contenus dans le contrôle. Au moment du design, le concepteur remplace ce nom par sa propre cible de fenêtre et met en cache la valeur d’origine.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Design.ControlDesigner.DefWndProc(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>