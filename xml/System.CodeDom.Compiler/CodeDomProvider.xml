<Type Name="CodeDomProvider" FullName="System.CodeDom.Compiler.CodeDomProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="10d65c2c6acb521c573e2db518ec80d92ba50400" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65002895" /></Metadata><TypeSignature Language="C#" Value="public abstract class CodeDomProvider : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeDomProvider extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.Compiler.CodeDomProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeDomProvider&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeDomProvider abstract : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type CodeDomProvider = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit une classe de base pour <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implémentations. Cette classe est abstraite.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.CodeDom.Compiler.CodeDomProvider> peut être utilisé pour créer et récupérer des instances de générateurs de code et des compilateurs de code. Générateurs de code peuvent être utilisées pour générer le code dans un langage particulier, et les compilateurs de code peuvent être utilisés pour compiler le code dans des assemblys.  
  
> [!NOTE]
>  Dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], les méthodes mises à disposition dans le Générateur de code et du compilateur de code sont directement disponibles dans le fournisseur de code. Vous n’avez pas besoin d’appeler <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> ou <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> pour accéder aux méthodes et ces méthodes sont marquées comme obsolètes. Cela s’applique aux préexistant, ainsi que de nouvelles implémentations de fournisseur de code.  
  
 Un <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation fournit généralement code des interfaces de compilation de code et/ou la génération pour la génération de code et la gestion de compilation pour un seul langage de programmation. Plusieurs langages sont pris en charge par <xref:System.CodeDom.Compiler.CodeDomProvider> implémentations fournies avec le [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)]. Ces langages incluent c#, Visual Basic, C++ et JScript. Les développeurs ou les éditeurs de compilateurs peuvent implémenter la <xref:System.CodeDom.Compiler.ICodeGenerator> et <xref:System.CodeDom.Compiler.ICodeCompiler> interfaces et de fournir un <xref:System.CodeDom.Compiler.CodeDomProvider> qui étend la prise en charge de CodeDOM à d’autres langages de programmation.  
  
 Le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans la configuration d’ordinateur (Machine.config) de fichier fournit un mécanisme pour les développeurs et éditeurs de compilateurs ajouter des paramètres de configuration supplémentaires <xref:System.CodeDom.Compiler.CodeDomProvider>implémentations.  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider> classe fournit des méthodes statiques pour découvrir et énumérer les <xref:System.CodeDom.Compiler.CodeDomProvider> implémentations sur un ordinateur. Le <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> méthode retourne les paramètres pour tous les <xref:System.CodeDom.Compiler.CodeDomProvider> implémentations sur un ordinateur. Le <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> méthode retourne les paramètres pour un spécifique <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation, en fonction du nom de langage de programmation. Le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> méthode retourne une instance d’un <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une langue spécifique.  
  
 Pour plus d’informations sur les paramètres de fournisseur de langages dans le fichier de configuration, consultez [compilateur et le schéma de paramètres de fournisseur de langage](~/docs/framework/configure-apps/file-schema/compiler/index.md).  
  
> [!NOTE]
>  Cette classe effectue une demande de liaison et une demande d’héritage au niveau de la classe. Un <xref:System.Security.SecurityException> est levée si l’appelant immédiat ou la classe dérivée n’a pas d’autorisation de confiance totale. Pour plus d’informations sur les demandes de sécurité, consultez [demandes de liaison](~/docs/framework/misc/link-demands.md) et [demandes d’héritage](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/x4yx82e6(v=vs.100)).  
  
   
  
## Examples  
 L’exemple de programme suivant peut générer et compiler le code source basé sur un modèle CodeDOM d’un programme qui imprime « Hello World » à l’aide de la <xref:System.Console> classe. Une interface utilisateur Windows Forms est fournie. L’utilisateur peut sélectionner la cible de langage à partir de plusieurs sélections de programmation : C#, Visual Basic et JScript.  
  
 [!code-cpp[CodeDomExample#1](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#1)]
 [!code-csharp[CodeDomExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#1)]
 [!code-vb[CodeDomExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Cette classe ne peut pas être utilisée par du code partiellement fiable.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">pour la confiance totale pour les héritiers. Cette classe ne peut pas être héritée par du code partiellement fiable.</permission>
    <block subset="none" type="overrides"><para>Dans les versions 1.0 et 1.1 du .NET Framework, les fournisseurs de code se composent d’implémentations de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />, <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, <see cref="T:System.CodeDom.Compiler.ICodeParser" />, et <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />. Dans le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], le <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />, <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />, et <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> sont obsolètes et les méthodes de <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> et <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> sont directement disponibles dans la <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> classe. Vous devez substituer ces méthodes dans votre implémentation de fournisseur de code et n’appelez pas les méthodes de base.</para></block>
    <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
    <altmember cref="T:Microsoft.CSharp.CSharpCodeProvider" />
    <altmember cref="T:Microsoft.VisualBasic.VBCodeProvider" />
    <altmember cref="T:Microsoft.JScript.JScriptCodeProvider" />
    <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schéma des paramètres du fournisseur de langage et du compilateur</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeDomProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeDomProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Cette classe ne peut pas être utilisée par du code partiellement fiable.</permission>
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromDom">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom (System.CodeDom.Compiler.CompilerParameters options, params System.CodeDom.CodeCompileUnit[] compilationUnits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom(class System.CodeDom.Compiler.CompilerParameters options, class System.CodeDom.CodeCompileUnit[] compilationUnits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromDom(System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromDom (options As CompilerParameters, ParamArray compilationUnits As CodeCompileUnit()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromDom(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::CodeDom::CodeCompileUnit ^&gt; ^ compilationUnits);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromDom (options, compilationUnits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="compilationUnits" Type="System.CodeDom.CodeCompileUnit[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Un <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> objet qui indique les paramètres pour la compilation.</param>
        <param name="compilationUnits">Tableau de type <see cref="T:System.CodeDom.CodeCompileUnit" /> qui indique le code à compiler.</param>
        <summary>Compile un assembly basé sur le <see cref="N:System.CodeDom" /> arborescences contenues dans le tableau spécifié de <see cref="T:System.CodeDom.CodeCompileUnit" /> objets, à l’aide des paramètres du compilateur spécifiés.</summary>
        <returns>Un <see cref="T:System.CodeDom.Compiler.CompilerResults" /> objet qui indique les résultats de la compilation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> méthode est substituée dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des compilateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas d’un compilateur de code.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromFile">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile (System.CodeDom.Compiler.CompilerParameters options, params string[] fileNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile(class System.CodeDom.Compiler.CompilerParameters options, string[] fileNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromFile(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromFile (options As CompilerParameters, ParamArray fileNames As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromFile(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ fileNames);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromFile (options, fileNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="fileNames" Type="System.String[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Un <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> objet qui indique les paramètres pour la compilation.</param>
        <param name="fileNames">Tableau des noms de fichiers à compiler.</param>
        <summary>Compile un assembly à partir du code source contenu dans les fichiers spécifiés, à l’aide des paramètres du compilateur spécifiés.</summary>
        <returns>Un <see cref="T:System.CodeDom.Compiler.CompilerResults" /> objet qui indique les résultats de la compilation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> méthode est substituée dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des compilateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas d’un compilateur de code.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromSource">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource (System.CodeDom.Compiler.CompilerParameters options, params string[] sources);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource(class System.CodeDom.Compiler.CompilerParameters options, string[] sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromSource(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromSource (options As CompilerParameters, ParamArray sources As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromSource(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ sources);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromSource (options, sources)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="sources" Type="System.String[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Un <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> objet qui indique les paramètres du compilateur pour cette compilation.</param>
        <param name="sources">Tableau de chaînes de code source à compiler.</param>
        <summary>Compile un assembly à partir du tableau spécifié de chaînes contenant du code source, à l’aide des paramètres du compilateur spécifiés.</summary>
        <returns>Un <see cref="T:System.CodeDom.Compiler.CompilerResults" /> objet qui indique les résultats de la compilation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> méthode est substituée dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des compilateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas d’un compilateur de code.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CreateCompiler">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeCompiler CreateCompiler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeCompiler CreateCompiler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCompiler () As ICodeCompiler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeCompiler ^ CreateCompiler();" />
      <MemberSignature Language="F#" Value="abstract member CreateCompiler : unit -&gt; System.CodeDom.Compiler.ICodeCompiler" Usage="codeDomProvider.CreateCompiler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeCompiler is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("Callers should not use the ICodeCompiler interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeCompiler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau compilateur de code.</summary>
        <returns>Un <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> qui peut être utilisé pour la compilation de <see cref="N:System.CodeDom" /> en fonction des représentations du code source.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est obsolète dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]. L’alternative recommandée consiste à appeler le <xref:System.CodeDom.Compiler.ICodeCompiler> les méthodes qui sont directement disponibles dans le fournisseur de code.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Dans le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], vous devez implémenter le <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> membres dans le <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> classe et lever une <see cref="T:System.NotSupportedException" /> lorsque cette méthode est appelée.</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateEscapedIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateEscapedIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateEscapedIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEscapedIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateEscapedIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateEscapedIdentifier : string -&gt; string&#xA;override this.CreateEscapedIdentifier : string -&gt; string" Usage="codeDomProvider.CreateEscapedIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">La chaîne pour laquelle un identificateur avec séquence d’échappement doit être créé.</param>
        <summary>Crée un identificateur avec séquence d’échappement pour la valeur spécifiée.</summary>
        <returns>L’identificateur avec séquence d’échappement pour la valeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A> tests si l’identificateur est en conflit avec n’importe quel réservés ou des mots clés du langage et si tel est le cas, retourne un nom équivalent avec la mise en forme du code d’échappement spécifique au langage. Cette opération est appelée un identificateur avec séquence d’échappement. L’identificateur avec séquence d’échappement contient la même `value` mais est mise en forme du code d’échappement ajoutée afin de différencier l’identificateur du mot clé. Deux exemples d’implémentation précèdent le `value` avec « @ » ou mettent entre crochets le `value` avec » [ » et «] ».  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode est substituée dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateGenerator">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau générateur de code.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeGenerator CreateGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateGenerator () As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator();" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : unit -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeGenerator is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("Callers should not use the ICodeGenerator interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau générateur de code.</summary>
        <returns>Un <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> qui peut être utilisé pour générer <see cref="N:System.CodeDom" /> en fonction des représentations du code source.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est obsolète dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]. L’alternative recommandée consiste à appeler le <xref:System.CodeDom.Compiler.ICodeGenerator> les méthodes qui sont directement disponibles dans la <xref:System.CodeDom.Compiler.CodeDomProvider> classe.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Dans le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], vous devez implémenter le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> membres dans le <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> classe et lever une <see cref="T:System.NotSupportedException" /> lorsque cette méthode est appelée.</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (output As TextWriter) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator output" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="output">Un <see cref="T:System.IO.TextWriter" /> à utiliser pour la sortie.</param>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau générateur de code à l’aide de la <see cref="T:System.IO.TextWriter" /> pour la sortie.</summary>
        <returns>Un <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> qui peut être utilisé pour générer <see cref="N:System.CodeDom" /> en fonction des représentations du code source.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise spécifié <xref:System.IO.TextWriter> pour la sortie. Cette méthode prend en charge la génération de code optimisé plus que de façon incrémentielle met à jour le code source.  
  
> [!NOTE]
>  L’implémentation de classe de base appelle la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> (méthode), qui est obsolète dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] et entraîne un <xref:System.NotSupportedException> si un <xref:System.CodeDom.Compiler.ICodeGenerator> objet n’est pas retourné.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.TextWriter" />
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (fileName As String) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom de fichier à la sortie.</param>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau générateur de code en utilisant le nom de fichier spécifié pour la sortie.</summary>
        <returns>Un <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> qui peut être utilisé pour générer <see cref="N:System.CodeDom" /> en fonction des représentations du code source.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise le nom de fichier spécifié pour la sortie.  
  
> [!NOTE]
>  L’implémentation de classe de base appelle la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> (méthode), qui est obsolète dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] et entraîne un <xref:System.NotSupportedException> si un <xref:System.CodeDom.Compiler.ICodeGenerator> objet n’est pas retourné.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParser">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeParser CreateParser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeParser CreateParser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateParser () As ICodeParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeParser ^ CreateParser();" />
      <MemberSignature Language="F#" Value="abstract member CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser&#xA;override this.CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser" Usage="codeDomProvider.CreateParser " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeParser is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("Callers should not use the ICodeParser interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeParser</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée un nouvel analyseur de code.</summary>
        <returns>Un <see cref="T:System.CodeDom.Compiler.ICodeParser" /> qui peut être utilisé pour analyser le code source. Retourne l’implémentation de base toujours <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProvider">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient un <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> instance pour la langue spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Le nom du langage.</param>
        <summary>Obtient un <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> instance pour la langue spécifiée.</summary>
        <returns>Fournisseur CodeDOM qui est implémenté pour le nom de la langue spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode est couramment utilisée pour créer une instance d’un fournisseur de code dans une application qui peut utiliser un des fournisseurs. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> vous permet de spécifier au moment de l’exécution le fournisseur de code que vous souhaitez instancier. Si vous connaissez au moment du design quel code fournisseur doit être utilisé, vous devez créer une instance de ce fournisseur de code au lieu d’utiliser le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> (méthode).  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> méthode retourne un <xref:System.CodeDom.Compiler.CodeDomProvider> de l’instance pour un nom de langage spécifique ; elle est similaire à l’appel le <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> méthode avec le type de fournisseur de langage. Utilisez <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> lorsque vous souhaitez rechercher dynamiquement une implémentation de fournisseur configuré pour un nom de langage.  
  
 Si plus d’une implémentation de fournisseur est configurée pour le nom du langage, <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> retourne une instance de fournisseur pour le dernier élément de configuration correspondant.  
  
 Utilisez le <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> surcharge de méthode lorsque vous souhaitez une implémentation de fournisseur de langage spécifique. Par exemple, utiliser le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> méthode pour obtenir une instance de fournisseur qui prend en charge le nom du langage `"CSharp"`; utiliser le <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> surcharge de méthode pour obtenir une instance de fournisseur spécifiquement pour le <xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType> implémentation. Vous devez utiliser le [\], CultureInfo, objet\<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D% 2CSystem.Globalization.CultureInfo%2CSystem.Object%5B%5D%29?displayProperty=nameWithType > méthode si vous disposez de plusieurs fournisseurs de code pour un langage et que vous souhaitez instancier un fournisseur de code spécifique.  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> méthode vérifie si au moins une implémentation de fournisseur prend en charge une langue spécifique. Vous pouvez valider un nom de langue à l’aide <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> avant leur transmission à <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>. Si vous passez un nom de langage non pris en charge à <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> un <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> est levée.  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> méthode peut être utilisée pour déterminer toutes <xref:System.CodeDom.Compiler.CodeDomProvider> implémentations sur un ordinateur, y compris les implémentations supplémentaires fournies par les développeurs et éditeurs de compilateurs qui sont identifiés dans le [ &lt;system.codedom &gt; Élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans le fichier de configuration machine (Machine.config).  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> méthode retourne une instance d’un <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une langue spécifique.  
  
 Les noms de langage respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant détermine le <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une langue d’entrée et affiche les paramètres configurés pour le fournisseur de langages. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Le <paramref name="language" /> n’a pas de fournisseur configuré sur cet ordinateur.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="language" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language, System.Collections.Generic.IDictionary&lt;string,string&gt; providerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; providerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String, providerOptions As IDictionary(Of String, String)) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ providerOptions);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string * System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider (language, providerOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="providerOptions" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Le nom du langage.</param>
        <param name="providerOptions">Une collection d’options de fournisseur à partir du fichier de configuration.</param>
        <summary>Obtient un <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> instance pour les options de langue et de fournisseur spécifiées.</summary>
        <returns>Fournisseur CodeDOM qui est implémenté pour le nom de la langue spécifiée et les options.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode est couramment utilisée pour créer une instance d’un fournisseur de code dans une application qui peut utiliser un des fournisseurs. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> vous permet de spécifier au moment de l’exécution la version du fournisseur de code que vous souhaitez instancier. Si vous connaissez au moment du design quel code fournisseur doit être utilisé, vous devez créer une instance de ce fournisseur de code au lieu d’utiliser le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> (méthode).  
  
 Utilisez <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> lorsque vous souhaitez rechercher dynamiquement une implémentation de fournisseur configuré pour une langue spécifique et les options. Les noms de langage respectent la casse. Pour plus d’informations sur les options de fournisseur pris en charge, consultez la documentation du fournisseur CodeDOM spécifique.  
  
 Pour plus d’informations sur la validation d’un fournisseur et l’appel d’un fournisseur si plusieurs implémentations de fournisseur sont configurée pour le nom du langage, consultez la section Notes de la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29> (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une instance d’un fournisseur à l’aide de le `providerOptions` paramètre.  
  
 [!code-csharp[CodeDomProvider.ProviderOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/codedomprovider.provideroptions/cs/program.cs#1)]
 [!code-vb[CodeDomProvider.ProviderOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/codedomprovider.provideroptions/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateValidIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateValidIdentifier : string -&gt; string&#xA;override this.CreateValidIdentifier : string -&gt; string" Usage="codeDomProvider.CreateValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">La chaîne pour lequel générer un identificateur valide.</param>
        <summary>Crée un identificateur valide pour la valeur spécifiée.</summary>
        <returns>Un identificateur valide pour la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A> Teste si l’identificateur est en conflit avec réservés ou des mots clés du langage, et le cas échéant, tente de retourner un identificateur valide nom qui ne sont pas en conflit. Généralement l’identificateur retourné est que légèrement modifié pour différencier l’identificateur du mot clé ; par exemple, le nom peut être précédé par le caractère de soulignement (« _ »).  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode est substituée dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FileExtension">
      <MemberSignature Language="C#" Value="public virtual string FileExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileExtension" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FileExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FileExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FileExtension : string" Usage="System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l’extension de nom de fichier par défaut à utiliser pour les fichiers de code source dans le langage actuel.</summary>
        <value>Une extension de nom de fichier correspondant à l’extension des fichiers sources du langage actuel. Retourne l’implémentation de base toujours <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est utilisée par les générateurs de code et des compilateurs de code pour indiquer les extensions de fichier doivent être générées ou a utilisée.  
  
   
  
## Examples  
 L’exemple de code suivant crée une instance de <xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>. L’exemple affiche le nom du fournisseur, le hachage par défaut et le code d’extension de fichier pour la nouvelle instance de fournisseur.  
  
 [!code-cpp[CodeDom_CompilerInfo#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#3)]
 [!code-csharp[CodeDom_CompilerInfo#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#3)]
 [!code-vb[CodeDom_CompilerInfo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromCompileUnit">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromCompileUnit (System.CodeDom.CodeCompileUnit compileUnit, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromCompileUnit(class System.CodeDom.CodeCompileUnit compileUnit, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit(System.CodeDom.CodeCompileUnit,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromCompileUnit (compileUnit As CodeCompileUnit, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromCompileUnit(System::CodeDom::CodeCompileUnit ^ compileUnit, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromCompileUnit (compileUnit, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compileUnit" Type="System.CodeDom.CodeCompileUnit" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="compileUnit">Un <see cref="T:System.CodeDom.CodeCompileUnit" /> pour lequel générer le code.</param>
        <param name="writer">Le <see cref="T:System.IO.TextWriter" /> auquel le code de sortie est envoyé.</param>
        <param name="options">Un <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer du code.</param>
        <summary>Génère du code pour l’unité de compilation de Code Document Object Model (CodeDOM) spécifiée et l’envoie au writer de texte spécifié, à l’aide des options spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A> méthode pour générer le code pour une application « Hello World » à partir d’un <xref:System.CodeDom.CodeCompileUnit>. Cet exemple fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CodeDomProvider> classe.  
  
 [!code-cpp[CodeDomExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#3)]
 [!code-vb[CodeDomExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode est substituée dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromExpression">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromExpression (System.CodeDom.CodeExpression expression, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromExpression(class System.CodeDom.CodeExpression expression, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromExpression(System.CodeDom.CodeExpression,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromExpression (expression As CodeExpression, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromExpression(System::CodeDom::CodeExpression ^ expression, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromExpression (expression, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.CodeDom.CodeExpression" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression">Un <see cref="T:System.CodeDom.CodeExpression" /> objet indiquant l’expression pour laquelle générer le code.</param>
        <param name="writer">Le <see cref="T:System.IO.TextWriter" /> qui génèrent le code est envoyé.</param>
        <param name="options">Un <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer du code.</param>
        <summary>Génère du code pour l’expression de Code Document Object Model (CodeDOM) spécifiée et l’envoie au writer de texte spécifié, à l’aide des options spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode est substituée dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromMember">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromMember (System.CodeDom.CodeTypeMember member, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromMember(class System.CodeDom.CodeTypeMember member, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember(System.CodeDom.CodeTypeMember,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromMember (member As CodeTypeMember, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromMember(System::CodeDom::CodeTypeMember ^ member, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromMember (member, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.CodeDom.CodeTypeMember" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="member">Un <see cref="T:System.CodeDom.CodeTypeMember" /> objet qui indique le membre pour lequel générer le code.</param>
        <param name="writer">Le <see cref="T:System.IO.TextWriter" /> qui génèrent le code est envoyé.</param>
        <param name="options">Un <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer du code.</param>
        <summary>Génère du code pour la déclaration de membre de Code Document Object Model (CodeDOM) spécifiée et l’envoie au writer de texte spécifié, à l’aide des options spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation de classe de base lève un <xref:System.NotImplementedException>. Consultez <xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType> pour obtenir une documentation décrivant une implémentation de cette méthode.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A> méthode implémenté par le <xref:Microsoft.CSharp.CSharpCodeProvider> et <xref:Microsoft.VisualBasic.VBCodeProvider> classes.  
  
 [!code-csharp[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/cs/program.cs#1)]
 [!code-vb[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Cette méthode n’est pas substituée dans une classe dérivée.</exception>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeMember" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromNamespace">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromNamespace (System.CodeDom.CodeNamespace codeNamespace, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromNamespace(class System.CodeDom.CodeNamespace codeNamespace, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromNamespace(System.CodeDom.CodeNamespace,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromNamespace(System::CodeDom::CodeNamespace ^ codeNamespace, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromNamespace (codeNamespace, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeNamespace" Type="System.CodeDom.CodeNamespace" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeNamespace">Un <see cref="T:System.CodeDom.CodeNamespace" /> objet qui indique l’espace de noms pour lequel générer le code.</param>
        <param name="writer">Le <see cref="T:System.IO.TextWriter" /> qui génèrent le code est envoyé.</param>
        <param name="options">Un <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer du code.</param>
        <summary>Génère du code pour l’espace de noms Code Document Object Model (CodeDOM) spécifiée et l’envoie au writer de texte spécifié, à l’aide des options spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode est substituée dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeNamespace" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromStatement">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromStatement (System.CodeDom.CodeStatement statement, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromStatement(class System.CodeDom.CodeStatement statement, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromStatement(System.CodeDom.CodeStatement,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromStatement (statement As CodeStatement, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromStatement(System::CodeDom::CodeStatement ^ statement, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromStatement (statement, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statement" Type="System.CodeDom.CodeStatement" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="statement">Un <see cref="T:System.CodeDom.CodeStatement" /> contenant les éléments CodeDOM pour laquelle générer le code.</param>
        <param name="writer">Le <see cref="T:System.IO.TextWriter" /> qui génèrent le code est envoyé.</param>
        <param name="options">Un <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer du code.</param>
        <summary>Génère du code pour l’instruction Code Document Object Model (CodeDOM) spécifiée et l’envoie au writer de texte spécifié, à l’aide des options spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode est substituée dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeStatement" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromType">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromType (System.CodeDom.CodeTypeDeclaration codeType, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromType(class System.CodeDom.CodeTypeDeclaration codeType, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromType(System.CodeDom.CodeTypeDeclaration,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromType (codeType As CodeTypeDeclaration, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromType(System::CodeDom::CodeTypeDeclaration ^ codeType, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromType (codeType, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeType" Type="System.CodeDom.CodeTypeDeclaration" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeType">Un <see cref="T:System.CodeDom.CodeTypeDeclaration" /> objet qui indique le type pour lequel générer le code.</param>
        <param name="writer">Le <see cref="T:System.IO.TextWriter" /> qui génèrent le code est envoyé.</param>
        <param name="options">Un <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer du code.</param>
        <summary>Génère du code pour la déclaration de type Code Document Object Model (CodeDOM) spécifiée et l’envoie au writer de texte spécifié, à l’aide des options spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode est substituée dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GetAllCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllCompilerInfo () As CompilerInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::CodeDom::Compiler::CompilerInfo ^&gt; ^ GetAllCompilerInfo();" />
      <MemberSignature Language="F#" Value="static member GetAllCompilerInfo : unit -&gt; System.CodeDom.Compiler.CompilerInfo[]" Usage="System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le langage de compilateur et le fournisseur de paramètres de configuration pour cet ordinateur.</summary>
        <returns>Tableau de type <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> représentant les paramètres de tous les configuré <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implémentations.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> méthode pour énumérer les paramètres du fournisseur de langue sur un ordinateur.  
  
> [!NOTE]
>  Dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], les fournisseurs de langage par défaut fournies par le .NET Framework ne sont pas spécifiées dans le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) configuration de compilateur section et ne peut pas être supprimé, par conséquent cette méthode retourne des informations sur les fournisseurs par défaut et tout spécifié dans le fichier de configuration.  
  
   
  
## Examples  
 L’exemple de code suivant énumère les fournisseurs de langages sur l’ordinateur et affiche les paramètres de configuration et de compilateur pour chaque fournisseur de langages. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#8](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#8)]
 [!code-csharp[CodeDom_CompilerInfo#8](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#8)]
 [!code-vb[CodeDom_CompilerInfo#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schéma des paramètres du fournisseur de langage et du compilateur</related>
      </Docs>
    </Member>
    <Member MemberName="GetCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo GetCompilerInfo (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo GetCompilerInfo(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompilerInfo (language As String) As CompilerInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CompilerInfo ^ GetCompilerInfo(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member GetCompilerInfo : string -&gt; System.CodeDom.Compiler.CompilerInfo" Usage="System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Un nom de langage.</param>
        <summary>Retourne le langage de paramètres de configuration de compilateur et du fournisseur pour la langue spécifiée.</summary>
        <returns>Un <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> objet rempli avec des paramètres de configuré <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implémentation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans la configuration d’ordinateur fichier contient les fournisseur et du compilateur configuration paramètres de langue pour chaque <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation sur l’ordinateur. Pour plus d’informations sur les fichiers de configuration machine, consultez la section fichiers de Configuration Machine dans [configuration des applications](~/docs/framework/configure-apps/index.md). Le <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> méthode recherche chaque élément de configuration de fournisseur pour le nom de la langue spécifiée. Retourné <xref:System.CodeDom.Compiler.CompilerInfo> instance contient les paramètres de compilateur et du fournisseur de langages configuré.  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> méthode vérifie si au moins une implémentation de fournisseur prend en charge une langue spécifique. Vous pouvez valider un nom de langue à l’aide <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> avant leur transmission à <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>. Cela empêche la levée une <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> lorsque vous accédez à la <xref:System.CodeDom.Compiler.CompilerInfo> instance pour un nom de langage non pris en charge.  
  
 Si plus d’une implémentation de fournisseur est configurée pour le nom de la langue d’entrée, <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> retourne les paramètres à partir du fournisseur correspondant dernier élément de configuration.  
  
 Les noms de langage respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant détermine le <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une langue d’entrée et affiche les paramètres configurés pour le fournisseur de langages. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">Le <paramref name="language" /> n’a pas de fournisseur configuré sur cet ordinateur.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException"><paramref name="language" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schéma des paramètres du fournisseur de langage et du compilateur</related>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetConverter : Type -&gt; System.ComponentModel.TypeConverter&#xA;override this.GetConverter : Type -&gt; System.ComponentModel.TypeConverter" Usage="codeDomProvider.GetConverter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Type d'objet pour lequel un convertisseur de type doit être récupéré.</param>
        <summary>Obtient un <see cref="T:System.ComponentModel.TypeConverter" /> pour le type de données spécifié.</summary>
        <returns>Un <see cref="T:System.ComponentModel.TypeConverter" /> pour le type spécifié, ou <see langword="null" /> si un <see cref="T:System.ComponentModel.TypeConverter" /> pour le type spécifié est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une classe dérivée peut substituer cette méthode pour fournir des types spécifiques de convertisseurs de type pour les types de données spécifiques.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetLanguageFromExtension">
      <MemberSignature Language="C#" Value="public static string GetLanguageFromExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetLanguageFromExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLanguageFromExtension (extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetLanguageFromExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member GetLanguageFromExtension : string -&gt; string" Usage="System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="extension">Une extension de nom de fichier.</param>
        <summary>Retourne un nom de langage associé à l’extension de nom de fichier spécifié, tel que configuré dans la <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> section de configuration du compilateur.</summary>
        <returns>Un nom de langage associé à l’extension de nom de fichier, tel que configuré dans le <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> les paramètres de configuration du compilateur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans la configuration d’ordinateur fichier (Machine.config) contient les fournisseur et du compilateur configuration paramètres de langue pour chaque <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation sur le ordinateur. Le <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> méthode recherche chaque élément de configuration de fournisseur pour l’extension de nom de fichier spécifié.  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> méthode vérifie si au moins une implémentation de fournisseur prend en charge une extension de nom de fichier spécifique. Vous pouvez valider une extension de nom de fichier à l’aide <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> avant leur transmission à <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>. Cela empêche <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> de lever un <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> pour une extension de nom de fichier non pris en charge.  
  
 Si une implémentation de fournisseur prend en charge l’extension de nom de fichier d’entrée et il existe plusieurs langues prises en charge configurés pour ce fournisseur, puis <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> retourne le premier nom de langage pour ce fournisseur. Si plus d’une implémentation de fournisseur est configurée pour l’extension de nom de fichier d’entrée, <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> retourne le nom de la langue à partir du fournisseur correspondant dernier élément de configuration.  
  
 Les noms de langage et les extensions de nom de fichier respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant détermine le <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une extension de nom de fichier d’entrée et affiche les paramètres configurés pour le fournisseur de langages. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">Le <paramref name="extension" /> n’a pas de fournisseur de langages configuré sur cet ordinateur.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException"><paramref name="extension" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schéma des paramètres du fournisseur de langage et du compilateur</related>
      </Docs>
    </Member>
    <Member MemberName="GetTypeOutput">
      <MemberSignature Language="C#" Value="public virtual string GetTypeOutput (System.CodeDom.CodeTypeReference type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeOutput(class System.CodeDom.CodeTypeReference type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetTypeOutput(System.CodeDom.CodeTypeReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeOutput (type As CodeTypeReference) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeOutput(System::CodeDom::CodeTypeReference ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string&#xA;override this.GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string" Usage="codeDomProvider.GetTypeOutput type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.CodeDom.CodeTypeReference" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Un <see cref="T:System.CodeDom.CodeTypeReference" /> qui indique le type à retourner.</param>
        <summary>Obtient le type indiqué par le <see cref="T:System.CodeDom.CodeTypeReference" />.</summary>
        <returns>Une représentation textuelle du type spécifié, mis en forme pour le langage dans lequel le code est généré par ce générateur de code. En Visual Basic, par exemple, en passant un <see cref="T:System.CodeDom.CodeTypeReference" /> pour la <see cref="T:System.Int32" /> type retourne « Integer ».</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode est substituée dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedExtension">
      <MemberSignature Language="C#" Value="public static bool IsDefinedExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedExtension (extension As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member IsDefinedExtension : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="extension">Une extension de nom de fichier.</param>
        <summary>Teste si une extension de nom de fichier est associé à un <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implémentation configurée sur l’ordinateur.</summary>
        <returns><see langword="true" /> Si un <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implémentation est configuré pour l’extension de nom de fichier spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans la configuration d’ordinateur fichier (Machine.config) contient les fournisseur et du compilateur configuration paramètres de langue pour chaque <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation sur le ordinateur. Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> méthode recherche les éléments de configuration de fournisseur pour l’extension de nom de fichier spécifié.  
  
 Extensions de nom de fichier respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant détermine le <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une extension de nom de fichier d’entrée et affiche les paramètres configurés pour le fournisseur de langages. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="extension" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schéma des paramètres du fournisseur de langage et du compilateur</related>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedLanguage">
      <MemberSignature Language="C#" Value="public static bool IsDefinedLanguage (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedLanguage(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedLanguage (language As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedLanguage(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member IsDefinedLanguage : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Le nom du langage.</param>
        <summary>Teste si un langage a un <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implémentation configurée sur l’ordinateur.</summary>
        <returns><see langword="true" /> Si un <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implémentation est configuré pour le langage spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans la configuration d’ordinateur fichier (Machine.config) contient les fournisseur et du compilateur configuration paramètres de langue pour chaque <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation sur le ordinateur. Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> méthode recherche les éléments de configuration de fournisseur pour le nom de la langue spécifiée.  
  
 Les noms de langage respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant détermine le <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une langue d’entrée et affiche les paramètres configurés pour le fournisseur de langages. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="language" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schéma des paramètres du fournisseur de langage et du compilateur</related>
      </Docs>
    </Member>
    <Member MemberName="IsValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual bool IsValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsValidIdentifier (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsValidIdentifier : string -&gt; bool&#xA;override this.IsValidIdentifier : string -&gt; bool" Usage="codeDomProvider.IsValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à vérifier comme identificateur valide.</param>
        <summary>Retourne une valeur qui indique si la valeur spécifiée est un identificateur valide pour le langage actuel.</summary>
        <returns><see langword="true" /> Si le <paramref name="value" /> paramètre est un identificateur valide ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode vérifie si un identificateur est valide. Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A> méthode est spécifique au fournisseur. Les identificateurs qui sont valides pour un fournisseur n’est peut-être pas valides pour les autres fournisseurs. Si `value` contient des caractères en dehors de la plage de caractères ASCII, vérifiez l’identificateur pour tous les langages qui pourraient être utilisées pour compiler le code.  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode est substituée dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" /> dans une classe dérivée, définissez la méthode pour retourner <see langword="true" /> uniquement si la valeur respecte les règles du langage et n’est pas en conflit avec un mot clé.  
  
Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
      </Docs>
    </Member>
    <Member MemberName="LanguageOptions">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.LanguageOptions LanguageOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.CodeDom.Compiler.LanguageOptions LanguageOptions" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LanguageOptions As LanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::CodeDom::Compiler::LanguageOptions LanguageOptions { System::CodeDom::Compiler::LanguageOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOptions : System.CodeDom.Compiler.LanguageOptions" Usage="System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.LanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un identificateur de fonctionnalités de langage.</summary>
        <value><see cref="T:System.CodeDom.Compiler.LanguageOptions" /> qui indique les fonctionnalités spéciales du langage.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.CodeCompileUnit Parse (System.IO.TextReader codeStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.CodeCompileUnit Parse(class System.IO.TextReader codeStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Parse(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Parse (codeStream As TextReader) As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::CodeCompileUnit ^ Parse(System::IO::TextReader ^ codeStream);" />
      <MemberSignature Language="F#" Value="abstract member Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit&#xA;override this.Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit" Usage="codeDomProvider.Parse codeStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeStream" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeStream">Un <see cref="T:System.IO.TextReader" /> objet qui est utilisé pour lire le code à analyser.</param>
        <summary>Compile le code lu à partir du flux de texte spécifié dans un <see cref="T:System.CodeDom.CodeCompileUnit" />.</summary>
        <returns>Un <see cref="T:System.CodeDom.CodeCompileUnit" /> qui contient une représentation du code analysé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeParser> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeParser> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode est substituée dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un analyseur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des analyseurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeParser" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas d’analyseur de code.</para></block>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.IO.TextReader" />
      </Docs>
    </Member>
    <Member MemberName="Supports">
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport generatorSupport) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport supports) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports generatorSupport" FrameworkAlternate="netframework-1.1;netcore-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports supports" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generatorSupport" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="supports" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generatorSupport">Un <see cref="T:System.CodeDom.Compiler.GeneratorSupport" /> objet qui indique le type de prise en charge de génération de code à vérifier.</param>
        <param name="supports">To be added.</param>
        <summary>Retourne une valeur indiquant si la génération de code spécifié prend en charge est fournie.</summary>
        <returns><see langword="true" /> Si la prise en charge de la génération de code spécifiée est fournie ; Sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée avec un nombre de <xref:System.CodeDom.Compiler.GeneratorSupport> indicateurs à la fois pour tester un ensemble de fonctionnalités en combinant un ensemble d’indicateurs appropriés ainsi que d’un fichier binaire `OR` opérateur (&#124;).  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode est substituée dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
      </Docs>
    </Member>
  </Members>
</Type>