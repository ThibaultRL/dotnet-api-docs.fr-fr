<Type Name="CodeDomProvider" FullName="System.CodeDom.Compiler.CodeDomProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="df52201d4a1c476b9b4db7b02ef8e4119a6cc969" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55333133" /></Metadata><TypeSignature Language="C#" Value="public abstract class CodeDomProvider : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeDomProvider extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.Compiler.CodeDomProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeDomProvider&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeDomProvider abstract : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type CodeDomProvider = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit une classe de base pour les implémentations de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />. Cette classe est abstraite.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.CodeDom.Compiler.CodeDomProvider> peut être utilisé pour créer et récupérer des instances de générateurs de code et des compilateurs de code. Les générateurs de code permettent de générer du code dans un langage donné, tandis que les compilateurs de code permettent de compiler du code dans des assemblys.  
  
> [!NOTE]
>  Dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], les méthodes mises à disposition dans le Générateur de code et du compilateur de code sont directement disponibles dans le fournisseur de code. Vous n’avez pas besoin d’appeler <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> ou <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> pour accéder aux méthodes et ces méthodes sont marquées comme obsolètes. Cela s’applique aux préexistant, ainsi que de nouvelles implémentations de fournisseur de code.  
  
 Un <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation fournit généralement code des interfaces de compilation de code et/ou la génération pour la génération de code et la gestion de compilation pour un seul langage de programmation. Plusieurs langages sont pris en charge par <xref:System.CodeDom.Compiler.CodeDomProvider> implémentations fournies avec le [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)]. Ces langages incluent c#, Visual Basic, C++ et JScript. Les développeurs ou les éditeurs de compilateurs peuvent implémenter la <xref:System.CodeDom.Compiler.ICodeGenerator> et <xref:System.CodeDom.Compiler.ICodeCompiler> interfaces et de fournir un <xref:System.CodeDom.Compiler.CodeDomProvider> qui étend la prise en charge de CodeDOM à d’autres langages de programmation.  
  
 Le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans la configuration d’ordinateur (Machine.config) de fichier fournit un mécanisme pour les développeurs et éditeurs de compilateurs ajouter des paramètres de configuration supplémentaires <xref:System.CodeDom.Compiler.CodeDomProvider>implémentations.  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider> classe fournit des méthodes statiques pour découvrir et énumérer les <xref:System.CodeDom.Compiler.CodeDomProvider> implémentations sur un ordinateur. Le <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> méthode retourne les paramètres pour tous les <xref:System.CodeDom.Compiler.CodeDomProvider> implémentations sur un ordinateur. Le <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> méthode retourne les paramètres pour un spécifique <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation, en fonction du nom de langage de programmation. Le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> méthode retourne une instance d’un <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une langue spécifique.  
  
 Pour plus d’informations sur les paramètres de fournisseur de langages dans le fichier de configuration, consultez [compilateur et le schéma de paramètres de fournisseur de langage](~/docs/framework/configure-apps/file-schema/compiler/index.md).  
  
> [!NOTE]
>  Cette classe effectue une demande de liaison et une demande d’héritage au niveau de la classe. Un <xref:System.Security.SecurityException> est levée si l’appelant immédiat ou la classe dérivée n’a pas d’autorisation de confiance totale. Pour plus d’informations sur les demandes de sécurité, consultez [demandes de liaison](~/docs/framework/misc/link-demands.md) et [demandes d’héritage](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/x4yx82e6(v=vs.100)).  
  
   
  
## Examples  
 L’exemple de programme suivant peut générer et compiler le code source basé sur un modèle CodeDOM d’un programme qui imprime « Hello World » à l’aide de la <xref:System.Console> classe. Une interface utilisateur Windows Forms est fournie. L’utilisateur peut sélectionner la cible de langage à partir de plusieurs sélections de programmation : C#, Visual Basic et JScript.  
  
 [!code-cpp[CodeDomExample#1](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#1)]
 [!code-csharp[CodeDomExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#1)]
 [!code-vb[CodeDomExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Cette classe ne peut pas être utilisée par du code partiellement fiable.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">pour la confiance totale pour les héritiers. Cette classe ne peut pas être héritée par du code partiellement fiable.</permission>
    <block subset="none" type="overrides"><para>Dans les versions 1.0 et 1.1 du .NET Framework, les fournisseurs de code se composent d’implémentations de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />, <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, <see cref="T:System.CodeDom.Compiler.ICodeParser" />, et <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />. Dans le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], le <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />, <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />, et <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> sont obsolètes et les méthodes de <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> et <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> sont directement disponibles dans la <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> classe. Vous devez substituer ces méthodes dans votre implémentation de fournisseur de code et n’appelez pas les méthodes de base.</para></block>
    <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
    <altmember cref="T:Microsoft.CSharp.CSharpCodeProvider" />
    <altmember cref="T:Microsoft.VisualBasic.VBCodeProvider" />
    <altmember cref="T:Microsoft.JScript.JScriptCodeProvider" />
    <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schéma des paramètres du fournisseur de langage et du compilateur</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeDomProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeDomProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Cette classe ne peut pas être utilisée par du code partiellement fiable.</permission>
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromDom">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom (System.CodeDom.Compiler.CompilerParameters options, params System.CodeDom.CodeCompileUnit[] compilationUnits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom(class System.CodeDom.Compiler.CompilerParameters options, class System.CodeDom.CodeCompileUnit[] compilationUnits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromDom(System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromDom (options As CompilerParameters, ParamArray compilationUnits As CodeCompileUnit()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromDom(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::CodeDom::CodeCompileUnit ^&gt; ^ compilationUnits);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromDom (options, compilationUnits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="compilationUnits" Type="System.CodeDom.CodeCompileUnit[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Objet <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> indiquant les paramètres de la compilation.</param>
        <param name="compilationUnits">Tableau de type <see cref="T:System.CodeDom.CodeCompileUnit" /> indiquant le code à compiler.</param>
        <summary>Compile un assembly basé sur les arborescences <see cref="N:System.CodeDom" /> contenues dans le tableau d'objets <see cref="T:System.CodeDom.CodeCompileUnit" /> spécifié, à l'aide des paramètres du compilateur spécifiés.</summary>
        <returns>Objet <see cref="T:System.CodeDom.Compiler.CompilerResults" /> indiquant les résultats de la compilation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des compilateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas d’un compilateur de code.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromFile">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile (System.CodeDom.Compiler.CompilerParameters options, params string[] fileNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile(class System.CodeDom.Compiler.CompilerParameters options, string[] fileNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromFile(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromFile (options As CompilerParameters, ParamArray fileNames As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromFile(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ fileNames);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromFile (options, fileNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="fileNames" Type="System.String[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Objet <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> indiquant les paramètres de la compilation.</param>
        <param name="fileNames">Tableau des noms des fichiers à compiler.</param>
        <summary>Compile un assembly à partir du code source contenu dans les fichiers spécifiés, à l'aide des paramètres du compilateur spécifiés.</summary>
        <returns>Objet <see cref="T:System.CodeDom.Compiler.CompilerResults" /> indiquant les résultats de la compilation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des compilateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas d’un compilateur de code.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromSource">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource (System.CodeDom.Compiler.CompilerParameters options, params string[] sources);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource(class System.CodeDom.Compiler.CompilerParameters options, string[] sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromSource(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromSource (options As CompilerParameters, ParamArray sources As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromSource(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ sources);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromSource (options, sources)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="sources" Type="System.String[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">Objet <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> indiquant les paramètres du compilateur pour cette compilation.</param>
        <param name="sources">Tableau de chaînes de code source à compiler.</param>
        <summary>Compile un assembly à partir du tableau de chaînes spécifié contenant le code source, à l'aide des paramètres du compilateur spécifiés.</summary>
        <returns>Objet <see cref="T:System.CodeDom.Compiler.CompilerResults" /> indiquant les résultats de la compilation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeCompiler> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des compilateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas d’un compilateur de code.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CreateCompiler">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeCompiler CreateCompiler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeCompiler CreateCompiler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCompiler () As ICodeCompiler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeCompiler ^ CreateCompiler();" />
      <MemberSignature Language="F#" Value="abstract member CreateCompiler : unit -&gt; System.CodeDom.Compiler.ICodeCompiler" Usage="codeDomProvider.CreateCompiler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeCompiler is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("Callers should not use the ICodeCompiler interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeCompiler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau compilateur de code.</summary>
        <returns><see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> pouvant être utilisé pour la compilation de représentations du code source basées sur <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est obsolète dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]. L’alternative recommandée consiste à appeler le <xref:System.CodeDom.Compiler.ICodeCompiler> les méthodes qui sont directement disponibles dans le fournisseur de code.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Dans le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], vous devez implémenter le <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> membres dans le <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> classe et lever une <see cref="T:System.NotSupportedException" /> lorsque cette méthode est appelée.</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateEscapedIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateEscapedIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateEscapedIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEscapedIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateEscapedIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateEscapedIdentifier : string -&gt; string&#xA;override this.CreateEscapedIdentifier : string -&gt; string" Usage="codeDomProvider.CreateEscapedIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne pour laquelle un identificateur avec séquence d'échappement doit être créé.</param>
        <summary>Crée un identificateur avec séquence d'échappement pour la valeur spécifiée.</summary>
        <returns>Identificateur avec séquence d'échappement pour la valeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A> tests si l’identificateur est en conflit avec n’importe quel réservés ou des mots clés du langage et si tel est le cas, retourne un nom équivalent avec la mise en forme du code d’échappement spécifique au langage. Cette opération est appelée un identificateur avec séquence d’échappement. L’identificateur avec séquence d’échappement contient la même `value` mais est mise en forme du code d’échappement ajoutée afin de différencier l’identificateur du mot clé. Deux exemples d’implémentation précèdent le `value` avec « @ » ou mettent entre crochets le `value` avec » [ » et «] ».  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateGenerator">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau générateur de code.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeGenerator CreateGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateGenerator () As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator();" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : unit -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeGenerator is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("Callers should not use the ICodeGenerator interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau générateur de code.</summary>
        <returns><see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> pouvant être utilisé pour générer des représentations du code source basées sur <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est obsolète dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]. L’alternative recommandée consiste à appeler le <xref:System.CodeDom.Compiler.ICodeGenerator> les méthodes qui sont directement disponibles dans la <xref:System.CodeDom.Compiler.CodeDomProvider> classe.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Dans le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], vous devez implémenter le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> membres dans le <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> classe et lever une <see cref="T:System.NotSupportedException" /> lorsque cette méthode est appelée.</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (output As TextWriter) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator output" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="output"><see cref="T:System.IO.TextWriter" /> à utiliser pour effectuer la sortie.</param>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau générateur de code à l'aide du <see cref="T:System.IO.TextWriter" /> spécifié pour la sortie.</summary>
        <returns><see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> pouvant être utilisé pour générer des représentations du code source basées sur <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise spécifié <xref:System.IO.TextWriter> pour la sortie. Cette méthode prend en charge la génération de code optimisé plus que de façon incrémentielle met à jour le code source.  
  
> [!NOTE]
>  L’implémentation de classe de base appelle la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> (méthode), qui est obsolète dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] et entraîne un <xref:System.NotSupportedException> si un <xref:System.CodeDom.Compiler.ICodeGenerator> objet n’est pas retourné.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.TextWriter" />
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (fileName As String) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier vers lequel effectuer la sortie.</param>
        <summary>En cas de substitution dans une classe dérivée, crée un nouveau générateur de code à l'aide du nom de fichier spécifié pour la sortie.</summary>
        <returns><see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> pouvant être utilisé pour générer des représentations du code source basées sur <see cref="N:System.CodeDom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise le nom de fichier spécifié pour la sortie.  
  
> [!NOTE]
>  L’implémentation de classe de base appelle la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> (méthode), qui est obsolète dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] et entraîne un <xref:System.NotSupportedException> si un <xref:System.CodeDom.Compiler.ICodeGenerator> objet n’est pas retourné.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParser">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeParser CreateParser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeParser CreateParser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateParser () As ICodeParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeParser ^ CreateParser();" />
      <MemberSignature Language="F#" Value="abstract member CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser&#xA;override this.CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser" Usage="codeDomProvider.CreateParser " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeParser is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("Callers should not use the ICodeParser interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeParser</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée un nouvel analyseur de code.</summary>
        <returns><see cref="T:System.CodeDom.Compiler.ICodeParser" /> pouvant être utilisé pour analyser le code source. L'implémentation de base retourne toujours <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProvider">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> pour le langage spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Nom du langage.</param>
        <summary>Crée une instance de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> pour le langage spécifié.</summary>
        <returns>Fournisseur CodeDOM  qui est implémentée pour le nom du langage spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode est couramment utilisée pour créer une instance d’un fournisseur de code dans une application qui peut utiliser un des fournisseurs. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> vous permet de spécifier au moment de l’exécution le fournisseur de code que vous souhaitez instancier. Si vous connaissez au moment du design quel code fournisseur doit être utilisé, vous devez créer une instance de ce fournisseur de code au lieu d’utiliser le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> (méthode).  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> méthode retourne un <xref:System.CodeDom.Compiler.CodeDomProvider> de l’instance pour un nom de langage spécifique ; elle est similaire à l’appel le <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> méthode avec le type de fournisseur de langage. Utilisez <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> lorsque vous souhaitez rechercher dynamiquement une implémentation de fournisseur configuré pour un nom de langage.  
  
 Si plus d’une implémentation de fournisseur est configurée pour le nom du langage, <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> retourne une instance de fournisseur pour le dernier élément de configuration correspondant.  
  
 Utilisez le <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> surcharge de méthode lorsque vous souhaitez une implémentation de fournisseur de langage spécifique. Par exemple, utiliser le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> méthode pour obtenir une instance de fournisseur qui prend en charge le nom du langage `"CSharp"`; utiliser le <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> surcharge de méthode pour obtenir une instance de fournisseur spécifiquement pour le <xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType> implémentation. Vous devez utiliser le [\], CultureInfo, objet\<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D% 2CSystem.Globalization.CultureInfo%2CSystem.Object%5B%5D%29?displayProperty=nameWithType > méthode si vous disposez de plusieurs fournisseurs de code pour un langage et que vous souhaitez instancier un fournisseur de code spécifique.  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> méthode vérifie si au moins une implémentation de fournisseur prend en charge une langue spécifique. Vous pouvez valider un nom de langue à l’aide <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> avant leur transmission à <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>. Si vous passez un nom de langage non pris en charge à <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> un <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> est levée.  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> méthode peut être utilisée pour déterminer toutes <xref:System.CodeDom.Compiler.CodeDomProvider> implémentations sur un ordinateur, y compris les implémentations supplémentaires fournies par les développeurs et éditeurs de compilateurs qui sont identifiés dans le [ &lt;system.codedom &gt; Élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans le fichier de configuration machine (Machine.config).  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> méthode retourne une instance d’un <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une langue spécifique.  
  
 Les noms de langage respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant détermine le <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une langue d’entrée et affiche les paramètres configurés pour le fournisseur de langages. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Le <paramref name="language" /> n'a pas de fournisseur configuré sur cet ordinateur.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="language" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language, System.Collections.Generic.IDictionary&lt;string,string&gt; providerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; providerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String, providerOptions As IDictionary(Of String, String)) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ providerOptions);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string * System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider (language, providerOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="providerOptions" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Nom du langage.</param>
        <param name="providerOptions">Collection d'options de fournisseur issue du fichier de configuration.</param>
        <summary>Obtient une instance <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> pour le langage et les options de fournisseur spécifiés.</summary>
        <returns>Fournisseur CodeDOM implémenté pour le nom de langage et les options spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode est couramment utilisée pour créer une instance d’un fournisseur de code dans une application qui peut utiliser un des fournisseurs. <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> vous permet de spécifier au moment de l’exécution la version du fournisseur de code que vous souhaitez instancier. Si vous connaissez au moment du design quel code fournisseur doit être utilisé, vous devez créer une instance de ce fournisseur de code au lieu d’utiliser le <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> (méthode).  
  
 Utilisez <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> lorsque vous souhaitez rechercher dynamiquement une implémentation de fournisseur configuré pour une langue spécifique et les options. Les noms de langage respectent la casse. Pour plus d’informations sur les options de fournisseur pris en charge, consultez la documentation du fournisseur CodeDOM spécifique.  
  
 Pour plus d’informations sur la validation d’un fournisseur et l’appel d’un fournisseur si plusieurs implémentations de fournisseur sont configurée pour le nom du langage, consultez la section Notes de la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29> (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une instance d’un fournisseur à l’aide de le `providerOptions` paramètre.  
  
 [!code-csharp[CodeDomProvider.ProviderOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/codedomprovider.provideroptions/cs/program.cs#1)]
 [!code-vb[CodeDomProvider.ProviderOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/codedomprovider.provideroptions/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateValidIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateValidIdentifier : string -&gt; string&#xA;override this.CreateValidIdentifier : string -&gt; string" Usage="codeDomProvider.CreateValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne pour laquelle un identificateur valide doit être généré.</param>
        <summary>Crée un identificateur valide pour la valeur spécifiée.</summary>
        <returns>Identificateur valide pour la valeur spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A> Teste si l’identificateur est en conflit avec réservés ou des mots clés du langage, et le cas échéant, tente de retourner un identificateur valide nom qui ne sont pas en conflit. Généralement l’identificateur retourné est que légèrement modifié pour différencier l’identificateur du mot clé ; par exemple, le nom peut être précédé par le caractère de soulignement (« _ »).  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FileExtension">
      <MemberSignature Language="C#" Value="public virtual string FileExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileExtension" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FileExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FileExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FileExtension : string" Usage="System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Définit l'extension du nom de fichier par défaut à utiliser pour les fichiers de code source dans le langage actuel.</summary>
        <value>Extension du nom de fichier correspondant à l'extension des fichiers sources du langage actuel. L'implémentation de base retourne toujours <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est utilisée par les générateurs de code et des compilateurs de code pour indiquer les extensions de fichier doivent être générées ou a utilisée.  
  
   
  
## Examples  
 L’exemple de code suivant crée une instance de <xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>. L’exemple affiche le nom du fournisseur, le hachage par défaut et le code d’extension de fichier pour la nouvelle instance de fournisseur.  
  
 [!code-cpp[CodeDom_CompilerInfo#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#3)]
 [!code-csharp[CodeDom_CompilerInfo#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#3)]
 [!code-vb[CodeDom_CompilerInfo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromCompileUnit">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromCompileUnit (System.CodeDom.CodeCompileUnit compileUnit, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromCompileUnit(class System.CodeDom.CodeCompileUnit compileUnit, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit(System.CodeDom.CodeCompileUnit,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromCompileUnit (compileUnit As CodeCompileUnit, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromCompileUnit(System::CodeDom::CodeCompileUnit ^ compileUnit, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromCompileUnit (compileUnit, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compileUnit" Type="System.CodeDom.CodeCompileUnit" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="compileUnit"><see cref="T:System.CodeDom.CodeCompileUnit" /> pour lequel du code doit être généré.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> auquel le code de sortie est envoyé.</param>
        <param name="options"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer le code.</param>
        <summary>Génère du code pour l'unité de compilation CodeDOM (Code Document Object Model) spécifiée et l'envoie au writer de texte spécifié, à l'aide des options définies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A> méthode pour générer le code pour une application « Hello World » à partir d’un <xref:System.CodeDom.CodeCompileUnit>. Cet exemple fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CodeDomProvider> classe.  
  
 [!code-cpp[CodeDomExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#3)]
 [!code-vb[CodeDomExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromExpression">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromExpression (System.CodeDom.CodeExpression expression, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromExpression(class System.CodeDom.CodeExpression expression, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromExpression(System.CodeDom.CodeExpression,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromExpression (expression As CodeExpression, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromExpression(System::CodeDom::CodeExpression ^ expression, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromExpression (expression, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.CodeDom.CodeExpression" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression">Objet <see cref="T:System.CodeDom.CodeExpression" /> indiquant l'expression pour laquelle du code doit être généré.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> auquel le code de sortie est envoyé.</param>
        <param name="options"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer le code.</param>
        <summary>Génère du code pour l'expression CodeDOM (Code Document Object Model) spécifiée et l'envoie au writer de texte spécifié, à l'aide des options définies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromMember">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromMember (System.CodeDom.CodeTypeMember member, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromMember(class System.CodeDom.CodeTypeMember member, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember(System.CodeDom.CodeTypeMember,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromMember (member As CodeTypeMember, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromMember(System::CodeDom::CodeTypeMember ^ member, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromMember (member, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.CodeDom.CodeTypeMember" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="member">Objet <see cref="T:System.CodeDom.CodeTypeMember" /> indiquant le membre pour lequel du code doit être généré.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> auquel le code de sortie est envoyé.</param>
        <param name="options"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer le code.</param>
        <summary>Génère du code pour la déclaration de membre CodeDOM (Code Document Object Model) spécifiée et l'envoie au writer de texte spécifié, à l'aide des options définies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation de classe de base lève un <xref:System.NotImplementedException>. Consultez <xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType> pour obtenir une documentation décrivant une implémentation de cette méthode.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A> méthode implémenté par le <xref:Microsoft.CSharp.CSharpCodeProvider> et <xref:Microsoft.VisualBasic.VBCodeProvider> classes.  
  
 [!code-csharp[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/cs/program.cs#1)]
 [!code-vb[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Cette méthode n'est pas substituée dans une classe dérivée.</exception>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeMember" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromNamespace">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromNamespace (System.CodeDom.CodeNamespace codeNamespace, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromNamespace(class System.CodeDom.CodeNamespace codeNamespace, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromNamespace(System.CodeDom.CodeNamespace,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromNamespace(System::CodeDom::CodeNamespace ^ codeNamespace, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromNamespace (codeNamespace, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeNamespace" Type="System.CodeDom.CodeNamespace" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeNamespace">Objet <see cref="T:System.CodeDom.CodeNamespace" /> indiquant l'espace de noms pour lequel du code doit être généré.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> auquel le code de sortie est envoyé.</param>
        <param name="options"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer le code.</param>
        <summary>Génère du code pour l'espace de noms CodeDOM (Code Document Object Model) spécifié et l'envoie au writer de texte spécifié, à l'aide des options définies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeNamespace" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromStatement">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromStatement (System.CodeDom.CodeStatement statement, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromStatement(class System.CodeDom.CodeStatement statement, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromStatement(System.CodeDom.CodeStatement,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromStatement (statement As CodeStatement, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromStatement(System::CodeDom::CodeStatement ^ statement, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromStatement (statement, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statement" Type="System.CodeDom.CodeStatement" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="statement"><see cref="T:System.CodeDom.CodeStatement" /> qui contient les éléments CodeDOM pour lesquels du code doit être généré.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> auquel le code de sortie est envoyé.</param>
        <param name="options"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer le code.</param>
        <summary>Génère du code pour l'instruction CodeDOM (Code Document Object Model) spécifiée et l'envoie au writer de texte spécifié, à l'aide des options définies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeStatement" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromType">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromType (System.CodeDom.CodeTypeDeclaration codeType, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromType(class System.CodeDom.CodeTypeDeclaration codeType, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromType(System.CodeDom.CodeTypeDeclaration,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromType (codeType As CodeTypeDeclaration, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromType(System::CodeDom::CodeTypeDeclaration ^ codeType, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromType (codeType, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeType" Type="System.CodeDom.CodeTypeDeclaration" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeType">Objet <see cref="T:System.CodeDom.CodeTypeDeclaration" /> indiquant le type pour lequel du code doit être généré.</param>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> auquel le code de sortie est envoyé.</param>
        <param name="options"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> qui indique les options à utiliser pour générer le code.</param>
        <summary>Génère du code pour la déclaration de type CodeDOM (Code Document Object Model) spécifiée et l'envoie au writer de texte spécifié, à l'aide des options définies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GetAllCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllCompilerInfo () As CompilerInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::CodeDom::Compiler::CompilerInfo ^&gt; ^ GetAllCompilerInfo();" />
      <MemberSignature Language="F#" Value="static member GetAllCompilerInfo : unit -&gt; System.CodeDom.Compiler.CompilerInfo[]" Usage="System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le fournisseur de langages et les paramètres de configuration de compilateur pour cet ordinateur.</summary>
        <returns>Tableau de type <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> qui représente les paramètres de toutes les implémentations de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> configurées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> méthode pour énumérer les paramètres du fournisseur de langue sur un ordinateur.  
  
> [!NOTE]
>  Dans le [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], les fournisseurs de langage par défaut fournies par le .NET Framework ne sont pas spécifiées dans le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) configuration de compilateur section et ne peut pas être supprimé, par conséquent cette méthode retourne des informations sur les fournisseurs par défaut et tout spécifié dans le fichier de configuration.  
  
   
  
## Examples  
 L’exemple de code suivant énumère les fournisseurs de langages sur l’ordinateur et affiche les paramètres de configuration et de compilateur pour chaque fournisseur de langages. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#8](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#8)]
 [!code-csharp[CodeDom_CompilerInfo#8](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#8)]
 [!code-vb[CodeDom_CompilerInfo#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schéma des paramètres du fournisseur de langage et du compilateur</related>
      </Docs>
    </Member>
    <Member MemberName="GetCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo GetCompilerInfo (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo GetCompilerInfo(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompilerInfo (language As String) As CompilerInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CompilerInfo ^ GetCompilerInfo(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member GetCompilerInfo : string -&gt; System.CodeDom.Compiler.CompilerInfo" Usage="System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Nom de langage.</param>
        <summary>Retourne le fournisseur de langages et les paramètres de configuration de compilateur pour le langage spécifié.</summary>
        <returns>Objet <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> rempli avec les paramètres de l'implémentation de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> configurée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans la configuration d’ordinateur fichier contient les fournisseur et du compilateur configuration paramètres de langue pour chaque <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation sur l’ordinateur. Pour plus d’informations sur les fichiers de configuration machine, consultez la section fichiers de Configuration Machine dans [configuration des applications](~/docs/framework/configure-apps/index.md). Le <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> méthode recherche chaque élément de configuration de fournisseur pour le nom de la langue spécifiée. Retourné <xref:System.CodeDom.Compiler.CompilerInfo> instance contient les paramètres de compilateur et du fournisseur de langages configuré.  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> méthode vérifie si au moins une implémentation de fournisseur prend en charge une langue spécifique. Vous pouvez valider un nom de langue à l’aide <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> avant leur transmission à <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>. Cela empêche la levée une <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> lorsque vous accédez à la <xref:System.CodeDom.Compiler.CompilerInfo> instance pour un nom de langage non pris en charge.  
  
 Si plus d’une implémentation de fournisseur est configurée pour le nom de la langue d’entrée, <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> retourne les paramètres à partir du fournisseur correspondant dernier élément de configuration.  
  
 Les noms de langage respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant détermine le <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une langue d’entrée et affiche les paramètres configurés pour le fournisseur de langages. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">Le <paramref name="language" /> n'a pas de fournisseur configuré sur cet ordinateur.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException"><paramref name="language" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schéma des paramètres du fournisseur de langage et du compilateur</related>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetConverter : Type -&gt; System.ComponentModel.TypeConverter&#xA;override this.GetConverter : Type -&gt; System.ComponentModel.TypeConverter" Usage="codeDomProvider.GetConverter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Type d'objet pour lequel un convertisseur de type doit être récupéré.</param>
        <summary>Obtient <see cref="T:System.ComponentModel.TypeConverter" /> pour le type de données spécifié.</summary>
        <returns><see cref="T:System.ComponentModel.TypeConverter" /> pour le type spécifié, ou <see langword="null" /> si aucun <see cref="T:System.ComponentModel.TypeConverter" /> n'est trouvé pour le type spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une classe dérivée peut substituer cette méthode pour fournir des types spécifiques de convertisseurs de type pour les types de données spécifiques.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetLanguageFromExtension">
      <MemberSignature Language="C#" Value="public static string GetLanguageFromExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetLanguageFromExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLanguageFromExtension (extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetLanguageFromExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member GetLanguageFromExtension : string -&gt; string" Usage="System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="extension">Extension de nom de fichier.</param>
        <summary>Retourne un nom de langage associé à l'extension de nom de fichier spécifiée, comme configuré dans la section de configuration de compilateur <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</summary>
        <returns>Nom de langage associé à l'extension de nom de fichier, comme configuré dans les paramètres de configuration de compilateur <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans la configuration d’ordinateur fichier (Machine.config) contient les fournisseur et du compilateur configuration paramètres de langue pour chaque <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation sur le ordinateur. Le <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> méthode recherche chaque élément de configuration de fournisseur pour l’extension de nom de fichier spécifié.  
  
 Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> méthode vérifie si au moins une implémentation de fournisseur prend en charge une extension de nom de fichier spécifique. Vous pouvez valider une extension de nom de fichier à l’aide <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> avant leur transmission à <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>. Cela empêche <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> de lever un <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> pour une extension de nom de fichier non pris en charge.  
  
 Si une implémentation de fournisseur prend en charge l’extension de nom de fichier d’entrée et il existe plusieurs langues prises en charge configurés pour ce fournisseur, puis <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> retourne le premier nom de langage pour ce fournisseur. Si plus d’une implémentation de fournisseur est configurée pour l’extension de nom de fichier d’entrée, <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> retourne le nom de la langue à partir du fournisseur correspondant dernier élément de configuration.  
  
 Les noms de langage et les extensions de nom de fichier respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant détermine le <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une extension de nom de fichier d’entrée et affiche les paramètres configurés pour le fournisseur de langages. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException">Le <paramref name="extension" /> n'a pas de fournisseur de langages configuré sur cet ordinateur.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException"><paramref name="extension" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schéma des paramètres du fournisseur de langage et du compilateur</related>
      </Docs>
    </Member>
    <Member MemberName="GetTypeOutput">
      <MemberSignature Language="C#" Value="public virtual string GetTypeOutput (System.CodeDom.CodeTypeReference type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeOutput(class System.CodeDom.CodeTypeReference type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetTypeOutput(System.CodeDom.CodeTypeReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeOutput (type As CodeTypeReference) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeOutput(System::CodeDom::CodeTypeReference ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string&#xA;override this.GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string" Usage="codeDomProvider.GetTypeOutput type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.CodeDom.CodeTypeReference" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.CodeDom.CodeTypeReference" /> qui indique le type à retourner.</param>
        <summary>Obtient le type indiqué par le <see cref="T:System.CodeDom.CodeTypeReference" /> spécifié.</summary>
        <returns>Représentation textuelle du type spécifié, mise en forme pour le langage dans lequel du code est généré par ce générateur de code. En Visual Basic, par exemple, passer <see cref="T:System.CodeDom.CodeTypeReference" /> pour le type <see cref="T:System.Int32" /> retourne "Integer".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedExtension">
      <MemberSignature Language="C#" Value="public static bool IsDefinedExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedExtension (extension As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member IsDefinedExtension : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="extension">Extension de nom de fichier.</param>
        <summary>Vérifie si une implémentation de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> configurée sur l'ordinateur est associée à une extension de nom de fichier.</summary>
        <returns><see langword="true" /> si une implémentation de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> est configurée pour l'extension de nom de fichier spécifiée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans la configuration d’ordinateur fichier (Machine.config) contient les fournisseur et du compilateur configuration paramètres de langue pour chaque <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation sur le ordinateur. Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> méthode recherche les éléments de configuration de fournisseur pour l’extension de nom de fichier spécifié.  
  
 Extensions de nom de fichier respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant détermine le <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une extension de nom de fichier d’entrée et affiche les paramètres configurés pour le fournisseur de langages. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="extension" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schéma des paramètres du fournisseur de langage et du compilateur</related>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedLanguage">
      <MemberSignature Language="C#" Value="public static bool IsDefinedLanguage (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedLanguage(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedLanguage (language As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedLanguage(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member IsDefinedLanguage : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">Nom du langage.</param>
        <summary>Vérifie si un langage dispose d'une implémentation de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> configurée sur l'ordinateur.</summary>
        <returns><see langword="true" /> si une implémentation de <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> est configurée pour le langage spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [ &lt;system.codedom&gt; élément](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) dans la configuration d’ordinateur fichier (Machine.config) contient les fournisseur et du compilateur configuration paramètres de langue pour chaque <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation sur le ordinateur. Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> méthode recherche les éléments de configuration de fournisseur pour le nom de la langue spécifiée.  
  
 Les noms de langage respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant détermine le <xref:System.CodeDom.Compiler.CodeDomProvider> implémentation pour une langue d’entrée et affiche les paramètres configurés pour le fournisseur de langages. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.CodeDom.Compiler.CompilerInfo> classe.  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="language" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">pour la confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par du code d'un niveau de confiance partiel.</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">Schéma des paramètres du fournisseur de langage et du compilateur</related>
      </Docs>
    </Member>
    <Member MemberName="IsValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual bool IsValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsValidIdentifier (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsValidIdentifier : string -&gt; bool&#xA;override this.IsValidIdentifier : string -&gt; bool" Usage="codeDomProvider.IsValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à vérifier comme identificateur valide.</param>
        <summary>Retourne une valeur indiquant si la valeur spécifiée est un identificateur valide pour le langage actuel.</summary>
        <returns><see langword="true" /> si le paramètre <paramref name="value" /> est un identificateur valide ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode vérifie si un identificateur est valide. Le <xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A> méthode est spécifique au fournisseur. Les identificateurs qui sont valides pour un fournisseur n’est peut-être pas valides pour les autres fournisseurs. Si `value` contient des caractères en dehors de la plage de caractères ASCII, vérifiez l’identificateur pour tous les langages qui pourraient être utilisées pour compiler le code.  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" /> dans une classe dérivée, définissez la méthode pour retourner <see langword="true" /> uniquement si la valeur respecte les règles du langage et n’est pas en conflit avec un mot clé.  
  
Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
      </Docs>
    </Member>
    <Member MemberName="LanguageOptions">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.LanguageOptions LanguageOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.CodeDom.Compiler.LanguageOptions LanguageOptions" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LanguageOptions As LanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::CodeDom::Compiler::LanguageOptions LanguageOptions { System::CodeDom::Compiler::LanguageOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOptions : System.CodeDom.Compiler.LanguageOptions" Usage="System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.LanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un identificateur de fonctionnalités de langage.</summary>
        <value><see cref="T:System.CodeDom.Compiler.LanguageOptions" /> qui indique les fonctionnalités spéciales du langage.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.CodeCompileUnit Parse (System.IO.TextReader codeStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.CodeCompileUnit Parse(class System.IO.TextReader codeStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Parse(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Parse (codeStream As TextReader) As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::CodeCompileUnit ^ Parse(System::IO::TextReader ^ codeStream);" />
      <MemberSignature Language="F#" Value="abstract member Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit&#xA;override this.Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit" Usage="codeDomProvider.Parse codeStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeStream" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeStream">Objet <see cref="T:System.IO.TextReader" /> utilisé pour lire le code à analyser.</param>
        <summary>Compile le code lu à partir du flux de texte spécifié dans <see cref="T:System.CodeDom.CodeCompileUnit" />.</summary>
        <returns><see cref="T:System.CodeDom.CodeCompileUnit" /> contenant une représentation du code analysé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeParser> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeParser> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un analyseur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des analyseurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeParser" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas d’analyseur de code.</para></block>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.IO.TextReader" />
      </Docs>
    </Member>
    <Member MemberName="Supports">
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport generatorSupport) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2" />
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport supports) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports generatorSupport" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports supports" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generatorSupport" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="supports" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generatorSupport">Objet <see cref="T:System.CodeDom.Compiler.GeneratorSupport" /> indiquant le type de prise en charge de la génération de code à vérifier.</param>
        <param name="supports">To be added.</param>
        <summary>Retourne une valeur indiquant si la prise en charge de la génération de code spécifiée est fournie.</summary>
        <returns><see langword="true" /> si la prise en charge de la génération de code spécifiée est fournie ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée avec un nombre de <xref:System.CodeDom.Compiler.GeneratorSupport> indicateurs à la fois pour tester un ensemble de fonctionnalités en combinant un ensemble d’indicateurs appropriés ainsi que d’un fichier binaire `OR` opérateur (&#124;).  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cette méthode est fournie par le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation qui est retournée par la <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> méthode du fournisseur. Dans la version 2.0, cette méthode peut être appelée directement sur le fournisseur de code, même si elle n’est pas remplacée par le fournisseur de code. Si le fournisseur de code ne remplace pas cette méthode, le <xref:System.CodeDom.Compiler.ICodeGenerator> implémentation est appelée par la classe de base.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Ni cette méthode ni la méthode <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> ne sont substituées dans une classe dérivée.</exception>
        <block subset="none" type="overrides"><para>Si vous substituez cette méthode, vous ne devez pas appeler la méthode correspondante de la classe de base. La méthode de classe de base crée un générateur dans la classe dérivée à l’aide de l’élément obsolète <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> méthode pour assurer la compatibilité avec des fournisseurs préexistants qui utilisent des générateurs de code. La méthode de classe de base appelle ensuite la méthode équivalente dans le <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implémentation pour exécuter cette fonction. Vous obtiendrez un <see cref="T:System.NotImplementedException" /> si vous appelez la méthode de classe de base à partir d’un fournisseur de code qui n’utilise pas un générateur de code.</para></block>
        <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
      </Docs>
    </Member>
  </Members>
</Type>