<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata><Meta Name="ms.openlocfilehash" Value="22d00f07f020bfde53c8853e9755c40a7d2411fe" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52592127" /></Metadata><TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="850a0-101">Représente un assembly, qui est un bloc de construction réutilisable, avec un numéro de version et autodescriptif d'une application du Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="850a0-101">Represents an assembly, which is a reusable, versionable, and self-describing building block of a common language runtime application.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-102">Utilisez la <xref:System.Reflection.Assembly> classe pour charger les assemblys, pour Explorer les parties de métadonnées et constituant des assemblys, pour découvrir les types contenus dans les assemblys et pour créer des instances de ces types.</span><span class="sxs-lookup"><span data-stu-id="850a0-102">Use the <xref:System.Reflection.Assembly> class to load assemblies, to explore the metadata and constituent parts of assemblies, to discover the types contained in assemblies, and to create instances of those types.</span></span>  
  
 <span data-ttu-id="850a0-103">Pour obtenir un tableau de <xref:System.Reflection.Assembly> objets représentant les assemblys actuellement chargés dans un domaine d’application (par exemple, la valeur par défaut domaine d’application d’un projet simple), utilisez le <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="850a0-103">To get an array of <xref:System.Reflection.Assembly> objects representing the assemblies currently loaded into an application domain (for example, the default application domain of a simple project), use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="850a0-104">Charger des assemblys de façon dynamique, le <xref:System.Reflection.Assembly> classe fournit les méthodes statiques suivantes (`Shared` méthodes en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="850a0-104">To load assemblies dynamically, the <xref:System.Reflection.Assembly> class provides the following static methods (`Shared` methods in Visual Basic).</span></span> <span data-ttu-id="850a0-105">Assemblys sont chargés dans le domaine d’application où l’opération de chargement se produit.</span><span class="sxs-lookup"><span data-stu-id="850a0-105">Assemblies are loaded into the application domain where the load operation occurs.</span></span>  
  
-   <span data-ttu-id="850a0-106">La méthode recommandée pour charger des assemblys consiste à utiliser le <xref:System.AppDomain.Load%2A> (méthode), qui identifie l’assembly à charger par son nom complet (par exemple, « System.Windows.Forms, Version = 2.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089 »).</span><span class="sxs-lookup"><span data-stu-id="850a0-106">The recommended way to load assemblies is to use the <xref:System.AppDomain.Load%2A> method, which identifies the assembly to be loaded by its display name (for example, "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089").</span></span> <span data-ttu-id="850a0-107">La recherche de l’assembly suit les règles décrites dans [méthode de localisation des assemblys par le Runtime](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="850a0-107">The search for the assembly follows the rules described in [How the Runtime Locates Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).</span></span>  
  
-   <span data-ttu-id="850a0-108">Le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> et <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> méthodes permettent de charger un assembly pour la réflexion, mais pas pour l’exécution.</span><span class="sxs-lookup"><span data-stu-id="850a0-108">The <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods enable you to load an assembly for reflection, but not for execution.</span></span> <span data-ttu-id="850a0-109">Par exemple, un assembly qui cible une plateforme 64 bits peut être examiné par le code qui s’exécute sur une plateforme 32 bits.</span><span class="sxs-lookup"><span data-stu-id="850a0-109">For example, an assembly that targets a 64-bit platform can be examined by code that is running on a 32-bit platform.</span></span>  
  
-   <span data-ttu-id="850a0-110">Le <xref:System.Reflection.Assembly.LoadFile%2A> et <xref:System.Reflection.Assembly.LoadFrom%2A> méthodes sont fournies pour les rares scénarios dans lesquels un assembly doit être identifié par le chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="850a0-110">The <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A> methods are provided for rare scenarios in which an assembly must be identified by path.</span></span>  
  
 <span data-ttu-id="850a0-111">Pour obtenir un <xref:System.Reflection.Assembly> objet pour l’assembly en cours d’exécution, utilisez le <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="850a0-111">To get an <xref:System.Reflection.Assembly> object for the currently executing assembly, use the <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> method.</span></span>  
  
 <span data-ttu-id="850a0-112">De nombreux membres de la <xref:System.Reflection.Assembly> classe fournissent des informations sur un assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-112">Many members of the <xref:System.Reflection.Assembly> class provide information about an assembly.</span></span> <span data-ttu-id="850a0-113">Exemple :</span><span class="sxs-lookup"><span data-stu-id="850a0-113">For example:</span></span>  
  
-   <span data-ttu-id="850a0-114">Le <xref:System.Reflection.Assembly.GetName%2A> méthode retourne un <xref:System.Reflection.AssemblyName> objet qui fournit l’accès aux parties du nom d’affichage de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-114">The <xref:System.Reflection.Assembly.GetName%2A> method returns an <xref:System.Reflection.AssemblyName> object that provides access to the parts of the assembly display name.</span></span>  
  
-   <span data-ttu-id="850a0-115">Le <xref:System.Reflection.Assembly.GetCustomAttributes%2A> méthode répertorie les attributs appliqués à l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-115">The <xref:System.Reflection.Assembly.GetCustomAttributes%2A> method lists the attributes applied to the assembly.</span></span>  
  
-   <span data-ttu-id="850a0-116">Le <xref:System.Reflection.Assembly.GetFiles%2A> méthode permet d’accéder aux fichiers dans le manifeste d’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-116">The <xref:System.Reflection.Assembly.GetFiles%2A> method provides access to the files in the assembly manifest.</span></span>  
  
-   <span data-ttu-id="850a0-117">Le <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> méthode fournit les noms des ressources dans le manifeste d’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-117">The <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> method provides the names of the resources in the assembly manifest.</span></span>  
  
 <span data-ttu-id="850a0-118">Le <xref:System.Reflection.Assembly.GetTypes%2A> méthode répertorie tous les types dans l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-118">The <xref:System.Reflection.Assembly.GetTypes%2A> method lists all the types in the assembly.</span></span> <span data-ttu-id="850a0-119">Le <xref:System.Reflection.Assembly.GetExportedTypes%2A> méthode répertorie les types qui sont visibles par les appelants à l’extérieur de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-119">The <xref:System.Reflection.Assembly.GetExportedTypes%2A> method lists the types that are visible to callers outside the assembly.</span></span> <span data-ttu-id="850a0-120">Le <xref:System.Reflection.Assembly.GetType%2A> méthode peut être utilisée pour rechercher un type particulier dans l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-120">The <xref:System.Reflection.Assembly.GetType%2A> method can be used to search for a particular type in the assembly.</span></span> <span data-ttu-id="850a0-121">Le <xref:System.Reflection.Assembly.CreateInstance%2A> méthode peut être utilisée pour rechercher et créer des instances de types dans l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-121">The <xref:System.Reflection.Assembly.CreateInstance%2A> method can be used to search for and create instances of types in the assembly.</span></span>  
  
 <span data-ttu-id="850a0-122">Pour plus d’informations sur les assemblys, consultez la section « Domaines d’Application et assemblys » dans le [domaines d’Application](~/docs/framework/app-domains/application-domains.md) rubrique.</span><span class="sxs-lookup"><span data-stu-id="850a0-122">For more information on assemblies, see the "Application Domains and Assemblies" section in the [Application Domains](~/docs/framework/app-domains/application-domains.md) topic.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-123">L’exemple de code suivant montre comment obtenir l’assembly en cours d’exécution, créez une instance d’un type contenu dans cet assembly et appeler une des méthodes du type avec une liaison tardive.</span><span class="sxs-lookup"><span data-stu-id="850a0-123">The following code example shows how to obtain the currently executing assembly, create an instance of a type contained in that assembly, and invoke one of the type's methods with late binding.</span></span> <span data-ttu-id="850a0-124">Pour cela, l’exemple de code définit une classe nommée `Example`, avec une méthode nommée `SampleMethod`.</span><span class="sxs-lookup"><span data-stu-id="850a0-124">For this purpose, the code example defines a class named `Example`, with a method named `SampleMethod`.</span></span> <span data-ttu-id="850a0-125">Le constructeur de la classe accepte un entier, qui est utilisé pour calculer la valeur de retour de la méthode.</span><span class="sxs-lookup"><span data-stu-id="850a0-125">The constructor of the class accepts an integer, which is used to compute the return value of the method.</span></span>  
  
 <span data-ttu-id="850a0-126">L’exemple de code illustre également l’utilisation de la <xref:System.Reflection.Assembly.GetName%2A> méthode pour obtenir un <xref:System.Reflection.AssemblyName> objet qui peut être utilisé pour analyser le nom complet de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-126">The code example also demonstrates the use of the <xref:System.Reflection.Assembly.GetName%2A> method to obtain an <xref:System.Reflection.AssemblyName> object that can be used to parse the full name of the assembly.</span></span> <span data-ttu-id="850a0-127">L’exemple affiche le numéro de version de l’assembly, le <xref:System.Reflection.Assembly.CodeBase%2A> propriété et le <xref:System.Reflection.Assembly.EntryPoint%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="850a0-127">The example displays the version number of the assembly, the <xref:System.Reflection.Assembly.CodeBase%2A> property, and the <xref:System.Reflection.Assembly.EntryPoint%2A> property.</span></span>  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="850a0-128">pour la confiance totale pour les héritiers.</span><span class="sxs-lookup"><span data-stu-id="850a0-128">for full trust for inheritors.</span></span> <span data-ttu-id="850a0-129">Cette classe ne peut pas être héritée par du code partiellement fiable.</span><span class="sxs-lookup"><span data-stu-id="850a0-129">This class cannot be inherited by partially trusted code.</span></span></permission>
    <threadsafe><span data-ttu-id="850a0-130">Ce type est thread-safe.</span><span class="sxs-lookup"><span data-stu-id="850a0-130">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
    <related type="Article" href="~/docs/framework/app-domains/application-domains.md"><span data-ttu-id="850a0-131">Domaines d'application</span><span class="sxs-lookup"><span data-stu-id="850a0-131">Application Domains</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-132">Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-132">Initializes a new instance of the <see cref="T:System.Reflection.Assembly" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-133">Ce constructeur est appelé par les classes dérivées lors de la construction de <xref:System.Reflection.Assembly> objets.</span><span class="sxs-lookup"><span data-stu-id="850a0-133">This constructor is invoked by derived classes during the construction of <xref:System.Reflection.Assembly> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-134">Obtient l'emplacement de l'assembly tel qu'il a été spécifié à l'origine, par exemple dans un objet <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-134">Gets the location of the assembly as specified originally, for example, in an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span></summary>
        <value><span data-ttu-id="850a0-135">Emplacement de l'assembly tel qu'il a été spécifié à l'origine.</span><span class="sxs-lookup"><span data-stu-id="850a0-135">The location of the assembly as specified originally.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-136">Pour obtenir le chemin d’accès absolu du fichier chargé qui contient le manifeste, utilisez le <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> propriété à la place.</span><span class="sxs-lookup"><span data-stu-id="850a0-136">To get the absolute path to the loaded manifest-containing file, use the <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> property instead.</span></span>  
  
 <span data-ttu-id="850a0-137">Si l’assembly a été chargé en tant que tableau d’octets, à l’aide d’une surcharge de la <xref:System.Reflection.Assembly.Load%2A> méthode qui accepte un tableau d’octets, cette propriété retourne l’emplacement de l’appelant de la méthode, et non l’emplacement de l’assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-137">If the assembly was loaded as a byte array, using an overload of the <xref:System.Reflection.Assembly.Load%2A> method that takes an array of bytes, this property returns the location of the caller of the method, not the location of the loaded assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-138">L’exemple suivant utilise le <xref:System.Reflection.Assembly.CodeBase%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="850a0-138">The following example uses the <xref:System.Reflection.Assembly.CodeBase%2A> property.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="850a0-139">Pour accéder au chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="850a0-139">for access to the path.</span></span> <span data-ttu-id="850a0-140">Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="850a0-140">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="850a0-141">Recherche un type dans cet assembly et en crée une instance à l'aide de l'activateur système.</span><span class="sxs-lookup"><span data-stu-id="850a0-141">Locates a type from this assembly and creates an instance of it using the system activator.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="850a0-142">Propriété <see cref="P:System.Type.FullName" /> du type à rechercher.</span><span class="sxs-lookup"><span data-stu-id="850a0-142">The <see cref="P:System.Type.FullName" /> of the type to locate.</span></span></param>
        <summary><span data-ttu-id="850a0-143">Recherche le type spécifié dans cet assembly et en crée une instance à l'aide de l'activateur système, avec une recherche respectant la casse.</span><span class="sxs-lookup"><span data-stu-id="850a0-143">Locates the specified type from this assembly and creates an instance of it using the system activator, using case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="850a0-144">Une instance du type spécifié créée avec le constructeur par défaut, ou <see langword="null" /> si <paramref name="typeName" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-144">An instance of the specified type created with the default constructor; or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="850a0-145">Le type est résolu à l'aide du binder par défaut, sans spécifier d'attributs de culture ou d'activation, et avec <see cref="T:System.Reflection.BindingFlags" /> défini sur <see langword="Public" /> ou <see langword="Instance" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-145">The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to <see langword="Public" /> or <see langword="Instance" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-146">Si le runtime ne peut pas trouver `typeName` dans le <xref:System.Reflection.Assembly> de l’instance, elle retourne `null` au lieu de lever une exception.</span><span class="sxs-lookup"><span data-stu-id="850a0-146">If the runtime is unable to find `typeName` in the <xref:System.Reflection.Assembly> instance, it returns `null` instead of throwing an exception.</span></span> <span data-ttu-id="850a0-147">Cela peut se produire si :</span><span class="sxs-lookup"><span data-stu-id="850a0-147">This might happen because:</span></span>  
  
-   <span data-ttu-id="850a0-148">Vous n’avez pas spécifié le nom qualifié complet du type.</span><span class="sxs-lookup"><span data-stu-id="850a0-148">You haven't specified the fully qualified name of the type.</span></span>  
  
-   <span data-ttu-id="850a0-149">Vous avez spécifié le nom de type qualifié complet, mais son cas ne correspond pas à la casse de du type <xref:System.Type.FullName%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="850a0-149">You've specified the fully qualified type name, but its case doesn't match the case of the type's <xref:System.Type.FullName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="850a0-150">Pour une comparaison respectant la casse de `typeName` avec le nom du type complet, appelez le <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> surcharge et spécifiez `true` pour le `ignoreCase` argument.</span><span class="sxs-lookup"><span data-stu-id="850a0-150">For a case-insensitive comparison of `typeName` with the type's full name, call the <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload and specify `true` for the `ignoreCase` argument.</span></span>  
  
-   <span data-ttu-id="850a0-151">Le type n’existe pas dans le courant <xref:System.Reflection.Assembly> instance.</span><span class="sxs-lookup"><span data-stu-id="850a0-151">The type doesn't exist in the current <xref:System.Reflection.Assembly> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-152">L’exemple suivant définit un `Person` classe et appelle le <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> méthode pour l’instancier.</span><span class="sxs-lookup"><span data-stu-id="850a0-152">The following example defines a `Person` class and calls the <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> method to instantiate it.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-153"><paramref name="typeName" /> est une chaîne vide ("") ou une chaîne commençant par un caractère Null.</span><span class="sxs-lookup"><span data-stu-id="850a0-153"><paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span></span>  
  
<span data-ttu-id="850a0-154">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-154">-or-</span></span> 
<span data-ttu-id="850a0-155">L’assembly actuel a été chargé dans le contexte ReflectionOnly.</span><span class="sxs-lookup"><span data-stu-id="850a0-155">The current assembly was loaded into the reflection-only context.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-156"><paramref name="typeName" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-156"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="850a0-157">Aucun constructeur correspondant n’a été trouvé.</span><span class="sxs-lookup"><span data-stu-id="850a0-157">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-158"><paramref name="typeName" /> requiert un assembly dépendant qui est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-158"><paramref name="typeName" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-159"><paramref name="typeName" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-159"><paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="850a0-160">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-160">-or-</span></span> 
<span data-ttu-id="850a0-161">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="typeName" /> nécessite un assembly dépendant qui n’a pas été préchargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-161">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-162"><paramref name="typeName" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-162"><paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-163">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-163">-or-</span></span> 
 <span data-ttu-id="850a0-164"><paramref name="typeName" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</span><span class="sxs-lookup"><span data-stu-id="850a0-164"><paramref name="typeName" /> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="850a0-165">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-165">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="850a0-166">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="850a0-166">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="850a0-167">Propriété <see cref="P:System.Type.FullName" /> du type à rechercher.</span><span class="sxs-lookup"><span data-stu-id="850a0-167">The <see cref="P:System.Type.FullName" /> of the type to locate.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="850a0-168"><see langword="true" /> pour ignorer la casse du nom de type ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-168"><see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="850a0-169">Recherche le type spécifié dans cet assembly et en crée une instance à l'aide de l'activateur système, avec une recherche facultative respectant la casse.</span><span class="sxs-lookup"><span data-stu-id="850a0-169">Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="850a0-170">Une instance du type spécifié créée avec le constructeur par défaut, ou <see langword="null" /> si <paramref name="typeName" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-170">An instance of the specified type created with the default constructor; or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="850a0-171">Le type est résolu à l'aide du binder par défaut, sans spécifier d'attributs de culture ou d'activation, et avec <see cref="T:System.Reflection.BindingFlags" /> défini sur <see langword="Public" /> ou <see langword="Instance" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-171">The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to <see langword="Public" /> or <see langword="Instance" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-172">Si le runtime ne peut pas trouver `typeName` dans le <xref:System.Reflection.Assembly> de l’instance, elle retourne `null` au lieu de lever une exception.</span><span class="sxs-lookup"><span data-stu-id="850a0-172">If the runtime is unable to find `typeName` in the <xref:System.Reflection.Assembly> instance, it returns `null` instead of throwing an exception.</span></span> <span data-ttu-id="850a0-173">Cela peut se produire si :</span><span class="sxs-lookup"><span data-stu-id="850a0-173">This might happen because:</span></span>  
  
-   <span data-ttu-id="850a0-174">Vous n’avez pas spécifié le nom qualifié complet du type.</span><span class="sxs-lookup"><span data-stu-id="850a0-174">You haven't specified the fully qualified name of the type.</span></span>  
  
-   <span data-ttu-id="850a0-175">Le type n’existe pas dans le courant <xref:System.Reflection.Assembly> instance.</span><span class="sxs-lookup"><span data-stu-id="850a0-175">The type doesn't exist in the current <xref:System.Reflection.Assembly> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-176">L’exemple suivant définit un `Person` classe.</span><span class="sxs-lookup"><span data-stu-id="850a0-176">The following example defines a `Person` class.</span></span> <span data-ttu-id="850a0-177">Il appelle ensuite la <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> méthode pour instancier, mais étant donné que la casse de la `typeName` argument ne correspond pas à celui du type <xref:System.Type.FullName%2A> propriété, la méthode retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="850a0-177">It then calls the <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> method to instantiate it, but because the casing of the `typeName` argument doesn't match that of the type's <xref:System.Type.FullName%2A> property, the method returns `null`.</span></span> <span data-ttu-id="850a0-178">Lorsque l’exemple passe la même chaîne pour le <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> surcharge et spécifie que la comparaison doit être pas la casse, le `Person` classe se trouve et un `Person` objet est instancié avec succès.</span><span class="sxs-lookup"><span data-stu-id="850a0-178">When the example passes the same string to the <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload and specifies that the comparison should be case-insensitive, the `Person` class is found, and a `Person` object is successfully instantiated.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-179"><paramref name="typeName" /> est une chaîne vide ("") ou une chaîne commençant par un caractère Null.</span><span class="sxs-lookup"><span data-stu-id="850a0-179"><paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span></span>  
  
<span data-ttu-id="850a0-180">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-180">-or-</span></span> 
<span data-ttu-id="850a0-181">L’assembly actuel a été chargé dans le contexte ReflectionOnly.</span><span class="sxs-lookup"><span data-stu-id="850a0-181">The current assembly was loaded into the reflection-only context.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="850a0-182">Aucun constructeur correspondant n’a été trouvé.</span><span class="sxs-lookup"><span data-stu-id="850a0-182">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-183"><paramref name="typeName" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-183"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-184"><paramref name="typeName" /> nécessite un assembly dépendant qui est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-184"><paramref name="typeName" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-185"><paramref name="typeName" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-185"><paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="850a0-186">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-186">-or-</span></span> 
<span data-ttu-id="850a0-187">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="typeName" /> nécessite un assembly dépendant qui n’a pas été préchargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-187">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-188"><paramref name="typeName" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-188"><paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-189">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-189">-or-</span></span> 
 <span data-ttu-id="850a0-190"><paramref name="typeName" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</span><span class="sxs-lookup"><span data-stu-id="850a0-190"><paramref name="typeName" /> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="850a0-191">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-191">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="850a0-192">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="850a0-192">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="850a0-193">Propriété <see cref="P:System.Type.FullName" /> du type à rechercher.</span><span class="sxs-lookup"><span data-stu-id="850a0-193">The <see cref="P:System.Type.FullName" /> of the type to locate.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="850a0-194"><see langword="true" /> pour ignorer la casse du nom de type ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-194"><see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="850a0-195">Masque de bits qui affecte la manière dont la recherche est effectuée.</span><span class="sxs-lookup"><span data-stu-id="850a0-195">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="850a0-196">La valeur est une combinaison de bits indicateurs de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-196">The value is a combination of bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <param name="binder"><span data-ttu-id="850a0-197">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see langword="MemberInfo" /> par le biais de la réflexion.</span><span class="sxs-lookup"><span data-stu-id="850a0-197">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span></span> <span data-ttu-id="850a0-198">Si <paramref name="binder" /> est <see langword="null" />, le binder par défaut est utilisé.</span><span class="sxs-lookup"><span data-stu-id="850a0-198">If <paramref name="binder" /> is <see langword="null" />, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="850a0-199">Tableau qui contient les arguments à passer au constructeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-199">An array that contains the arguments to be passed to the constructor.</span></span> <span data-ttu-id="850a0-200">Ce tableau d'arguments doit posséder les mêmes nombres, ordre et type que les paramètres du constructeur à appeler.</span><span class="sxs-lookup"><span data-stu-id="850a0-200">This array of arguments must match in number, order, and type the parameters of the constructor to be invoked.</span></span> <span data-ttu-id="850a0-201">Si vous souhaitez utiliser le constructeur par défaut, <paramref name="args" /> doit être un tableau vide ou <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-201">If the default constructor is desired, <paramref name="args" /> must be an empty array or <see langword="null" />.</span></span></param>
        <param name="culture"><span data-ttu-id="850a0-202">Instance de <see langword="CultureInfo" /> utilisée pour régir la contrainte des types.</span><span class="sxs-lookup"><span data-stu-id="850a0-202">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="850a0-203">Si la valeur est <see langword="null" />, le <see langword="CultureInfo" /> du thread actuel est utilisé.</span><span class="sxs-lookup"><span data-stu-id="850a0-203">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span> <span data-ttu-id="850a0-204">(Par exemple, cela est nécessaire pour convertir un <see langword="String" /> représentant 1000 en valeur <see langword="Double" />, car 1000 est représenté de différentes manières selon la culture.)</span><span class="sxs-lookup"><span data-stu-id="850a0-204">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="850a0-205">Tableau à un ou plusieurs attributs pouvant participer à l'activation.</span><span class="sxs-lookup"><span data-stu-id="850a0-205">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="850a0-206">En général, tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.</span><span class="sxs-lookup"><span data-stu-id="850a0-206">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  <span data-ttu-id="850a0-207">Ce paramètre est lié aux objets activés par le client.</span><span class="sxs-lookup"><span data-stu-id="850a0-207">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="850a0-208">L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement.</span><span class="sxs-lookup"><span data-stu-id="850a0-208">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="850a0-209">Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="850a0-209">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="850a0-210">Recherche le type spécifié dans cet assembly et en crée une instance à l'aide de l'activateur système, avec une recherche facultative respectant la casse et possédant la culture, les arguments, ainsi que les attributs de liaison et d'activation spécifiés.</span><span class="sxs-lookup"><span data-stu-id="850a0-210">Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search and having the specified culture, arguments, and binding and activation attributes.</span></span></summary>
        <returns><span data-ttu-id="850a0-211">Une instance du type spécifié ou <see langword="null" /> si <paramref name="typeName" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-211">An instance of the specified type, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="850a0-212">Les arguments fournis sont utilisés pour résoudre le type, et lier le constructeur utilisé pour créer l'instance.</span><span class="sxs-lookup"><span data-stu-id="850a0-212">The supplied arguments are used to resolve the type, and to bind the constructor that is used to create the instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-213"><paramref name="typeName" /> est une chaîne vide ("") ou une chaîne commençant par un caractère null.</span><span class="sxs-lookup"><span data-stu-id="850a0-213"><paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span></span>  
  
<span data-ttu-id="850a0-214">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-214">-or-</span></span> 
<span data-ttu-id="850a0-215">L’assembly actuel a été chargé dans le contexte ReflectionOnly.</span><span class="sxs-lookup"><span data-stu-id="850a0-215">The current assembly was loaded into the reflection-only context.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-216"><paramref name="typeName" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-216"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="850a0-217">Aucun constructeur correspondant n’a été trouvé.</span><span class="sxs-lookup"><span data-stu-id="850a0-217">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="850a0-218">Un tableau d’attributs d’activation non vides est passé à un type qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-218">A non-empty activation attributes array is passed to a type that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-219"><paramref name="typeName" /> nécessite un assembly dépendant qui est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-219"><paramref name="typeName" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-220"><paramref name="typeName" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-220"><paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="850a0-221">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-221">-or-</span></span> 
<span data-ttu-id="850a0-222">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="typeName" /> nécessite un assembly dépendant qui n’a pas été préchargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-222">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-223"><paramref name="typeName" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-223"><paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-224">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-224">-or-</span></span> 
 <span data-ttu-id="850a0-225"><paramref name="typeName" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</span><span class="sxs-lookup"><span data-stu-id="850a0-225"><paramref name="typeName" /> requires a dependent assembly which that was compiled for a version of the runtime that is later than the currently loaded version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="850a0-226">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-226">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="850a0-227">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="850a0-227">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="850a0-228">Pour créer une instance d’un délégué.</span><span class="sxs-lookup"><span data-stu-id="850a0-228">to create an instance of a delegate.</span></span> <span data-ttu-id="850a0-229">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="850a0-229">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="850a0-230">Nom complet d'un assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-230">The display name of an assembly.</span></span></param>
        <param name="typeName"><span data-ttu-id="850a0-231">Nom complet d'un type.</span><span class="sxs-lookup"><span data-stu-id="850a0-231">The full name of a type.</span></span></param>
        <summary><span data-ttu-id="850a0-232">Crée le nom d'un type qualifié par le nom complet de son assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-232">Creates the name of a type qualified by the display name of its assembly.</span></span></summary>
        <returns><span data-ttu-id="850a0-233">Nom complet du type complet par le nom d'affichage de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-233">The full name of the type qualified by the display name of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-234">Le format de la chaîne retournée est :</span><span class="sxs-lookup"><span data-stu-id="850a0-234">The format of the returned string is:</span></span>  
  
 <span data-ttu-id="850a0-235">\<FullTypeName>, \<AssemblyDisplayName></span><span class="sxs-lookup"><span data-stu-id="850a0-235">\<FullTypeName>, \<AssemblyDisplayName></span></span>  
  
 <span data-ttu-id="850a0-236">Consultez <xref:System.Reflection.AssemblyName> pour obtenir une description du format du nom complet d’un assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-236">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
 <span data-ttu-id="850a0-237">Pour prendre en compte les modifications dans les versions du common language runtime, utilisez cette méthode, plutôt que de construire le nom qualifié vous-même.</span><span class="sxs-lookup"><span data-stu-id="850a0-237">To accommodate changes in versions of the common language runtime, use this method rather than constructing the qualified name yourself.</span></span>  <span data-ttu-id="850a0-238">Pour plus d’informations sur les noms d’assemblys qualifiés, consultez <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="850a0-238">For information about qualified assembly names, see <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-239">Obtient une collection qui contient les attributs personnalisés de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-239">Gets a collection that contains this assembly's custom attributes.</span></span></summary>
        <value><span data-ttu-id="850a0-240">Collection qui contient les attributs personnalisés de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-240">A collection that contains this assembly's custom attributes.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-241">Obtient une collection des types définis dans cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-241">Gets a collection of the types defined in this assembly.</span></span></summary>
        <value><span data-ttu-id="850a0-242">Collection des types définis dans cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-242">A collection of the types defined in this assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-243">Le <xref:System.Reflection.Assembly.DefinedTypes%2A> propriété est comparable à la <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> (méthode), à ceci près que le <xref:System.Reflection.Assembly.DefinedTypes%2A> propriété retourne une collection de <xref:System.Reflection.TypeInfo> objets et le <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> méthode retourne un tableau de <xref:System.Type> objets.</span><span class="sxs-lookup"><span data-stu-id="850a0-243">The <xref:System.Reflection.Assembly.DefinedTypes%2A> property is comparable to the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method, except that the <xref:System.Reflection.Assembly.DefinedTypes%2A> property returns a collection of <xref:System.Reflection.TypeInfo> objects, and the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method returns an array of <xref:System.Type> objects.</span></span>  
  
 <span data-ttu-id="850a0-244">Le tableau retourné inclut des types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="850a0-244">The returned array includes nested types.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-245">Obtient le point d'entrée de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-245">Gets the entry point of this assembly.</span></span></summary>
        <value><span data-ttu-id="850a0-246">Objet qui représente le point d'entrée de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-246">An object that represents the entry point of this assembly.</span></span> <span data-ttu-id="850a0-247">Si aucun point d'entrée n'est détecté (par exemple, si l'assembly est une DLL), <see langword="null" /> est retourné.</span><span class="sxs-lookup"><span data-stu-id="850a0-247">If no entry point is found (for example, the assembly is a DLL), <see langword="null" /> is returned.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="850a0-248">Objet à comparer avec cette instance.</span><span class="sxs-lookup"><span data-stu-id="850a0-248">The object to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="850a0-249">Détermine si cet assembly et l'objet spécifié sont égaux.</span><span class="sxs-lookup"><span data-stu-id="850a0-249">Determines whether this assembly and the specified object are equal.</span></span></summary>
        <returns><span data-ttu-id="850a0-250"><see langword="true" /> si <paramref name="o" /> est égal à cette instance ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-250"><see langword="true" /> if <paramref name="o" /> is equal to this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-251">Le <xref:System.Reflection.Assembly.Equals%2A> méthode effectue un test d’égalité de référence déterminer si l’instance actuelle et `o` sont égaux.</span><span class="sxs-lookup"><span data-stu-id="850a0-251">The <xref:System.Reflection.Assembly.Equals%2A> method performs a test for reference equality to determine whether the current instance and `o` are equal.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-252">Obtient l'URI, y compris les caractères d'espacement, qui représente le code base.</span><span class="sxs-lookup"><span data-stu-id="850a0-252">Gets the URI, including escape characters, that represents the codebase.</span></span></summary>
        <value><span data-ttu-id="850a0-253">Un URI avec des caractères d'espacement.</span><span class="sxs-lookup"><span data-stu-id="850a0-253">A URI with escape characters.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="850a0-254">Pour accéder au chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="850a0-254">for access to the path.</span></span> <span data-ttu-id="850a0-255">Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="850a0-255">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-256">Obtient la preuve pour cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-256">Gets the evidence for this assembly.</span></span></summary>
        <value><span data-ttu-id="850a0-257">Preuve pour cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-257">The evidence for this assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-258">La preuve est le jeu d'informations qui alimente les décisions de stratégie de sécurité, telles que les autorisations qui peuvent être accordées au code.</span><span class="sxs-lookup"><span data-stu-id="850a0-258">Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="850a0-259">pour charger un assembly avec la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-259">to load an assembly with evidence.</span></span> <span data-ttu-id="850a0-260">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="850a0-260">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-261">Obtient une collection des types publics définis dans cet assembly qui sont visibles à l’extérieur de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-261">Gets a collection of the public types defined in this assembly that are visible outside the assembly.</span></span></summary>
        <value><span data-ttu-id="850a0-262">Collection des types publics définis dans cet assembly qui sont visibles à l’extérieur de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-262">A collection of the public types defined in this assembly that are visible outside the assembly.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-263">Obtient le nom complet de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-263">Gets the display name of the assembly.</span></span></summary>
        <value><span data-ttu-id="850a0-264">Nom complet de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-264">The display name of the assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-265">Consultez <xref:System.Reflection.AssemblyName> pour obtenir une description du format du nom complet d’un assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-265">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-266">Écrire votre propre code pour analyser les noms d’affichage n’est pas recommandée.</span><span class="sxs-lookup"><span data-stu-id="850a0-266">Writing your own code to parse display names is not recommended.</span></span> <span data-ttu-id="850a0-267">Au lieu de cela, passez le nom de l’affichage à la <xref:System.Reflection.AssemblyName.%23ctor%2A> constructeur, qui analyse et remplit les champs appropriés du nouveau <xref:System.Reflection.AssemblyName>.</span><span class="sxs-lookup"><span data-stu-id="850a0-267">Instead, pass the display name to the <xref:System.Reflection.AssemblyName.%23ctor%2A> constructor, which parses it and populates the appropriate fields of the new <xref:System.Reflection.AssemblyName>.</span></span>  
  
 <span data-ttu-id="850a0-268">Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-268">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="850a0-269">Toutefois, il n’est pas inclus dans la chaîne retournée par la <xref:System.Reflection.Assembly.FullName%2A> propriété, pour des raisons de compatibilité.</span><span class="sxs-lookup"><span data-stu-id="850a0-269">However, it is not included in the string returned by the <xref:System.Reflection.Assembly.FullName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="850a0-270">Consultez <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="850a0-270">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-271">L’exemple suivant récupère le nom complet de l’assembly en cours d’exécution et le nom complet de l’assembly qui contient le <xref:System.Int32> type (`int` en c#, `Integer` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="850a0-271">The following example retrieves the display name of the currently executing assembly, and the display name of the assembly that contains the <xref:System.Int32> type (`int` in C#, `Integer` in Visual Basic).</span></span>  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="850a0-272">Spécification des noms de types qualifiés complets</span><span class="sxs-lookup"><span data-stu-id="850a0-272">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="850a0-273">Objet représentant un type de l’assembly retourné.</span><span class="sxs-lookup"><span data-stu-id="850a0-273">An object representing a type in the assembly that will be returned.</span></span></param>
        <summary><span data-ttu-id="850a0-274">Obtient l’assembly actuellement chargé dans lequel le type spécifié est défini.</span><span class="sxs-lookup"><span data-stu-id="850a0-274">Gets the currently loaded assembly in which the specified type is defined.</span></span></summary>
        <returns><span data-ttu-id="850a0-275">Assembly dans lequel le type spécifié est défini.</span><span class="sxs-lookup"><span data-stu-id="850a0-275">The assembly in which the specified type is defined.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-276">Appel de cette méthode est équivalente à la récupération de la valeur de la <xref:System.Type.Assembly?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="850a0-276">Calling this method is equivalent to retrieving the value of the  <xref:System.Type.Assembly?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="850a0-277">Toutefois, le <xref:System.Type.Assembly?displayProperty=nameWithType> propriété offre généralement de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="850a0-277">However, the <xref:System.Type.Assembly?displayProperty=nameWithType> property typically offers superior performance.</span></span>  
  
 <span data-ttu-id="850a0-278">Pour appeler cette méthode, vous devez avoir un <xref:System.Type> objet, ce qui signifie que l’assembly dans lequel la classe est définie doit déjà être chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-278">In order to call this method, you must have a <xref:System.Type> object, which means that the assembly in which the class is defined must already be loaded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-279">L’exemple suivant récupère l’assembly qui contient le <xref:System.Int32> tapez et affiche son emplacement de nom et le fichier.</span><span class="sxs-lookup"><span data-stu-id="850a0-279">The following example retrieves the assembly that contains the <xref:System.Int32> type and displays its name and file location.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-280"><paramref name="type" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-280"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="850a0-281">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-281">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="850a0-282">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="850a0-282">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-283">Retourne le <see cref="T:System.Reflection.Assembly" /> de la méthode ayant appelé la méthode en cours d'exécution.</span><span class="sxs-lookup"><span data-stu-id="850a0-283">Returns the <see cref="T:System.Reflection.Assembly" /> of the method that invoked the currently executing method.</span></span></summary>
        <returns><span data-ttu-id="850a0-284">Objet <see langword="Assembly" /> de la méthode ayant appelé la méthode en cours d'exécution.</span><span class="sxs-lookup"><span data-stu-id="850a0-284">The <see langword="Assembly" /> object of the method that invoked the currently executing method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-285">Si la méthode qui appelle le <xref:System.Reflection.Assembly.GetCallingAssembly%2A> méthode est développée inline par le compilateur juste-à-temps (JIT), ou si son appelant est développé inline, l’assembly qui est retourné par <xref:System.Reflection.Assembly.GetCallingAssembly%2A> peuvent différer de manière inattendue.</span><span class="sxs-lookup"><span data-stu-id="850a0-285">If the method that calls the <xref:System.Reflection.Assembly.GetCallingAssembly%2A> method is expanded inline by the just-in-time (JIT) compiler, or if its caller is expanded inline, the assembly that is returned by <xref:System.Reflection.Assembly.GetCallingAssembly%2A> may differ unexpectedly.</span></span> <span data-ttu-id="850a0-286">Par exemple, considérez les méthodes et les assemblys suivants :</span><span class="sxs-lookup"><span data-stu-id="850a0-286">For example, consider the following methods and assemblies:</span></span>  
  
-   <span data-ttu-id="850a0-287">Méthode `M1` dans l’assembly `A1` appels <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span><span class="sxs-lookup"><span data-stu-id="850a0-287">Method `M1` in assembly `A1` calls <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span></span>  
  
-   <span data-ttu-id="850a0-288">Méthode `M2` dans l’assembly `A2` appels `M1`.</span><span class="sxs-lookup"><span data-stu-id="850a0-288">Method `M2` in assembly `A2` calls `M1`.</span></span>  
  
-   <span data-ttu-id="850a0-289">Méthode `M3` dans l’assembly `A3` appels `M2`.</span><span class="sxs-lookup"><span data-stu-id="850a0-289">Method `M3` in assembly `A3` calls `M2`.</span></span>  
  
 <span data-ttu-id="850a0-290">Lorsque `M1` n’est pas mise inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retourne `A2`.</span><span class="sxs-lookup"><span data-stu-id="850a0-290">When `M1` is not inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A2`.</span></span> <span data-ttu-id="850a0-291">Lorsque `M1` est inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retourne `A3`.</span><span class="sxs-lookup"><span data-stu-id="850a0-291">When `M1` is inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A3`.</span></span> <span data-ttu-id="850a0-292">De même, lorsque `M2` n’est pas mise inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retourne `A2`.</span><span class="sxs-lookup"><span data-stu-id="850a0-292">Similarly, when `M2` is not inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A2`.</span></span> <span data-ttu-id="850a0-293">Lorsque `M2` est inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retourne `A3`.</span><span class="sxs-lookup"><span data-stu-id="850a0-293">When `M2` is inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A3`.</span></span>  
  
 <span data-ttu-id="850a0-294">Cet effet se produit également lorsque `M1` s’exécute comme un appel tail de `M2`, ou lorsque `M2` s’exécute comme un appel tail de `M3`.</span><span class="sxs-lookup"><span data-stu-id="850a0-294">This effect also occurs when `M1` executes as a tail call from `M2`, or when `M2` executes as a tail call from `M3`.</span></span> <span data-ttu-id="850a0-295">Vous pouvez empêcher le compilateur JIT d’incorporation (inlining) la méthode qui appelle <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, en appliquant la <xref:System.Runtime.CompilerServices.MethodImplAttribute> attribut avec le <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> indicateur, mais il n’existe aucun mécanisme similaire pour empêcher les appels tail.</span><span class="sxs-lookup"><span data-stu-id="850a0-295">You can prevent the JIT compiler from inlining the method that calls <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, by applying the <xref:System.Runtime.CompilerServices.MethodImplAttribute> attribute with the <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> flag, but there is no similar mechanism for preventing tail calls.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-296">L’exemple suivant obtient l’assembly appelant de la méthode actuelle.</span><span class="sxs-lookup"><span data-stu-id="850a0-296">The following example gets the calling assembly of the current method.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="850a0-297">Obtient les attributs personnalisés pour cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-297">Gets the custom attributes for this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit"><span data-ttu-id="850a0-298">Cet argument est ignoré pour les objets de type <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-298">This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />.</span></span></param>
        <summary><span data-ttu-id="850a0-299">Obtient tous les attributs personnalisés pour cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-299">Gets all the custom attributes for this assembly.</span></span></summary>
        <returns><span data-ttu-id="850a0-300">Tableau qui contient les attributs personnalisés pour cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-300">An array that contains the custom attributes for this assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-301">Cette méthode implémente le correspondantes <xref:System.Reflection.ICustomAttributeProvider> méthode d’interface.</span><span class="sxs-lookup"><span data-stu-id="850a0-301">This method implements the corresponding <xref:System.Reflection.ICustomAttributeProvider> interface method.</span></span> <span data-ttu-id="850a0-302">Par conséquent, le `inherit` paramètre doit être spécifié même s’il est ignoré.</span><span class="sxs-lookup"><span data-stu-id="850a0-302">Therefore, the `inherit` parameter must be specified even though it is ignored.</span></span>  
  
 <span data-ttu-id="850a0-303">Un attribut pseudo-aléatoire indique les bits des métadonnées de base qui doit être défini lors de l’attribut est présent.</span><span class="sxs-lookup"><span data-stu-id="850a0-303">A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</span></span> <span data-ttu-id="850a0-304">Contrairement à un attribut personnalisé qui étend les métadonnées d’un type et est enregistré avec le type, un attribut pseudo-aléatoire modifie les métadonnées pour le type et qu’elle est ensuite ignoré.</span><span class="sxs-lookup"><span data-stu-id="850a0-304">Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</span></span> <span data-ttu-id="850a0-305">Certaines des bits qui en résulte n’est pas accessible à l’aide des API de réflexion existantes.</span><span class="sxs-lookup"><span data-stu-id="850a0-305">Some of the resulting bits cannot be accessed using existing reflection APIs.</span></span>  
  
 <span data-ttu-id="850a0-306">Le tableau suivant résume les divers pseudo-attributs et les accesseurs pour les bits qui sont disponibles dans la réflexion.</span><span class="sxs-lookup"><span data-stu-id="850a0-306">The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</span></span>  
  
|<span data-ttu-id="850a0-307">Pseudo-attributs</span><span class="sxs-lookup"><span data-stu-id="850a0-307">Pseudo-Attribute</span></span>|<span data-ttu-id="850a0-308">Bits de métadonnées</span><span class="sxs-lookup"><span data-stu-id="850a0-308">Metadata Bits</span></span>|<span data-ttu-id="850a0-309">Accesseur de réflexion</span><span class="sxs-lookup"><span data-stu-id="850a0-309">Reflection Accessor</span></span>|  
|-----------------------|-------------------|-------------------------|  
|<span data-ttu-id="850a0-310">DllImportAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-310">DllImportAttribute</span></span>|<span data-ttu-id="850a0-311">CorPInvokeMap</span><span class="sxs-lookup"><span data-stu-id="850a0-311">CorPInvokeMap</span></span><br /><br /> <span data-ttu-id="850a0-312">Nom de la DLL</span><span class="sxs-lookup"><span data-stu-id="850a0-312">DLL name</span></span>|<span data-ttu-id="850a0-313">Pas d’accesseur pour PInvokeMap pour les attributs de méthode méthode ordinaire/globaux.</span><span class="sxs-lookup"><span data-stu-id="850a0-313">No accessor for PInvokeMap for ordinary method/global method attributes.</span></span><br /><br /> <span data-ttu-id="850a0-314">Pas d’accesseur pour le nom de la DLL.</span><span class="sxs-lookup"><span data-stu-id="850a0-314">No accessor for DLL name.</span></span>|  
|<span data-ttu-id="850a0-315">GuidAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-315">GuidAttribute</span></span>|<span data-ttu-id="850a0-316">Stockées sous la forme d’un attribut personnalisé réel.</span><span class="sxs-lookup"><span data-stu-id="850a0-316">Stored as a real custom attribute.</span></span>|<span data-ttu-id="850a0-317">Accessible en tant que d’un attribut personnalisé réel.</span><span class="sxs-lookup"><span data-stu-id="850a0-317">Accessed as a real custom attribute.</span></span>|  
|<span data-ttu-id="850a0-318">ComImportAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-318">ComImportAttribute</span></span>|<span data-ttu-id="850a0-319">CorTypeAttr.tdImport</span><span class="sxs-lookup"><span data-stu-id="850a0-319">CorTypeAttr.tdImport</span></span>|<span data-ttu-id="850a0-320">Type.Attributes.Import</span><span class="sxs-lookup"><span data-stu-id="850a0-320">Type.Attributes.Import</span></span>|  
|<span data-ttu-id="850a0-321">SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-321">SerializableAttribute</span></span>|<span data-ttu-id="850a0-322">CorTypeAttr.tdSerializable</span><span class="sxs-lookup"><span data-stu-id="850a0-322">CorTypeAttr.tdSerializable</span></span>|<span data-ttu-id="850a0-323">Type.Attributes.Serializable</span><span class="sxs-lookup"><span data-stu-id="850a0-323">Type.Attributes.Serializable</span></span>|  
|<span data-ttu-id="850a0-324">NonSerializedAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-324">NonSerializedAttribute</span></span>|<span data-ttu-id="850a0-325">CorFieldAttr.fdNotSerialized</span><span class="sxs-lookup"><span data-stu-id="850a0-325">CorFieldAttr.fdNotSerialized</span></span>|<span data-ttu-id="850a0-326">FieldInfo.Attributes.NotSerialized</span><span class="sxs-lookup"><span data-stu-id="850a0-326">FieldInfo.Attributes.NotSerialized</span></span>|  
|<span data-ttu-id="850a0-327">MethodImplAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-327">MethodImplAttribute</span></span>|<span data-ttu-id="850a0-328">CorMethodImpl</span><span class="sxs-lookup"><span data-stu-id="850a0-328">CorMethodImpl</span></span>|<span data-ttu-id="850a0-329">MethodInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="850a0-329">MethodInfo.GetMethodImplementationFlags()</span></span><br /><br /> <span data-ttu-id="850a0-330">ConstructorInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="850a0-330">ConstructorInfo.GetMethodImplementationFlags()</span></span>|  
|<span data-ttu-id="850a0-331">MarshalAsAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-331">MarshalAsAttribute</span></span>|<span data-ttu-id="850a0-332">Divers éléments.</span><span class="sxs-lookup"><span data-stu-id="850a0-332">Various bits.</span></span>|<span data-ttu-id="850a0-333">Pas d’accesseur.</span><span class="sxs-lookup"><span data-stu-id="850a0-333">No accessor.</span></span>|  
|<span data-ttu-id="850a0-334">PreserveSigAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-334">PreserveSigAttribute</span></span>|<span data-ttu-id="850a0-335">CorMethodImpl.miOLE</span><span class="sxs-lookup"><span data-stu-id="850a0-335">CorMethodImpl.miOLE</span></span>|<span data-ttu-id="850a0-336">MethodInfo.GetMethodImplementationFlags(). OLE</span><span class="sxs-lookup"><span data-stu-id="850a0-336">MethodInfo.GetMethodImplementationFlags().OLE</span></span><br /><br /> <span data-ttu-id="850a0-337">ConstructorInfo.GetMethodImplementationFlags(). OLE</span><span class="sxs-lookup"><span data-stu-id="850a0-337">ConstructorInfo.GetMethodImplementationFlags().OLE</span></span>|  
|<span data-ttu-id="850a0-338">InAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-338">InAttribute</span></span>|<span data-ttu-id="850a0-339">CorParamAttr.pdIn</span><span class="sxs-lookup"><span data-stu-id="850a0-339">CorParamAttr.pdIn</span></span>|<span data-ttu-id="850a0-340">ParameterInfo.Attributes.In</span><span class="sxs-lookup"><span data-stu-id="850a0-340">ParameterInfo.Attributes.In</span></span>|  
|<span data-ttu-id="850a0-341">OutAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-341">OutAttribute</span></span>|<span data-ttu-id="850a0-342">CorParamAttr.pdOut</span><span class="sxs-lookup"><span data-stu-id="850a0-342">CorParamAttr.pdOut</span></span>|<span data-ttu-id="850a0-343">ParameterInfo.Attributes.Out</span><span class="sxs-lookup"><span data-stu-id="850a0-343">ParameterInfo.Attributes.Out</span></span>|  
|<span data-ttu-id="850a0-344">StructLayoutAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-344">StructLayoutAttribute</span></span>|<span data-ttu-id="850a0-345">CorTypeAttr.tdLayoutSequential</span><span class="sxs-lookup"><span data-stu-id="850a0-345">CorTypeAttr.tdLayoutSequential</span></span><br /><br /> <span data-ttu-id="850a0-346">CorTypeAttr.tdExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="850a0-346">CorTypeAttr.tdExplicitLayout</span></span><br /><br /> <span data-ttu-id="850a0-347">CorTypeAttr.tdAnsiClass</span><span class="sxs-lookup"><span data-stu-id="850a0-347">CorTypeAttr.tdAnsiClass</span></span><br /><br /> <span data-ttu-id="850a0-348">CorTypeAttr.tdUnicodeClass</span><span class="sxs-lookup"><span data-stu-id="850a0-348">CorTypeAttr.tdUnicodeClass</span></span><br /><br /> <span data-ttu-id="850a0-349">CorTypeAttr.tdAutoClass</span><span class="sxs-lookup"><span data-stu-id="850a0-349">CorTypeAttr.tdAutoClass</span></span><br /><br /> <span data-ttu-id="850a0-350">Compression de la classe.</span><span class="sxs-lookup"><span data-stu-id="850a0-350">Class packing.</span></span>|<span data-ttu-id="850a0-351">Type.Attributes.LayoutSequential</span><span class="sxs-lookup"><span data-stu-id="850a0-351">Type.Attributes.LayoutSequential</span></span><br /><br /> <span data-ttu-id="850a0-352">Type.Attributes.ExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="850a0-352">Type.Attributes.ExplicitLayout</span></span><br /><br /> <span data-ttu-id="850a0-353">Type.Attributes.AnsiClass</span><span class="sxs-lookup"><span data-stu-id="850a0-353">Type.Attributes.AnsiClass</span></span><br /><br /> <span data-ttu-id="850a0-354">Type.Attributes.UnicodeClass</span><span class="sxs-lookup"><span data-stu-id="850a0-354">Type.Attributes.UnicodeClass</span></span><br /><br /> <span data-ttu-id="850a0-355">Type.Attributes.AutoClass</span><span class="sxs-lookup"><span data-stu-id="850a0-355">Type.Attributes.AutoClass</span></span><br /><br /> <span data-ttu-id="850a0-356">Pas d’accesseur.</span><span class="sxs-lookup"><span data-stu-id="850a0-356">No accessor.</span></span>|  
|<span data-ttu-id="850a0-357">FieldOffsetAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-357">FieldOffsetAttribute</span></span>|<span data-ttu-id="850a0-358">Offset de champ.</span><span class="sxs-lookup"><span data-stu-id="850a0-358">Field offset.</span></span>|<span data-ttu-id="850a0-359">Pas d’accesseur.</span><span class="sxs-lookup"><span data-stu-id="850a0-359">No accessor.</span></span>|  
|<span data-ttu-id="850a0-360">AssemblyLoadAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-360">AssemblyLoadAttribute</span></span>|<span data-ttu-id="850a0-361">CorAssemblyFlags</span><span class="sxs-lookup"><span data-stu-id="850a0-361">CorAssemblyFlags</span></span>|<span data-ttu-id="850a0-362">Aucun accesseur ou l’énumérateur.</span><span class="sxs-lookup"><span data-stu-id="850a0-362">No accessor or enumerator.</span></span>|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="850a0-363">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-363">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="850a0-364">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="850a0-364">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="850a0-365">Type pour lequel les attributs personnalisés doivent être retournés.</span><span class="sxs-lookup"><span data-stu-id="850a0-365">The type for which the custom attributes are to be returned.</span></span></param>
        <param name="inherit"><span data-ttu-id="850a0-366">Cet argument est ignoré pour les objets de type <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-366">This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />.</span></span></param>
        <summary><span data-ttu-id="850a0-367">Obtient les attributs personnalisés pour cet assembly, tels qu'ils sont spécifiés par le type.</span><span class="sxs-lookup"><span data-stu-id="850a0-367">Gets the custom attributes for this assembly as specified by type.</span></span></summary>
        <returns><span data-ttu-id="850a0-368">Tableau qui contient les attributs personnalisés pour cet assembly, tels qu'ils sont spécifiés par <paramref name="attributeType" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-368">An array that contains the custom attributes for this assembly as specified by <paramref name="attributeType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-369">Cette méthode implémente le correspondantes <xref:System.Reflection.ICustomAttributeProvider> méthode d’interface.</span><span class="sxs-lookup"><span data-stu-id="850a0-369">This method implements the corresponding <xref:System.Reflection.ICustomAttributeProvider> interface method.</span></span> <span data-ttu-id="850a0-370">Par conséquent, le `inherit` paramètre doit être spécifié même s’il est ignoré.</span><span class="sxs-lookup"><span data-stu-id="850a0-370">Therefore, the `inherit` parameter must be specified even though it is ignored.</span></span>  
  
 <span data-ttu-id="850a0-371">Un attribut pseudo-aléatoire indique les bits des métadonnées de base qui doit être défini lors de l’attribut est présent.</span><span class="sxs-lookup"><span data-stu-id="850a0-371">A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</span></span> <span data-ttu-id="850a0-372">Contrairement à un attribut personnalisé qui étend les métadonnées d’un type et est enregistré avec le type, un attribut pseudo-aléatoire modifie les métadonnées pour le type et qu’elle est ensuite ignoré.</span><span class="sxs-lookup"><span data-stu-id="850a0-372">Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</span></span> <span data-ttu-id="850a0-373">Certaines des bits qui en résulte n’est pas accessible à l’aide des API de réflexion existantes.</span><span class="sxs-lookup"><span data-stu-id="850a0-373">Some of the resulting bits cannot be accessed using existing reflection APIs.</span></span>  
  
 <span data-ttu-id="850a0-374">Le tableau suivant résume les divers pseudo-attributs et les accesseurs pour les bits qui sont disponibles dans la réflexion.</span><span class="sxs-lookup"><span data-stu-id="850a0-374">The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</span></span>  
  
|<span data-ttu-id="850a0-375">Pseudo-attributs</span><span class="sxs-lookup"><span data-stu-id="850a0-375">Pseudo-Attribute</span></span>|<span data-ttu-id="850a0-376">Bits de métadonnées</span><span class="sxs-lookup"><span data-stu-id="850a0-376">Metadata Bits</span></span>|<span data-ttu-id="850a0-377">Accesseur de réflexion</span><span class="sxs-lookup"><span data-stu-id="850a0-377">Reflection Accessor</span></span>|  
|-----------------------|-------------------|-------------------------|  
|<span data-ttu-id="850a0-378">DllImportAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-378">DllImportAttribute</span></span>|<span data-ttu-id="850a0-379">CorPInvokeMap</span><span class="sxs-lookup"><span data-stu-id="850a0-379">CorPInvokeMap</span></span><br /><br /> <span data-ttu-id="850a0-380">Nom de la DLL</span><span class="sxs-lookup"><span data-stu-id="850a0-380">DLL name</span></span>|<span data-ttu-id="850a0-381">Pas d’accesseur pour PInvokeMap pour les attributs de méthode méthode ordinaire/globaux.</span><span class="sxs-lookup"><span data-stu-id="850a0-381">No accessor for PInvokeMap for ordinary method/global method attributes.</span></span><br /><br /> <span data-ttu-id="850a0-382">Pas d’accesseur pour le nom de la DLL.</span><span class="sxs-lookup"><span data-stu-id="850a0-382">No accessor for DLL name.</span></span>|  
|<span data-ttu-id="850a0-383">GuidAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-383">GuidAttribute</span></span>|<span data-ttu-id="850a0-384">Stockées sous la forme d’un attribut personnalisé réel.</span><span class="sxs-lookup"><span data-stu-id="850a0-384">Stored as a real custom attribute.</span></span>|<span data-ttu-id="850a0-385">Accessible en tant que d’un attribut personnalisé réel.</span><span class="sxs-lookup"><span data-stu-id="850a0-385">Accessed as a real custom attribute.</span></span>|  
|<span data-ttu-id="850a0-386">ComImportAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-386">ComImportAttribute</span></span>|<span data-ttu-id="850a0-387">CorTypeAttr.tdImport</span><span class="sxs-lookup"><span data-stu-id="850a0-387">CorTypeAttr.tdImport</span></span>|<span data-ttu-id="850a0-388">Type.Attributes.Import</span><span class="sxs-lookup"><span data-stu-id="850a0-388">Type.Attributes.Import</span></span>|  
|<span data-ttu-id="850a0-389">SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-389">SerializableAttribute</span></span>|<span data-ttu-id="850a0-390">CorTypeAttr.tdSerializable</span><span class="sxs-lookup"><span data-stu-id="850a0-390">CorTypeAttr.tdSerializable</span></span>|<span data-ttu-id="850a0-391">Type.Attributes.Serializable</span><span class="sxs-lookup"><span data-stu-id="850a0-391">Type.Attributes.Serializable</span></span>|  
|<span data-ttu-id="850a0-392">NonSerializedAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-392">NonSerializedAttribute</span></span>|<span data-ttu-id="850a0-393">CorFieldAttr.fdNotSerialized</span><span class="sxs-lookup"><span data-stu-id="850a0-393">CorFieldAttr.fdNotSerialized</span></span>|<span data-ttu-id="850a0-394">FieldInfo.Attributes.NotSerialized</span><span class="sxs-lookup"><span data-stu-id="850a0-394">FieldInfo.Attributes.NotSerialized</span></span>|  
|<span data-ttu-id="850a0-395">MethodImplAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-395">MethodImplAttribute</span></span>|<span data-ttu-id="850a0-396">CorMethodImpl</span><span class="sxs-lookup"><span data-stu-id="850a0-396">CorMethodImpl</span></span>|<span data-ttu-id="850a0-397">MethodInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="850a0-397">MethodInfo.GetMethodImplementationFlags()</span></span><br /><br /> <span data-ttu-id="850a0-398">ConstructorInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="850a0-398">ConstructorInfo.GetMethodImplementationFlags()</span></span>|  
|<span data-ttu-id="850a0-399">MarshalAsAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-399">MarshalAsAttribute</span></span>|<span data-ttu-id="850a0-400">Divers éléments.</span><span class="sxs-lookup"><span data-stu-id="850a0-400">Various bits.</span></span>|<span data-ttu-id="850a0-401">Pas d’accesseur.</span><span class="sxs-lookup"><span data-stu-id="850a0-401">No accessor.</span></span>|  
|<span data-ttu-id="850a0-402">PreserveSigAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-402">PreserveSigAttribute</span></span>|<span data-ttu-id="850a0-403">CorMethodImpl.miOLE</span><span class="sxs-lookup"><span data-stu-id="850a0-403">CorMethodImpl.miOLE</span></span>|<span data-ttu-id="850a0-404">MethodInfo.GetMethodImplementationFlags(). OLE</span><span class="sxs-lookup"><span data-stu-id="850a0-404">MethodInfo.GetMethodImplementationFlags().OLE</span></span><br /><br /> <span data-ttu-id="850a0-405">ConstructorInfo.GetMethodImplementationFlags(). OLE</span><span class="sxs-lookup"><span data-stu-id="850a0-405">ConstructorInfo.GetMethodImplementationFlags().OLE</span></span>|  
|<span data-ttu-id="850a0-406">InAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-406">InAttribute</span></span>|<span data-ttu-id="850a0-407">CorParamAttr.pdIn</span><span class="sxs-lookup"><span data-stu-id="850a0-407">CorParamAttr.pdIn</span></span>|<span data-ttu-id="850a0-408">ParameterInfo.Attributes.In</span><span class="sxs-lookup"><span data-stu-id="850a0-408">ParameterInfo.Attributes.In</span></span>|  
|<span data-ttu-id="850a0-409">OutAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-409">OutAttribute</span></span>|<span data-ttu-id="850a0-410">CorParamAttr.pdOut</span><span class="sxs-lookup"><span data-stu-id="850a0-410">CorParamAttr.pdOut</span></span>|<span data-ttu-id="850a0-411">ParameterInfo.Attributes.Out</span><span class="sxs-lookup"><span data-stu-id="850a0-411">ParameterInfo.Attributes.Out</span></span>|  
|<span data-ttu-id="850a0-412">StructLayoutAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-412">StructLayoutAttribute</span></span>|<span data-ttu-id="850a0-413">CorTypeAttr.tdLayoutSequential</span><span class="sxs-lookup"><span data-stu-id="850a0-413">CorTypeAttr.tdLayoutSequential</span></span><br /><br /> <span data-ttu-id="850a0-414">CorTypeAttr.tdExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="850a0-414">CorTypeAttr.tdExplicitLayout</span></span><br /><br /> <span data-ttu-id="850a0-415">CorTypeAttr.tdAnsiClass</span><span class="sxs-lookup"><span data-stu-id="850a0-415">CorTypeAttr.tdAnsiClass</span></span><br /><br /> <span data-ttu-id="850a0-416">CorTypeAttr.tdUnicodeClass</span><span class="sxs-lookup"><span data-stu-id="850a0-416">CorTypeAttr.tdUnicodeClass</span></span><br /><br /> <span data-ttu-id="850a0-417">CorTypeAttr.tdAutoClass</span><span class="sxs-lookup"><span data-stu-id="850a0-417">CorTypeAttr.tdAutoClass</span></span><br /><br /> <span data-ttu-id="850a0-418">Compression de la classe.</span><span class="sxs-lookup"><span data-stu-id="850a0-418">Class packing.</span></span>|<span data-ttu-id="850a0-419">Type.Attributes.LayoutSequential</span><span class="sxs-lookup"><span data-stu-id="850a0-419">Type.Attributes.LayoutSequential</span></span><br /><br /> <span data-ttu-id="850a0-420">Type.Attributes.ExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="850a0-420">Type.Attributes.ExplicitLayout</span></span><br /><br /> <span data-ttu-id="850a0-421">Type.Attributes.AnsiClass</span><span class="sxs-lookup"><span data-stu-id="850a0-421">Type.Attributes.AnsiClass</span></span><br /><br /> <span data-ttu-id="850a0-422">Type.Attributes.UnicodeClass</span><span class="sxs-lookup"><span data-stu-id="850a0-422">Type.Attributes.UnicodeClass</span></span><br /><br /> <span data-ttu-id="850a0-423">Type.Attributes.AutoClass</span><span class="sxs-lookup"><span data-stu-id="850a0-423">Type.Attributes.AutoClass</span></span><br /><br /> <span data-ttu-id="850a0-424">Pas d’accesseur.</span><span class="sxs-lookup"><span data-stu-id="850a0-424">No accessor.</span></span>|  
|<span data-ttu-id="850a0-425">FieldOffsetAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-425">FieldOffsetAttribute</span></span>|<span data-ttu-id="850a0-426">Offset de champ.</span><span class="sxs-lookup"><span data-stu-id="850a0-426">Field offset.</span></span>|<span data-ttu-id="850a0-427">Pas d’accesseur.</span><span class="sxs-lookup"><span data-stu-id="850a0-427">No accessor.</span></span>|  
|<span data-ttu-id="850a0-428">AssemblyLoadAttribute</span><span class="sxs-lookup"><span data-stu-id="850a0-428">AssemblyLoadAttribute</span></span>|<span data-ttu-id="850a0-429">CorAssemblyFlags</span><span class="sxs-lookup"><span data-stu-id="850a0-429">CorAssemblyFlags</span></span>|<span data-ttu-id="850a0-430">Aucun accesseur ou l’énumérateur.</span><span class="sxs-lookup"><span data-stu-id="850a0-430">No accessor or enumerator.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-431"><paramref name="attributeType" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-431"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-432"><paramref name="attributeType" /> n’est pas un type de runtime.</span><span class="sxs-lookup"><span data-stu-id="850a0-432"><paramref name="attributeType" /> is not a runtime type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="850a0-433">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-433">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="850a0-434">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="850a0-434">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-435">Retourne des informations sur les attributs appliqués au <see cref="T:System.Reflection.Assembly" /> actuel, en tant qu'objets <see cref="T:System.Reflection.CustomAttributeData" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-435">Returns information about the attributes that have been applied to the current <see cref="T:System.Reflection.Assembly" />, expressed as <see cref="T:System.Reflection.CustomAttributeData" /> objects.</span></span></summary>
        <returns><span data-ttu-id="850a0-436">Liste générique d'objets <see cref="T:System.Reflection.CustomAttributeData" /> représentant des données relatives aux attributs qui ont été appliqués à l'assembly actuel.</span><span class="sxs-lookup"><span data-stu-id="850a0-436">A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-437">Utilisez cette méthode pour examiner les attributs personnalisés du code dans le contexte de réflexion uniquement, dans les cas où les attributs personnalisés eux-mêmes sont définis dans le code qui est chargé dans le contexte de réflexion uniquement.</span><span class="sxs-lookup"><span data-stu-id="850a0-437">Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</span></span> <span data-ttu-id="850a0-438">Méthodes telles que <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> et <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> ne peut pas être utilisé dans ce cas, car ils créent des instances des attributs.</span><span class="sxs-lookup"><span data-stu-id="850a0-438">Methods like <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> cannot be used in such cases, because they create instances of the attributes.</span></span> <span data-ttu-id="850a0-439">Impossible d’exécuter le code dans le contexte de réflexion uniquement.</span><span class="sxs-lookup"><span data-stu-id="850a0-439">Code in the reflection-only context cannot be executed.</span></span> <span data-ttu-id="850a0-440">Pour plus d’informations et un par exemple de code, consultez la <xref:System.Reflection.CustomAttributeData> classe.</span><span class="sxs-lookup"><span data-stu-id="850a0-440">For more information and for example code, see the <xref:System.Reflection.CustomAttributeData> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-441">Obtient l'exécutable du processus dans le domaine d'application par défaut.</span><span class="sxs-lookup"><span data-stu-id="850a0-441">Gets the process executable in the default application domain.</span></span> <span data-ttu-id="850a0-442">Dans les autres domaines d'application, il s'agit du premier exécutable exécuté par <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-442">In other application domains, this is the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span></span></summary>
        <returns><span data-ttu-id="850a0-443">Assembly qui est l'exécutable du processus dans le domaine d'application par défaut, ou le premier exécutable exécuté par <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-443">The assembly that is the process executable in the default application domain, or the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span></span> <span data-ttu-id="850a0-444">Peut retourner <see langword="null" /> quand il est appelé à partir de code non managé.</span><span class="sxs-lookup"><span data-stu-id="850a0-444">Can return <see langword="null" /> when called from unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-445">Le <xref:System.Reflection.Assembly.GetEntryAssembly%2A> méthode peut retourner `null` lorsqu’un assembly managé a été chargé à partir d’une application non managée.</span><span class="sxs-lookup"><span data-stu-id="850a0-445">The <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method can return `null` when a managed assembly has been loaded from an unmanaged application.</span></span> <span data-ttu-id="850a0-446">Par exemple, si une application non managée crée une instance d’un composant COM écrit en c#, un appel à la <xref:System.Reflection.Assembly.GetEntryAssembly%2A> méthode à partir du composant c# retourne la valeur null, car le point d’entrée pour le processus était du code non managé plutôt qu’un assembly managé.</span><span class="sxs-lookup"><span data-stu-id="850a0-446">For example, if an unmanaged application creates an instance of a COM component written in C#, a call to the <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method from the C# component returns null, because the entry point for the process was unmanaged code rather than a managed assembly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-447">Obtient l'assembly qui contient le code en cours d'exécution.</span><span class="sxs-lookup"><span data-stu-id="850a0-447">Gets the assembly that contains the code that is currently executing.</span></span></summary>
        <returns><span data-ttu-id="850a0-448">Assembly qui contient le code en cours d'exécution.</span><span class="sxs-lookup"><span data-stu-id="850a0-448">The assembly that contains the code that is currently executing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-449">Pour des raisons de performances, vous devez appeler cette méthode uniquement lorsque vous ne connaissez pas au moment du design quel assembly est en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="850a0-449">For performance reasons, you should call this method only when you do not know at design time what assembly is currently executing.</span></span> <span data-ttu-id="850a0-450">La méthode recommandée pour récupérer un <xref:System.Reflection.Assembly> objet qui représente l’assembly actuel consiste à utiliser le <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propriété d’un type trouvé dans l’assembly, comme l’illustre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="850a0-450">The recommended way to retrieve an <xref:System.Reflection.Assembly> object that represents the current assembly is to use the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property of a type found in the assembly, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 <span data-ttu-id="850a0-451">Pour obtenir l’assembly qui contient la méthode qui a appelé le code en cours d’exécution, utilisez <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span><span class="sxs-lookup"><span data-stu-id="850a0-451">To get the assembly that contains the method that called the currently executing code, use <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-452">L’exemple suivant utilise le <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propriété à obtenir l’assembly en cours d’exécution basée sur un type de contenu dans cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-452">The following example uses the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property to get the currently executing assembly based on a type contained in that assembly.</span></span> <span data-ttu-id="850a0-453">Il appelle également la <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> méthode pour montrer qu’il retourne un <xref:System.Reflection.Assembly> objet qui représente le même assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-453">It also calls the <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> method to show that it returns an <xref:System.Reflection.Assembly> object that represents the same assembly.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-454">Obtient les types publics définis dans cet assembly qui sont visibles à l'extérieur de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-454">Gets the public types defined in this assembly that are visible outside the assembly.</span></span></summary>
        <returns><span data-ttu-id="850a0-455">Tableau qui représente les types définis dans cet assembly qui sont visibles à l'extérieur de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-455">An array that represents the types defined in this assembly that are visible outside the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-456">Les seuls types visibles en dehors d’un assembly sont les types publics et les types publics imbriqués dans d’autres types publics.</span><span class="sxs-lookup"><span data-stu-id="850a0-456">The only types visible outside an assembly are public types and public types nested within other public types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-457">L’exemple de code suivant définit plusieurs classes avec différents niveaux d’accès et appelle <xref:System.Reflection.Assembly.GetExportedTypes%2A> pour afficher celles qui sont visibles en dehors de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-457">The following code sample defines a number of classes with various access levels, and calls <xref:System.Reflection.Assembly.GetExportedTypes%2A> to display the ones that are visible from outside the assembly.</span></span>  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="850a0-458">L’assembly est un assembly dynamique.</span><span class="sxs-lookup"><span data-stu-id="850a0-458">The assembly is a dynamic assembly.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-459">Impossible de charger un assembly dépendant.</span><span class="sxs-lookup"><span data-stu-id="850a0-459">Unable to load a dependent assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="850a0-460">Nom du fichier spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-460">The name of the specified file.</span></span> <span data-ttu-id="850a0-461">N’incluez pas le chemin d’accès au fichier.</span><span class="sxs-lookup"><span data-stu-id="850a0-461">Do not include the path to the file.</span></span></param>
        <summary><span data-ttu-id="850a0-462">Obtient un <see cref="T:System.IO.FileStream" /> pour le fichier spécifié dans la table de fichiers du manifeste de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-462">Gets a <see cref="T:System.IO.FileStream" /> for the specified file in the file table of the manifest of this assembly.</span></span></summary>
        <returns><span data-ttu-id="850a0-463">Flux qui contient le fichier spécifié, ou <see langword="null" /> si le fichier est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-463">A stream that contains the specified file, or <see langword="null" /> if the file is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-464">Cette méthode fonctionne sur les deux fichiers de ressources publics et privés.</span><span class="sxs-lookup"><span data-stu-id="850a0-464">This method works on both public and private resource files.</span></span>  
  
 <span data-ttu-id="850a0-465">Le `name` ne doit pas inclure le chemin d’accès au fichier.</span><span class="sxs-lookup"><span data-stu-id="850a0-465">The `name` should not include the path to the file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-466">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-466">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-467">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-467">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-468">Le paramètre <paramref name="name" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="850a0-468">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-469"><paramref name="name" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-469"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-470"><paramref name="name" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-470"><paramref name="name" /> is not a valid assembly.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="850a0-471">pour l’accès pour le chemin d’accès et pour lire le fichier spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-471">for access to the path and for reading the specified file.</span></span> <span data-ttu-id="850a0-472">Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="850a0-472">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="850a0-473">Obtient les fichiers de la table de fichiers d'un manifeste d'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-473">Gets the files in the file table of an assembly manifest.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-474">Obtient les fichiers de la table de fichiers d'un manifeste d'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-474">Gets the files in the file table of an assembly manifest.</span></span></summary>
        <returns><span data-ttu-id="850a0-475">Tableau des flux de données qui contiennent les fichiers.</span><span class="sxs-lookup"><span data-stu-id="850a0-475">An array of streams that contain the files.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-476">Cette méthode fonctionne sur les fichiers de ressources publiques et privées.</span><span class="sxs-lookup"><span data-stu-id="850a0-476">This method works on public and private resource files.</span></span>  
  
 <span data-ttu-id="850a0-477">Cette surcharge revient à appeler le <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> surcharge et en spécifiant `false`.</span><span class="sxs-lookup"><span data-stu-id="850a0-477">This overload is equivalent to calling the <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> overload and specifying `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-478">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-478">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-479">Un fichier est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-479">A file was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-480">Un fichier n’était pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-480">A file was not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><span data-ttu-id="850a0-481"><see langword="true" /> pour inclure des modules de ressources ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-481"><see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="850a0-482">Obtient les fichiers de la table de fichiers d'un manifeste d'assembly, en spécifiant si des modules de ressources doivent être inclus.</span><span class="sxs-lookup"><span data-stu-id="850a0-482">Gets the files in the file table of an assembly manifest, specifying whether to include resource modules.</span></span></summary>
        <returns><span data-ttu-id="850a0-483">Tableau des flux de données qui contiennent les fichiers.</span><span class="sxs-lookup"><span data-stu-id="850a0-483">An array of streams that contain the files.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-484">Cette méthode fonctionne sur les fichiers de ressources publiques et privées.</span><span class="sxs-lookup"><span data-stu-id="850a0-484">This method works on public and private resource files.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-485">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-485">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-486">Un fichier est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-486">A file was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-487">Un fichier n’était pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-487">A file was not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-488">Retourne le code de hachage de cette instance.</span><span class="sxs-lookup"><span data-stu-id="850a0-488">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="850a0-489">Code de hachage d'un entier signé 32 bits.</span><span class="sxs-lookup"><span data-stu-id="850a0-489">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="850a0-490">Obtient tous les modules chargés qui appartiennent à cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-490">Gets all the loaded modules that are part of this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-491">Obtient tous les modules chargés qui appartiennent à cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-491">Gets all the loaded modules that are part of this assembly.</span></span></summary>
        <returns><span data-ttu-id="850a0-492">Tableau de modules.</span><span class="sxs-lookup"><span data-stu-id="850a0-492">An array of modules.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><span data-ttu-id="850a0-493"><see langword="true" /> pour inclure des modules de ressources ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-493"><see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="850a0-494">Obtient tous les modules chargés qui appartiennent à cet assembly, en spécifiant si des modules de ressources doivent être inclus.</span><span class="sxs-lookup"><span data-stu-id="850a0-494">Gets all the loaded modules that are part of this assembly, specifying whether to include resource modules.</span></span></summary>
        <returns><span data-ttu-id="850a0-495">Tableau de modules.</span><span class="sxs-lookup"><span data-stu-id="850a0-495">An array of modules.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName"><span data-ttu-id="850a0-496">Nom de la ressource respectant la casse.</span><span class="sxs-lookup"><span data-stu-id="850a0-496">The case-sensitive name of the resource.</span></span></param>
        <summary><span data-ttu-id="850a0-497">Retourne des informations sur la manière dont la ressource donnée a été persistante.</span><span class="sxs-lookup"><span data-stu-id="850a0-497">Returns information about how the given resource has been persisted.</span></span></summary>
        <returns><span data-ttu-id="850a0-498">Objet qui est rempli par des informations sur la topologie de la ressource, ou <see langword="null" /> si la ressource est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-498">An object that is populated with information about the resource's topology, or <see langword="null" /> if the resource is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-499">Informations sur la ressource sont renvoyées uniquement si la ressource est visible à l’appelant ou l’appelant a <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="850a0-499">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-500"><paramref name="resourceName" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-500"><paramref name="resourceName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-501">Le paramètre <paramref name="resourceName" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="850a0-501">The <paramref name="resourceName" /> parameter is an empty string ("").</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="850a0-502">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-502">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="850a0-503">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="850a0-503">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-504">Retourne les noms de toutes les ressources de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-504">Returns the names of all the resources in this assembly.</span></span></summary>
        <returns><span data-ttu-id="850a0-505">Tableau qui contient les noms de toutes les ressources.</span><span class="sxs-lookup"><span data-stu-id="850a0-505">An array that contains the names of all the resources.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-506">Vous pouvez utiliser chaque nom de ressource dans le tableau retourné par cette méthode comme suit :</span><span class="sxs-lookup"><span data-stu-id="850a0-506">You can use each resource name in the array returned by this method as follows:</span></span>  
  
-   <span data-ttu-id="850a0-507">Vous pouvez passer le nom de ressource pour le <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> méthode pour obtenir des informations supplémentaires sur la ressource.</span><span class="sxs-lookup"><span data-stu-id="850a0-507">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> method to get additional information about the resource.</span></span>  
  
-   <span data-ttu-id="850a0-508">Si le nom identifie un fichier .resources binaire, vous pouvez supprimer son extension de fichier .resources et transmettez-le à la <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> constructeur pour instancier le Gestionnaire de ressources.</span><span class="sxs-lookup"><span data-stu-id="850a0-508">If the name identifies a binary .resources file, you can remove its .resources file extension and pass it to the <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> constructor to instantiate the resource manager.</span></span>  
  
-   <span data-ttu-id="850a0-509">Vous pouvez passer le nom de ressource pour le <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> méthode pour récupérer un <xref:System.IO.Stream> objet que vous pouvez ensuite passer à la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-509">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> method to retrieve a <xref:System.IO.Stream> object that you can then pass to the <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span></span>  
  
-   <span data-ttu-id="850a0-510">Vous pouvez passer le nom de ressource pour le <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> méthode pour récupérer un <xref:System.IO.Stream> objet que vous pouvez ensuite passer à la <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-510">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> method to retrieve a <xref:System.IO.Stream> object that you can then pass to the <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span></span>  
  
 <span data-ttu-id="850a0-511">Informations sur la ressource sont renvoyées uniquement si la ressource est visible à l’appelant ou l’appelant a <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="850a0-511">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="850a0-512">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-512">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="850a0-513">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="850a0-513">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="850a0-514">Charge la ressource de manifeste spécifiée à partir de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-514">Loads the specified manifest resource from this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="850a0-515">Nom de la ressource de manifeste demandée respectant la casse.</span><span class="sxs-lookup"><span data-stu-id="850a0-515">The case-sensitive name of the manifest resource being requested.</span></span></param>
        <summary><span data-ttu-id="850a0-516">Charge la ressource de manifeste spécifiée à partir de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-516">Loads the specified manifest resource from this assembly.</span></span></summary>
        <returns><span data-ttu-id="850a0-517">La ressource de manifeste ; ou <see langword="null" /> si aucune ressource n'a été spécifiée pendant la compilation, ou si la ressource n'est pas visible par l'appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-517">The manifest resource; or <see langword="null" /> if no resources were specified during compilation or if the resource is not visible to the caller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-518">Une ressource de manifeste est une ressource (par exemple, un fichier image) qui est incorporée dans l’assembly au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="850a0-518">A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</span></span> <span data-ttu-id="850a0-519">Pour plus d’informations sur les ressources de manifeste, consultez [les principes des ressources Microsoft .NET Framework](https://go.microsoft.com/fwlink/?LinkId=204554) dans MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="850a0-519">For more information about manifest resources, see [Microsoft .NET Framework Resource Basics](https://go.microsoft.com/fwlink/?LinkId=204554) in the MSDN Library.</span></span>  
  
 <span data-ttu-id="850a0-520">Informations sur la ressource sont renvoyées uniquement si la ressource est visible à l’appelant ou l’appelant a <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="850a0-520">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-521">Cette méthode retourne `null` si une ressource privée dans un autre assembly est accessible et que l’appelant n’a pas <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> indicateur.</span><span class="sxs-lookup"><span data-stu-id="850a0-521">This method returns `null` if a private resource in another assembly is accessed and the caller does not have <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="850a0-522">Si le manifeste d’assembly répertorie un fichier de ressources, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> retourne un <xref:System.IO.Stream> même si le fichier de ressources est introuvable sur le disque au moment de l’objet.</span><span class="sxs-lookup"><span data-stu-id="850a0-522">If the assembly manifest lists a resource file, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> returns a <xref:System.IO.Stream> object even if the resource file cannot be found on disk at the time.</span></span> <span data-ttu-id="850a0-523">Si le fichier de ressources est introuvable, en passant le résultat <xref:System.IO.Stream> de l’objet à la <xref:System.Resources.ResourceReader> constructeur entraîne une <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-523">If the resource file is not found, passing the resulting <xref:System.IO.Stream> object to the <xref:System.Resources.ResourceReader> constructor causes an <xref:System.ArgumentException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-524">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-524">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-525">Le paramètre <paramref name="name" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="850a0-525">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="850a0-526">Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.IO.IOException" />, à la place.</span><span class="sxs-lookup"><span data-stu-id="850a0-526">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="850a0-527">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-527">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-528"><paramref name="name" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-528"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-529"><paramref name="name" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-529"><paramref name="name" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="850a0-530">La longueur de la ressource est supérieure à <see cref="F:System.Int64.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-530">Resource length is greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="850a0-531">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-531">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="850a0-532">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="850a0-532">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md"><span data-ttu-id="850a0-533">Manifeste d'assembly</span><span class="sxs-lookup"><span data-stu-id="850a0-533">Assembly Manifest</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="850a0-534">Type dont l'espace de noms définit la portée du nom de la ressource de manifeste.</span><span class="sxs-lookup"><span data-stu-id="850a0-534">The type whose namespace is used to scope the manifest resource name.</span></span></param>
        <param name="name"><span data-ttu-id="850a0-535">Nom de la ressource de manifeste demandée respectant la casse.</span><span class="sxs-lookup"><span data-stu-id="850a0-535">The case-sensitive name of the manifest resource being requested.</span></span></param>
        <summary><span data-ttu-id="850a0-536">Charge la ressource de manifeste spécifiée, dont la portée est définie par l'espace de noms du type déterminé, à partir de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-536">Loads the specified manifest resource, scoped by the namespace of the specified type, from this assembly.</span></span></summary>
        <returns><span data-ttu-id="850a0-537">La ressource de manifeste ; ou <see langword="null" /> si aucune ressource n'a été spécifiée pendant la compilation, ou si la ressource n'est pas visible par l'appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-537">The manifest resource; or <see langword="null" /> if no resources were specified during compilation or if the resource is not visible to the caller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-538">Par exemple, si le nom complet spécifié pour `type` est « MyNameSpace.MyClasses » et `name` est « Net », cette méthode recherche une ressource appelée « MyNameSpace.Net » de surcharge.</span><span class="sxs-lookup"><span data-stu-id="850a0-538">For example, if the full name specified for `type` is "MyNameSpace.MyClasses" and `name` is "Net", this method overload searches for a resource named "MyNameSpace.Net".</span></span>  
  
 <span data-ttu-id="850a0-539">Une ressource de manifeste est une ressource (par exemple, un fichier image) qui est incorporée dans l’assembly au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="850a0-539">A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</span></span> <span data-ttu-id="850a0-540">Pour plus d’informations sur les ressources de manifeste, consultez [les principes des ressources Microsoft .NET Framework](https://go.microsoft.com/fwlink/?LinkId=204554) dans MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="850a0-540">For more information about manifest resources, see [Microsoft .NET Framework Resource Basics](https://go.microsoft.com/fwlink/?LinkId=204554) in the MSDN Library.</span></span>  
  
 <span data-ttu-id="850a0-541">Informations sur la ressource sont renvoyées uniquement si la ressource est visible à l’appelant ou l’appelant a <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="850a0-541">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-542">Cette méthode retourne `null` si une ressource privée dans un autre assembly est accessible et que l’appelant n’a pas <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> indicateur.</span><span class="sxs-lookup"><span data-stu-id="850a0-542">This method returns `null` if a private resource in another assembly is accessed and the caller does not have <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="850a0-543">Si le manifeste d’assembly répertorie un fichier de ressources, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> retourne un <xref:System.IO.Stream> même si le fichier de ressources est introuvable sur le disque au moment de l’objet.</span><span class="sxs-lookup"><span data-stu-id="850a0-543">If the assembly manifest lists a resource file, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> returns a <xref:System.IO.Stream> object even if the resource file cannot be found on disk at the time.</span></span> <span data-ttu-id="850a0-544">Si le fichier de ressources est introuvable, en passant le résultat <xref:System.IO.Stream> de l’objet à la <xref:System.Resources.ResourceReader> constructeur entraîne une <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-544">If the resource file is not found, passing the resulting <xref:System.IO.Stream> object to the <xref:System.Resources.ResourceReader> constructor causes an <xref:System.ArgumentException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-545">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-545">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-546">Le paramètre <paramref name="name" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="850a0-546">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-547">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-547">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-548"><paramref name="name" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-548"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-549"><paramref name="name" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-549"><paramref name="name" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="850a0-550">La longueur de la ressource est supérieure à <see cref="F:System.Int64.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-550">Resource length is greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="850a0-551">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-551">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="850a0-552">Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="850a0-552">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md"><span data-ttu-id="850a0-553">Manifeste d'assembly</span><span class="sxs-lookup"><span data-stu-id="850a0-553">Assembly Manifest</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="850a0-554">Nom du module demandé.</span><span class="sxs-lookup"><span data-stu-id="850a0-554">The name of the module being requested.</span></span></param>
        <summary><span data-ttu-id="850a0-555">Obtient le module spécifié dans cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-555">Gets the specified module in this assembly.</span></span></summary>
        <returns><span data-ttu-id="850a0-556">Module demandé, ou <see langword="null" /> si le module est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-556">The module being requested, or <see langword="null" /> if the module is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-557">Cette méthode fonctionne sur les noms de fichiers.</span><span class="sxs-lookup"><span data-stu-id="850a0-557">This method works on file names.</span></span>  
  
 <span data-ttu-id="850a0-558">Classes dans le `Reflection.Emit` espace de noms émettent le nom de la portée d’un module dynamique.</span><span class="sxs-lookup"><span data-stu-id="850a0-558">Classes in the `Reflection.Emit` namespace emit the scope name for a dynamic module.</span></span> <span data-ttu-id="850a0-559">Le nom de l’étendue peut être déterminé par le <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="850a0-559">The scope name can be determined by the <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="850a0-560">Passez le type de module à `Assembly.GetModule`.</span><span class="sxs-lookup"><span data-stu-id="850a0-560">Pass the kind of module you want to `Assembly.GetModule`.</span></span> <span data-ttu-id="850a0-561">Par exemple, si vous souhaitez que le module qui contient le manifeste d’assembly, passez le nom de la portée du module à `GetModule`.</span><span class="sxs-lookup"><span data-stu-id="850a0-561">For example, if you want the module that contains the assembly manifest, pass the scope name of the module to `GetModule`.</span></span> <span data-ttu-id="850a0-562">Sinon, passez le nom de fichier du module.</span><span class="sxs-lookup"><span data-stu-id="850a0-562">Otherwise, pass the file name of the module.</span></span> <span data-ttu-id="850a0-563">Les assemblys chargés par un de le `Load` les méthodes qui ont un paramètre byte [] ont un seul module, et c’est le module du manifeste.</span><span class="sxs-lookup"><span data-stu-id="850a0-563">Assemblies loaded by one of the `Load` methods that have a byte[] parameter have only one module, and that is the manifest module.</span></span> <span data-ttu-id="850a0-564">Toujours ces modules en utilisant le nom de l’étendue de recherche.</span><span class="sxs-lookup"><span data-stu-id="850a0-564">Always seek these modules using the scope name.</span></span>  
  
 <span data-ttu-id="850a0-565">Un type peut être récupéré à partir d’un module spécifique <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="850a0-565">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="850a0-566">Appel de `Module.GetType` sur le module qui contient le manifeste pas lance une recherche de la totalité de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-566">Calling `Module.GetType` on the module containing the manifest will not initiate a search of the entire assembly.</span></span> <span data-ttu-id="850a0-567">Pour récupérer un type d’un assembly, quel que soit le module dans lequel il se trouve dans, vous devez appeler <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="850a0-567">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-568">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-568">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-569">Le paramètre <paramref name="name" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="850a0-569">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-570">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-570">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-571"><paramref name="name" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-571"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-572"><paramref name="name" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-572"><paramref name="name" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="850a0-573">Obtient tous les modules qui appartiennent à cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-573">Gets all the modules that are part of this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-574">Obtient tous les modules qui appartiennent à cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-574">Gets all the modules that are part of this assembly.</span></span></summary>
        <returns><span data-ttu-id="850a0-575">Tableau de modules.</span><span class="sxs-lookup"><span data-stu-id="850a0-575">An array of modules.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-576">Cette méthode fonctionne sur les fichiers de ressources publiques et privées.</span><span class="sxs-lookup"><span data-stu-id="850a0-576">This method works on public and private resource files.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-577">Modules doivent être émises avec des extensions de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="850a0-577">Modules must be emitted with file name extensions.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-578">L’exemple suivant affiche le nom du module dans le tableau retourné qui contient le manifeste d’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-578">The following example displays the name of the module in the returned array that contains the assembly manifest.</span></span>  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-579">Le module à charger ne spécifie pas une extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="850a0-579">The module to be loaded does not specify a file name extension.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><span data-ttu-id="850a0-580"><see langword="true" /> pour inclure des modules de ressources ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-580"><see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="850a0-581">Obtient tous les modules qui appartiennent à cet assembly, en spécifiant si des modules de ressources doivent être inclus.</span><span class="sxs-lookup"><span data-stu-id="850a0-581">Gets all the modules that are part of this assembly, specifying whether to include resource modules.</span></span></summary>
        <returns><span data-ttu-id="850a0-582">Tableau de modules.</span><span class="sxs-lookup"><span data-stu-id="850a0-582">An array of modules.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-583">Cette méthode fonctionne sur les fichiers de ressources publiques et privées.</span><span class="sxs-lookup"><span data-stu-id="850a0-583">This method works on public and private resource files.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-584">Modules doivent être émises avec des extensions de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="850a0-584">Modules must be emitted with file name extensions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="850a0-585">Obtient <see cref="T:System.Reflection.AssemblyName" /> pour cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-585">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-586">Obtient <see cref="T:System.Reflection.AssemblyName" /> pour cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-586">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly.</span></span></summary>
        <returns><span data-ttu-id="850a0-587">Objet qui contient le nom complet analysé correspondant à cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-587">An object that contains the fully parsed display name for this assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="850a0-588">Pour accéder au chemin de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-588">for access to the path of the assembly.</span></span> <span data-ttu-id="850a0-589">Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="850a0-589">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName"><span data-ttu-id="850a0-590"><see langword="true" /> pour affecter à <see cref="P:System.Reflection.Assembly.CodeBase" /> l'emplacement de l'assembly une fois qu'il est devenu un cliché instantané ; <see langword="false" /> pour affecter un emplacement d'origine à <see cref="P:System.Reflection.Assembly.CodeBase" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-590"><see langword="true" /> to set the <see cref="P:System.Reflection.Assembly.CodeBase" /> to the location of the assembly after it was shadow copied; <see langword="false" /> to set <see cref="P:System.Reflection.Assembly.CodeBase" /> to the original location.</span></span></param>
        <summary><span data-ttu-id="850a0-591">Obtient un <see cref="T:System.Reflection.AssemblyName" /> pour cet assembly, en définissant le code base de la manière spécifiée par <paramref name="copiedName" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-591">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly, setting the codebase as specified by <paramref name="copiedName" />.</span></span></summary>
        <returns><span data-ttu-id="850a0-592">Objet qui contient le nom complet analysé correspondant à cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-592">An object that contains the fully parsed display name for this assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="850a0-593">Pour accéder au chemin de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-593">for access to the path of the assembly.</span></span> <span data-ttu-id="850a0-594">Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="850a0-594">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="850a0-595">Objet à remplir à l'aide des informations de sérialisation.</span><span class="sxs-lookup"><span data-stu-id="850a0-595">The object to be populated with serialization information.</span></span></param>
        <param name="context"><span data-ttu-id="850a0-596">Contexte de destination de la sérialisation.</span><span class="sxs-lookup"><span data-stu-id="850a0-596">The destination context of the serialization.</span></span></param>
        <summary><span data-ttu-id="850a0-597">Obtient les informations de sérialisation avec toutes les données nécessaires pour réinstancier cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-597">Gets serialization information with all of the data needed to reinstantiate this assembly.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-598"><paramref name="info" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-598"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="850a0-599">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="850a0-599">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="850a0-600">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="850a0-600">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-601">Obtient les objets <see cref="T:System.Reflection.AssemblyName" /> pour tous les assemblys référencés par cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-601">Gets the <see cref="T:System.Reflection.AssemblyName" /> objects for all the assemblies referenced by this assembly.</span></span></summary>
        <returns><span data-ttu-id="850a0-602">Tableau qui contient les noms complets analysés de tous les assemblys référencés par cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-602">An array that contains the fully parsed display names of all the assemblies referenced by this assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="850a0-603">En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> propriété d’un <xref:System.Reflection.AssemblyName> objet qui est retourné par cette méthode est <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> s’il n’existe aucun algorithme de hachage pour l’assembly référencé, ou si l’algorithme de hachage de l’assembly référencé n’est pas identifié par le <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> énumération.</span><span class="sxs-lookup"><span data-stu-id="850a0-603">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property of an <xref:System.Reflection.AssemblyName> object that is returned by this method is <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> if there is no hash algorithm for the referenced assembly, or if the hash algorithm of the referenced assembly is not identified by the <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="850a0-604">Dans les versions précédentes du .NET Framework, le <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> propriété retournée <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> dans cette situation.</span><span class="sxs-lookup"><span data-stu-id="850a0-604">In previous versions of the .NET Framework, the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property returned <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> in this situation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-605">L’exemple de code suivant montre l’appel la <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="850a0-605">The following code example demonstrates calling the <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> method.</span></span> <span data-ttu-id="850a0-606">Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Assembly> classe.</span><span class="sxs-lookup"><span data-stu-id="850a0-606">This code example is part of a larger example provided for the <xref:System.Reflection.Assembly> class.</span></span>  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="850a0-607">Obtient l'assembly satellite.</span><span class="sxs-lookup"><span data-stu-id="850a0-607">Gets the satellite assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="850a0-608">Culture spécifiée.</span><span class="sxs-lookup"><span data-stu-id="850a0-608">The specified culture.</span></span></param>
        <summary><span data-ttu-id="850a0-609">Obtient l'assembly satellite pour la culture spécifiée.</span><span class="sxs-lookup"><span data-stu-id="850a0-609">Gets the satellite assembly for the specified culture.</span></span></summary>
        <returns><span data-ttu-id="850a0-610">Assembly satellite spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-610">The specified satellite assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-611">Les assemblys satellites contiennent des ressources localisées, comme les assemblys d’application principaux qui contiennent du code exécutable non localisable et les ressources pour une culture unique utilisée comme culture neutre ou par défaut.</span><span class="sxs-lookup"><span data-stu-id="850a0-611">Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</span></span>  
  
 <span data-ttu-id="850a0-612">Appelez cette méthode pour utiliser votre version actuelle de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-612">Call this method to use your current assembly version.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-613"><paramref name="culture" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-613"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-614">L’assembly est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-614">The assembly cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-615">L’assembly satellite avec un nom de fichier correspondant a été trouvé, mais l’élément <see langword="CultureInfo" /> ne correspondait pas à l’élément spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-615">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> did not match the one specified.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-616">L’assembly satellite n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-616">The satellite assembly is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="850a0-617">Culture spécifiée.</span><span class="sxs-lookup"><span data-stu-id="850a0-617">The specified culture.</span></span></param>
        <param name="version"><span data-ttu-id="850a0-618">Version de l'assembly satellite.</span><span class="sxs-lookup"><span data-stu-id="850a0-618">The version of the satellite assembly.</span></span></param>
        <summary><span data-ttu-id="850a0-619">Obtient la version spécifiée de l'assembly satellite pour la culture donnée.</span><span class="sxs-lookup"><span data-stu-id="850a0-619">Gets the specified version of the satellite assembly for the specified culture.</span></span></summary>
        <returns><span data-ttu-id="850a0-620">Assembly satellite spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-620">The specified satellite assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-621">Les assemblys satellites contiennent des ressources localisées, comme les assemblys d’application principaux qui contiennent du code exécutable non localisable et les ressources pour une culture unique utilisée comme culture neutre ou par défaut.</span><span class="sxs-lookup"><span data-stu-id="850a0-621">Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</span></span>  
  
 <span data-ttu-id="850a0-622">Appelez le <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> surcharge à utiliser votre version actuelle de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-622">Call the <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> overload to use your current assembly version.</span></span>  
  
 <span data-ttu-id="850a0-623">Si `version` est `null`, la version actuelle de l’assembly est utilisée si la ressource et les principaux assemblys sont signés.</span><span class="sxs-lookup"><span data-stu-id="850a0-623">If `version` is `null`, the current assembly version is used if both the resource and main assemblies are signed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-624"><paramref name="culture" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-624"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-625">L’assembly satellite avec un nom de fichier correspondant a été trouvé, mais l’élément <see langword="CultureInfo" /> ou la version ne correspondait pas à l’élément spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-625">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> or the version did not match the one specified.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-626">L’assembly est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-626">The assembly cannot be found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-627">L’assembly satellite n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-627">The satellite assembly is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="850a0-628">Obtient l'objet <see cref="T:System.Type" /> qui représente le type spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-628">Gets the <see cref="T:System.Type" /> object that represents the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="850a0-629">Nom complet du type.</span><span class="sxs-lookup"><span data-stu-id="850a0-629">The full name of the type.</span></span></param>
        <summary><span data-ttu-id="850a0-630">Obtient l'objet <see cref="T:System.Type" /> avec le nom spécifié dans l'instance de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-630">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance.</span></span></summary>
        <returns><span data-ttu-id="850a0-631">Objet qui représente la classe spécifiée ou <see langword="null" /> si la classe est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-631">An object that represents the specified class, or <see langword="null" /> if the class is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-632">Cette méthode recherche uniquement l’instance actuelle de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-632">This method only searches the current assembly instance.</span></span> <span data-ttu-id="850a0-633">Le `name` paramètre inclut l’espace de noms mais pas l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-633">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="850a0-634">Pour rechercher d’autres assemblys pour un type, utilisez le <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> surcharge de méthode, qui peut éventuellement inclure un nom d’assembly complet en tant que partie du nom de type.</span><span class="sxs-lookup"><span data-stu-id="850a0-634">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-635">Si le type a été transféré à un autre assembly, il est toujours retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="850a0-635">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="850a0-636">Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="850a0-636">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-637">L’exemple suivant définit abstraite `MeansOfTransportation` classe dans le `Transportation` espace de noms.</span><span class="sxs-lookup"><span data-stu-id="850a0-637">The following example defines an abstract `MeansOfTransportation` class in the `Transportation` namespace.</span></span> <span data-ttu-id="850a0-638">Il appelle le <xref:System.Reflection.Assembly.GetType%28System.String%29> méthode pour récupérer son <xref:System.Type> objet, appelle le <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> méthode pour obtenir un tableau de <xref:System.Reflection.PropertyInfo> objets qui représentent les propriétés du type et puis affiche des informations sur le type abstraite des propriétés.</span><span class="sxs-lookup"><span data-stu-id="850a0-638">It calls the <xref:System.Reflection.Assembly.GetType%28System.String%29> method to retrieve its <xref:System.Type> object, calls the <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> method to get an array of <xref:System.Reflection.PropertyInfo> objects that represent the type's properties, and then displays information on the type's abstract properties.</span></span> <span data-ttu-id="850a0-639">Notez que l’appel à la <xref:System.Reflection.Assembly.GetType%28System.String%29> méthode utilise le nom du type qualifié complet (autrement dit, son espace de noms, ainsi que son nom de type).</span><span class="sxs-lookup"><span data-stu-id="850a0-639">Note that the call to the <xref:System.Reflection.Assembly.GetType%28System.String%29> method uses the type's fully qualified name (that is, its namespace along with its type name).</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-640"><paramref name="name" /> n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-640"><paramref name="name" /> is invalid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-641"><paramref name="name" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-641"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-642"><paramref name="name" /> requiert un assembly dépendant qui est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-642"><paramref name="name" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="850a0-643">Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.IO.IOException" />, à la place.</span><span class="sxs-lookup"><span data-stu-id="850a0-643">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block><span data-ttu-id="850a0-644">
          <paramref name="name" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-644">
          <paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="850a0-645">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-645">-or-</span></span> 
<span data-ttu-id="850a0-646">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="name" /> nécessite un assembly dépendant qui n’a pas été préchargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-646">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-647"><paramref name="name" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-647"><paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-648">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-648">-or-</span></span> 
 <span data-ttu-id="850a0-649"><paramref name="name" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</span><span class="sxs-lookup"><span data-stu-id="850a0-649"><paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="850a0-650">Nom complet du type.</span><span class="sxs-lookup"><span data-stu-id="850a0-650">The full name of the type.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="850a0-651"><see langword="true" /> pour lever une exception si le type est introuvable ; <see langword="false" /> pour retourner la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-651"><see langword="true" /> to throw an exception if the type is not found; <see langword="false" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="850a0-652">Obtient l'objet <see cref="T:System.Type" /> portant le nom spécifié dans l'instance de l'assembly et lève éventuellement une exception si le type est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-652">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance and optionally throws an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="850a0-653">Objet qui représente la classe spécifiée.</span><span class="sxs-lookup"><span data-stu-id="850a0-653">An object that represents the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-654">Cette méthode recherche uniquement l’instance actuelle de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-654">This method only searches the current assembly instance.</span></span> <span data-ttu-id="850a0-655">Le `name` paramètre inclut l’espace de noms mais pas l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-655">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="850a0-656">Pour rechercher d’autres assemblys pour un type, utilisez le <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> surcharge de méthode, qui peut éventuellement inclure un nom d’assembly complet en tant que partie du nom de type.</span><span class="sxs-lookup"><span data-stu-id="850a0-656">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-657">Si le type a été transféré à un autre assembly, il est toujours retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="850a0-657">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="850a0-658">Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="850a0-658">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="850a0-659">Le `throwOnError` paramètre affecte uniquement ce qui se passe lorsque le type est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-659">The `throwOnError` parameter only affects what happens when the type is not found.</span></span> <span data-ttu-id="850a0-660">Il n’affecte pas toutes les exceptions levées.</span><span class="sxs-lookup"><span data-stu-id="850a0-660">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="850a0-661">En particulier, si le type est trouvé mais ne peut pas être chargé, <xref:System.TypeLoadException> peut être levée même si `throwOnError` est `false`.</span><span class="sxs-lookup"><span data-stu-id="850a0-661">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-662"><paramref name="name" /> n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-662"><paramref name="name" /> is invalid.</span></span>  
  
<span data-ttu-id="850a0-663">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-663">-or-</span></span> 
<span data-ttu-id="850a0-664">La longueur de <paramref name="name" /> dépasse 1 024 caractères.</span><span class="sxs-lookup"><span data-stu-id="850a0-664">The length of <paramref name="name" /> exceeds 1024 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-665"><paramref name="name" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-665"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="850a0-666"><paramref name="throwOnError" /> a la valeur <see langword="true" /> et le type est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-666"><paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-667"><paramref name="name" /> requiert un assembly dépendant qui est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-667"><paramref name="name" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-668"><paramref name="name" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-668"><paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="850a0-669">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-669">-or-</span></span> 
<span data-ttu-id="850a0-670">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="name" /> nécessite un assembly dépendant qui n’a pas été préchargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-670">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-671"><paramref name="name" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-671"><paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-672">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-672">-or-</span></span> 
 <span data-ttu-id="850a0-673"><paramref name="name" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</span><span class="sxs-lookup"><span data-stu-id="850a0-673"><paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="850a0-674">Nom complet du type.</span><span class="sxs-lookup"><span data-stu-id="850a0-674">The full name of the type.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="850a0-675"><see langword="true" /> pour lever une exception si le type est introuvable ; <see langword="false" /> pour retourner la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-675"><see langword="true" /> to throw an exception if the type is not found; <see langword="false" /> to return <see langword="null" />.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="850a0-676"><see langword="true" /> pour ignorer la casse du nom de type ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-676"><see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="850a0-677">Obtient l'objet <see cref="T:System.Type" /> portant le nom spécifié dans l'instance de l'assembly et propose d'ignorer la casse et de lever une exception si le type est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-677">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance, with the options of ignoring the case, and of throwing an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="850a0-678">Objet qui représente la classe spécifiée.</span><span class="sxs-lookup"><span data-stu-id="850a0-678">An object that represents the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-679">Cette méthode recherche uniquement l’instance actuelle de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-679">This method only searches the current assembly instance.</span></span> <span data-ttu-id="850a0-680">Le `name` paramètre inclut l’espace de noms mais pas l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-680">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="850a0-681">Pour rechercher d’autres assemblys pour un type, utilisez le <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> surcharge de méthode, qui peut éventuellement inclure un nom d’assembly complet en tant que partie du nom de type.</span><span class="sxs-lookup"><span data-stu-id="850a0-681">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-682">Si le type a été transféré à un autre assembly, il est toujours retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="850a0-682">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="850a0-683">Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="850a0-683">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="850a0-684">Le `throwOnError` paramètre affecte uniquement ce qui se passe lorsque le type est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-684">The `throwOnError` parameter only affects what happens when the type is not found.</span></span> <span data-ttu-id="850a0-685">Il n’affecte pas toutes les exceptions levées.</span><span class="sxs-lookup"><span data-stu-id="850a0-685">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="850a0-686">En particulier, si le type est trouvé mais ne peut pas être chargé, <xref:System.TypeLoadException> peut être levée même si `throwOnError` est `false`.</span><span class="sxs-lookup"><span data-stu-id="850a0-686">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-687"><paramref name="name" /> n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-687"><paramref name="name" /> is invalid.</span></span>  
  
<span data-ttu-id="850a0-688">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-688">-or-</span></span> 
<span data-ttu-id="850a0-689">La longueur de <paramref name="name" /> dépasse 1 024 caractères.</span><span class="sxs-lookup"><span data-stu-id="850a0-689">The length of <paramref name="name" /> exceeds 1024 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-690"><paramref name="name" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-690"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="850a0-691"><paramref name="throwOnError" /> a la valeur <see langword="true" /> et le type est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-691"><paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-692"><paramref name="name" /> requiert un assembly dépendant qui est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-692"><paramref name="name" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-693"><paramref name="name" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-693"><paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="850a0-694">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-694">-or-</span></span> 
<span data-ttu-id="850a0-695">L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="name" /> nécessite un assembly dépendant qui n’a pas été préchargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-695">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-696"><paramref name="name" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-696"><paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-697">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-697">-or-</span></span> 
 <span data-ttu-id="850a0-698"><paramref name="name" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</span><span class="sxs-lookup"><span data-stu-id="850a0-698"><paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-699">Obtient les types définis dans cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-699">Gets the types defined in this assembly.</span></span></summary>
        <returns><span data-ttu-id="850a0-700">Tableau qui contient tous les types définis dans cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-700">An array that contains all the types that are defined in this assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-701">Le tableau retourné inclut des types imbriqués.</span><span class="sxs-lookup"><span data-stu-id="850a0-701">The returned array includes nested types.</span></span>  
  
 <span data-ttu-id="850a0-702">Si le <xref:System.Reflection.Assembly.GetTypes%2A> méthode est appelée sur un assembly et un type de cet assembly est dépendant d’un type dans un assembly qui n’a pas a été chargé (par exemple, si elle dérive d’un type dans le deuxième assembly), un <xref:System.Reflection.ReflectionTypeLoadException> est levée.</span><span class="sxs-lookup"><span data-stu-id="850a0-702">If the <xref:System.Reflection.Assembly.GetTypes%2A> method is called on an assembly and a type in that assembly is dependent on a type in an assembly that has not been loaded (for example, if it derives from a type in the second assembly), a <xref:System.Reflection.ReflectionTypeLoadException> is thrown.</span></span> <span data-ttu-id="850a0-703">Par exemple, cela peut se produire si le premier assembly a été chargé avec le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> ou <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> méthodes et le deuxième assembly n’a pas été chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-703">For example, this can happen if the first assembly was loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> or <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods, and the second assembly was not loaded.</span></span> <span data-ttu-id="850a0-704">Il peut également se produire avec les assemblys chargés à l’aide de la <xref:System.Reflection.Assembly.Load%2A> et <xref:System.Reflection.Assembly.LoadFile%2A> méthodes si le deuxième assembly ne peut pas être localisé quand le <xref:System.Reflection.Assembly.GetTypes%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="850a0-704">It can also happen with assemblies loaded using the <xref:System.Reflection.Assembly.Load%2A> and <xref:System.Reflection.Assembly.LoadFile%2A> methods if the second assembly cannot be located when the <xref:System.Reflection.Assembly.GetTypes%2A> method is called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-705">Si un type a été transféré à un autre assembly, il n’est pas inclus dans le tableau retourné.</span><span class="sxs-lookup"><span data-stu-id="850a0-705">If a type has been forwarded to another assembly, it is not included in the returned array.</span></span> <span data-ttu-id="850a0-706">Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="850a0-706">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="850a0-707">Pour récupérer une collection de <xref:System.Reflection.TypeInfo> objets plutôt qu’un tableau de <xref:System.Type> objets, utiliser le <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="850a0-707">To retrieve a collection of <xref:System.Reflection.TypeInfo> objects instead of an array of <xref:System.Type> objects, use the <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-708">L’exemple suivant affiche les paramètres d’une méthode sur un type dans l’assembly spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-708">The following example displays parameters of one method on a type in the specified assembly.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException"><span data-ttu-id="850a0-709">L’assembly contient un ou plusieurs types qui ne peuvent pas être chargés.</span><span class="sxs-lookup"><span data-stu-id="850a0-709">The assembly contains one or more types that cannot be loaded.</span></span> <span data-ttu-id="850a0-710">Le tableau retourné par la propriété <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> de cette exception contient un objet <see cref="T:System.Type" /> pour chaque type qui a été chargé et <see langword="null" /> pour chaque type qui n’a pas pu être chargé, tandis que la propriété <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> contient une exception pour chaque type qui n’a pas pu être chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-710">The array returned by the <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> property of this exception contains a <see cref="T:System.Type" /> object for each type that was loaded and <see langword="null" /> for each type that could not be loaded, while the <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> property contains an exception for each type that could not be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-711">Obtient une valeur indiquant si l'assembly a été chargé à partir du Global Assembly Cache.</span><span class="sxs-lookup"><span data-stu-id="850a0-711">Gets a value indicating whether the assembly was loaded from the global assembly cache.</span></span></summary>
        <value><span data-ttu-id="850a0-712"><see langword="true" /> si l'assembly a été chargé à partir du Global Assembly Cache ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-712"><see langword="true" /> if the assembly was loaded from the global assembly cache; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-713">Obtient le contexte hôte avec lequel l'assembly a été chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-713">Gets the host context with which the assembly was loaded.</span></span></summary>
        <value><span data-ttu-id="850a0-714">Valeur <see cref="T:System.Int64" /> qui indique le contexte hôte avec lequel l'assembly a été chargé, le cas échéant.</span><span class="sxs-lookup"><span data-stu-id="850a0-714">An <see cref="T:System.Int64" /> value that indicates the host context with which the assembly was loaded, if any.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-715">Obtient une représentation sous forme de chaîne de la version du Common Language Runtime (CLR) enregistrée dans le fichier contenant le manifeste.</span><span class="sxs-lookup"><span data-stu-id="850a0-715">Gets a string representing the version of the common language runtime (CLR) saved in the file containing the manifest.</span></span></summary>
        <value><span data-ttu-id="850a0-716">Nom du dossier de la version CLR.</span><span class="sxs-lookup"><span data-stu-id="850a0-716">The CLR version folder name.</span></span> <span data-ttu-id="850a0-717">Il ne s’agit pas d’un chemin d’accès complet.</span><span class="sxs-lookup"><span data-stu-id="850a0-717">This is not a full path.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-718">Par exemple, la valeur de la version 1.1 du .NET Framework serait v1.1.4322.</span><span class="sxs-lookup"><span data-stu-id="850a0-718">For example, the value for the .NET Framework version 1.1 would be v1.1.4322.</span></span> <span data-ttu-id="850a0-719">Les fichiers binaires pour cette version seraient situés dans le chemin d’accès % windir%\Microsoft.NET\Framework\v1.1.4322.</span><span class="sxs-lookup"><span data-stu-id="850a0-719">The binary files for that version would be located in the path %windir%\Microsoft.NET\Framework\v1.1.4322.</span></span>  
  
 <span data-ttu-id="850a0-720">Par défaut, <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> est définie sur la version du CLR utilisée pour générer l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-720">By default, <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> is set to the version of the CLR used to build the assembly.</span></span> <span data-ttu-id="850a0-721">Toutefois, elle peut avoir été définie à une autre valeur au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="850a0-721">However, it might have been set to another value at compile time.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="850a0-722">Type de l'attribut à vérifier pour cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-722">The type of the attribute to be checked for this assembly.</span></span></param>
        <param name="inherit"><span data-ttu-id="850a0-723">Cet argument est ignoré pour les objets de ce type.</span><span class="sxs-lookup"><span data-stu-id="850a0-723">This argument is ignored for objects of this type.</span></span></param>
        <summary><span data-ttu-id="850a0-724">Indique si un attribut spécifié a été appliqué à l'assembly ou non.</span><span class="sxs-lookup"><span data-stu-id="850a0-724">Indicates whether or not a specified attribute has been applied to the assembly.</span></span></summary>
        <returns><span data-ttu-id="850a0-725"><see langword="true" /> si l'attribut a été appliqué à l'assembly ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-725"><see langword="true" /> if the attribute has been applied to the assembly; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="850a0-726">L’exemple de code suivant applique le <xref:System.Reflection.AssemblyTitleAttribute> attribut à un assembly, puis utilise <xref:System.Reflection.Assembly.IsDefined%2A> pour indiquer s’il a été appliqué.</span><span class="sxs-lookup"><span data-stu-id="850a0-726">The following code example applies the <xref:System.Reflection.AssemblyTitleAttribute> attribute to an assembly and then uses <xref:System.Reflection.Assembly.IsDefined%2A> to indicate whether it was applied.</span></span> <span data-ttu-id="850a0-727">Il teste également un attribut qui n’a été appliqué.</span><span class="sxs-lookup"><span data-stu-id="850a0-727">It also tests an attribute that was not applied.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-728"><paramref name="attributeType" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-728"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-729"><paramref name="attributeType" /> utilise un type non valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-729"><paramref name="attributeType" /> uses an invalid type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-730">Obtient une valeur qui indique si l'assembly actuel a été généré dynamiquement dans le processus actuel à l'aide de l'émission de réflexion.</span><span class="sxs-lookup"><span data-stu-id="850a0-730">Gets a value that indicates whether the current assembly was generated dynamically in the current process by using reflection emit.</span></span></summary>
        <value><span data-ttu-id="850a0-731"><see langword="true" /> si l'assembly actuel a été généré dynamiquement dans le processus actuel ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-731"><see langword="true" /> if the current assembly was generated dynamically in the current process; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-732">Assemblys dynamiques sont représentées par la classe dérivée <xref:System.Reflection.Emit.AssemblyBuilder>.</span><span class="sxs-lookup"><span data-stu-id="850a0-732">Dynamic assemblies are represented by the derived class <xref:System.Reflection.Emit.AssemblyBuilder>.</span></span>  
  
 <span data-ttu-id="850a0-733">Quand un assembly dynamique est enregistré sur disque, l’assembly enregistré n’est pas dynamique.</span><span class="sxs-lookup"><span data-stu-id="850a0-733">When a dynamic assembly is saved to disk, the saved assembly is not dynamic.</span></span> <span data-ttu-id="850a0-734">Si l’assembly enregistré est chargé dans un autre domaine d’application ou processus, la <xref:System.Reflection.Assembly.IsDynamic%2A> retourne de la propriété `false`.</span><span class="sxs-lookup"><span data-stu-id="850a0-734">If the saved assembly is loaded into another application domain or process, the <xref:System.Reflection.Assembly.IsDynamic%2A> property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-735">Obtient une valeur qui indique si l'assembly actuel est chargé avec une confiance totale.</span><span class="sxs-lookup"><span data-stu-id="850a0-735">Gets a value that indicates whether the current assembly is loaded with full trust.</span></span></summary>
        <value><span data-ttu-id="850a0-736"><see langword="true" /> si l'assembly actuel est chargé avec une confiance totale ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-736"><see langword="true" /> if the current assembly is loaded with full trust; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="850a0-737">Charge un assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-737">Loads an assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="850a0-738">Tableau d'octets qui est une image au format COFF contenant un assembly émis.</span><span class="sxs-lookup"><span data-stu-id="850a0-738">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="850a0-739">Charge l'assembly avec une image au format COFF (Common Object File Format) contenant un assembly émis.</span><span class="sxs-lookup"><span data-stu-id="850a0-739">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly.</span></span> <span data-ttu-id="850a0-740">L'assembly est chargé dans le domaine d'application de l'appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-740">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="850a0-741">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-741">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-742">Le niveau de confiance d’un assembly est chargé à l’aide de cette méthode est le même que le niveau de confiance de l’assembly appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-742">The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</span></span> <span data-ttu-id="850a0-743">Pour charger un assembly à partir d’un tableau d’octets dont le niveau de confiance du domaine d’application, utilisez le <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="850a0-743">To load an assembly from a byte array with the trust level of the application domain, use the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> method overload.</span></span> <span data-ttu-id="850a0-744">Pour plus d’informations sur l’utilisation de la preuve avec les surcharges de la <xref:System.Reflection.Assembly.Load%2A> méthode qui acceptent les tableaux d’octets, consultez la <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="850a0-744">For more information about the use of evidence with overloads of the <xref:System.Reflection.Assembly.Load%2A> method that take byte arrays, see the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> method overload.</span></span>  
  
 <span data-ttu-id="850a0-745">La réflexion sur des fichiers exécutables C++ peut lever une <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-745">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="850a0-746">Cela est probablement dû au fait généralement de la suppression des adresses de réadressage ou `.reloc` section à partir de votre fichier exécutable.</span><span class="sxs-lookup"><span data-stu-id="850a0-746">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="850a0-747">Pour conserver le `.reloc` d’adresses de votre fichier exécutable C++, spécifiez `/fixed:no` lors de la liaison.</span><span class="sxs-lookup"><span data-stu-id="850a0-747">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="850a0-748">Notez que cette surcharge de méthode crée toujours un nouveau <xref:System.Reflection.Assembly> objet avec son propre mappage.</span><span class="sxs-lookup"><span data-stu-id="850a0-748">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-749"><paramref name="rawAssembly" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-749"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-750"><paramref name="rawAssembly" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-750"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-751">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-751">-or-</span></span> 
<span data-ttu-id="850a0-752">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="rawAssembly" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-752">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="850a0-753">Objet qui décrit l'assembly à charger.</span><span class="sxs-lookup"><span data-stu-id="850a0-753">The object that describes the assembly to be loaded.</span></span></param>
        <summary><span data-ttu-id="850a0-754">Charge un assembly en fonction de son <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-754">Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="850a0-755">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-755">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-756"><xref:System.IO.FileLoadException> est levée si `assemblyRef` Spécifie le nom complet de l’assembly et le premier assembly correspondant au nom simple a une autre version, culture ou jeton de clé publique.</span><span class="sxs-lookup"><span data-stu-id="850a0-756"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="850a0-757">Le chargeur ne continue pas à détecter d’autres assemblys qui correspondent au nom simple.</span><span class="sxs-lookup"><span data-stu-id="850a0-757">The loader does not continue probing for other assemblies that match the simple name.</span></span> <span data-ttu-id="850a0-758">Démarrer avec .NET Framework 4, car l’exécution de code dans les assemblys à distance est désactivée par défaut, un <xref:System.IO.FileLoadException> est également levée si `assemblyRef` spécifie un assembly distant.</span><span class="sxs-lookup"><span data-stu-id="850a0-758">Starting with .NET Framework 4, because execution of code in remote assemblies is disabled by default, a <xref:System.IO.FileLoadException> is also thrown if `assemblyRef` specifies a remote assembly.</span></span> <span data-ttu-id="850a0-759">Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.</span><span class="sxs-lookup"><span data-stu-id="850a0-759">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>     
  
> [!NOTE]
>  <span data-ttu-id="850a0-760">N’utilisez pas un <xref:System.Reflection.AssemblyName> avec uniquement le <xref:System.Reflection.AssemblyName.CodeBase%2A> jeu de propriétés.</span><span class="sxs-lookup"><span data-stu-id="850a0-760">Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set.</span></span> <span data-ttu-id="850a0-761">Le <xref:System.Reflection.AssemblyName.CodeBase%2A> propriété ne fournit pas tous les éléments de l’identité d’assembly (par exemple, le nom ou la version), ainsi le chargement ne se produit pas d’en fonction des règles de charge par identité, comme vous pouvez l’imaginer à partir de la <xref:System.Reflection.Assembly.Load%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="850a0-761">The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="850a0-762">Au lieu de cela, l’assembly est chargé à l’aide de règles load-from.</span><span class="sxs-lookup"><span data-stu-id="850a0-762">Instead, the assembly is loaded using load-from rules.</span></span> <span data-ttu-id="850a0-763">Pour plus d’informations sur les inconvénients de l’utilisation du contexte de chargement, consultez la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> surcharge de méthode ou [meilleures pratiques de chargement d’Assembly](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span><span class="sxs-lookup"><span data-stu-id="850a0-763">For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method overload or [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span></span>  
  
 <span data-ttu-id="850a0-764">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-764">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="850a0-765">Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="850a0-765">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="850a0-766">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode sans aucune <xref:System.Security.Policy.Evidence> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-766">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="850a0-767">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées.</span><span class="sxs-lookup"><span data-stu-id="850a0-767">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="850a0-768">Preuves fournies en tant qu’argument à la <xref:System.Reflection.Assembly.Load%2A> méthode annulent et remplacent les preuves fournies par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-768">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="850a0-769">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image common object file format (COFF), la preuve est héritée de l’assembly appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-769">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="850a0-770">Cela s’applique à la version 1.1 du .NET Framework Service Pack 1 (SP1) et les versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="850a0-770">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="850a0-771">Dans le .NET Framework version 1.0 et dans la version 1.1 sans SP1, lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image COFF, la preuve est combinée.</span><span class="sxs-lookup"><span data-stu-id="850a0-771">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="850a0-772">`Zone`, `Url` et `Site` sont héritées de l’assembly appelant, et `Hash` et `StrongName` proviennent de l’assembly COFF.</span><span class="sxs-lookup"><span data-stu-id="850a0-772">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="850a0-773">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un `Byte[]` paramètre et <xref:System.Security.Policy.Evidence> pour charger une image COFF, seule la preuve fournie est utilisée.</span><span class="sxs-lookup"><span data-stu-id="850a0-773">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="850a0-774">Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="850a0-774">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="850a0-775">La réflexion sur des fichiers exécutables C++ peut lever une <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-775">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="850a0-776">Cela est probablement dû au fait généralement de la suppression des adresses de réadressage ou `.reloc` section à partir de votre fichier exécutable.</span><span class="sxs-lookup"><span data-stu-id="850a0-776">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="850a0-777">Pour conserver le `.reloc` d’adresses de votre fichier exécutable C++, spécifiez `/fixed:no` lors de la liaison.</span><span class="sxs-lookup"><span data-stu-id="850a0-777">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-778">Si les deux le <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> propriété et la <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> propriété sont définies, la première tentative de charger l’assembly utilise le nom d’affichage (notamment la version, culture et ainsi de suite, tel que retourné par la <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriété).</span><span class="sxs-lookup"><span data-stu-id="850a0-778">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="850a0-779">Si le fichier est introuvable, <xref:System.Reflection.AssemblyName.CodeBase%2A> est utilisé pour rechercher l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-779">If the file is not found, <xref:System.Reflection.AssemblyName.CodeBase%2A> is used to search for the assembly.</span></span> <span data-ttu-id="850a0-780">Si l’assembly se trouve à l’aide de <xref:System.Reflection.AssemblyName.CodeBase%2A>, le nom d’affichage est comparé à l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-780">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="850a0-781">Si la correspondance échoue, un <xref:System.IO.FileLoadException> est levée.</span><span class="sxs-lookup"><span data-stu-id="850a0-781">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-782">L’exemple suivant instancie un <xref:System.Reflection.AssemblyName> de l’objet et l’utilise pour charger le `sysglobal.dll` assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-782">The following example instantiates an <xref:System.Reflection.AssemblyName> object and uses it to load the `sysglobal.dll` assembly.</span></span> <span data-ttu-id="850a0-783">L’exemple affiche ensuite le nom complet de types publics de l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-783">The example then displays the full name of the assembly's public types.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-784"><paramref name="assemblyRef" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-784"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-785"><paramref name="assemblyRef" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-785"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="850a0-786">Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.IO.IOException" />, à la place.</span><span class="sxs-lookup"><span data-stu-id="850a0-786">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="850a0-787">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-787">A file that was found could not be loaded.</span></span>

<span data-ttu-id="850a0-788">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-788">-or-</span></span>

<span data-ttu-id="850a0-789"><paramref name="assemblyRef" /> spécifie un assembly distant, mais la possibilité d’exécuter du code dans des assemblys distants est désactivée.</span><span class="sxs-lookup"><span data-stu-id="850a0-789"><paramref name="assemblyRef" /> specifies a remote assembly, but the ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="850a0-790">Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="850a0-790">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-791"><paramref name="assemblyRef" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-791"><paramref name="assemblyRef" /> is not a valid assembly.</span></span> <span data-ttu-id="850a0-792">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-792">-or-</span></span> 
<span data-ttu-id="850a0-793">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyRef" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-793">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="850a0-794">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</span><span class="sxs-lookup"><span data-stu-id="850a0-794">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="850a0-795">Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="850a0-795">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="850a0-796">pour lire un URI qui ne commence pas par « file:// ».</span><span class="sxs-lookup"><span data-stu-id="850a0-796">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="850a0-797">pour charger un assembly avec la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-797">to load an assembly with evidence.</span></span> <span data-ttu-id="850a0-798">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="850a0-798">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="850a0-799">Méthode de localisation des assemblys par le runtime</span><span class="sxs-lookup"><span data-stu-id="850a0-799">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="850a0-800">Forme longue du nom d'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-800">The long form of the assembly name.</span></span></param>
        <summary><span data-ttu-id="850a0-801">Charge un assembly en fonction de la forme longue de son nom.</span><span class="sxs-lookup"><span data-stu-id="850a0-801">Loads an assembly given the long form of its name.</span></span></summary>
        <returns><span data-ttu-id="850a0-802">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-802">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-803">La forme longue du nom d’un assembly se compose de son nom simple (par exemple, « système » de l’assembly System.dll), ainsi que sa version, culture, jeton de clé publique et, éventuellement, son architecture de processeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-803">The long form of an assembly name consists of its simple name (such as "System" for the System.dll assembly) along with its version, culture, public key token, and optionally its processor architecture.</span></span> <span data-ttu-id="850a0-804">Il correspond à l’assembly <xref:System.Reflection.Assembly.FullName%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="850a0-804">It corresponds to the assembly's <xref:System.Reflection.Assembly.FullName%2A> property.</span></span> <span data-ttu-id="850a0-805">L’exemple suivant illustre l’utilisation d’un nom long à charger l’assembly System.dll pour le .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="850a0-805">The following example illustrates the use of a long name to load the System.dll assembly for the .NET Framework 4.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <span data-ttu-id="850a0-806"><xref:System.IO.FileLoadException> est levée si `assemblyString` Spécifie le nom complet de l’assembly et le premier assembly correspondant au nom simple a une autre version, culture ou jeton de clé publique.</span><span class="sxs-lookup"><span data-stu-id="850a0-806"><xref:System.IO.FileLoadException> is thrown if `assemblyString` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="850a0-807">Le chargeur ne continue pas à détecter d’autres assemblys qui correspondent au nom simple.</span><span class="sxs-lookup"><span data-stu-id="850a0-807">The loader does not continue probing for other assemblies that match the simple name.</span></span>  
  
 <span data-ttu-id="850a0-808">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-808">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="850a0-809">Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="850a0-809">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="850a0-810">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode sans aucune <xref:System.Security.Policy.Evidence> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-810">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="850a0-811">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées.</span><span class="sxs-lookup"><span data-stu-id="850a0-811">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="850a0-812">Preuves fournies en tant qu’argument à la <xref:System.Reflection.Assembly.Load%2A> méthode annulent et remplacent les preuves fournies par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-812">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="850a0-813">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image common object file format (COFF), la preuve est héritée de l’assembly appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-813">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="850a0-814">Cela s’applique à la version 1.1 du .NET Framework Service Pack 1 (SP1) et les versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="850a0-814">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="850a0-815">Dans le .NET Framework version 1.0 et dans la version 1.1 sans SP1, lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image COFF, la preuve est combinée.</span><span class="sxs-lookup"><span data-stu-id="850a0-815">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="850a0-816">`Zone`, `Url` et `Site` sont héritées de l’assembly appelant, et `Hash` et `StrongName` proviennent de l’assembly COFF.</span><span class="sxs-lookup"><span data-stu-id="850a0-816">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="850a0-817">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un `Byte[]` paramètre et <xref:System.Security.Policy.Evidence> pour charger une image COFF, seule la preuve fournie est utilisée.</span><span class="sxs-lookup"><span data-stu-id="850a0-817">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="850a0-818">Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="850a0-818">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="850a0-819">La réflexion sur des fichiers exécutables C++ peut lever une <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-819">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="850a0-820">Cela est probablement dû au fait généralement de la suppression des adresses de réadressage ou `.reloc` section à partir de votre fichier exécutable.</span><span class="sxs-lookup"><span data-stu-id="850a0-820">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="850a0-821">Pour conserver le `.reloc` d’adresses de votre fichier exécutable C++, spécifiez `/fixed:no` lors de la liaison.</span><span class="sxs-lookup"><span data-stu-id="850a0-821">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="850a0-822">Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-822">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="850a0-823">Par exemple, « ProcessorArchitecture = msil ».</span><span class="sxs-lookup"><span data-stu-id="850a0-823">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="850a0-824">Toutefois, la méthode recommandée pour spécifier un nom d’assembly consiste à créer un <xref:System.Reflection.AssemblyName> de l’objet et le passer à une surcharge appropriée de la <xref:System.Reflection.Assembly.Load%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="850a0-824">However, the recommended way to specify an assembly name is to create an <xref:System.Reflection.AssemblyName> object and pass it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="850a0-825">Consultez <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="850a0-825">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-826">L’exemple suivant charge un assembly en fonction de son nom qualifié complet et répertorie tous les types contenus dans l’assembly spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-826">The following example loads an assembly given its fully qualified name, and lists all the types contained in the specified assembly.</span></span> <span data-ttu-id="850a0-827">Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet.</span><span class="sxs-lookup"><span data-stu-id="850a0-827">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="850a0-828">Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="850a0-828">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-829"><paramref name="assemblyString" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-829"><paramref name="assemblyString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-830"><paramref name="assemblyString" /> est une chaîne de longueur nulle.</span><span class="sxs-lookup"><span data-stu-id="850a0-830"><paramref name="assemblyString" /> is a zero-length string.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-831"><paramref name="assemblyString" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-831"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-832">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-832">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-833"><paramref name="assemblyString" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-833"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-834">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-834">-or-</span></span> 
<span data-ttu-id="850a0-835">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyString" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-835">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="850a0-836">pour charger un assembly avec la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-836">to load an assembly with evidence.</span></span> <span data-ttu-id="850a0-837">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="850a0-837">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="850a0-838">Méthode de localisation des assemblys par le runtime</span><span class="sxs-lookup"><span data-stu-id="850a0-838">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="850a0-839">Tableau d'octets qui est une image au format COFF contenant un assembly émis.</span><span class="sxs-lookup"><span data-stu-id="850a0-839">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="850a0-840">Tableau d'octets qui contient les octets bruts représentant les symboles de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-840">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="850a0-841">Charge l'assembly avec une image COFF (Common Object File Format) contenant un assembly émis qui inclut éventuellement des symboles de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-841">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols for the assembly.</span></span> <span data-ttu-id="850a0-842">L'assembly est chargé dans le domaine d'application de l'appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-842">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="850a0-843">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-843">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-844">Le niveau de confiance d’un assembly est chargé à l’aide de cette méthode est le même que le niveau de confiance de l’assembly appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-844">The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</span></span> <span data-ttu-id="850a0-845">Pour charger un assembly à partir d’un tableau d’octets dont le niveau de confiance du domaine d’application, utilisez le <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="850a0-845">To load an assembly from a byte array with the trust level of the application domain, use the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> method overload.</span></span> <span data-ttu-id="850a0-846">Pour plus d’informations sur l’utilisation de la preuve avec les surcharges de la <xref:System.Reflection.Assembly.Load%2A> méthode qui acceptent les tableaux d’octets, consultez la <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="850a0-846">For more information about the use of evidence with overloads of the <xref:System.Reflection.Assembly.Load%2A> method that take byte arrays, see the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> method overload.</span></span>  
  
 <span data-ttu-id="850a0-847">La réflexion sur des fichiers exécutables C++ peut lever une <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-847">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="850a0-848">Cela est probablement dû au fait généralement de la suppression des adresses de réadressage ou `.reloc` section à partir de votre fichier exécutable.</span><span class="sxs-lookup"><span data-stu-id="850a0-848">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="850a0-849">Pour conserver le `.reloc` d’adresses de votre fichier exécutable C++, spécifiez `/fixed:no` lors de la liaison.</span><span class="sxs-lookup"><span data-stu-id="850a0-849">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="850a0-850">Notez que cette surcharge de méthode crée toujours un nouveau <xref:System.Reflection.Assembly> objet avec son propre mappage.</span><span class="sxs-lookup"><span data-stu-id="850a0-850">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-851"><paramref name="rawAssembly" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-851"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-852"><paramref name="rawAssembly" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-852"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-853">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-853">-or-</span></span> 
<span data-ttu-id="850a0-854">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="rawAssembly" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-854">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="850a0-855">Objet qui décrit l'assembly à charger.</span><span class="sxs-lookup"><span data-stu-id="850a0-855">The object that describes the assembly to be loaded.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="850a0-856">Preuve de chargement de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-856">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="850a0-857">Charge un assembly en fonction de son <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-857">Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span></span> <span data-ttu-id="850a0-858">L'assembly est chargé dans le domaine de l'appelant à l'aide de la preuve fournie.</span><span class="sxs-lookup"><span data-stu-id="850a0-858">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="850a0-859">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-859">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-860"><xref:System.IO.FileLoadException> est levée si `assemblyRef` Spécifie le nom complet de l’assembly et le premier assembly correspondant au nom simple a une autre version, culture ou jeton de clé publique.</span><span class="sxs-lookup"><span data-stu-id="850a0-860"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="850a0-861">Le chargeur ne continue pas à détecter d’autres assemblys qui correspondent au nom simple.</span><span class="sxs-lookup"><span data-stu-id="850a0-861">The loader does not continue probing for other assemblies that match the simple name.</span></span>  <span data-ttu-id="850a0-862">Démarrer avec .NET Framework 4, car l’exécution de code dans les assemblys à distance est désactivée par défaut, un <xref:System.IO.FileLoadException> est également levée si `assemblyRef` spécifie un assembly distant.</span><span class="sxs-lookup"><span data-stu-id="850a0-862">Starting with .NET Framework 4, because execution of code in remote assemblies is disabled by default, a <xref:System.IO.FileLoadException> is also thrown if `assemblyRef` specifies a remote assembly.</span></span> <span data-ttu-id="850a0-863">Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.</span><span class="sxs-lookup"><span data-stu-id="850a0-863">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>   
  
> [!NOTE]
>  <span data-ttu-id="850a0-864">N’utilisez pas un <xref:System.Reflection.AssemblyName> avec uniquement le <xref:System.Reflection.AssemblyName.CodeBase%2A> jeu de propriétés.</span><span class="sxs-lookup"><span data-stu-id="850a0-864">Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set.</span></span> <span data-ttu-id="850a0-865">Le <xref:System.Reflection.AssemblyName.CodeBase%2A> propriété ne fournit pas tous les éléments de l’identité d’assembly (par exemple, le nom ou la version), ainsi le chargement ne se produit pas d’en fonction des règles de charge par identité, comme vous pouvez l’imaginer à partir de la <xref:System.Reflection.Assembly.Load%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="850a0-865">The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="850a0-866">Au lieu de cela, l’assembly est chargé à l’aide de règles load-from.</span><span class="sxs-lookup"><span data-stu-id="850a0-866">Instead, the assembly is loaded using load-from rules.</span></span> <span data-ttu-id="850a0-867">Pour plus d’informations sur les inconvénients de l’utilisation du contexte de chargement, consultez la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> surcharge de méthode ou [meilleures pratiques de chargement d’Assembly](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span><span class="sxs-lookup"><span data-stu-id="850a0-867">For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method overload or [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span></span>  
  
 <span data-ttu-id="850a0-868">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-868">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="850a0-869">Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="850a0-869">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="850a0-870">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode sans aucune <xref:System.Security.Policy.Evidence> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-870">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="850a0-871">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées.</span><span class="sxs-lookup"><span data-stu-id="850a0-871">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="850a0-872">Preuves fournies en tant qu’argument à la <xref:System.Reflection.Assembly.Load%2A> méthode annulent et remplacent les preuves fournies par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-872">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="850a0-873">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image common object file format (COFF), la preuve est héritée de l’assembly appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-873">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="850a0-874">Cela s’applique à la version 1.1 du .NET Framework Service Pack 1 (SP1) et les versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="850a0-874">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="850a0-875">Dans le .NET Framework version 1.0 et dans la version 1.1 sans SP1, lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image COFF, la preuve est combinée.</span><span class="sxs-lookup"><span data-stu-id="850a0-875">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="850a0-876">`Zone`, `Url` et `Site` sont héritées de l’assembly appelant, et `Hash` et `StrongName` proviennent de l’assembly COFF.</span><span class="sxs-lookup"><span data-stu-id="850a0-876">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="850a0-877">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un `Byte[]` paramètre et <xref:System.Security.Policy.Evidence> pour charger une image COFF, seule la preuve fournie est utilisée.</span><span class="sxs-lookup"><span data-stu-id="850a0-877">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="850a0-878">Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="850a0-878">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="850a0-879">La réflexion sur des fichiers exécutables C++ peut lever une <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-879">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="850a0-880">Cela est probablement dû au fait généralement de la suppression des adresses de réadressage ou `.reloc` section à partir de votre fichier exécutable.</span><span class="sxs-lookup"><span data-stu-id="850a0-880">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="850a0-881">Pour conserver le `.reloc` d’adresses de votre fichier exécutable C++, spécifiez `/fixed:no` lors de la liaison.</span><span class="sxs-lookup"><span data-stu-id="850a0-881">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-882">Si les deux le <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> propriété et la <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> propriété sont définies, la première tentative de charger l’assembly utilise le nom d’affichage (notamment la version, culture et ainsi de suite, tel que retourné par la <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriété).</span><span class="sxs-lookup"><span data-stu-id="850a0-882">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="850a0-883">Si le fichier est introuvable, <xref:System.Reflection.AssemblyName.CodeBase%2A> est utilisé pour rechercher l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-883">If the file is not found, <xref:System.Reflection.AssemblyName.CodeBase%2A> is used to search for the assembly.</span></span> <span data-ttu-id="850a0-884">Si l’assembly se trouve à l’aide de <xref:System.Reflection.AssemblyName.CodeBase%2A>, le nom d’affichage est comparé à l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-884">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="850a0-885">Si la correspondance échoue, un <xref:System.IO.FileLoadException> est levée.</span><span class="sxs-lookup"><span data-stu-id="850a0-885">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
 <span data-ttu-id="850a0-886">Si vous appelez le <xref:System.Reflection.Assembly.Load%2A> méthode plusieurs fois sur le même assembly, mais avec une preuve spécifiée différente, le common language runtime ne lève pas une <xref:System.IO.FileLoadException> , car l’égalité et l’intégrité des différentes spécifications de preuve ne peut pas être déterminé.</span><span class="sxs-lookup"><span data-stu-id="850a0-886">If you call the <xref:System.Reflection.Assembly.Load%2A> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="850a0-887">La première preuve qui réussit est la preuve est utilisée.</span><span class="sxs-lookup"><span data-stu-id="850a0-887">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-888"><paramref name="assemblyRef" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-888"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-889"><paramref name="assemblyRef" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-889"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-890"><paramref name="assemblyRef" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-890"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-891">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-891">-or-</span></span> 
<span data-ttu-id="850a0-892">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyRef" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-892">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-893">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</span><span class="sxs-lookup"><span data-stu-id="850a0-893">An assembly or module was loaded twice with two different evidences.</span></span>

<span data-ttu-id="850a0-894">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-894">-or-</span></span>

<span data-ttu-id="850a0-895"><paramref name="assemblyRef" /> spécifie un assembly distant, mais la possibilité d’exécuter du code dans des assemblys distants est désactivée.</span><span class="sxs-lookup"><span data-stu-id="850a0-895"><paramref name="assemblyRef" /> specifies a remote assembly, but the ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="850a0-896">Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="850a0-896">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="850a0-897">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</span><span class="sxs-lookup"><span data-stu-id="850a0-897">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="850a0-898">Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="850a0-898">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="850a0-899">pour lire un URI qui ne commence pas par « file:// ».</span><span class="sxs-lookup"><span data-stu-id="850a0-899">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="850a0-900">pour charger un assembly avec la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-900">to load an assembly with evidence.</span></span> <span data-ttu-id="850a0-901">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="850a0-901">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="850a0-902">Méthode de localisation des assemblys par le runtime</span><span class="sxs-lookup"><span data-stu-id="850a0-902">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="850a0-903">Nom complet de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-903">The display name of the assembly.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="850a0-904">Preuve de chargement de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-904">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="850a0-905">Charge un assembly en fonction de son nom complet, en le chargeant dans le domaine de l'appelant à l'aide de la preuve fournie.</span><span class="sxs-lookup"><span data-stu-id="850a0-905">Loads an assembly given its display name, loading the assembly into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="850a0-906">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-906">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-907"><xref:System.IO.FileLoadException> est levée si `assemblyString` Spécifie le nom complet de l’assembly et le premier assembly correspondant au nom simple a une autre version, culture ou jeton de clé publique.</span><span class="sxs-lookup"><span data-stu-id="850a0-907"><xref:System.IO.FileLoadException> is thrown if `assemblyString` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="850a0-908">Le chargeur ne continue pas à détecter d’autres assemblys qui correspondent au nom simple.</span><span class="sxs-lookup"><span data-stu-id="850a0-908">The loader does not continue probing for other assemblies that match the simple name.</span></span>  
  
 <span data-ttu-id="850a0-909">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-909">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="850a0-910">Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="850a0-910">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="850a0-911">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode sans aucune <xref:System.Security.Policy.Evidence> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-911">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="850a0-912">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées.</span><span class="sxs-lookup"><span data-stu-id="850a0-912">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="850a0-913">Preuves fournies en tant qu’argument à la <xref:System.Reflection.Assembly.Load%2A> méthode annulent et remplacent les preuves fournies par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-913">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="850a0-914">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image common object file format (COFF), la preuve est héritée de l’assembly appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-914">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="850a0-915">Cela s’applique à la version 1.1 du .NET Framework Service Pack 1 (SP1) et les versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="850a0-915">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="850a0-916">Dans le .NET Framework version 1.0 et dans la version 1.1 sans SP1, lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image COFF, la preuve est combinée.</span><span class="sxs-lookup"><span data-stu-id="850a0-916">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="850a0-917">`Zone`, `Url` et `Site` sont héritées de l’assembly appelant, et `Hash` et `StrongName` proviennent de l’assembly COFF.</span><span class="sxs-lookup"><span data-stu-id="850a0-917">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="850a0-918">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un `Byte[]` paramètre et <xref:System.Security.Policy.Evidence> pour charger une image COFF, seule la preuve fournie est utilisée.</span><span class="sxs-lookup"><span data-stu-id="850a0-918">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="850a0-919">Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="850a0-919">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="850a0-920">La réflexion sur des fichiers exécutables C++ peut lever une <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-920">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="850a0-921">Cela est probablement dû au fait généralement de la suppression des adresses de réadressage ou `.reloc` section à partir de votre fichier exécutable.</span><span class="sxs-lookup"><span data-stu-id="850a0-921">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="850a0-922">Pour conserver le `.reloc` d’adresses de votre fichier exécutable C++, spécifiez `/fixed:no` lors de la liaison.</span><span class="sxs-lookup"><span data-stu-id="850a0-922">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="850a0-923">Si vous appelez cette méthode plusieurs fois sur le même assembly, mais avec une preuve spécifiée différente, le common language runtime ne lève pas une <xref:System.IO.FileLoadException> , car il est impossible de déterminer l’égalité et l’intégrité des différentes spécifications de preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-923">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="850a0-924">La première preuve qui réussit est la preuve est utilisée.</span><span class="sxs-lookup"><span data-stu-id="850a0-924">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 <span data-ttu-id="850a0-925">Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-925">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="850a0-926">Par exemple, « ProcessorArchitecture = msil ».</span><span class="sxs-lookup"><span data-stu-id="850a0-926">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="850a0-927">Toutefois, la méthode recommandée pour spécifier un nom d’assembly consiste à créer un <xref:System.Reflection.AssemblyName> de l’objet et le passer à une surcharge appropriée de la <xref:System.Reflection.Assembly.Load%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="850a0-927">However, the recommended way to specify an assembly name is to create an <xref:System.Reflection.AssemblyName> object and pass it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="850a0-928">Consultez <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="850a0-928">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-929"><paramref name="assemblyString" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-929"><paramref name="assemblyString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-930"><paramref name="assemblyString" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-930"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-931"><paramref name="assemblyString" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-931"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-932">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-932">-or-</span></span> 
<span data-ttu-id="850a0-933">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyString" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-933">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-934">Un fichier qui a été trouvé n’a pas pu être chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-934">A file that was found could not be loaded.</span></span>  
  
<span data-ttu-id="850a0-935">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-935">-or-</span></span> 
<span data-ttu-id="850a0-936">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</span><span class="sxs-lookup"><span data-stu-id="850a0-936">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="850a0-937">pour charger un assembly avec la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-937">to load an assembly with evidence.</span></span> <span data-ttu-id="850a0-938">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="850a0-938">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="850a0-939">Méthode de localisation des assemblys par le runtime</span><span class="sxs-lookup"><span data-stu-id="850a0-939">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="850a0-940">Tableau d'octets qui est une image au format COFF contenant un assembly émis.</span><span class="sxs-lookup"><span data-stu-id="850a0-940">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="850a0-941">Tableau d'octets qui contient les octets bruts représentant les symboles de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-941">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="850a0-942">Preuve de chargement de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-942">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="850a0-943">Charge l'assembly avec une image COFF (Common Object File Format) contenant un assembly émis qui inclut éventuellement des symboles et des preuves de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-943">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and evidence for the assembly.</span></span> <span data-ttu-id="850a0-944">L'assembly est chargé dans le domaine d'application de l'appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-944">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="850a0-945">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-945">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-946">L'assembly est chargé dans le domaine de l'appelant à l'aide de la preuve fournie.</span><span class="sxs-lookup"><span data-stu-id="850a0-946">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span> <span data-ttu-id="850a0-947">Les octets bruts représentant les symboles de l’assembly sont également chargés.</span><span class="sxs-lookup"><span data-stu-id="850a0-947">The raw bytes representing the symbols for the assembly are also loaded.</span></span>  
  
 <span data-ttu-id="850a0-948">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-948">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="850a0-949">Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="850a0-949">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="850a0-950">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode sans aucune <xref:System.Security.Policy.Evidence> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-950">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="850a0-951">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées.</span><span class="sxs-lookup"><span data-stu-id="850a0-951">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="850a0-952">Preuves fournies en tant qu’argument à la <xref:System.Reflection.Assembly.Load%2A> méthode annulent et remplacent les preuves fournies par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-952">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="850a0-953">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image COFF, la preuve est héritée de l’assembly appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-953">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="850a0-954">Cela s’applique à la version 1.1 du .NET Framework Service Pack 1 (SP1) et les versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="850a0-954">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="850a0-955">Dans le .NET Framework version 1.0 et dans la version 1.1 sans SP1, lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image COFF, la preuve est combinée.</span><span class="sxs-lookup"><span data-stu-id="850a0-955">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="850a0-956">`Zone`, `Url` et `Site` sont héritées de l’assembly appelant, et `Hash` et `StrongName` proviennent de l’assembly COFF.</span><span class="sxs-lookup"><span data-stu-id="850a0-956">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="850a0-957">Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un `Byte[]` paramètre et <xref:System.Security.Policy.Evidence> pour charger une image COFF, seule la preuve fournie est utilisée.</span><span class="sxs-lookup"><span data-stu-id="850a0-957">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="850a0-958">Preuve de l’assembly appelant et celle de l’image COFF sont ignorées.</span><span class="sxs-lookup"><span data-stu-id="850a0-958">Evidence of the calling assembly and evidence of the COFF image are ignored.</span></span>  
  
 <span data-ttu-id="850a0-959">La réflexion sur des fichiers exécutables C++ peut lever une <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-959">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="850a0-960">Cela est probablement dû au fait généralement de la suppression des adresses de réadressage ou `.reloc` section à partir de votre fichier exécutable.</span><span class="sxs-lookup"><span data-stu-id="850a0-960">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="850a0-961">Pour conserver le `.reloc` d’adresses de votre fichier exécutable C++, spécifiez `/fixed:no` lors de la liaison.</span><span class="sxs-lookup"><span data-stu-id="850a0-961">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="850a0-962">Si vous appelez le [\], octets\<xref:System.Reflection.Assembly.Load%2A > méthode plusieurs fois sur le même assembly, mais avec une preuve spécifiée différente, le common language runtime ne lève pas une <xref:System.IO.FileLoadException> , car le Impossible de déterminer l’égalité et l’intégrité des différentes spécifications de preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-962">If you call the [\], Byte\<xref:System.Reflection.Assembly.Load%2A> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="850a0-963">La première preuve qui réussit est la preuve est utilisée.</span><span class="sxs-lookup"><span data-stu-id="850a0-963">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 <span data-ttu-id="850a0-964">Notez que cette surcharge de méthode crée toujours un nouveau <xref:System.Reflection.Assembly> objet avec son propre mappage.</span><span class="sxs-lookup"><span data-stu-id="850a0-964">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-965"><paramref name="rawAssembly" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-965"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-966"><paramref name="rawAssembly" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-966"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-967">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-967">-or-</span></span> 
<span data-ttu-id="850a0-968">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="rawAssembly" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-968">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-969">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</span><span class="sxs-lookup"><span data-stu-id="850a0-969">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="850a0-970"><paramref name="securityEvidence" /> n’est pas un <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-970"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span>  <span data-ttu-id="850a0-971">Par défaut, la stratégie CAS héritée n’est pas activée dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ; quand elle n’est pas activée, <paramref name="securityEvidence" /> doit avoir la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-971">By default, legacy CAS policy is not enabled in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; when it is not enabled, <paramref name="securityEvidence" /> must be <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="850a0-972">la capacité à fournir une preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-972">for the ability to supply evidence.</span></span> <span data-ttu-id="850a0-973">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-973">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span> <span data-ttu-id="850a0-974">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-974">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="850a0-975">Tableau d'octets qui est une image au format COFF contenant un assembly émis.</span><span class="sxs-lookup"><span data-stu-id="850a0-975">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="850a0-976">Tableau d'octets qui contient les octets bruts représentant les symboles de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-976">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityContextSource"><span data-ttu-id="850a0-977">Source du contexte de sécurité.</span><span class="sxs-lookup"><span data-stu-id="850a0-977">The source of the security context.</span></span></param>
        <summary><span data-ttu-id="850a0-978">Charge l'assembly avec une image COFF (Common Object File Format) contenant un assembly émis qui inclut éventuellement des symboles et qui spécifie la source du contexte de sécurité.</span><span class="sxs-lookup"><span data-stu-id="850a0-978">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and specifying the source for the security context.</span></span> <span data-ttu-id="850a0-979">L'assembly est chargé dans le domaine d'application de l'appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-979">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="850a0-980">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-980">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-981">L’assembly est chargé dans le domaine d’application de l’appelant à l’aide de la source spécifiée pour le contexte de sécurité.</span><span class="sxs-lookup"><span data-stu-id="850a0-981">The assembly is loaded into the application domain of the caller using the specified source for the security context.</span></span> <span data-ttu-id="850a0-982">Si `rawSymbolStore` a été spécifié, les octets bruts représentant les symboles pour l’assembly sont également chargés.</span><span class="sxs-lookup"><span data-stu-id="850a0-982">If `rawSymbolStore` was specified, the raw bytes that represent the symbols for the assembly are also loaded.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-983"><paramref name="rawAssembly" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-983"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-984"><paramref name="rawAssembly" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-984"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-985">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-985">-or-</span></span> 
 <span data-ttu-id="850a0-986"><paramref name="rawAssembly" /> a été compilé avec une version du common language runtime ultérieure à la version actuellement chargée.</span><span class="sxs-lookup"><span data-stu-id="850a0-986"><paramref name="rawAssembly" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="850a0-987">La valeur de <paramref name="securityContextSource" /> n’est pas l’une des valeurs d’énumération.</span><span class="sxs-lookup"><span data-stu-id="850a0-987">The value of <paramref name="securityContextSource" /> is not one of the enumeration values.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="850a0-988">Charge le contenu d'un fichier d'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-988">Loads the contents of an assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="850a0-989">Chemin d’accès complet du fichier à charger.</span><span class="sxs-lookup"><span data-stu-id="850a0-989">The fully qualified path of the file to load.</span></span></param>
        <summary><span data-ttu-id="850a0-990">Charge le contenu d’un fichier d’assembly sur le chemin d’accès spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-990">Loads the contents of an assembly file on the specified path.</span></span></summary>
        <returns><span data-ttu-id="850a0-991">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-991">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-992">Utilisez le <xref:System.Reflection.Assembly.LoadFile%2A> méthode pour charger et examiner des assemblys qui ont la même identité, mais se trouvent dans différents chemins d’accès.</span><span class="sxs-lookup"><span data-stu-id="850a0-992">Use the <xref:System.Reflection.Assembly.LoadFile%2A> method to load and examine assemblies that have the same identity, but are located in different paths.</span></span> <span data-ttu-id="850a0-993"><xref:System.Reflection.Assembly.LoadFile%2A> ne pas charger des fichiers dans le contexte de chargement et ne résout pas les dépendances à l’aide du chemin de chargement, comme le <xref:System.Reflection.Assembly.LoadFrom%2A> méthode effectue.</span><span class="sxs-lookup"><span data-stu-id="850a0-993"><xref:System.Reflection.Assembly.LoadFile%2A> does not load files into the load-from  context, and does not resolve dependencies using the load path, as the <xref:System.Reflection.Assembly.LoadFrom%2A> method does.</span></span> <span data-ttu-id="850a0-994"><xref:System.Reflection.Assembly.LoadFile%2A> est utile dans ce scénario spécifique, car <xref:System.Reflection.Assembly.LoadFrom%2A> ne peut pas être utilisé pour charger les assemblys qui ont la même identité mais différents chemins d’accès ; elle chargera uniquement le premier tel assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-994"><xref:System.Reflection.Assembly.LoadFile%2A> is useful in this limited scenario because <xref:System.Reflection.Assembly.LoadFrom%2A> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</span></span>  

<span data-ttu-id="850a0-995">En commençant par le .NET Framework 4, si `path` spécifie un assembly dans un emplacement distant, le chargement d’assembly est désactivé par défaut et le `LoadFile` méthode lève un <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-995">Starting with .NET Framework 4, if `path` specifies an assembly in a remote location, assembly loading is disabled by default, and the `LoadFile` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="850a0-996">Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.</span><span class="sxs-lookup"><span data-stu-id="850a0-996">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-997">L’argument <paramref name="path" /> n’est pas un chemin absolu.</span><span class="sxs-lookup"><span data-stu-id="850a0-997">The <paramref name="path" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-998">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-998">The <paramref name="path" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-999">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-999">A file that was found could not be loaded.</span></span>

<span data-ttu-id="850a0-1000">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1000">-or-</span></span>

<span data-ttu-id="850a0-1001">La possibilité d’exécuter du code dans des assemblys distants est désactivée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1001">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="850a0-1002">Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1002">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-1003">Le paramètre <paramref name="path" /> est une chaîne vide ("") ou n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="850a0-1003">The <paramref name="path" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-1004"><paramref name="path" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-1004"><paramref name="path" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-1005">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1005">-or-</span></span> 
<span data-ttu-id="850a0-1006">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="path" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-1006">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="path" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="850a0-1007">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</span><span class="sxs-lookup"><span data-stu-id="850a0-1007">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="850a0-1008">Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1008">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="850a0-1009">pour charger un assembly avec la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-1009">to load an assembly with evidence.</span></span> <span data-ttu-id="850a0-1010">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1010">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="850a0-1011">Chemin complet du fichier d’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1011">The fully qualified path of the assembly file.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="850a0-1012">Preuve de chargement de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1012">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="850a0-1013">Charge un assembly en fonction de son chemin d’accès, en le chargeant dans le domaine de l’appelant à l’aide de la preuve fournie.</span><span class="sxs-lookup"><span data-stu-id="850a0-1013">Loads an assembly given its path, loading the assembly into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="850a0-1014">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1014">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-1015">Utilisez le <xref:System.Reflection.Assembly.LoadFile%2A> méthode pour charger et examiner des assemblys qui ont la même identité, mais se trouvent dans différents chemins d’accès.</span><span class="sxs-lookup"><span data-stu-id="850a0-1015">Use the <xref:System.Reflection.Assembly.LoadFile%2A> method to load and examine assemblies that have the same identity, but are located in different paths.</span></span> <span data-ttu-id="850a0-1016"><xref:System.Reflection.Assembly.LoadFile%2A> ne pas charger des fichiers dans le <xref:System.Reflection.Assembly.LoadFrom%2A> contexte et ne résout pas les dépendances à l’aide du chemin de chargement, comme le <xref:System.Reflection.Assembly.LoadFrom%2A> méthode effectue.</span><span class="sxs-lookup"><span data-stu-id="850a0-1016"><xref:System.Reflection.Assembly.LoadFile%2A> does not load files into the <xref:System.Reflection.Assembly.LoadFrom%2A> context, and does not resolve dependencies using the load path, as the <xref:System.Reflection.Assembly.LoadFrom%2A> method does.</span></span> <span data-ttu-id="850a0-1017"><xref:System.Reflection.Assembly.LoadFile%2A> est utile dans ce scénario spécifique, car <xref:System.Reflection.Assembly.LoadFrom%2A> ne peut pas être utilisé pour charger les assemblys qui ont la même identité mais différents chemins d’accès ; elle chargera uniquement le premier tel assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1017"><xref:System.Reflection.Assembly.LoadFile%2A> is useful in this limited scenario because <xref:System.Reflection.Assembly.LoadFrom%2A> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</span></span>  

<span data-ttu-id="850a0-1018">En commençant par le .NET Framework 4, si `path` spécifie un assembly dans un emplacement distant, le chargement d’assembly est désactivé par défaut et le `LoadFile` méthode lève un <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1018">Starting with .NET Framework 4, if `path` specifies an assembly in a remote location, assembly loading is disabled by default, and the `LoadFile` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="850a0-1019">Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.</span><span class="sxs-lookup"><span data-stu-id="850a0-1019">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-1020">L’argument <paramref name="path" /> n’est pas un chemin absolu.</span><span class="sxs-lookup"><span data-stu-id="850a0-1020">The <paramref name="path" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-1021">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1021">The <paramref name="path" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-1022">Le paramètre <paramref name="path" /> est une chaîne vide ("") ou n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="850a0-1022">The <paramref name="path" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-1023">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-1023">A file that was found could not be loaded.</span></span>

<span data-ttu-id="850a0-1024">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1024">-or-</span></span>

<span data-ttu-id="850a0-1025">La possibilité d’exécuter du code dans des assemblys distants est désactivée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1025">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="850a0-1026">Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1026">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-1027"><paramref name="path" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-1027"><paramref name="path" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-1028">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1028">-or-</span></span> 
<span data-ttu-id="850a0-1029">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="path" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-1029">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="path" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="850a0-1030"><paramref name="securityEvidence" /> n’est pas un <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1030"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span> <span data-ttu-id="850a0-1031">Par défaut, la stratégie CAS héritée n’est pas activée dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ; quand elle n’est pas activée, <paramref name="securityEvidence" /> doit avoir la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1031">By default, legacy CAS policy is not enabled in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; when it is not enabled, <paramref name="securityEvidence" /> must be <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="850a0-1032">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même.</span><span class="sxs-lookup"><span data-stu-id="850a0-1032">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="850a0-1033">Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1033">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="850a0-1034">pour charger un assembly avec la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-1034">to load an assembly with evidence.</span></span> <span data-ttu-id="850a0-1035">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1035">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="850a0-1036">Charge un assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1036">Loads an assembly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

<span data-ttu-id="850a0-1037">À compter de .NET Framework 4, la possibilité d’exécuter du code dans les assemblys chargés à partir d’emplacements distants est désactivée par défaut et l’appel à la `LoadFrom` méthode lève un <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1037">Starting with .NET Framework 4, the ability to execute code in assemblies loaded from remote locations is disabled by default, and the call to the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="850a0-1038">Pour charger l’assembly et exécuter son code, vous devez :</span><span class="sxs-lookup"><span data-stu-id="850a0-1038">To load the assembly and execute its code, you must either:</span></span>

- <span data-ttu-id="850a0-1039">Créer explicitement un bac à sable pour l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1039">Explicitly create a sandbox for the assembly.</span></span> <span data-ttu-id="850a0-1040">(Consultez [Comment : exécuter du Code de confiance partiel dans un bac à sable](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)</span><span class="sxs-lookup"><span data-stu-id="850a0-1040">(See [How to: Run Partially Trusted Code in a Sandbox](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)</span></span>

- <span data-ttu-id="850a0-1041">Exécuter du code de l’assembly avec une confiance totale en définissant le `enabled` attribut de la [ `<loadFromRemoteSources>` élément de configuration](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) à `true`.</span><span class="sxs-lookup"><span data-stu-id="850a0-1041">Run the assembly's code in full trust by setting the `enabled` attribute of the [`<loadFromRemoteSources>` configuration element](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) to `true`.</span></span> <span data-ttu-id="850a0-1042">Pour plus d’informations, consultez le [ `<loadFromRemoteSources>` élément de configuration](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) article.</span><span class="sxs-lookup"><span data-stu-id="850a0-1042">For more information, see the [`<loadFromRemoteSources>` configuration element](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) article.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="850a0-1043">Nom ou chemin d’accès du fichier qui contient le manifeste d’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1043">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <summary><span data-ttu-id="850a0-1044">Charge un assembly en fonction de son nom de fichier ou de son chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="850a0-1044">Loads an assembly given its file name or path.</span></span></summary>
        <returns><span data-ttu-id="850a0-1045">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1045">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-1046">Le `assemblyFile` paramètre doit faire référence à un URI sans caractères d’échappement.</span><span class="sxs-lookup"><span data-stu-id="850a0-1046">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="850a0-1047">Cette méthode fournit les caractères d’échappement pour tous les caractères non valides dans l’URI.</span><span class="sxs-lookup"><span data-stu-id="850a0-1047">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-1048">Protocole de transfert de fichiers (FTP) n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="850a0-1048">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="850a0-1049">Si l’URI fourni pour `assemblyFile` est une adresse FTP, l’assembly n’est pas chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1049">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="850a0-1050">Aucune exception n'est levée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1050">No exception is thrown.</span></span>  
  
 <span data-ttu-id="850a0-1051">`assemblyFile` peut être absolu ou relatif au répertoire en cours, et l’assembly est chargé dans le domaine de l’appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-1051">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="850a0-1052">Les assemblys peuvent être chargés dans un des trois contextes, ou peuvent être chargés sans contexte :</span><span class="sxs-lookup"><span data-stu-id="850a0-1052">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="850a0-1053">Le contexte de chargement contient des assemblys trouvés en recherchant : dans le GAC, dans un assembly hôte stocker si le runtime est hébergé, ou dans le <xref:System.AppDomainSetup.ApplicationBase%2A> et <xref:System.AppDomainSetup.PrivateBinPath%2A> du domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="850a0-1053">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="850a0-1054">La plupart des surcharges de la méthode <xref:System.Reflection.Assembly.Load%2A> chargent les assemblys dans ce contexte.</span><span class="sxs-lookup"><span data-stu-id="850a0-1054">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="850a0-1055">Le contexte de chargement contient des assemblys pour lesquels l’utilisateur a fourni un chemin d’accès non inclus dans les répertoires de recherche par la détection.</span><span class="sxs-lookup"><span data-stu-id="850a0-1055">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="850a0-1056"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> et <xref:System.AppDomain.ExecuteAssembly%2A> sont des exemples de méthodes qui sont chargées via un chemin.</span><span class="sxs-lookup"><span data-stu-id="850a0-1056"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span> 

    <span data-ttu-id="850a0-1057">En commençant par le .NET Framework 4, si l’URI de `assemblyFile` spécifie un emplacement distant, le chargement des assemblys sont désactivée par défaut et le `LoadFrom` méthode lève un <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1057">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="850a0-1058">Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.</span><span class="sxs-lookup"><span data-stu-id="850a0-1058">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="850a0-1059">Le contexte de réflexion uniquement contient des assemblys chargés avec le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> et <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> méthodes ; le code dans ces contextes ne peut pas être exécutées.</span><span class="sxs-lookup"><span data-stu-id="850a0-1059">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="850a0-1060">Si l’utilisateur a généré ou trouvé l’assembly, il n’est pas dans n’importe quel contexte.</span><span class="sxs-lookup"><span data-stu-id="850a0-1060">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="850a0-1061">Cela s’applique aux assemblys chargés à l’aide de surcharges de la <xref:System.Reflection.Assembly.Load%2A> méthode qui spécifient un tableau d’octets qui contient un assembly et aux assemblys dynamiques transitoires créés avec la réflexion l’émission et pas enregistré sur le disque.</span><span class="sxs-lookup"><span data-stu-id="850a0-1061">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="850a0-1062">Le contexte load-from permet à un assembly à charger à partir d’un chemin d’accès non inclus dans la détection et permet cependant de dépendances sur ce chemin d’accès pour trouver et de charger, car les informations de chemin d’accès sont conservées par le contexte.</span><span class="sxs-lookup"><span data-stu-id="850a0-1062">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="850a0-1063">Le <xref:System.Reflection.Assembly.LoadFrom%2A> méthode présente les inconvénients suivants.</span><span class="sxs-lookup"><span data-stu-id="850a0-1063">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="850a0-1064">Utilisez <xref:System.Reflection.Assembly.Load%2A> à la place.</span><span class="sxs-lookup"><span data-stu-id="850a0-1064">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="850a0-1065">Si un assembly avec la même identité est déjà chargé, <xref:System.Reflection.Assembly.LoadFrom%2A> retourne l’assembly chargé même si un autre chemin a été spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-1065">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="850a0-1066">Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>et ultérieurement un assembly dans le contexte de chargement essaie de charger le même assembly par nom d’affichage, la tentative de chargement échoue.</span><span class="sxs-lookup"><span data-stu-id="850a0-1066">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="850a0-1067">Cela peut se produire lorsqu’un assembly est désérialisé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1067">This can occur when an assembly is de-serialized.</span></span>  
  
-   <span data-ttu-id="850a0-1068">Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>, et le chemin de recherche inclut un assembly avec la même identité mais un emplacement différent, un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou tout autre comportement inattendu peut se produire.</span><span class="sxs-lookup"><span data-stu-id="850a0-1068">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="850a0-1069"><xref:System.Reflection.Assembly.LoadFrom%2A> demande <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> et <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, sur le chemin spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-1069"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="850a0-1070">Si une image native existe pour `assemblyFile`, il n’est pas utilisé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1070">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="850a0-1071">L’assembly ne peut pas être chargé comme indépendant du domaine.</span><span class="sxs-lookup"><span data-stu-id="850a0-1071">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="850a0-1072">Dans la version 1.0 et 1.1 du .NET Framework, la stratégie n’est pas appliquée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1072">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-1073">L’exemple suivant charge un assembly en fonction de son nom de fichier ou le chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="850a0-1073">The following example loads an assembly given its file name or path.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-1074"><paramref name="assemblyFile" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1074"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-1075"><paramref name="assemblyFile" /> est introuvable ou le module que vous essayez de charger ne spécifie pas d’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="850a0-1075"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-1076">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-1076">A file that was found could not be loaded.</span></span>

<span data-ttu-id="850a0-1077">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1077">-or-</span></span>

<span data-ttu-id="850a0-1078">La possibilité d’exécuter du code dans des assemblys distants est désactivée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1078">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="850a0-1079">Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1079">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-1080"><paramref name="assemblyFile" /> n’est pas un assembly valide ; par exemple, un assembly 32 bits dans un processus 64 bits.</span><span class="sxs-lookup"><span data-stu-id="850a0-1080"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="850a0-1081">Pour plus d’informations, consultez la rubrique sur les exceptions.</span><span class="sxs-lookup"><span data-stu-id="850a0-1081">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="850a0-1082">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1082">-or-</span></span> 
<span data-ttu-id="850a0-1083">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyFile" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-1083">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="850a0-1084">Un code base qui ne commence pas par "file://" a été spécifié sans le <see cref="T:System.Net.WebPermission" /> requis.</span><span class="sxs-lookup"><span data-stu-id="850a0-1084">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-1085">Le paramètre <paramref name="assemblyFile" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="850a0-1085">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="850a0-1086">Le nom de l’assembly dépasse la longueur maximale définie par le système.</span><span class="sxs-lookup"><span data-stu-id="850a0-1086">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="850a0-1087">pour lire un URI qui commence par « file:// ».</span><span class="sxs-lookup"><span data-stu-id="850a0-1087">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="850a0-1088">Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1088">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="850a0-1089">pour lire un URI qui ne commence pas par « file:// ».</span><span class="sxs-lookup"><span data-stu-id="850a0-1089">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="850a0-1090">Nom ou chemin d’accès du fichier qui contient le manifeste d’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1090">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="850a0-1091">Preuve de chargement de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1091">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="850a0-1092">Charge un assembly en fonction de son nom de fichier ou de son chemin d’accès et en fournissant la preuve de sécurité.</span><span class="sxs-lookup"><span data-stu-id="850a0-1092">Loads an assembly given its file name or path and supplying security evidence.</span></span></summary>
        <returns><span data-ttu-id="850a0-1093">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1093">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-1094">Le `assemblyFile` paramètre doit faire référence à un URI sans caractères d’échappement.</span><span class="sxs-lookup"><span data-stu-id="850a0-1094">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="850a0-1095">Cette méthode fournit les caractères d’échappement pour tous les caractères non valides dans l’URI.</span><span class="sxs-lookup"><span data-stu-id="850a0-1095">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-1096">Protocole de transfert de fichiers (FTP) n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="850a0-1096">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="850a0-1097">Si l’URI fourni pour `assemblyFile` est une adresse FTP, l’assembly n’est pas chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1097">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="850a0-1098">Aucune exception n'est levée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1098">No exception is thrown.</span></span>  
  
 <span data-ttu-id="850a0-1099">`assemblyFile` peut être absolu ou relatif au répertoire en cours, et l’assembly est chargé dans le domaine de l’appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-1099">`assemblyFile` may be absolute or  relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="850a0-1100">Les assemblys peuvent être chargés dans un des trois contextes, ou peuvent être chargés sans contexte :</span><span class="sxs-lookup"><span data-stu-id="850a0-1100">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="850a0-1101">Le contexte de chargement contient des assemblys trouvés en recherchant : dans le GAC, dans un assembly hôte stocker si le runtime est hébergé, ou dans le <xref:System.AppDomainSetup.ApplicationBase%2A> et <xref:System.AppDomainSetup.PrivateBinPath%2A> du domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="850a0-1101">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="850a0-1102">La plupart des surcharges de la méthode <xref:System.Reflection.Assembly.Load%2A> chargent les assemblys dans ce contexte.</span><span class="sxs-lookup"><span data-stu-id="850a0-1102">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="850a0-1103">Le contexte de chargement contient des assemblys pour lesquels l’utilisateur a fourni un chemin d’accès non inclus dans les répertoires de recherche par la détection.</span><span class="sxs-lookup"><span data-stu-id="850a0-1103">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="850a0-1104"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> et <xref:System.AppDomain.ExecuteAssembly%2A> sont des exemples de méthodes qui sont chargées via un chemin.</span><span class="sxs-lookup"><span data-stu-id="850a0-1104"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>

    <span data-ttu-id="850a0-1105">En commençant par le .NET Framework 4, si l’URI de `assemblyFile` spécifie un emplacement distant, le chargement des assemblys sont désactivée par défaut et le `LoadFrom` méthode lève un <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1105">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="850a0-1106">Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.</span><span class="sxs-lookup"><span data-stu-id="850a0-1106">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="850a0-1107">Le contexte de réflexion uniquement contient des assemblys chargés avec le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> et <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> méthodes ; le code dans ces contextes ne peut pas être exécutées.</span><span class="sxs-lookup"><span data-stu-id="850a0-1107">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="850a0-1108">Si l’utilisateur a généré ou trouvé l’assembly, il n’est pas dans n’importe quel contexte.</span><span class="sxs-lookup"><span data-stu-id="850a0-1108">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="850a0-1109">Cela s’applique aux assemblys chargés à l’aide de surcharges de la <xref:System.Reflection.Assembly.Load%2A> méthode qui spécifient un tableau d’octets qui contient un assembly et aux assemblys dynamiques transitoires créés avec la réflexion l’émission et pas enregistré sur le disque.</span><span class="sxs-lookup"><span data-stu-id="850a0-1109">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="850a0-1110">Le contexte load-from permet à un assembly à charger à partir d’un chemin d’accès non inclus dans la détection et permet cependant de dépendances sur ce chemin d’accès pour trouver et de charger, car les informations de chemin d’accès sont conservées par le contexte.</span><span class="sxs-lookup"><span data-stu-id="850a0-1110">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="850a0-1111">Le <xref:System.Reflection.Assembly.LoadFrom%2A> méthode présente les inconvénients suivants.</span><span class="sxs-lookup"><span data-stu-id="850a0-1111">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="850a0-1112">Utilisez <xref:System.Reflection.Assembly.Load%2A> à la place.</span><span class="sxs-lookup"><span data-stu-id="850a0-1112">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="850a0-1113">Si un assembly avec la même identité est déjà chargé, <xref:System.Reflection.Assembly.LoadFrom%2A> retourne l’assembly chargé même si un autre chemin a été spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-1113">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="850a0-1114">Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>et ultérieurement un assembly dans le contexte de chargement essaie de charger le même assembly par nom d’affichage, la tentative de chargement échoue.</span><span class="sxs-lookup"><span data-stu-id="850a0-1114">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="850a0-1115">Ceci peut se produire quand un assembly est désérialisé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1115">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="850a0-1116">Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>, et le chemin de recherche inclut un assembly avec la même identité mais un emplacement différent, un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou tout autre comportement inattendu peut se produire.</span><span class="sxs-lookup"><span data-stu-id="850a0-1116">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="850a0-1117"><xref:System.Reflection.Assembly.LoadFrom%2A> demande <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> et <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, sur le chemin spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-1117"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="850a0-1118">Si une image native existe pour `assemblyFile`, il n’est pas utilisé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1118">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="850a0-1119">L’assembly ne peut pas être chargé comme indépendant du domaine.</span><span class="sxs-lookup"><span data-stu-id="850a0-1119">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="850a0-1120">Dans la version 1.0 et 1.1 du .NET Framework, la stratégie n’est pas appliquée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1120">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
 <span data-ttu-id="850a0-1121">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-1121">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="850a0-1122">Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="850a0-1122">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="850a0-1123">Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode sans aucune <xref:System.Security.Policy.Evidence> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-1123">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="850a0-1124">Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées.</span><span class="sxs-lookup"><span data-stu-id="850a0-1124">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="850a0-1125">Preuves fournies en tant qu’argument à la <xref:System.Reflection.Assembly.LoadFrom%2A> méthode annulent et remplacent les preuves fournies par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-1125">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.LoadFrom%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="850a0-1126">Si vous appelez cette méthode plusieurs fois sur le même assembly, mais avec une preuve spécifiée différente, le common language runtime ne lève pas une <xref:System.IO.FileLoadException> , car il est impossible de déterminer l’égalité et l’intégrité des différentes spécifications de preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-1126">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="850a0-1127">La première preuve qui réussit est la preuve est utilisée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1127">The evidence that first succeeds is the evidence that is used.</span></span>  
  
-   <span data-ttu-id="850a0-1128">Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode avec un `Byte[]` paramètre pour charger une image common object file format (COFF), la preuve est combinée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1128">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is combined.</span></span> <span data-ttu-id="850a0-1129">`Zone`, `Url` et `Site` sont héritées de l’assembly appelant, et `Hash` et `StrongName` proviennent de l’assembly COFF.</span><span class="sxs-lookup"><span data-stu-id="850a0-1129">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="850a0-1130">Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode avec un `Byte[]` paramètre et <xref:System.Security.Policy.Evidence> pour charger une image COFF, seule la preuve fournie est utilisée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1130">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="850a0-1131">Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="850a0-1131">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-1132"><paramref name="assemblyFile" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1132"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-1133"><paramref name="assemblyFile" /> est introuvable ou le module que vous essayez de charger ne spécifie pas d’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="850a0-1133"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-1134">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-1134">A file that was found could not be loaded.</span></span>  
  
<span data-ttu-id="850a0-1135">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1135">-or-</span></span> 
<span data-ttu-id="850a0-1136">Le <paramref name="securityEvidence" /> n’est pas ambigu et est considéré comme étant non valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-1136">The <paramref name="securityEvidence" /> is not ambiguous and is determined to be invalid.</span></span>

<span data-ttu-id="850a0-1137">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1137">-or-</span></span>

<span data-ttu-id="850a0-1138">La possibilité d’exécuter du code dans des assemblys distants est désactivée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1138">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="850a0-1139">Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1139">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-1140"><paramref name="assemblyFile" /> n’est pas un assembly valide ; par exemple, un assembly 32 bits dans un processus 64 bits.</span><span class="sxs-lookup"><span data-stu-id="850a0-1140"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="850a0-1141">Pour plus d’informations, consultez la rubrique sur les exceptions.</span><span class="sxs-lookup"><span data-stu-id="850a0-1141">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="850a0-1142">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1142">-or-</span></span> 
<span data-ttu-id="850a0-1143">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyFile" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-1143">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="850a0-1144">Un code base qui ne commence pas par "file://" a été spécifié sans le <see cref="T:System.Net.WebPermission" /> requis.</span><span class="sxs-lookup"><span data-stu-id="850a0-1144">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-1145">Le paramètre <paramref name="assemblyFile" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="850a0-1145">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="850a0-1146">Le nom de l’assembly dépasse la longueur maximale définie par le système.</span><span class="sxs-lookup"><span data-stu-id="850a0-1146">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="850a0-1147">pour charger un assembly avec la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-1147">to load an assembly with evidence.</span></span> <span data-ttu-id="850a0-1148">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1148">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="850a0-1149">pour lire un URI qui commence par « file:// ».</span><span class="sxs-lookup"><span data-stu-id="850a0-1149">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="850a0-1150">Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1150">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="850a0-1151">pour lire un URI qui ne commence pas par « file:// ».</span><span class="sxs-lookup"><span data-stu-id="850a0-1151">for reading a URI that does not begin with "file://".</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="850a0-1152">Nom ou chemin d’accès du fichier qui contient le manifeste d’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1152">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="850a0-1153">Valeur du code de hachage calculé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1153">The value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="850a0-1154">Algorithme de hachage utilisé pour hacher les fichiers et pour générer le nom fort.</span><span class="sxs-lookup"><span data-stu-id="850a0-1154">The hash algorithm used for hashing files and for generating the strong name.</span></span></param>
        <summary><span data-ttu-id="850a0-1155">Charge un assembly en fonction de son nom de fichier ou de son chemin d’accès, de la valeur de hachage et de l’algorithme de hachage.</span><span class="sxs-lookup"><span data-stu-id="850a0-1155">Loads an assembly given its file name or path, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="850a0-1156">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1156">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-1157">Le `assemblyFile` paramètre doit faire référence à un URI sans caractères d’échappement.</span><span class="sxs-lookup"><span data-stu-id="850a0-1157">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="850a0-1158">Cette méthode fournit les caractères d’échappement pour tous les caractères non valides dans l’URI.</span><span class="sxs-lookup"><span data-stu-id="850a0-1158">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-1159">Protocole de transfert de fichiers (FTP) n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="850a0-1159">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="850a0-1160">Si l’URI fourni pour `assemblyFile` est une adresse FTP, l’assembly n’est pas chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1160">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="850a0-1161">Aucune exception n'est levée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1161">No exception is thrown.</span></span>  
  
 <span data-ttu-id="850a0-1162">`assemblyFile` peut être absolu ou relatif au répertoire en cours, et l’assembly est chargé dans le domaine de l’appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-1162">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="850a0-1163">Les assemblys peuvent être chargés dans un des trois contextes, ou peuvent être chargés sans contexte :</span><span class="sxs-lookup"><span data-stu-id="850a0-1163">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="850a0-1164">Le contexte de chargement contient des assemblys trouvés en recherchant : dans le global assembly cache, dans un assembly hôte stocker si le runtime est hébergé, ou dans le <xref:System.AppDomainSetup.ApplicationBase%2A> et <xref:System.AppDomainSetup.PrivateBinPath%2A> du domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="850a0-1164">The load context contains assemblies found by probing: in the global assembly cache, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="850a0-1165">La plupart des surcharges de la méthode <xref:System.Reflection.Assembly.Load%2A> chargent les assemblys dans ce contexte.</span><span class="sxs-lookup"><span data-stu-id="850a0-1165">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="850a0-1166">Le contexte de chargement contient des assemblys pour lesquels l’utilisateur a fourni un chemin d’accès n’est pas inclus dans la recherche.</span><span class="sxs-lookup"><span data-stu-id="850a0-1166">The load-from context contains assemblies for which the user provided a path that is not included in probing.</span></span> <span data-ttu-id="850a0-1167"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> et <xref:System.AppDomain.ExecuteAssembly%2A> sont des exemples de méthodes qui sont chargées via un chemin.</span><span class="sxs-lookup"><span data-stu-id="850a0-1167"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>  

    <span data-ttu-id="850a0-1168">En commençant par le .NET Framework 4, si l’URI de `assemblyFile` spécifie un emplacement distant, le chargement des assemblys sont désactivée par défaut et le `LoadFrom` méthode lève un <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1168">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="850a0-1169">Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.</span><span class="sxs-lookup"><span data-stu-id="850a0-1169">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="850a0-1170">Le contexte de réflexion uniquement contient des assemblys chargés avec le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> et <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> méthodes ; le code dans ces contextes ne peut pas être exécutées.</span><span class="sxs-lookup"><span data-stu-id="850a0-1170">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="850a0-1171">Si l’utilisateur a généré ou trouvé l’assembly, il n’est pas dans n’importe quel contexte.</span><span class="sxs-lookup"><span data-stu-id="850a0-1171">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="850a0-1172">Cela s’applique aux assemblys chargés à l’aide de surcharges de la <xref:System.Reflection.Assembly.Load%2A> méthode qui spécifient un tableau d’octets qui contient un assembly et aux assemblys dynamiques transitoires créés avec la réflexion l’émission et pas enregistré sur le disque.</span><span class="sxs-lookup"><span data-stu-id="850a0-1172">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="850a0-1173">Le contexte load-from permet à un assembly à charger à partir d’un chemin d’accès n’est pas inclus dans la détection et permet cependant de dépendances sur ce chemin d’accès pour trouver et de charger, car les informations de chemin d’accès sont conservées par le contexte.</span><span class="sxs-lookup"><span data-stu-id="850a0-1173">The load-from context allows an assembly to be loaded from a path that is not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="850a0-1174">Le <xref:System.Reflection.Assembly.LoadFrom%2A> méthode présente les inconvénients suivants.</span><span class="sxs-lookup"><span data-stu-id="850a0-1174">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="850a0-1175">Utilisez <xref:System.Reflection.Assembly.Load%2A> à la place.</span><span class="sxs-lookup"><span data-stu-id="850a0-1175">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="850a0-1176">Si un assembly avec la même identité est déjà chargé, <xref:System.Reflection.Assembly.LoadFrom%2A> retourne l’assembly chargé même si un autre chemin a été spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-1176">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="850a0-1177">Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>et ultérieurement un assembly dans le contexte de chargement essaie de charger le même assembly par nom d’affichage, la tentative de chargement échoue.</span><span class="sxs-lookup"><span data-stu-id="850a0-1177">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="850a0-1178">Ceci peut se produire quand un assembly est désérialisé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1178">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="850a0-1179">Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>, et le chemin de recherche inclut un assembly avec la même identité mais un emplacement différent, un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou tout autre comportement inattendu peut se produire.</span><span class="sxs-lookup"><span data-stu-id="850a0-1179">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="850a0-1180"><xref:System.Reflection.Assembly.LoadFrom%2A> demande <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> et <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, sur le chemin spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-1180"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="850a0-1181">Si une image native existe pour `assemblyFile`, il n’est pas utilisé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1181">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="850a0-1182">L’assembly ne peut pas être chargé comme étant indépendant du domaine.</span><span class="sxs-lookup"><span data-stu-id="850a0-1182">The assembly cannot be loaded as domain-neutral.</span></span>  
  
 <span data-ttu-id="850a0-1183">L’assembly est chargé avec la preuve fournie par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-1183">The assembly is loaded with the evidence that the loader supplies.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-1184"><paramref name="assemblyFile" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1184"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-1185"><paramref name="assemblyFile" /> est introuvable ou le module que vous essayez de charger ne spécifie pas une extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="850a0-1185"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a file name extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-1186">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-1186">A file that was found could not be loaded.</span></span>

<span data-ttu-id="850a0-1187">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1187">-or-</span></span>

<span data-ttu-id="850a0-1188">La possibilité d’exécuter du code dans des assemblys distants est désactivée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1188">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="850a0-1189">Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1189">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-1190"><paramref name="assemblyFile" /> n’est pas un assembly valide ; par exemple, un assembly 32 bits dans un processus 64 bits.</span><span class="sxs-lookup"><span data-stu-id="850a0-1190"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="850a0-1191">Pour plus d’informations, consultez la rubrique sur les exceptions.</span><span class="sxs-lookup"><span data-stu-id="850a0-1191">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="850a0-1192">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1192">-or-</span></span> 
 <span data-ttu-id="850a0-1193"><paramref name="assemblyFile" /> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1193"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="850a0-1194">Un code base qui ne commence pas par "file://" a été spécifié sans la <see cref="T:System.Net.WebPermission" /> requise.</span><span class="sxs-lookup"><span data-stu-id="850a0-1194">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-1195">Le paramètre <paramref name="assemblyFile" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="850a0-1195">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="850a0-1196">Le nom de l’assembly dépasse la longueur maximale définie par le système.</span><span class="sxs-lookup"><span data-stu-id="850a0-1196">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="850a0-1197">pour charger un assembly avec la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-1197">to load an assembly with evidence.</span></span> <span data-ttu-id="850a0-1198">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1198">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="850a0-1199">pour lire un URI qui commence par « file:// ».</span><span class="sxs-lookup"><span data-stu-id="850a0-1199">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="850a0-1200">Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1200">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="850a0-1201">pour lire un URI qui ne commence pas par « file:// ».</span><span class="sxs-lookup"><span data-stu-id="850a0-1201">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="850a0-1202">Nom ou chemin d’accès du fichier qui contient le manifeste d’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1202">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="850a0-1203">Preuve de chargement de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1203">Evidence for loading the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="850a0-1204">Valeur du code de hachage calculé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1204">The value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="850a0-1205">Algorithme de hachage utilisé pour hacher les fichiers et pour générer le nom fort.</span><span class="sxs-lookup"><span data-stu-id="850a0-1205">The hash algorithm used for hashing files and for generating the strong name.</span></span></param>
        <summary><span data-ttu-id="850a0-1206">Charge un assembly en fonction de son nom de fichier ou de son chemin d’accès, de la preuve de sécurité, de la valeur de hachage et de l’algorithme de hachage.</span><span class="sxs-lookup"><span data-stu-id="850a0-1206">Loads an assembly given its file name or path, security evidence, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="850a0-1207">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1207">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-1208">Le `assemblyFile` paramètre doit faire référence à un URI sans caractères d’échappement.</span><span class="sxs-lookup"><span data-stu-id="850a0-1208">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="850a0-1209">Cette méthode fournit les caractères d’échappement pour tous les caractères non valides dans l’URI.</span><span class="sxs-lookup"><span data-stu-id="850a0-1209">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-1210">Protocole de transfert de fichiers (FTP) n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="850a0-1210">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="850a0-1211">Si l’URI fourni pour `assemblyFile` est une adresse FTP, l’assembly n’est pas chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1211">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="850a0-1212">Aucune exception n'est levée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1212">No exception is thrown.</span></span>  
  
 <span data-ttu-id="850a0-1213">`assemblyFile` peut être absolu ou relatif au répertoire en cours, et l’assembly est chargé dans le domaine de l’appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-1213">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="850a0-1214">Les assemblys peuvent être chargés dans un des trois contextes, ou peuvent être chargés sans contexte :</span><span class="sxs-lookup"><span data-stu-id="850a0-1214">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="850a0-1215">Le contexte de chargement contient des assemblys trouvés en recherchant : dans le GAC, dans un assembly hôte stocker si le runtime est hébergé, ou dans le <xref:System.AppDomainSetup.ApplicationBase%2A> et <xref:System.AppDomainSetup.PrivateBinPath%2A> du domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="850a0-1215">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="850a0-1216">La plupart des surcharges de la méthode <xref:System.Reflection.Assembly.Load%2A> chargent les assemblys dans ce contexte.</span><span class="sxs-lookup"><span data-stu-id="850a0-1216">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="850a0-1217">Le contexte de chargement contient des assemblys pour lesquels l’utilisateur a fourni un chemin d’accès non inclus dans les répertoires de recherche par la détection.</span><span class="sxs-lookup"><span data-stu-id="850a0-1217">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="850a0-1218"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> et <xref:System.AppDomain.ExecuteAssembly%2A> sont des exemples de méthodes qui sont chargées via un chemin.</span><span class="sxs-lookup"><span data-stu-id="850a0-1218"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>  

    <span data-ttu-id="850a0-1219">En commençant par le .NET Framework 4, si l’URI de `assemblyFile` spécifie un emplacement distant, le chargement des assemblys sont désactivée par défaut et le `LoadFrom` méthode lève un <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1219">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="850a0-1220">Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.</span><span class="sxs-lookup"><span data-stu-id="850a0-1220">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="850a0-1221">Le contexte de réflexion uniquement contient des assemblys chargés avec le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> et <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> méthodes ; le code dans ces contextes ne peut pas être exécutées.</span><span class="sxs-lookup"><span data-stu-id="850a0-1221">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="850a0-1222">Si l’utilisateur a généré ou trouvé l’assembly, il n’est pas dans n’importe quel contexte.</span><span class="sxs-lookup"><span data-stu-id="850a0-1222">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="850a0-1223">Cela s’applique aux assemblys chargés à l’aide de surcharges de la <xref:System.Reflection.Assembly.Load%2A> méthode qui spécifient un tableau d’octets qui contient un assembly et aux assemblys dynamiques transitoires créés avec la réflexion l’émission et pas enregistré sur le disque.</span><span class="sxs-lookup"><span data-stu-id="850a0-1223">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="850a0-1224">Le contexte load-from permet à un assembly à charger à partir d’un chemin d’accès non inclus dans la détection et permet cependant de dépendances sur ce chemin d’accès pour trouver et de charger, car les informations de chemin d’accès sont conservées par le contexte.</span><span class="sxs-lookup"><span data-stu-id="850a0-1224">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="850a0-1225">Le <xref:System.Reflection.Assembly.LoadFrom%2A> méthode présente les inconvénients suivants.</span><span class="sxs-lookup"><span data-stu-id="850a0-1225">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="850a0-1226">Utilisez <xref:System.Reflection.Assembly.Load%2A> à la place.</span><span class="sxs-lookup"><span data-stu-id="850a0-1226">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="850a0-1227">Si un assembly avec la même identité est déjà chargé, <xref:System.Reflection.Assembly.LoadFrom%2A> retourne l’assembly chargé même si un autre chemin a été spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-1227">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="850a0-1228">Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>et ultérieurement un assembly dans le contexte de chargement essaie de charger le même assembly par nom d’affichage, la tentative de chargement échoue.</span><span class="sxs-lookup"><span data-stu-id="850a0-1228">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="850a0-1229">Ceci peut se produire quand un assembly est désérialisé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1229">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="850a0-1230">Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>, et le chemin de recherche inclut un assembly avec la même identité mais un emplacement différent, un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou tout autre comportement inattendu peut se produire.</span><span class="sxs-lookup"><span data-stu-id="850a0-1230">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="850a0-1231"><xref:System.Reflection.Assembly.LoadFrom%2A> demande <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> et <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, sur le chemin spécifié.</span><span class="sxs-lookup"><span data-stu-id="850a0-1231"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="850a0-1232">Si une image native existe pour `assemblyFile`, il n’est pas utilisé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1232">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="850a0-1233">L’assembly ne peut pas être chargé comme indépendant du domaine.</span><span class="sxs-lookup"><span data-stu-id="850a0-1233">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="850a0-1234">Dans la version 1.0 et 1.1 du .NET Framework, la stratégie n’est pas appliquée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1234">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
 <span data-ttu-id="850a0-1235">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-1235">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="850a0-1236">Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="850a0-1236">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="850a0-1237">Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode sans aucune <xref:System.Security.Policy.Evidence> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-1237">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="850a0-1238">Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées.</span><span class="sxs-lookup"><span data-stu-id="850a0-1238">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="850a0-1239">Preuves fournies en tant qu’argument à la <xref:System.Reflection.Assembly.LoadFrom%2A> méthode annulent et remplacent les preuves fournies par le chargeur.</span><span class="sxs-lookup"><span data-stu-id="850a0-1239">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.LoadFrom%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="850a0-1240">Si vous appelez cette méthode plusieurs fois sur le même assembly, mais avec une preuve spécifiée différente, le common language runtime ne lève pas une <xref:System.IO.FileLoadException> , car il est impossible de déterminer l’égalité et l’intégrité des différentes spécifications de preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-1240">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="850a0-1241">La première preuve qui réussit est la preuve est utilisée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1241">The evidence that first succeeds is the evidence that is used.</span></span>  
  
-   <span data-ttu-id="850a0-1242">Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode avec un `Byte[]` paramètre pour charger une image common object file format (COFF), la preuve est combinée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1242">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is combined.</span></span> <span data-ttu-id="850a0-1243">`Zone`, `Url` et `Site` sont héritées de l’assembly appelant, et `Hash` et `StrongName` proviennent de l’assembly COFF.</span><span class="sxs-lookup"><span data-stu-id="850a0-1243">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="850a0-1244">Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode avec un `Byte[]` paramètre et <xref:System.Security.Policy.Evidence> pour charger une image COFF, seule la preuve fournie est utilisée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1244">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="850a0-1245">Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.</span><span class="sxs-lookup"><span data-stu-id="850a0-1245">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-1246"><paramref name="assemblyFile" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1246"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-1247"><paramref name="assemblyFile" /> est introuvable ou le module que vous essayez de charger ne spécifie pas d’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="850a0-1247"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-1248">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-1248">A file that was found could not be loaded.</span></span>  
  
<span data-ttu-id="850a0-1249">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1249">-or-</span></span> 
<span data-ttu-id="850a0-1250">Le <paramref name="securityEvidence" /> n’est pas ambigu et est considéré comme étant non valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-1250">The <paramref name="securityEvidence" /> is not ambiguous and is determined to be invalid.</span></span>

<span data-ttu-id="850a0-1251">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1251">-or-</span></span>

<span data-ttu-id="850a0-1252">La possibilité d’exécuter du code dans des assemblys distants est désactivée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1252">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="850a0-1253">Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1253">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-1254"><paramref name="assemblyFile" /> n’est pas un assembly valide ; par exemple, un assembly 32 bits dans un processus 64 bits.</span><span class="sxs-lookup"><span data-stu-id="850a0-1254"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="850a0-1255">Pour plus d’informations, consultez la rubrique sur les exceptions.</span><span class="sxs-lookup"><span data-stu-id="850a0-1255">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="850a0-1256">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1256">-or-</span></span> 
<span data-ttu-id="850a0-1257">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyFile" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-1257">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="850a0-1258">Un code base qui ne commence pas par "file://" a été spécifié sans le <see cref="T:System.Net.WebPermission" /> requis.</span><span class="sxs-lookup"><span data-stu-id="850a0-1258">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-1259">Le paramètre <paramref name="assemblyFile" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="850a0-1259">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="850a0-1260">Le nom de l’assembly dépasse la longueur maximale définie par le système.</span><span class="sxs-lookup"><span data-stu-id="850a0-1260">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="850a0-1261">pour charger un assembly avec la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-1261">to load an assembly with evidence.</span></span> <span data-ttu-id="850a0-1262">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1262">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="850a0-1263">pour lire un URI qui commence par « file:// ».</span><span class="sxs-lookup"><span data-stu-id="850a0-1263">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="850a0-1264">Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1264">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="850a0-1265">pour lire un URI qui ne commence pas par « file:// ».</span><span class="sxs-lookup"><span data-stu-id="850a0-1265">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="850a0-1266">Charge le module interne à cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1266">Loads the module internal to this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName"><span data-ttu-id="850a0-1267">Nom du module.</span><span class="sxs-lookup"><span data-stu-id="850a0-1267">The name of the module.</span></span> <span data-ttu-id="850a0-1268">Cette chaîne doit correspondre à un nom de fichier du manifeste de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1268">This string must correspond to a file name in this assembly's manifest.</span></span></param>
        <param name="rawModule"><span data-ttu-id="850a0-1269">Tableau d'octets qui est une image COFF contenant un module émis ou une ressource.</span><span class="sxs-lookup"><span data-stu-id="850a0-1269">A byte array that is a COFF-based image containing an emitted module, or a resource.</span></span></param>
        <summary><span data-ttu-id="850a0-1270">Charge le module, interne à cet assembly, avec une image COFF (Common Object File Format) contenant un module émis ou un fichier de ressources.</span><span class="sxs-lookup"><span data-stu-id="850a0-1270">Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</span></span></summary>
        <returns><span data-ttu-id="850a0-1271">Module chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1271">The loaded module.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-1272"><paramref name="moduleName" /> ou <paramref name="rawModule" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1272"><paramref name="moduleName" /> or <paramref name="rawModule" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-1273"><paramref name="moduleName" /> ne correspond pas à une entrée de fichier du manifeste de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1273"><paramref name="moduleName" /> does not match a file entry in this assembly's manifest.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-1274"><paramref name="rawModule" /> n’est pas un module valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-1274"><paramref name="rawModule" /> is not a valid module.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-1275">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-1275">A file that was found could not be loaded.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="850a0-1276">pour fournir la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-1276">to provide evidence.</span></span> <span data-ttu-id="850a0-1277">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1277">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName"><span data-ttu-id="850a0-1278">Nom du module.</span><span class="sxs-lookup"><span data-stu-id="850a0-1278">The name of the module.</span></span> <span data-ttu-id="850a0-1279">Cette chaîne doit correspondre à un nom de fichier du manifeste de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1279">This string must correspond to a file name in this assembly's manifest.</span></span></param>
        <param name="rawModule"><span data-ttu-id="850a0-1280">Tableau d'octets qui est une image COFF contenant un module émis ou une ressource.</span><span class="sxs-lookup"><span data-stu-id="850a0-1280">A byte array that is a COFF-based image containing an emitted module, or a resource.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="850a0-1281">Tableau d'octets contenant les octets bruts représentant les symboles du module.</span><span class="sxs-lookup"><span data-stu-id="850a0-1281">A byte array containing the raw bytes representing the symbols for the module.</span></span> <span data-ttu-id="850a0-1282">Doit avoir la valeur <see langword="null" /> s'il s'agit d'un fichier de ressources.</span><span class="sxs-lookup"><span data-stu-id="850a0-1282">Must be <see langword="null" /> if this is a resource file.</span></span></param>
        <summary><span data-ttu-id="850a0-1283">Charge le module, interne à cet assembly, avec une image COFF (Common Object File Format) contenant un module émis ou un fichier de ressources.</span><span class="sxs-lookup"><span data-stu-id="850a0-1283">Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</span></span> <span data-ttu-id="850a0-1284">Les octets bruts représentant les symboles du module sont également chargés.</span><span class="sxs-lookup"><span data-stu-id="850a0-1284">The raw bytes representing the symbols for the module are also loaded.</span></span></summary>
        <returns><span data-ttu-id="850a0-1285">Module chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1285">The loaded module.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-1286"><paramref name="moduleName" /> ou <paramref name="rawModule" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1286"><paramref name="moduleName" /> or <paramref name="rawModule" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-1287"><paramref name="moduleName" /> ne correspond pas à une entrée de fichier du manifeste de cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1287"><paramref name="moduleName" /> does not match a file entry in this assembly's manifest.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-1288"><paramref name="rawModule" /> n’est pas un module valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-1288"><paramref name="rawModule" /> is not a valid module.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-1289">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-1289">A file that was found could not be loaded.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="850a0-1290">pour fournir la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-1290">to provide evidence.</span></span> <span data-ttu-id="850a0-1291">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1291">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="850a0-1292">Charge un assembly à partir du répertoire de l'application ou du Global Assembly Cache en utilisant un nom partiel.</span><span class="sxs-lookup"><span data-stu-id="850a0-1292">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="850a0-1293">Les surcharges de la <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> méthode sont obsolète et ont été conservés pour la compatibilité descendante.</span><span class="sxs-lookup"><span data-stu-id="850a0-1293">The overloads of the <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method are obsolete and have been retained for backward compatibility.</span></span> <span data-ttu-id="850a0-1294">L'alternative non obsolète est <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1294">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName"><span data-ttu-id="850a0-1295">Nom complet de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1295">The display name of the assembly.</span></span></param>
        <summary><span data-ttu-id="850a0-1296">Charge un assembly à partir du répertoire de l'application ou du Global Assembly Cache en utilisant un nom partiel.</span><span class="sxs-lookup"><span data-stu-id="850a0-1296">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span></span></summary>
        <returns><span data-ttu-id="850a0-1297">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1297">The loaded assembly.</span></span> <span data-ttu-id="850a0-1298">Si <paramref name="partialName" /> est introuvable, cette méthode retourne <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1298">If <paramref name="partialName" /> is not found, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="850a0-1299">Le <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> méthode est obsolète et a été conservée pour la compatibilité descendante.</span><span class="sxs-lookup"><span data-stu-id="850a0-1299">The <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> method is obsolete and has been retained for backward compatibility.</span></span> <span data-ttu-id="850a0-1300">L'alternative non obsolète est <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1300">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="850a0-1301">Les applications qui chargent des assemblys avec cette méthode seront affectées par les mises à niveau de ces assemblys.</span><span class="sxs-lookup"><span data-stu-id="850a0-1301">Applications that load assemblies with this method will be affected by upgrades of those assemblies.</span></span> <span data-ttu-id="850a0-1302">Par conséquent, n’utilisez pas cette méthode ; reconcevez l’application pour utiliser le <xref:System.Reflection.Assembly.Load%28System.String%29> surcharge de méthode ou le <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="850a0-1302">Therefore, do not use this method; redesign the application to use the <xref:System.Reflection.Assembly.Load%28System.String%29> method overload or the <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> method overload.</span></span>  
  
 <span data-ttu-id="850a0-1303">Cette méthode appelle d’abord <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1303">This method first calls <xref:System.Reflection.Assembly.Load%2A>.</span></span> <span data-ttu-id="850a0-1304">Si l’assembly est introuvable, cette méthode retourne l’assembly du global assembly cache qui a le même nom simple et le numéro de version le plus élevé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1304">If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-1305">Le paramètre <paramref name="partialName" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1305">The <paramref name="partialName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-1306"><paramref name="assemblyFile" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-1306"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-1307">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1307">-or-</span></span> 
<span data-ttu-id="850a0-1308">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="partialName" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-1308">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="partialName" /> was compiled with a later version.</span></span></exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName"><span data-ttu-id="850a0-1309">Nom complet de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1309">The display name of the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="850a0-1310">Preuve de chargement de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1310">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="850a0-1311">Charge un assembly à partir du répertoire de l'application ou du Global Assembly Cache en utilisant un nom partiel.</span><span class="sxs-lookup"><span data-stu-id="850a0-1311">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span></span> <span data-ttu-id="850a0-1312">L'assembly est chargé dans le domaine de l'appelant à l'aide de la preuve fournie.</span><span class="sxs-lookup"><span data-stu-id="850a0-1312">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="850a0-1313">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1313">The loaded assembly.</span></span> <span data-ttu-id="850a0-1314">Si <paramref name="partialName" /> est introuvable, cette méthode retourne <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1314">If <paramref name="partialName" /> is not found, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="850a0-1315">Le <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> méthode est obsolète et a été conservée pour la compatibilité descendante.</span><span class="sxs-lookup"><span data-stu-id="850a0-1315">The <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> method is obsolete and has been retained for backward compatibility.</span></span> <span data-ttu-id="850a0-1316">L'alternative non obsolète est <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1316">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="850a0-1317">La preuve est le jeu d'informations qui alimente les décisions de stratégie de sécurité, telles que les autorisations qui peuvent être accordées au code.</span><span class="sxs-lookup"><span data-stu-id="850a0-1317">Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</span></span>  
  
 <span data-ttu-id="850a0-1318">Les applications qui chargent des assemblys avec cette méthode seront affectées par les mises à niveau de ces assemblys.</span><span class="sxs-lookup"><span data-stu-id="850a0-1318">Applications that load assemblies with this method will be affected by upgrades of those assemblies.</span></span> <span data-ttu-id="850a0-1319">Par conséquent, n’utilisez pas cette méthode ; reconcevez l’application pour utiliser le <xref:System.Reflection.Assembly.Load%2A> méthode ou le <xref:System.Reflection.Assembly.LoadFrom%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="850a0-1319">Therefore, do not use this method; redesign the application to use the <xref:System.Reflection.Assembly.Load%2A> method or the <xref:System.Reflection.Assembly.LoadFrom%2A> method.</span></span>  
  
 <span data-ttu-id="850a0-1320">Cette méthode appelle d’abord <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1320">This method first calls <xref:System.Reflection.Assembly.Load%2A>.</span></span> <span data-ttu-id="850a0-1321">Si l’assembly est introuvable, cette méthode retourne l’assembly du global assembly cache qui a le même nom simple et le numéro de version le plus élevé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1321">If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-1322">Un assembly ou un module a été chargé à deux reprises avec deux ensembles de preuves différents.</span><span class="sxs-lookup"><span data-stu-id="850a0-1322">An assembly or module was loaded twice with two different sets of evidence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-1323">Le paramètre <paramref name="partialName" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1323">The <paramref name="partialName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-1324"><paramref name="assemblyFile" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-1324"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-1325">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1325">-or-</span></span> 
<span data-ttu-id="850a0-1326">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="partialName" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-1326">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="partialName" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="850a0-1327">pour appeler du code non managé et charger un assembly avec la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-1327">for calling unmanaged code and to load an assembly with evidence.</span></span> <span data-ttu-id="850a0-1328">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1328">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-1329">Obtient le chemin d’accès complet ou l’emplacement UNC du fichier chargé qui contient le manifeste.</span><span class="sxs-lookup"><span data-stu-id="850a0-1329">Gets the full path or UNC location of the loaded file that contains the manifest.</span></span></summary>
        <value><span data-ttu-id="850a0-1330">Emplacement du fichier chargé qui contient le manifeste.</span><span class="sxs-lookup"><span data-stu-id="850a0-1330">The location of the loaded file that contains the manifest.</span></span> <span data-ttu-id="850a0-1331">Si le fichier chargé était une copie fantôme, l'emplacement est celui du fichier après qu'il soit une copie fantôme.</span><span class="sxs-lookup"><span data-stu-id="850a0-1331">If the loaded file was shadow-copied, the location is that of the file after being shadow-copied.</span></span> <span data-ttu-id="850a0-1332">Si l'assembly est chargé à partir d'un tableau d'octets, par exemple lors de l'utilisation de la surcharge de méthode <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" />, la valeur retournée est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="850a0-1332">If the assembly is loaded from a byte array, such as when using the <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> method overload, the value returned is an empty string ("").</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-1333">Pour obtenir l’emplacement avant que le fichier a été copié de clichés instantanés, utilisez le <xref:System.Reflection.Assembly.CodeBase%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="850a0-1333">To get the location before the file has been shadow-copied, use the <xref:System.Reflection.Assembly.CodeBase%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="850a0-1334">L’exemple suivant affiche l’emplacement du fichier chargé qui contient le manifeste.</span><span class="sxs-lookup"><span data-stu-id="850a0-1334">The following example displays the location of the loaded file that contains the manifest.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="850a0-1335">L’assembly actuel est un assembly dynamique représenté par un objet <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1335">The current assembly is a dynamic assembly, represented by an <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> object.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="850a0-1336">Pour accéder au chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="850a0-1336">for access to the path.</span></span> <span data-ttu-id="850a0-1337">Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1337">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="850a0-1338">Clichés instantanés d'assemblys</span><span class="sxs-lookup"><span data-stu-id="850a0-1338">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-1339">Obtient le module qui contient le manifeste de l'assembly actuel.</span><span class="sxs-lookup"><span data-stu-id="850a0-1339">Gets the module that contains the manifest for the current assembly.</span></span></summary>
        <value><span data-ttu-id="850a0-1340">Module qui contient le manifeste d'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1340">The module that contains the manifest for the assembly.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-1341">Se produit si le chargeur de classes du Common Language Runtime ne peut pas résoudre une référence à un module interne d'un assembly à l'aide des moyens normaux.</span><span class="sxs-lookup"><span data-stu-id="850a0-1341">Occurs when the common language runtime class loader cannot resolve a reference to an internal module of an assembly through normal means.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-1342">Cet événement permet le rappel pour rechercher et charger le module lui-même et renvoyez-le.</span><span class="sxs-lookup"><span data-stu-id="850a0-1342">This event gives the callback a chance to find and load the module itself and return it.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="850a0-1343">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="850a0-1343">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="850a0-1344">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="850a0-1344">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-1345">Obtient une collection qui contient les modules dans cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1345">Gets a collection that contains the modules in this assembly.</span></span></summary>
        <value><span data-ttu-id="850a0-1346">Collection qui contient les modules dans cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1346">A collection that contains the modules in this assembly.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="850a0-1347">Assembly à comparer à <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1347">The assembly to compare to <paramref name="right" />.</span></span></param>
        <param name="right"><span data-ttu-id="850a0-1348">Assembly à comparer à <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1348">The assembly to compare to <paramref name="left" />.</span></span></param>
        <summary><span data-ttu-id="850a0-1349">Indique si deux objets <see cref="T:System.Reflection.Assembly" /> sont égaux.</span><span class="sxs-lookup"><span data-stu-id="850a0-1349">Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="850a0-1350"><see langword="true" /> si <paramref name="left" /> est égal à <paramref name="right" /> ; sinon <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1350"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="850a0-1351">Assembly à comparer à <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1351">The assembly to compare to <paramref name="right" />.</span></span></param>
        <param name="right"><span data-ttu-id="850a0-1352">Assembly à comparer à <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1352">The assembly to compare to <paramref name="left" />.</span></span></param>
        <summary><span data-ttu-id="850a0-1353">Indique si deux objets <see cref="T:System.Reflection.Assembly" /> ne sont pas égaux.</span><span class="sxs-lookup"><span data-stu-id="850a0-1353">Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="850a0-1354"><see langword="true" /> si <paramref name="left" /> n'est pas égal à <paramref name="right" /> ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1354"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-1355">Obtient le jeu accordé de l'assembly actuel.</span><span class="sxs-lookup"><span data-stu-id="850a0-1355">Gets the grant set of the current assembly.</span></span></summary>
        <value><span data-ttu-id="850a0-1356">Jeu accordé de l'assembly actuel.</span><span class="sxs-lookup"><span data-stu-id="850a0-1356">The grant set of the current assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-1357"><xref:System.Security.PermissionSet> les objets peuvent contenir des informations sensibles telles que des chemins d’accès.</span><span class="sxs-lookup"><span data-stu-id="850a0-1357"><xref:System.Security.PermissionSet> objects can contain sensitive information such as paths.</span></span> <span data-ttu-id="850a0-1358">Par conséquent, une confiance totale est nécessaire pour accéder à ces objets.</span><span class="sxs-lookup"><span data-stu-id="850a0-1358">Therefore, full trust is required to access these objects.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="850a0-1359">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="850a0-1359">requires full trust for the immediate caller.</span></span> <span data-ttu-id="850a0-1360">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="850a0-1360">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-1361">Obtient une valeur <see cref="T:System.Boolean" /> indiquant si cet assembly a été chargé dans le contexte de réflexion uniquement.</span><span class="sxs-lookup"><span data-stu-id="850a0-1361">Gets a <see cref="T:System.Boolean" /> value indicating whether this assembly was loaded into the reflection-only context.</span></span></summary>
        <value><span data-ttu-id="850a0-1362"><see langword="true" /> si l'assembly a été chargé dans le contexte de réflexion uniquement, plutôt que dans le contexte d'exécution ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1362"><see langword="true" /> if the assembly was loaded into the reflection-only context, rather than the execution context; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-1363">Si un assembly a été chargé dans le contexte de réflexion uniquement, à l’aide du <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> (méthode), vous ne pouvez pas exécuter du code dans l’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1363">If an assembly has been loaded into the reflection-only context, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, you cannot execute code in the assembly.</span></span> <span data-ttu-id="850a0-1364">Pour exécuter du code, l’assembly doit être chargé dans le contexte d’exécution.</span><span class="sxs-lookup"><span data-stu-id="850a0-1364">To execute code, the assembly must be loaded into the execution context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="850a0-1365">Charge un assembly dans le contexte de réflexion uniquement, où il peut être examiné mais pas exécuté.</span><span class="sxs-lookup"><span data-stu-id="850a0-1365">Loads an assembly into the reflection-only context, where it can be examined but not executed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="850a0-1366">Tableau d'octets qui est une image au format COFF contenant un assembly émis.</span><span class="sxs-lookup"><span data-stu-id="850a0-1366">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="850a0-1367">Charge l'assembly à partir d'une image au format COFF (Common Object File Format) contenant un assembly émis.</span><span class="sxs-lookup"><span data-stu-id="850a0-1367">Loads the assembly from a common object file format (COFF)-based image containing an emitted assembly.</span></span> <span data-ttu-id="850a0-1368">L'assembly est chargé dans le contexte de réflexion uniquement du domaine d'application de l'appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-1368">The assembly is loaded into the reflection-only context of the caller's application domain.</span></span></summary>
        <returns><span data-ttu-id="850a0-1369">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1369">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-1370">Vous ne pouvez pas exécuter du code à partir d’un assembly chargé dans le contexte de réflexion uniquement.</span><span class="sxs-lookup"><span data-stu-id="850a0-1370">You cannot execute code from an assembly loaded into the reflection-only context.</span></span> <span data-ttu-id="850a0-1371">Pour exécuter du code, l’assembly doit être chargé dans le contexte d’exécution, à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="850a0-1371">To execute code, the assembly must be loaded into the execution context as well, using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="850a0-1372">Le contexte de réflexion uniquement n’est pas différent d’autres contextes.</span><span class="sxs-lookup"><span data-stu-id="850a0-1372">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="850a0-1373">Les assemblys sont chargés dans le contexte peuvent être déchargées seulement en déchargeant le domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="850a0-1373">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-1374"><paramref name="rawAssembly" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1374"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-1375"><paramref name="rawAssembly" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-1375"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-1376">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1376">-or-</span></span> 
<span data-ttu-id="850a0-1377">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="rawAssembly" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-1377">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-1378">Impossible de charger <paramref name="rawAssembly" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1378"><paramref name="rawAssembly" /> cannot be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="850a0-1379">Nom complet de l'assembly, tel que retourné par la propriété <see cref="P:System.Reflection.AssemblyName.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1379">The display name of the assembly, as returned by the <see cref="P:System.Reflection.AssemblyName.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="850a0-1380">Charge un assembly dans le contexte de réflexion uniquement, étant donné son nom complet.</span><span class="sxs-lookup"><span data-stu-id="850a0-1380">Loads an assembly into the reflection-only context, given its display name.</span></span></summary>
        <returns><span data-ttu-id="850a0-1381">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1381">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-1382">Dépendances ne sont pas chargés automatiquement dans le contexte de réflexion uniquement.</span><span class="sxs-lookup"><span data-stu-id="850a0-1382">Dependencies are not automatically loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="850a0-1383">Vous ne pouvez pas exécuter du code à partir d’un assembly chargé dans le contexte de réflexion uniquement.</span><span class="sxs-lookup"><span data-stu-id="850a0-1383">You cannot execute code from an assembly loaded into the reflection-only context.</span></span> <span data-ttu-id="850a0-1384">Pour exécuter du code, l’assembly doit être chargé dans le contexte d’exécution, à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="850a0-1384">To execute code, the assembly must be loaded into the execution context as well, using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="850a0-1385">L'octroi ou non de certaines autorisations à un assembly repose sur la preuve.</span><span class="sxs-lookup"><span data-stu-id="850a0-1385">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="850a0-1386">Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="850a0-1386">The rules for assembly and security evidence merging are as follows:</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="850a0-1387">La réflexion sur des fichiers exécutables compilés en C++ peut lever une <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="850a0-1387">Reflecting on executable files compiled in C++ might throw a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="850a0-1388">Cela est probablement causé par le compilateur C++ suppression des adresses de réadressage ou de la section .reloc de votre fichier exécutable.</span><span class="sxs-lookup"><span data-stu-id="850a0-1388">This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file.</span></span> <span data-ttu-id="850a0-1389">Pour conserver l’adresse .reloc, spécifiez `/fixed:no` lors de la liaison.</span><span class="sxs-lookup"><span data-stu-id="850a0-1389">To preserve the .reloc address, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="850a0-1390">Le contexte de réflexion uniquement n’est pas différent d’autres contextes.</span><span class="sxs-lookup"><span data-stu-id="850a0-1390">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="850a0-1391">Les assemblys sont chargés dans le contexte peuvent être déchargées seulement en déchargeant le domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="850a0-1391">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-1392"><paramref name="assemblyString" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1392"><paramref name="assemblyString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-1393">Le <paramref name="assemblyString" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="850a0-1393"><paramref name="assemblyString" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-1394"><paramref name="assemblyString" /> est introuvable.</span><span class="sxs-lookup"><span data-stu-id="850a0-1394"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-1395"><paramref name="assemblyString" /> a été trouvé, mais impossible de le charger.</span><span class="sxs-lookup"><span data-stu-id="850a0-1395"><paramref name="assemblyString" /> is found, but cannot be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-1396"><paramref name="assemblyString" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-1396"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-1397">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1397">-or-</span></span> 
<span data-ttu-id="850a0-1398">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyString" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-1398">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="850a0-1399">Chemin d’accès du fichier qui contient le manifeste d’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1399">The path of the file that contains the manifest of the assembly.</span></span></param>
        <summary><span data-ttu-id="850a0-1400">Charge un assembly dans le contexte de réflexion uniquement, étant donné son chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="850a0-1400">Loads an assembly into the reflection-only context, given its path.</span></span></summary>
        <returns><span data-ttu-id="850a0-1401">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1401">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-1402">Dépendances ne sont pas chargés automatiquement dans le contexte de réflexion uniquement.</span><span class="sxs-lookup"><span data-stu-id="850a0-1402">Dependencies are not automatically loaded into the reflection-only context.</span></span> <span data-ttu-id="850a0-1403">Pour charger automatiquement les dépendances, gérer le <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> événement et charge la dépendance dans le Gestionnaire d’événements.</span><span class="sxs-lookup"><span data-stu-id="850a0-1403">To automatically load dependencies, handle the <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> event and load the dependency in the event handler.</span></span>  
  
 <span data-ttu-id="850a0-1404">Vous ne pouvez pas exécuter du code à partir d’un assembly qui a été chargé dans le contexte de réflexion uniquement.</span><span class="sxs-lookup"><span data-stu-id="850a0-1404">You cannot execute code from an assembly that has been loaded into the reflection-only context.</span></span> <span data-ttu-id="850a0-1405">Pour exécuter le code, chargez l’assembly avec le <xref:System.Reflection.Assembly.LoadFile%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="850a0-1405">To execute the code, load the assembly with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="850a0-1406">Le `assemblyFile` paramètre doit faire référence à un URI sans caractères d’échappement.</span><span class="sxs-lookup"><span data-stu-id="850a0-1406">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="850a0-1407">Cette méthode fournit les caractères d’échappement pour tous les caractères non valides dans l’URI.</span><span class="sxs-lookup"><span data-stu-id="850a0-1407">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
 <span data-ttu-id="850a0-1408">Le chemin d’accès spécifié pour `assemblyFile` est relatif au répertoire actif.</span><span class="sxs-lookup"><span data-stu-id="850a0-1408">The path specified for `assemblyFile` is relative to the current directory.</span></span> <span data-ttu-id="850a0-1409">L’assembly est chargé dans le domaine de l’appelant.</span><span class="sxs-lookup"><span data-stu-id="850a0-1409">The assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="850a0-1410">Le contexte de réflexion uniquement n’est pas différent d’autres contextes.</span><span class="sxs-lookup"><span data-stu-id="850a0-1410">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="850a0-1411">Les assemblys sont chargés dans le contexte peuvent être déchargées seulement en déchargeant le domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="850a0-1411">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-1412"><paramref name="assemblyFile" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1412"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-1413"><paramref name="assemblyFile" /> est introuvable ou le module que vous essayez de charger ne spécifie pas une extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="850a0-1413"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a file name extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-1414"><paramref name="assemblyFile" /> a été trouvé, mais impossible de le charger.</span><span class="sxs-lookup"><span data-stu-id="850a0-1414"><paramref name="assemblyFile" /> is found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-1415"><paramref name="assemblyFile" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-1415"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-1416">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1416">-or-</span></span> 
<span data-ttu-id="850a0-1417">La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyFile" /> a été compilé avec une version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="850a0-1417">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="850a0-1418">Un code base qui ne commence pas par "file://" a été spécifié sans le <see cref="T:System.Net.WebPermission" /> requis.</span><span class="sxs-lookup"><span data-stu-id="850a0-1418">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="850a0-1419">Le nom de l’assembly dépasse la longueur maximale définie par le système.</span><span class="sxs-lookup"><span data-stu-id="850a0-1419">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-1420">Le <paramref name="assemblyFile" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="850a0-1420"><paramref name="assemblyFile" /> is an empty string ("").</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="850a0-1421">pour lire un URI qui commence par « file:// ».</span><span class="sxs-lookup"><span data-stu-id="850a0-1421">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="850a0-1422">Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="850a0-1422">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="850a0-1423">pour lire un URI qui ne commence pas par « file:// ».</span><span class="sxs-lookup"><span data-stu-id="850a0-1423">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="850a0-1424">Obtient une valeur qui indique quel ensemble de règles de sécurité le Common Language Runtime (CLR) applique pour cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1424">Gets a value that indicates which set of security rules the common language runtime (CLR) enforces for this assembly.</span></span></summary>
        <value><span data-ttu-id="850a0-1425">Ensemble de règles de sécurité que le CLR applique pour cet assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1425">The security rule set that the CLR enforces for this assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-1426">Par défaut, les assemblys que vous compilez avec le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ont une transparence, bien que vous puissiez utiliser explicitement à la place.</span><span class="sxs-lookup"><span data-stu-id="850a0-1426">By default, assemblies that you compile with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] have  transparency, although you can explicitly make them  instead.</span></span> <span data-ttu-id="850a0-1427">Les assemblys qui ont été compilés avec les versions antérieures du .NET Framework ont la transparence de niveau 1.</span><span class="sxs-lookup"><span data-stu-id="850a0-1427">Assemblies that were compiled with earlier versions of the .NET Framework have level 1 transparency.</span></span>  
  
 <span data-ttu-id="850a0-1428">Consultez [Changements en matière de sécurité](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="850a0-1428">See [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/misc/security-transparent-code.md"><span data-ttu-id="850a0-1429">Code transparent de sécurité (security-transparent)</span><span class="sxs-lookup"><span data-stu-id="850a0-1429">Security-Transparent Code</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="850a0-1430">Modifications de sécurité dans le .NET Framework 4</span><span class="sxs-lookup"><span data-stu-id="850a0-1430">Security Changes in the .NET Framework 4</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-1431">Retourne le type de l'instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="850a0-1431">Returns the type of the current instance.</span></span></summary>
        <returns><span data-ttu-id="850a0-1432">Objet qui représente le type <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1432">An object that represents the <see cref="T:System.Reflection.Assembly" /> type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="850a0-1433">Retourne le nom complet de l'assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1433">Returns the full name of the assembly, also known as the display name.</span></span></summary>
        <returns><span data-ttu-id="850a0-1434">Nom complet de l'assembly, ou nom de la classe si le nom complet de l'assembly ne peut pas être déterminé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1434">The full name of the assembly, or the class name if the full name of the assembly cannot be determined.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="850a0-1435">Nom ou chemin d’accès du fichier qui contient le manifeste d’assembly.</span><span class="sxs-lookup"><span data-stu-id="850a0-1435">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <summary><span data-ttu-id="850a0-1436">Charge un assembly dans le contexte de chargement, en ignorant des vérifications de sécurité.</span><span class="sxs-lookup"><span data-stu-id="850a0-1436">Loads an assembly into the load-from context, bypassing some security checks.</span></span></summary>
        <returns><span data-ttu-id="850a0-1437">Assembly chargé.</span><span class="sxs-lookup"><span data-stu-id="850a0-1437">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="850a0-1438">Utilisez cette méthode pour charger un assembly local que le système d’exploitation a signalé comme ayant été chargé à partir du Web (par exemple, un fichier temporaire a été téléchargé depuis Internet ou intranet).</span><span class="sxs-lookup"><span data-stu-id="850a0-1438">Use this method to load a local assembly that the operating system has flagged as having been loaded from the Web (for example, a temporary file that was downloaded from the Internet or intranet).</span></span> <span data-ttu-id="850a0-1439">Avant du [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], ces assemblys ont été chargés automatiquement dans un domaine d’application sandbox.</span><span class="sxs-lookup"><span data-stu-id="850a0-1439">Before the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], such assemblies were automatically loaded into a sandboxed application domain.</span></span> <span data-ttu-id="850a0-1440">En commençant par le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], ils sont chargés avec une confiance totale.</span><span class="sxs-lookup"><span data-stu-id="850a0-1440">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], they are loaded with full trust.</span></span>  
  
 <span data-ttu-id="850a0-1441">Comme alternative à l’aide de cette méthode, vous pouvez appliquer le [ &lt;NetFx40_LegacySecurityPolicy&gt; élément](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) dans votre fichier de configuration d’application.</span><span class="sxs-lookup"><span data-stu-id="850a0-1441">As an alternative to using this method, you can apply the [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) in your application configuration file.</span></span> <span data-ttu-id="850a0-1442">Cela entraîne le common language runtime rétablir la stratégie de sécurité de le [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span><span class="sxs-lookup"><span data-stu-id="850a0-1442">This causes the common language runtime to revert to the security policy of the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="850a0-1443">Si vous utilisez une de ces solutions, vous devez être certain qu’elle est sécurisée pour charger `assemblyFile` avec une confiance totale.</span><span class="sxs-lookup"><span data-stu-id="850a0-1443">If you use either of these solutions, you must be certain that it is safe to load `assemblyFile` with full trust.</span></span>  
  
 <span data-ttu-id="850a0-1444">Pour une présentation des contextes de chargement, y compris le contexte de chargement, consultez le <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="850a0-1444">For a discussion of load contexts, including the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="850a0-1445"><paramref name="assemblyFile" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="850a0-1445"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="850a0-1446"><paramref name="assemblyFile" /> est introuvable ou le module que vous essayez de charger ne spécifie pas d’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="850a0-1446"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="850a0-1447">Impossible de charger l’un des fichiers trouvés.</span><span class="sxs-lookup"><span data-stu-id="850a0-1447">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="850a0-1448"><paramref name="assemblyFile" /> n’est pas un assembly valide.</span><span class="sxs-lookup"><span data-stu-id="850a0-1448"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="850a0-1449">- ou -</span><span class="sxs-lookup"><span data-stu-id="850a0-1449">-or-</span></span> 
 <span data-ttu-id="850a0-1450"><paramref name="assemblyFile" /> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</span><span class="sxs-lookup"><span data-stu-id="850a0-1450"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="850a0-1451">Un code base qui ne commence pas par "file://" a été spécifié sans la <see cref="T:System.Net.WebPermission" /> requise.</span><span class="sxs-lookup"><span data-stu-id="850a0-1451">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="850a0-1452">Le paramètre <paramref name="assemblyFile" /> est une chaîne vide ("").</span><span class="sxs-lookup"><span data-stu-id="850a0-1452">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="850a0-1453">Le nom de l’assembly dépasse la longueur maximale définie par le système.</span><span class="sxs-lookup"><span data-stu-id="850a0-1453">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="850a0-1454">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="850a0-1454">requires full trust for the immediate caller.</span></span> <span data-ttu-id="850a0-1455">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="850a0-1455">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>