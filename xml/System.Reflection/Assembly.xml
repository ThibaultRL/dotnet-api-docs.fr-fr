<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata><Meta Name="ms.openlocfilehash" Value="05adb251a801722ef316092a68b4bda8ac4f1500" /><Meta Name="ms.sourcegitcommit" Value="67e8bb367eab32b26025454e7769040cfb1d71c4" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/09/2019" /><Meta Name="ms.locfileid" Value="57701382" /></Metadata><TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un assembly, qui est un bloc de construction réutilisable, avec un numéro de version et autodescriptif d'une application du Common Language Runtime.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Reflection.Assembly> classe pour charger les assemblys, pour Explorer les parties de métadonnées et constituant des assemblys, pour découvrir les types contenus dans les assemblys et pour créer des instances de ces types.  
  
 Pour obtenir un tableau de <xref:System.Reflection.Assembly> objets représentant les assemblys actuellement chargés dans un domaine d’application (par exemple, la valeur par défaut domaine d’application d’un projet simple), utilisez le <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> (méthode).  
  
 Charger des assemblys de façon dynamique, le <xref:System.Reflection.Assembly> classe fournit les méthodes statiques suivantes (`Shared` méthodes en Visual Basic). Assemblys sont chargés dans le domaine d’application où l’opération de chargement se produit.  
  
-   La méthode recommandée pour charger des assemblys consiste à utiliser le <xref:System.AppDomain.Load%2A> (méthode), qui identifie l’assembly à charger par son nom complet (par exemple, « System.Windows.Forms, Version = 2.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089 »). La recherche de l’assembly suit les règles décrites dans [méthode de localisation des assemblys par le Runtime](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).  
  
-   Le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> et <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> méthodes permettent de charger un assembly pour la réflexion, mais pas pour l’exécution. Par exemple, un assembly qui cible une plateforme 64 bits peut être examiné par le code qui s’exécute sur une plateforme 32 bits.  
  
-   Le <xref:System.Reflection.Assembly.LoadFile%2A> et <xref:System.Reflection.Assembly.LoadFrom%2A> méthodes sont fournies pour les rares scénarios dans lesquels un assembly doit être identifié par le chemin d’accès.  
  
 Pour obtenir un <xref:System.Reflection.Assembly> objet pour l’assembly en cours d’exécution, utilisez le <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> (méthode).  
  
 De nombreux membres de la <xref:System.Reflection.Assembly> classe fournissent des informations sur un assembly. Par exemple :  
  
-   Le <xref:System.Reflection.Assembly.GetName%2A> méthode retourne un <xref:System.Reflection.AssemblyName> objet qui fournit l’accès aux parties du nom d’affichage de l’assembly.  
  
-   Le <xref:System.Reflection.Assembly.GetCustomAttributes%2A> méthode répertorie les attributs appliqués à l’assembly.  
  
-   Le <xref:System.Reflection.Assembly.GetFiles%2A> méthode permet d’accéder aux fichiers dans le manifeste d’assembly.  
  
-   Le <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> méthode fournit les noms des ressources dans le manifeste d’assembly.  
  
 Le <xref:System.Reflection.Assembly.GetTypes%2A> méthode répertorie tous les types dans l’assembly. Le <xref:System.Reflection.Assembly.GetExportedTypes%2A> méthode répertorie les types qui sont visibles par les appelants à l’extérieur de l’assembly. Le <xref:System.Reflection.Assembly.GetType%2A> méthode peut être utilisée pour rechercher un type particulier dans l’assembly. Le <xref:System.Reflection.Assembly.CreateInstance%2A> méthode peut être utilisée pour rechercher et créer des instances de types dans l’assembly.  
  
 Pour plus d’informations sur les assemblys, consultez la section « Domaines d’Application et assemblys » dans le [domaines d’Application](~/docs/framework/app-domains/application-domains.md) rubrique.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment obtenir l’assembly en cours d’exécution, créez une instance d’un type contenu dans cet assembly et appeler une des méthodes du type avec une liaison tardive. Pour cela, l’exemple de code définit une classe nommée `Example`, avec une méthode nommée `SampleMethod`. Le constructeur de la classe accepte un entier, qui est utilisé pour calculer la valeur de retour de la méthode.  
  
 L’exemple de code illustre également l’utilisation de la <xref:System.Reflection.Assembly.GetName%2A> méthode pour obtenir un <xref:System.Reflection.AssemblyName> objet qui peut être utilisé pour analyser le nom complet de l’assembly. L’exemple affiche le numéro de version de l’assembly, le <xref:System.Reflection.Assembly.CodeBase%2A> propriété et le <xref:System.Reflection.Assembly.EntryPoint%2A> propriété.  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">pour la confiance totale pour les héritiers. Cette classe ne peut pas être héritée par du code partiellement fiable.</permission>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
    <related type="Article" href="~/docs/framework/app-domains/application-domains.md">Domaines d'application</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Reflection.Assembly" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est appelé par les classes dérivées lors de la construction de <xref:System.Reflection.Assembly> objets.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'emplacement de l'assembly tel qu'il a été spécifié à l'origine, par exemple dans un objet <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <value>Emplacement de l'assembly tel qu'il a été spécifié à l'origine.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir le chemin d’accès absolu du fichier chargé qui contient le manifeste, utilisez le <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> propriété à la place.  
  
 Si l’assembly a été chargé en tant que tableau d’octets, à l’aide d’une surcharge de la <xref:System.Reflection.Assembly.Load%2A> méthode qui accepte un tableau d’octets, cette propriété retourne l’emplacement de l’appelant de la méthode, et non l’emplacement de l’assembly chargé.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Reflection.Assembly.CodeBase%2A> propriété.  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder au chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche un type dans cet assembly et en crée une instance à l'aide de l'activateur système.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Propriété <see cref="P:System.Type.FullName" /> du type à rechercher.</param>
        <summary>Recherche le type spécifié dans cet assembly et en crée une instance à l'aide de l'activateur système, avec une recherche respectant la casse.</summary>
        <returns>Une instance du type spécifié créée avec le constructeur par défaut, ou <see langword="null" /> si <paramref name="typeName" /> est introuvable. Le type est résolu à l'aide du binder par défaut, sans spécifier d'attributs de culture ou d'activation, et avec <see cref="T:System.Reflection.BindingFlags" /> défini sur <see langword="Public" /> ou <see langword="Instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le runtime ne peut pas trouver `typeName` dans le <xref:System.Reflection.Assembly> de l’instance, elle retourne `null` au lieu de lever une exception. Cela peut se produire si :  
  
-   Vous n’avez pas spécifié le nom qualifié complet du type.  
  
-   Vous avez spécifié le nom de type qualifié complet, mais son cas ne correspond pas à la casse de du type <xref:System.Type.FullName%2A?displayProperty=nameWithType> propriété. Pour une comparaison respectant la casse de `typeName` avec le nom du type complet, appelez le <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> surcharge et spécifiez `true` pour le `ignoreCase` argument.  
  
-   Le type n’existe pas dans le courant <xref:System.Reflection.Assembly> instance.  
  
   
  
## Examples  
 L’exemple suivant définit un `Person` classe et appelle le <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> méthode pour l’instancier.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> est une chaîne vide ("") ou une chaîne commençant par un caractère Null.  
  
ou 
L’assembly actuel a été chargé dans le contexte ReflectionOnly.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="typeName" /> requiert un assembly dépendant qui est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="typeName" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.  
  
ou 
L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="typeName" /> nécessite un assembly dépendant qui n’a pas été préchargé.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="typeName" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.  
  
ou 
 <paramref name="typeName" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Propriété <see cref="P:System.Type.FullName" /> du type à rechercher.</param>
        <param name="ignoreCase"><see langword="true" /> pour ignorer la casse du nom de type ; sinon, <see langword="false" />.</param>
        <summary>Recherche le type spécifié dans cet assembly et en crée une instance à l'aide de l'activateur système, avec une recherche facultative respectant la casse.</summary>
        <returns>Une instance du type spécifié créée avec le constructeur par défaut, ou <see langword="null" /> si <paramref name="typeName" /> est introuvable. Le type est résolu à l'aide du binder par défaut, sans spécifier d'attributs de culture ou d'activation, et avec <see cref="T:System.Reflection.BindingFlags" /> défini sur <see langword="Public" /> ou <see langword="Instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le runtime ne peut pas trouver `typeName` dans le <xref:System.Reflection.Assembly> de l’instance, elle retourne `null` au lieu de lever une exception. Cela peut se produire si :  
  
-   Vous n’avez pas spécifié le nom qualifié complet du type.  
  
-   Le type n’existe pas dans le courant <xref:System.Reflection.Assembly> instance.  
  
   
  
## Examples  
 L’exemple suivant définit un `Person` classe. Il appelle ensuite la <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> méthode pour instancier, mais étant donné que la casse de la `typeName` argument ne correspond pas à celui du type <xref:System.Type.FullName%2A> propriété, la méthode retourne `null`. Lorsque l’exemple passe la même chaîne pour le <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> surcharge et spécifie que la comparaison doit être pas la casse, le `Person` classe se trouve et un `Person` objet est instancié avec succès.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> est une chaîne vide ("") ou une chaîne commençant par un caractère Null.  
  
ou 
L’assembly actuel a été chargé dans le contexte ReflectionOnly.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="typeName" /> nécessite un assembly dépendant qui est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="typeName" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.  
  
ou 
L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="typeName" /> nécessite un assembly dépendant qui n’a pas été préchargé.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="typeName" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.  
  
ou 
 <paramref name="typeName" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">Propriété <see cref="P:System.Type.FullName" /> du type à rechercher.</param>
        <param name="ignoreCase"><see langword="true" /> pour ignorer la casse du nom de type ; sinon, <see langword="false" />.</param>
        <param name="bindingAttr">Masque de bits qui affecte la manière dont la recherche est effectuée. La valeur est une combinaison de bits indicateurs de <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see langword="MemberInfo" /> par le biais de la réflexion. Si <paramref name="binder" /> est <see langword="null" />, le binder par défaut est utilisé.</param>
        <param name="args">Tableau qui contient les arguments à passer au constructeur. Ce tableau d'arguments doit posséder les mêmes nombres, ordre et type que les paramètres du constructeur à appeler. Si vous souhaitez utiliser le constructeur par défaut, <paramref name="args" /> doit être un tableau vide ou <see langword="null" />.</param>
        <param name="culture">Instance de <see langword="CultureInfo" /> utilisée pour régir la contrainte des types. Si la valeur est <see langword="null" />, le <see langword="CultureInfo" /> du thread actuel est utilisé. (Par exemple, cela est nécessaire pour convertir un <see langword="String" /> représentant 1000 en valeur <see langword="Double" />, car 1000 est représenté de différentes manières selon la culture.)</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. En général, tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Recherche le type spécifié dans cet assembly et en crée une instance à l'aide de l'activateur système, avec une recherche facultative respectant la casse et possédant la culture, les arguments, ainsi que les attributs de liaison et d'activation spécifiés.</summary>
        <returns>Une instance du type spécifié ou <see langword="null" /> si <paramref name="typeName" /> est introuvable. Les arguments fournis sont utilisés pour résoudre le type, et lier le constructeur utilisé pour créer l'instance.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> est une chaîne vide ("") ou une chaîne commençant par un caractère null.  
  
ou 
L’assembly actuel a été chargé dans le contexte ReflectionOnly.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.NotSupportedException">Un tableau d’attributs d’activation non vides est passé à un type qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="typeName" /> requiert un assembly dépendant qui est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="typeName" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.  
  
ou 
L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="typeName" /> nécessite un assembly dépendant qui n’a pas été préchargé.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="typeName" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.  
  
ou 
 <paramref name="typeName" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour créer une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom complet d'un assembly.</param>
        <param name="typeName">Nom complet d'un type.</param>
        <summary>Crée le nom d'un type qualifié par le nom complet de son assembly.</summary>
        <returns>Nom complet du type complet par le nom d'affichage de l'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le format de la chaîne retournée est :  
  
 \<FullTypeName>, \<AssemblyDisplayName>  
  
 Consultez <xref:System.Reflection.AssemblyName> pour obtenir une description du format du nom complet d’un assembly.  
  
 Pour prendre en compte les modifications dans les versions du common language runtime, utilisez cette méthode, plutôt que de construire le nom qualifié vous-même.  Pour plus d’informations sur les noms d’assemblys qualifiés, consultez <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection qui contient les attributs personnalisés de cet assembly.</summary>
        <value>Collection qui contient les attributs personnalisés de cet assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection des types définis dans cet assembly.</summary>
        <value>Collection des types définis dans cet assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Assembly.DefinedTypes%2A> propriété est comparable à la <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> (méthode), à ceci près que le <xref:System.Reflection.Assembly.DefinedTypes%2A> propriété retourne une collection de <xref:System.Reflection.TypeInfo> objets et le <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> méthode retourne un tableau de <xref:System.Type> objets.  
  
 Le tableau retourné inclut des types imbriqués.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le point d'entrée de cet assembly.</summary>
        <value>Objet qui représente le point d'entrée de cet assembly. Si aucun point d'entrée n'est détecté (par exemple, si l'assembly est une DLL), <see langword="null" /> est retourné.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Objet à comparer avec cette instance.</param>
        <summary>Détermine si cet assembly et l'objet spécifié sont égaux.</summary>
        <returns><see langword="true" /> si <paramref name="o" /> est égal à cette instance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Assembly.Equals%2A> méthode effectue un test d’égalité de référence déterminer si l’instance actuelle et `o` sont égaux.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'URI, y compris les caractères d'espacement, qui représente le code base.</summary>
        <value>Un URI avec des caractères d'espacement.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder au chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la preuve pour cet assembly.</summary>
        <value>Preuve pour cet assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La preuve est le jeu d'informations qui alimente les décisions de stratégie de sécurité, telles que les autorisations qui peuvent être accordées au code.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection des types publics définis dans cet assembly qui sont visibles à l'extérieur de l'assembly.</summary>
        <value>Collection des types publics définis dans cet assembly qui sont visibles à l’extérieur de l’assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom complet de l'assembly.</summary>
        <value>Nom complet de l'assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consultez <xref:System.Reflection.AssemblyName> pour obtenir une description du format du nom complet d’un assembly.  
  
> [!NOTE]
>  Écrire votre propre code pour analyser les noms d’affichage n’est pas recommandée. Au lieu de cela, passez le nom de l’affichage à la <xref:System.Reflection.AssemblyName.%23ctor%2A> constructeur, qui analyse et remplit les champs appropriés du nouveau <xref:System.Reflection.AssemblyName>.  
  
 Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly. Toutefois, il n’est pas inclus dans la chaîne retournée par la <xref:System.Reflection.Assembly.FullName%2A> propriété, pour des raisons de compatibilité. Consultez <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant récupère le nom complet de l’assembly en cours d’exécution et le nom complet de l’assembly qui contient le <xref:System.Int32> type (`int` en c#, `Integer` en Visual Basic).  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Spécification des noms de types qualifiés complets</related>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Objet représentant un type de l’assembly retourné.</param>
        <summary>Obtient l’assembly actuellement chargé dans lequel le type spécifié est défini.</summary>
        <returns>Assembly dans lequel le type spécifié est défini.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette méthode est équivalente à la récupération de la valeur de la <xref:System.Type.Assembly?displayProperty=nameWithType> propriété. Toutefois, le <xref:System.Type.Assembly?displayProperty=nameWithType> propriété offre généralement de meilleures performances.  
  
 Pour appeler cette méthode, vous devez avoir un <xref:System.Type> objet, ce qui signifie que l’assembly dans lequel la classe est définie doit déjà être chargé.  
  
   
  
## Examples  
 L’exemple suivant récupère l’assembly qui contient le <xref:System.Int32> tapez et affiche son emplacement de nom et le fichier.  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le <see cref="T:System.Reflection.Assembly" /> de la méthode ayant appelé la méthode en cours d'exécution.</summary>
        <returns>Objet <see langword="Assembly" /> de la méthode ayant appelé la méthode en cours d'exécution.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la méthode qui appelle le <xref:System.Reflection.Assembly.GetCallingAssembly%2A> méthode est développée inline par le compilateur juste-à-temps (JIT), ou si son appelant est développé inline, l’assembly qui est retourné par <xref:System.Reflection.Assembly.GetCallingAssembly%2A> peuvent différer de manière inattendue. Par exemple, considérez les méthodes et les assemblys suivants :  
  
-   Méthode `M1` dans l’assembly `A1` appels <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
-   Méthode `M2` dans l’assembly `A2` appels `M1`.  
  
-   Méthode `M3` dans l’assembly `A3` appels `M2`.  
  
 Lorsque `M1` n’est pas mise inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retourne `A2`. Lorsque `M1` est inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retourne `A3`. De même, lorsque `M2` n’est pas mise inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retourne `A2`. Lorsque `M2` est inline, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retourne `A3`.  
  
 Cet effet se produit également lorsque `M1` s’exécute comme un appel tail de `M2`, ou lorsque `M2` s’exécute comme un appel tail de `M3`. Vous pouvez empêcher le compilateur JIT d’incorporation (inlining) la méthode qui appelle <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, en appliquant la <xref:System.Runtime.CompilerServices.MethodImplAttribute> attribut avec le <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> indicateur, mais il n’existe aucun mécanisme similaire pour empêcher les appels tail.  
  
   
  
## Examples  
 L’exemple suivant obtient l’assembly appelant de la méthode actuelle.  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient les attributs personnalisés pour cet assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Cet argument est ignoré pour les objets de type <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Obtient tous les attributs personnalisés pour cet assembly.</summary>
        <returns>Tableau qui contient les attributs personnalisés pour cet assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode implémente le correspondantes <xref:System.Reflection.ICustomAttributeProvider> méthode d’interface. Par conséquent, le `inherit` paramètre doit être spécifié même s’il est ignoré.  
  
 Un attribut pseudo-aléatoire indique les bits des métadonnées de base qui doit être défini lors de l’attribut est présent. Contrairement à un attribut personnalisé qui étend les métadonnées d’un type et est enregistré avec le type, un attribut pseudo-aléatoire modifie les métadonnées pour le type et qu’elle est ensuite ignoré. Certaines des bits qui en résulte n’est pas accessible à l’aide des API de réflexion existantes.  
  
 Le tableau suivant résume les divers pseudo-attributs et les accesseurs pour les bits qui sont disponibles dans la réflexion.  
  
|Pseudo-attributs|Bits de métadonnées|Accesseur de réflexion|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> Nom de la DLL|Pas d’accesseur pour PInvokeMap pour les attributs de méthode méthode ordinaire/globaux.<br /><br /> Pas d’accesseur pour le nom de la DLL.|  
|GuidAttribute|Stockées sous la forme d’un attribut personnalisé réel.|Accessible en tant que d’un attribut personnalisé réel.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Divers éléments.|Pas d’accesseur.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Compression de la classe.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Pas d’accesseur.|  
|FieldOffsetAttribute|Offset de champ.|Pas d’accesseur.|  
|AssemblyLoadAttribute|CorAssemblyFlags|Aucun accesseur ou l’énumérateur.|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Type pour lequel les attributs personnalisés doivent être retournés.</param>
        <param name="inherit">Cet argument est ignoré pour les objets de type <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Obtient les attributs personnalisés pour cet assembly, tels qu'ils sont spécifiés par le type.</summary>
        <returns>Tableau qui contient les attributs personnalisés pour cet assembly, tels qu'ils sont spécifiés par <paramref name="attributeType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode implémente le correspondantes <xref:System.Reflection.ICustomAttributeProvider> méthode d’interface. Par conséquent, le `inherit` paramètre doit être spécifié même s’il est ignoré.  
  
 Un attribut pseudo-aléatoire indique les bits des métadonnées de base qui doit être défini lors de l’attribut est présent. Contrairement à un attribut personnalisé qui étend les métadonnées d’un type et est enregistré avec le type, un attribut pseudo-aléatoire modifie les métadonnées pour le type et qu’elle est ensuite ignoré. Certaines des bits qui en résulte n’est pas accessible à l’aide des API de réflexion existantes.  
  
 Le tableau suivant résume les divers pseudo-attributs et les accesseurs pour les bits qui sont disponibles dans la réflexion.  
  
|Pseudo-attributs|Bits de métadonnées|Accesseur de réflexion|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> Nom de la DLL|Pas d’accesseur pour PInvokeMap pour les attributs de méthode méthode ordinaire/globaux.<br /><br /> Pas d’accesseur pour le nom de la DLL.|  
|GuidAttribute|Stockées sous la forme d’un attribut personnalisé réel.|Accessible en tant que d’un attribut personnalisé réel.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Divers éléments.|Pas d’accesseur.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags().OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags().OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Compression de la classe.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Pas d’accesseur.|  
|FieldOffsetAttribute|Offset de champ.|Pas d’accesseur.|  
|AssemblyLoadAttribute|CorAssemblyFlags|Aucun accesseur ou l’énumérateur.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="attributeType" /> n’est pas un type de runtime.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne des informations sur les attributs appliqués au <see cref="T:System.Reflection.Assembly" /> actuel, en tant qu'objets <see cref="T:System.Reflection.CustomAttributeData" />.</summary>
        <returns>Liste générique d'objets <see cref="T:System.Reflection.CustomAttributeData" /> représentant des données relatives aux attributs qui ont été appliqués à l'assembly actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour examiner les attributs personnalisés du code dans le contexte de réflexion uniquement, dans les cas où les attributs personnalisés eux-mêmes sont définis dans le code qui est chargé dans le contexte de réflexion uniquement. Méthodes telles que <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> et <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> ne peut pas être utilisé dans ce cas, car ils créent des instances des attributs. Impossible d’exécuter le code dans le contexte de réflexion uniquement. Pour plus d’informations et un par exemple de code, consultez la <xref:System.Reflection.CustomAttributeData> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient l'exécutable du processus dans le domaine d'application par défaut. Dans les autres domaines d'application, il s'agit du premier exécutable exécuté par <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</summary>
        <returns>Assembly qui est l'exécutable du processus dans le domaine d'application par défaut, ou le premier exécutable exécuté par <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />. Peut retourner <see langword="null" /> quand il est appelé à partir de code non managé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.Assembly.GetEntryAssembly%2A> méthode peut retourner `null` lorsqu’un assembly managé a été chargé à partir d’une application non managée. Par exemple, si une application non managée crée une instance d’un composant COM écrit en c#, un appel à la <xref:System.Reflection.Assembly.GetEntryAssembly%2A> méthode à partir du composant c# retourne la valeur null, car le point d’entrée pour le processus était du code non managé plutôt qu’un assembly managé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient l'assembly qui contient le code en cours d'exécution.</summary>
        <returns>Assembly qui contient le code en cours d'exécution.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour des raisons de performances, vous devez appeler cette méthode uniquement lorsque vous ne connaissez pas au moment du design quel assembly est en cours d’exécution. La méthode recommandée pour récupérer un <xref:System.Reflection.Assembly> objet qui représente l’assembly actuel consiste à utiliser le <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propriété d’un type trouvé dans l’assembly, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 Pour obtenir l’assembly qui contient la méthode qui a appelé le code en cours d’exécution, utilisez <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propriété à obtenir l’assembly en cours d’exécution basée sur un type de contenu dans cet assembly. Il appelle également la <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> méthode pour montrer qu’il retourne un <xref:System.Reflection.Assembly> objet qui représente le même assembly.  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient les types publics définis dans cet assembly qui sont visibles à l'extérieur de l'assembly.</summary>
        <returns>Tableau qui représente les types définis dans cet assembly qui sont visibles à l'extérieur de l'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les seuls types visibles en dehors d’un assembly sont les types publics et les types publics imbriqués dans d’autres types publics.  
  
   
  
## Examples  
 L’exemple de code suivant définit plusieurs classes avec différents niveaux d’accès et appelle <xref:System.Reflection.Assembly.GetExportedTypes%2A> pour afficher celles qui sont visibles en dehors de l’assembly.  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L’assembly est un assembly dynamique.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de charger un assembly dépendant.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom du fichier spécifié. N'incluez pas le chemin d'accès au fichier.</param>
        <summary>Obtient un <see cref="T:System.IO.FileStream" /> pour le fichier spécifié dans la table de fichiers du manifeste de cet assembly.</summary>
        <returns>Flux qui contient le fichier spécifié, ou <see langword="null" /> si le fichier est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fonctionne sur les deux fichiers de ressources publics et privés.  
  
 Le `name` ne doit pas inclure le chemin d’accès au fichier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="name" /> est une chaîne vide ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> n’est pas un assembly valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’accès pour le chemin d’accès et pour lire le fichier spécifié. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient les fichiers de la table de fichiers d'un manifeste d'assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient les fichiers de la table de fichiers d'un manifeste d'assembly.</summary>
        <returns>Tableau des flux de données qui contiennent les fichiers.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fonctionne sur les fichiers de ressources publiques et privées.  
  
 Cette surcharge revient à appeler le <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> surcharge et en spécifiant `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Un fichier est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException">Un fichier n’était pas un assembly valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><see langword="true" /> pour inclure des modules de ressources ; sinon, <see langword="false" />.</param>
        <summary>Obtient les fichiers de la table de fichiers d'un manifeste d'assembly, en spécifiant si des modules de ressources doivent être inclus.</summary>
        <returns>Tableau des flux de données qui contiennent les fichiers.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fonctionne sur les fichiers de ressources publiques et privées.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Un fichier est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException">Un fichier n’était pas un assembly valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage de cette instance.</summary>
        <returns>Code de hachage d'un entier signé 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient tous les modules chargés qui appartiennent à cet assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient tous les modules chargés qui appartiennent à cet assembly.</summary>
        <returns>Tableau de modules.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><see langword="true" /> pour inclure des modules de ressources ; sinon, <see langword="false" />.</param>
        <summary>Obtient tous les modules chargés qui appartiennent à cet assembly, en spécifiant si des modules de ressources doivent être inclus.</summary>
        <returns>Tableau de modules.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">Nom de la ressource respectant la casse.</param>
        <summary>Retourne des informations sur la manière dont la ressource donnée a été persistante.</summary>
        <returns>Objet qui est rempli par des informations sur la topologie de la ressource, ou <see langword="null" /> si la ressource est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informations sur la ressource sont renvoyées uniquement si la ressource est visible à l’appelant ou l’appelant a <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="resourceName" /> est une chaîne vide ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne les noms de toutes les ressources de cet assembly.</summary>
        <returns>Tableau qui contient les noms de toutes les ressources.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser chaque nom de ressource dans le tableau retourné par cette méthode comme suit :  
  
-   Vous pouvez passer le nom de ressource pour le <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> méthode pour obtenir des informations supplémentaires sur la ressource.  
  
-   Si le nom identifie un fichier .resources binaire, vous pouvez supprimer son extension de fichier .resources et transmettez-le à la <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> constructeur pour instancier le Gestionnaire de ressources.  
  
-   Vous pouvez passer le nom de ressource pour le <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> méthode pour récupérer un <xref:System.IO.Stream> objet que vous pouvez ensuite passer à la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructeur.  
  
-   Vous pouvez passer le nom de ressource pour le <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> méthode pour récupérer un <xref:System.IO.Stream> objet que vous pouvez ensuite passer à la <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructeur.  
  
 Informations sur la ressource sont renvoyées uniquement si la ressource est visible à l’appelant ou l’appelant a <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Charge la ressource de manifeste spécifiée à partir de cet assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la ressource de manifeste demandée respectant la casse.</param>
        <summary>Charge la ressource de manifeste spécifiée à partir de cet assembly.</summary>
        <returns>La ressource de manifeste ; ou <see langword="null" /> si aucune ressource n'a été spécifiée pendant la compilation, ou si la ressource n'est pas visible par l'appelant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une ressource de manifeste est une ressource (par exemple, un fichier image) qui est incorporée dans l’assembly au moment de la compilation. Pour plus d’informations sur les ressources de manifeste, consultez [les principes des ressources Microsoft .NET Framework](https://go.microsoft.com/fwlink/?LinkId=204554) dans MSDN Library.  
  
 Informations sur la ressource sont renvoyées uniquement si la ressource est visible à l’appelant ou l’appelant a <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Cette méthode retourne `null` si une ressource privée dans un autre assembly est accessible et que l’appelant n’a pas <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> indicateur.  
  
 Si le manifeste d’assembly répertorie un fichier de ressources, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> retourne un <xref:System.IO.Stream> même si le fichier de ressources est introuvable sur le disque au moment de l’objet. Si le fichier de ressources est introuvable, en passant le résultat <xref:System.IO.Stream> de l’objet à la <xref:System.Resources.ResourceReader> constructeur entraîne une <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="name" /> est une chaîne vide ("").</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.IO.IOException" />, à la place.  
  
</para>
          </block>  
  
 Impossible de charger l’un des fichiers trouvés.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> n’est pas un assembly valide.</exception>
        <exception cref="T:System.NotImplementedException">La longueur de la ressource est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">Manifeste d'assembly</related>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Type dont l'espace de noms définit la portée du nom de la ressource de manifeste.</param>
        <param name="name">Nom de la ressource de manifeste demandée respectant la casse.</param>
        <summary>Charge la ressource de manifeste spécifiée, dont la portée est définie par l'espace de noms du type déterminé, à partir de cet assembly.</summary>
        <returns>La ressource de manifeste ; ou <see langword="null" /> si aucune ressource n'a été spécifiée pendant la compilation, ou si la ressource n'est pas visible par l'appelant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par exemple, si le nom complet spécifié pour `type` est « MyNameSpace.MyClasses » et `name` est « Net », cette méthode recherche une ressource appelée « MyNameSpace.Net » de surcharge.  
  
 Une ressource de manifeste est une ressource (par exemple, un fichier image) qui est incorporée dans l’assembly au moment de la compilation. Pour plus d’informations sur les ressources de manifeste, consultez [les principes des ressources Microsoft .NET Framework](https://go.microsoft.com/fwlink/?LinkId=204554) dans MSDN Library.  
  
 Informations sur la ressource sont renvoyées uniquement si la ressource est visible à l’appelant ou l’appelant a <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Cette méthode retourne `null` si une ressource privée dans un autre assembly est accessible et que l’appelant n’a pas <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> indicateur.  
  
 Si le manifeste d’assembly répertorie un fichier de ressources, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> retourne un <xref:System.IO.Stream> même si le fichier de ressources est introuvable sur le disque au moment de l’objet. Si le fichier de ressources est introuvable, en passant le résultat <xref:System.IO.Stream> de l’objet à la <xref:System.Resources.ResourceReader> constructeur entraîne une <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="name" /> est une chaîne vide ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> n’est pas un assembly valide.</exception>
        <exception cref="T:System.NotImplementedException">La longueur de la ressource est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">Manifeste d'assembly</related>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom du module demandé.</param>
        <summary>Obtient le module spécifié dans cet assembly.</summary>
        <returns>Module demandé, ou <see langword="null" /> si le module est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fonctionne sur les noms de fichiers.  
  
 Classes dans le `Reflection.Emit` espace de noms émettent le nom de la portée d’un module dynamique. Le nom de l’étendue peut être déterminé par le <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> propriété. Passez le type de module à `Assembly.GetModule`. Par exemple, si vous souhaitez que le module qui contient le manifeste d’assembly, passez le nom de la portée du module à `GetModule`. Sinon, passez le nom de fichier du module. Les assemblys chargés par un de le `Load` les méthodes qui ont un paramètre byte [] ont un seul module, et c’est le module du manifeste. Toujours ces modules en utilisant le nom de l’étendue de recherche.  
  
 Un type peut être récupéré à partir d’un module spécifique <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>. Appel de `Module.GetType` sur le module qui contient le manifeste pas lance une recherche de la totalité de l’assembly. Pour récupérer un type d’un assembly, quel que soit le module dans lequel il se trouve dans, vous devez appeler <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="name" /> est une chaîne vide ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> n’est pas un assembly valide.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient tous les modules qui appartiennent à cet assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient tous les modules qui appartiennent à cet assembly.</summary>
        <returns>Tableau de modules.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fonctionne sur les fichiers de ressources publiques et privées.  
  
> [!NOTE]
>  Modules doivent être émises avec des extensions de nom de fichier.  
  
   
  
## Examples  
 L’exemple suivant affiche le nom du module dans le tableau retourné qui contient le manifeste d’assembly.  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Le module à charger ne spécifie pas une extension de nom de fichier.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><see langword="true" /> pour inclure des modules de ressources ; sinon, <see langword="false" />.</param>
        <summary>Obtient tous les modules qui appartiennent à cet assembly, en spécifiant si des modules de ressources doivent être inclus.</summary>
        <returns>Tableau de modules.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fonctionne sur les fichiers de ressources publiques et privées.  
  
> [!NOTE]
>  Modules doivent être émises avec des extensions de nom de fichier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient <see cref="T:System.Reflection.AssemblyName" /> pour cet assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient <see cref="T:System.Reflection.AssemblyName" /> pour cet assembly.</summary>
        <returns>Objet qui contient le nom complet analysé correspondant à cet assembly.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder au chemin de l’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName"><see langword="true" /> pour affecter à <see cref="P:System.Reflection.Assembly.CodeBase" /> l'emplacement de l'assembly une fois qu'il est devenu un cliché instantané ; <see langword="false" /> pour affecter un emplacement d'origine à <see cref="P:System.Reflection.Assembly.CodeBase" />.</param>
        <summary>Obtient un <see cref="T:System.Reflection.AssemblyName" /> pour cet assembly, en définissant le code base de la manière spécifiée par <paramref name="copiedName" />.</summary>
        <returns>Objet qui contient le nom complet analysé correspondant à cet assembly.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder au chemin de l’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Objet à remplir à l'aide des informations de sérialisation.</param>
        <param name="context">Contexte de destination de la sérialisation.</param>
        <summary>Obtient les informations de sérialisation avec toutes les données nécessaires pour réinstancier cet assembly.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient les objets <see cref="T:System.Reflection.AssemblyName" /> pour tous les assemblys référencés par cet assembly.</summary>
        <returns>Tableau qui contient les noms complets analysés de tous les assemblys référencés par cet assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> propriété d’un <xref:System.Reflection.AssemblyName> objet qui est retourné par cette méthode est <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> s’il n’existe aucun algorithme de hachage pour l’assembly référencé, ou si l’algorithme de hachage de l’assembly référencé n’est pas identifié par le <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> énumération. Dans les versions précédentes du .NET Framework, le <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> propriété retournée <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> dans cette situation.  
  
   
  
## Examples  
 L’exemple de code suivant montre l’appel la <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> (méthode). Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Reflection.Assembly> classe.  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient l'assembly satellite.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Culture spécifiée.</param>
        <summary>Obtient l'assembly satellite pour la culture spécifiée.</summary>
        <returns>Assembly satellite spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les assemblys satellites contiennent des ressources localisées, comme les assemblys d’application principaux qui contiennent du code exécutable non localisable et les ressources pour une culture unique utilisée comme culture neutre ou par défaut.  
  
 Appelez cette méthode pour utiliser votre version actuelle de l’assembly.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L’assembly est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException">L’assembly satellite avec un nom de fichier correspondant a été trouvé, mais l’élément <see langword="CultureInfo" /> ne correspondait pas à l’élément spécifié.</exception>
        <exception cref="T:System.BadImageFormatException">L’assembly satellite n’est pas un assembly valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">Culture spécifiée.</param>
        <param name="version">Version de l'assembly satellite.</param>
        <summary>Obtient la version spécifiée de l'assembly satellite pour la culture donnée.</summary>
        <returns>Assembly satellite spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les assemblys satellites contiennent des ressources localisées, comme les assemblys d’application principaux qui contiennent du code exécutable non localisable et les ressources pour une culture unique utilisée comme culture neutre ou par défaut.  
  
 Appelez le <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> surcharge à utiliser votre version actuelle de l’assembly.  
  
 Si `version` est `null`, la version actuelle de l’assembly est utilisée si la ressource et les principaux assemblys sont signés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">L’assembly satellite avec un nom de fichier correspondant a été trouvé, mais l’élément <see langword="CultureInfo" /> ou la version ne correspondait pas à l’élément spécifié.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L’assembly est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException">L’assembly satellite n’est pas un assembly valide.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Type" /> qui représente le type spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom complet du type.</param>
        <summary>Obtient l'objet <see cref="T:System.Type" /> avec le nom spécifié dans l'instance de l'assembly.</summary>
        <returns>Objet qui représente la classe spécifiée ou <see langword="null" /> si la classe est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche uniquement l’instance actuelle de l’assembly. Le `name` paramètre inclut l’espace de noms mais pas l’assembly. Pour rechercher d’autres assemblys pour un type, utilisez le <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> surcharge de méthode, qui peut éventuellement inclure un nom d’assembly complet en tant que partie du nom de type.  
  
> [!NOTE]
>  Si le type a été transféré à un autre assembly, il est toujours retourné par cette méthode. Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
   
  
## Examples  
 L’exemple suivant définit abstraite `MeansOfTransportation` classe dans le `Transportation` espace de noms. Il appelle le <xref:System.Reflection.Assembly.GetType%28System.String%29> méthode pour récupérer son <xref:System.Type> objet, appelle le <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> méthode pour obtenir un tableau de <xref:System.Reflection.PropertyInfo> objets qui représentent les propriétés du type et puis affiche des informations sur le type abstraite des propriétés. Notez que l’appel à la <xref:System.Reflection.Assembly.GetType%28System.String%29> méthode utilise le nom du type qualifié complet (autrement dit, son espace de noms, ainsi que son nom de type).  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> n'est pas valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> requiert un assembly dépendant qui est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.IO.IOException" />, à la place.  
  
</para>
          </block>
          <paramref name="name" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.  
  
ou 
L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="name" /> nécessite un assembly dépendant qui n’a pas été préchargé.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.  
  
ou 
 <paramref name="name" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nom complet du type.</param>
        <param name="throwOnError"><see langword="true" /> pour lever une exception si le type est introuvable ; <see langword="false" /> pour retourner la valeur <see langword="null" />.</param>
        <summary>Obtient l'objet <see cref="T:System.Type" /> portant le nom spécifié dans l'instance de l'assembly et lève éventuellement une exception si le type est introuvable.</summary>
        <returns>Objet qui représente la classe spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche uniquement l’instance actuelle de l’assembly. Le `name` paramètre inclut l’espace de noms mais pas l’assembly. Pour rechercher d’autres assemblys pour un type, utilisez le <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> surcharge de méthode, qui peut éventuellement inclure un nom d’assembly complet en tant que partie du nom de type.  
  
> [!NOTE]
>  Si le type a été transféré à un autre assembly, il est toujours retourné par cette méthode. Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Le `throwOnError` paramètre affecte uniquement ce qui se passe lorsque le type est introuvable. Il n’affecte pas toutes les exceptions levées. En particulier, si le type est trouvé mais ne peut pas être chargé, <xref:System.TypeLoadException> peut être levée même si `throwOnError` est `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> n'est pas valide.  
  
ou 
La longueur de <paramref name="name" /> dépasse 1 024 caractères.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> a la valeur <see langword="true" /> et le type est introuvable.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> requiert un assembly dépendant qui est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="name" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.  
  
ou 
L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="name" /> nécessite un assembly dépendant qui n’a pas été préchargé.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.  
  
ou 
 <paramref name="name" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nom complet du type.</param>
        <param name="throwOnError"><see langword="true" /> pour lever une exception si le type est introuvable ; <see langword="false" /> pour retourner la valeur <see langword="null" />.</param>
        <param name="ignoreCase"><see langword="true" /> pour ignorer la casse du nom de type ; sinon, <see langword="false" />.</param>
        <summary>Obtient l'objet <see cref="T:System.Type" /> portant le nom spécifié dans l'instance de l'assembly et propose d'ignorer la casse et de lever une exception si le type est introuvable.</summary>
        <returns>Objet qui représente la classe spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche uniquement l’instance actuelle de l’assembly. Le `name` paramètre inclut l’espace de noms mais pas l’assembly. Pour rechercher d’autres assemblys pour un type, utilisez le <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> surcharge de méthode, qui peut éventuellement inclure un nom d’assembly complet en tant que partie du nom de type.  
  
> [!NOTE]
>  Si le type a été transféré à un autre assembly, il est toujours retourné par cette méthode. Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Le `throwOnError` paramètre affecte uniquement ce qui se passe lorsque le type est introuvable. Il n’affecte pas toutes les exceptions levées. En particulier, si le type est trouvé mais ne peut pas être chargé, <xref:System.TypeLoadException> peut être levée même si `throwOnError` est `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> n'est pas valide.  
  
ou 
La longueur de <paramref name="name" /> dépasse 1 024 caractères.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> a la valeur <see langword="true" /> et le type est introuvable.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> requiert un assembly dépendant qui est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="name" /> nécessite un assembly dépendant qui a été trouvé, mais qui n’a pas pu être chargé.  
  
ou 
L’assembly actuel a été chargé dans le contexte ReflectionOnly, et <paramref name="name" /> nécessite un assembly dépendant qui n’a pas été préchargé.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> nécessite un assembly dépendant, mais le fichier n’est pas un assembly valide.  
  
ou 
 <paramref name="name" /> nécessite un assembly dépendant qui a été compilé pour une version du runtime ultérieure à la version actuellement chargée.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient les types définis dans cet assembly.</summary>
        <returns>Tableau qui contient tous les types définis dans cet assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau retourné inclut des types imbriqués.  
  
 Si le <xref:System.Reflection.Assembly.GetTypes%2A> méthode est appelée sur un assembly et un type de cet assembly est dépendant d’un type dans un assembly qui n’a pas a été chargé (par exemple, si elle dérive d’un type dans le deuxième assembly), un <xref:System.Reflection.ReflectionTypeLoadException> est levée. Par exemple, cela peut se produire si le premier assembly a été chargé avec le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> ou <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> méthodes et le deuxième assembly n’a pas été chargé. Il peut également se produire avec les assemblys chargés à l’aide de la <xref:System.Reflection.Assembly.Load%2A> et <xref:System.Reflection.Assembly.LoadFile%2A> méthodes si le deuxième assembly ne peut pas être localisé quand le <xref:System.Reflection.Assembly.GetTypes%2A> méthode est appelée.  
  
> [!NOTE]
>  Si un type a été transféré à un autre assembly, il n’est pas inclus dans le tableau retourné. Pour plus d’informations sur le transfert de type, consultez [transfert de Type dans le Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Pour récupérer une collection de <xref:System.Reflection.TypeInfo> objets plutôt qu’un tableau de <xref:System.Type> objets, utiliser le <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> propriété.  
  
   
  
## Examples  
 L’exemple suivant affiche les paramètres d’une méthode sur un type dans l’assembly spécifié.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">L’assembly contient un ou plusieurs types qui ne peuvent pas être chargés. Le tableau retourné par la propriété <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> de cette exception contient un objet <see cref="T:System.Type" /> pour chaque type qui a été chargé et <see langword="null" /> pour chaque type qui n’a pas pu être chargé, tandis que la propriété <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> contient une exception pour chaque type qui n’a pas pu être chargé.</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'assembly a été chargé à partir du Global Assembly Cache.</summary>
        <value><see langword="true" /> si l'assembly a été chargé à partir du Global Assembly Cache ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le contexte hôte avec lequel l'assembly a été chargé.</summary>
        <value>Valeur <see cref="T:System.Int64" /> qui indique le contexte hôte avec lequel l'assembly a été chargé, le cas échéant.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une représentation sous forme de chaîne de la version du Common Language Runtime (CLR) enregistrée dans le fichier contenant le manifeste.</summary>
        <value>Nom du dossier de la version CLR. Il ne s’agit pas d’un chemin d’accès complet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par exemple, la valeur de la version 1.1 du .NET Framework serait v1.1.4322. Les fichiers binaires pour cette version seraient situés dans le chemin d’accès % windir%\Microsoft.NET\Framework\v1.1.4322.  
  
 Par défaut, <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> est définie sur la version du CLR utilisée pour générer l’assembly. Toutefois, elle peut avoir été définie à une autre valeur au moment de la compilation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public virtual bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Reflection.Assembly.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l’assembly est contenu dans un <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> pouvant être collecté.</summary>
        <value><see langword="true" /> Si cet assembly est maintenu dans un pouvant être collectés <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Pour plus d’informations, consultez <see href="/en-us/dotnet/standard/assembly/unloadability-howto">comment utiliser et déboguer unloadability assembly dans .NET Core</see>.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Type de l'attribut à vérifier pour cet assembly.</param>
        <param name="inherit">Cet argument est ignoré pour les objets de ce type.</param>
        <summary>Indique si un attribut spécifié a été appliqué à l'assembly ou non.</summary>
        <returns><see langword="true" /> si l'attribut a été appliqué à l'assembly ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant applique le <xref:System.Reflection.AssemblyTitleAttribute> attribut à un assembly, puis utilise <xref:System.Reflection.Assembly.IsDefined%2A> pour indiquer s’il a été appliqué. Il teste également un attribut qui n’a été appliqué.  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="attributeType" /> utilise un type non valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l'assembly actuel a été généré dynamiquement dans le processus actuel à l'aide de l'émission de réflexion.</summary>
        <value><see langword="true" /> si l'assembly actuel a été généré dynamiquement dans le processus actuel ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assemblys dynamiques sont représentées par la classe dérivée <xref:System.Reflection.Emit.AssemblyBuilder>.  
  
 Quand un assembly dynamique est enregistré sur disque, l’assembly enregistré n’est pas dynamique. Si l’assembly enregistré est chargé dans un autre domaine d’application ou processus, la <xref:System.Reflection.Assembly.IsDynamic%2A> retourne de la propriété `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l'assembly actuel est chargé avec une confiance totale.</summary>
        <value><see langword="true" /> si l'assembly actuel est chargé avec une confiance totale ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Charge un assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tableau d'octets qui est une image au format COFF contenant un assembly émis.</param>
        <summary>Charge l'assembly avec une image au format COFF (Common Object File Format) contenant un assembly émis. L'assembly est chargé dans le domaine d'application de l'appelant.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le niveau de confiance d’un assembly est chargé à l’aide de cette méthode est le même que le niveau de confiance de l’assembly appelant. Pour charger un assembly à partir d’un tableau d’octets dont le niveau de confiance du domaine d’application, utilisez le <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> surcharge de méthode. Pour plus d’informations sur l’utilisation de la preuve avec les surcharges de la <xref:System.Reflection.Assembly.Load%2A> méthode qui acceptent les tableaux d’octets, consultez la <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> surcharge de méthode.  
  
 La réflexion sur des fichiers exécutables C++ peut lever une <xref:System.BadImageFormatException>. Cela est probablement dû au fait généralement de la suppression des adresses de réadressage ou `.reloc` section à partir de votre fichier exécutable. Pour conserver le `.reloc` d’adresses de votre fichier exécutable C++, spécifiez `/fixed:no` lors de la liaison.  
  
 Notez que cette surcharge de méthode crée toujours un nouveau <xref:System.Reflection.Assembly> objet avec son propre mappage.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> est <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> n’est pas un assembly valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="rawAssembly" /> a été compilé avec une version ultérieure.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Objet qui décrit l'assembly à charger.</param>
        <summary>Charge un assembly en fonction de son <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> est levée si `assemblyRef` Spécifie le nom complet de l’assembly et le premier assembly correspondant au nom simple a une autre version, culture ou jeton de clé publique. Le chargeur ne continue pas à détecter d’autres assemblys qui correspondent au nom simple. Démarrer avec .NET Framework 4, car l’exécution de code dans les assemblys à distance est désactivée par défaut, un <xref:System.IO.FileLoadException> est également levée si `assemblyRef` spécifie un assembly distant. Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.     
  
> [!NOTE]
>  N’utilisez pas un <xref:System.Reflection.AssemblyName> avec uniquement le <xref:System.Reflection.AssemblyName.CodeBase%2A> jeu de propriétés. Le <xref:System.Reflection.AssemblyName.CodeBase%2A> propriété ne fournit pas tous les éléments de l’identité d’assembly (par exemple, le nom ou la version), ainsi le chargement ne se produit pas d’en fonction des règles de charge par identité, comme vous pouvez l’imaginer à partir de la <xref:System.Reflection.Assembly.Load%2A> (méthode). Au lieu de cela, l’assembly est chargé à l’aide de règles load-from. Pour plus d’informations sur les inconvénients de l’utilisation du contexte de chargement, consultez la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> surcharge de méthode ou [meilleures pratiques de chargement d’Assembly](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 L'octroi ou non de certaines autorisations à un assembly repose sur la preuve. Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode sans aucune <xref:System.Security.Policy.Evidence> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées. Preuves fournies en tant qu’argument à la <xref:System.Reflection.Assembly.Load%2A> méthode annulent et remplacent les preuves fournies par le chargeur.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image common object file format (COFF), la preuve est héritée de l’assembly appelant. Cela s’applique à la version 1.1 du .NET Framework Service Pack 1 (SP1) et les versions ultérieures.  
  
    > [!NOTE]
    >  Dans le .NET Framework version 1.0 et dans la version 1.1 sans SP1, lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image COFF, la preuve est combinée. `Zone`, `Url` et `Site` sont héritées de l’assembly appelant, et `Hash` et `StrongName` proviennent de l’assembly COFF.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un `Byte[]` paramètre et <xref:System.Security.Policy.Evidence> pour charger une image COFF, seule la preuve fournie est utilisée. Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.  
  
 La réflexion sur des fichiers exécutables C++ peut lever une <xref:System.BadImageFormatException>. Cela est probablement dû au fait généralement de la suppression des adresses de réadressage ou `.reloc` section à partir de votre fichier exécutable. Pour conserver le `.reloc` d’adresses de votre fichier exécutable C++, spécifiez `/fixed:no` lors de la liaison.  
  
> [!NOTE]
>  Si les deux le <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> propriété et la <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> propriété sont définies, la première tentative de charger l’assembly utilise le nom d’affichage (notamment la version, culture et ainsi de suite, tel que retourné par la <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriété). Si le fichier est introuvable, <xref:System.Reflection.AssemblyName.CodeBase%2A> est utilisé pour rechercher l’assembly. Si l’assembly se trouve à l’aide de <xref:System.Reflection.AssemblyName.CodeBase%2A>, le nom d’affichage est comparé à l’assembly. Si la correspondance échoue, un <xref:System.IO.FileLoadException> est levée.  
  
   
  
## Examples  
 L’exemple suivant instancie un <xref:System.Reflection.AssemblyName> de l’objet et l’utilise pour charger le `sysglobal.dll` assembly. L’exemple affiche ensuite le nom complet de types publics de l’assembly.  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyRef" /> est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.IO.IOException" />, à la place.  
  
</para>
          </block>  
  
 Impossible de charger l’un des fichiers trouvés.

ou

<paramref name="assemblyRef" /> spécifie un assembly distant, mais la possibilité d’exécuter du code dans des assemblys distants est désactivée. Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyRef" /> n’est pas un assembly valide. ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyRef" /> a été compilé avec une version ultérieure.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">Méthode de localisation des assemblys par le runtime</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Forme longue du nom d'assembly.</param>
        <summary>Charge un assembly en fonction de la forme longue de son nom.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La forme longue du nom d’un assembly se compose de son nom simple (par exemple, « système » de l’assembly System.dll), ainsi que sa version, culture, jeton de clé publique et, éventuellement, son architecture de processeur. Il correspond à l’assembly <xref:System.Reflection.Assembly.FullName%2A> propriété. L’exemple suivant illustre l’utilisation d’un nom long à charger l’assembly System.dll pour le .NET Framework 4.  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException> est levée si `assemblyString` Spécifie le nom complet de l’assembly et le premier assembly correspondant au nom simple a une autre version, culture ou jeton de clé publique. Le chargeur ne continue pas à détecter d’autres assemblys qui correspondent au nom simple.  
  
 L'octroi ou non de certaines autorisations à un assembly repose sur la preuve. Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode sans aucune <xref:System.Security.Policy.Evidence> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées. Preuves fournies en tant qu’argument à la <xref:System.Reflection.Assembly.Load%2A> méthode annulent et remplacent les preuves fournies par le chargeur.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image common object file format (COFF), la preuve est héritée de l’assembly appelant. Cela s’applique à la version 1.1 du .NET Framework Service Pack 1 (SP1) et les versions ultérieures.  
  
    > [!NOTE]
    >  Dans le .NET Framework version 1.0 et dans la version 1.1 sans SP1, lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image COFF, la preuve est combinée. `Zone`, `Url` et `Site` sont héritées de l’assembly appelant, et `Hash` et `StrongName` proviennent de l’assembly COFF.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un `Byte[]` paramètre et <xref:System.Security.Policy.Evidence> pour charger une image COFF, seule la preuve fournie est utilisée. Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.  
  
 La réflexion sur des fichiers exécutables C++ peut lever une <xref:System.BadImageFormatException>. Cela est probablement dû au fait généralement de la suppression des adresses de réadressage ou `.reloc` section à partir de votre fichier exécutable. Pour conserver le `.reloc` d’adresses de votre fichier exécutable C++, spécifiez `/fixed:no` lors de la liaison.  
  
 Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly. Par exemple, « ProcessorArchitecture = msil ». Toutefois, la méthode recommandée pour spécifier un nom d’assembly consiste à créer un <xref:System.Reflection.AssemblyName> de l’objet et le passer à une surcharge appropriée de la <xref:System.Reflection.Assembly.Load%2A> (méthode). Consultez <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant charge un assembly en fonction de son nom qualifié complet et répertorie tous les types contenus dans l’assembly spécifié. Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyString" /> est une chaîne de longueur nulle.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> n’est pas un assembly valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyString" /> a été compilé avec une version ultérieure.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">Méthode de localisation des assemblys par le runtime</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tableau d'octets qui est une image au format COFF contenant un assembly émis.</param>
        <param name="rawSymbolStore">Tableau d'octets qui contient les octets bruts représentant les symboles de l'assembly.</param>
        <summary>Charge l'assembly avec une image COFF (Common Object File Format) contenant un assembly émis qui inclut éventuellement des symboles de l'assembly. L'assembly est chargé dans le domaine d'application de l'appelant.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le niveau de confiance d’un assembly est chargé à l’aide de cette méthode est le même que le niveau de confiance de l’assembly appelant. Pour charger un assembly à partir d’un tableau d’octets dont le niveau de confiance du domaine d’application, utilisez le <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> surcharge de méthode. Pour plus d’informations sur l’utilisation de la preuve avec les surcharges de la <xref:System.Reflection.Assembly.Load%2A> méthode qui acceptent les tableaux d’octets, consultez la <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> surcharge de méthode.  
  
 La réflexion sur des fichiers exécutables C++ peut lever une <xref:System.BadImageFormatException>. Cela est probablement dû au fait généralement de la suppression des adresses de réadressage ou `.reloc` section à partir de votre fichier exécutable. Pour conserver le `.reloc` d’adresses de votre fichier exécutable C++, spécifiez `/fixed:no` lors de la liaison.  
  
 Notez que cette surcharge de méthode crée toujours un nouveau <xref:System.Reflection.Assembly> objet avec son propre mappage.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> est <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> n’est pas un assembly valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="rawAssembly" /> a été compilé avec une version ultérieure.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Objet qui décrit l'assembly à charger.</param>
        <param name="assemblySecurity">Preuve de chargement de l'assembly.</param>
        <summary>Charge un assembly en fonction de son <see cref="T:System.Reflection.AssemblyName" />. L'assembly est chargé dans le domaine de l'appelant à l'aide de la preuve fournie.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> est levée si `assemblyRef` Spécifie le nom complet de l’assembly et le premier assembly correspondant au nom simple a une autre version, culture ou jeton de clé publique. Le chargeur ne continue pas à détecter d’autres assemblys qui correspondent au nom simple.  Démarrer avec .NET Framework 4, car l’exécution de code dans les assemblys à distance est désactivée par défaut, un <xref:System.IO.FileLoadException> est également levée si `assemblyRef` spécifie un assembly distant. Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.   
  
> [!NOTE]
>  N’utilisez pas un <xref:System.Reflection.AssemblyName> avec uniquement le <xref:System.Reflection.AssemblyName.CodeBase%2A> jeu de propriétés. Le <xref:System.Reflection.AssemblyName.CodeBase%2A> propriété ne fournit pas tous les éléments de l’identité d’assembly (par exemple, le nom ou la version), ainsi le chargement ne se produit pas d’en fonction des règles de charge par identité, comme vous pouvez l’imaginer à partir de la <xref:System.Reflection.Assembly.Load%2A> (méthode). Au lieu de cela, l’assembly est chargé à l’aide de règles load-from. Pour plus d’informations sur les inconvénients de l’utilisation du contexte de chargement, consultez la <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> surcharge de méthode ou [meilleures pratiques de chargement d’Assembly](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 L'octroi ou non de certaines autorisations à un assembly repose sur la preuve. Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode sans aucune <xref:System.Security.Policy.Evidence> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées. Preuves fournies en tant qu’argument à la <xref:System.Reflection.Assembly.Load%2A> méthode annulent et remplacent les preuves fournies par le chargeur.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image common object file format (COFF), la preuve est héritée de l’assembly appelant. Cela s’applique à la version 1.1 du .NET Framework Service Pack 1 (SP1) et les versions ultérieures.  
  
    > [!NOTE]
    >  Dans le .NET Framework version 1.0 et dans la version 1.1 sans SP1, lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image COFF, la preuve est combinée. `Zone`, `Url` et `Site` sont héritées de l’assembly appelant, et `Hash` et `StrongName` proviennent de l’assembly COFF.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un `Byte[]` paramètre et <xref:System.Security.Policy.Evidence> pour charger une image COFF, seule la preuve fournie est utilisée. Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.  
  
 La réflexion sur des fichiers exécutables C++ peut lever une <xref:System.BadImageFormatException>. Cela est probablement dû au fait généralement de la suppression des adresses de réadressage ou `.reloc` section à partir de votre fichier exécutable. Pour conserver le `.reloc` d’adresses de votre fichier exécutable C++, spécifiez `/fixed:no` lors de la liaison.  
  
> [!NOTE]
>  Si les deux le <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> propriété et la <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> propriété sont définies, la première tentative de charger l’assembly utilise le nom d’affichage (notamment la version, culture et ainsi de suite, tel que retourné par la <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriété). Si le fichier est introuvable, <xref:System.Reflection.AssemblyName.CodeBase%2A> est utilisé pour rechercher l’assembly. Si l’assembly se trouve à l’aide de <xref:System.Reflection.AssemblyName.CodeBase%2A>, le nom d’affichage est comparé à l’assembly. Si la correspondance échoue, un <xref:System.IO.FileLoadException> est levée.  
  
 Si vous appelez le <xref:System.Reflection.Assembly.Load%2A> méthode plusieurs fois sur le même assembly, mais avec une preuve spécifiée différente, le common language runtime ne lève pas une <xref:System.IO.FileLoadException> , car l’égalité et l’intégrité des différentes spécifications de preuve ne peut pas être déterminé. La première preuve qui réussit est la preuve est utilisée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyRef" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyRef" /> n’est pas un assembly valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyRef" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.

ou

<paramref name="assemblyRef" /> spécifie un assembly distant, mais la possibilité d’exécuter du code dans des assemblys distants est désactivée. Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">Méthode de localisation des assemblys par le runtime</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nom complet de l'assembly.</param>
        <param name="assemblySecurity">Preuve de chargement de l'assembly.</param>
        <summary>Charge un assembly en fonction de son nom complet, en le chargeant dans le domaine de l'appelant à l'aide de la preuve fournie.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> est levée si `assemblyString` Spécifie le nom complet de l’assembly et le premier assembly correspondant au nom simple a une autre version, culture ou jeton de clé publique. Le chargeur ne continue pas à détecter d’autres assemblys qui correspondent au nom simple.  
  
 L'octroi ou non de certaines autorisations à un assembly repose sur la preuve. Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode sans aucune <xref:System.Security.Policy.Evidence> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées. Preuves fournies en tant qu’argument à la <xref:System.Reflection.Assembly.Load%2A> méthode annulent et remplacent les preuves fournies par le chargeur.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image common object file format (COFF), la preuve est héritée de l’assembly appelant. Cela s’applique à la version 1.1 du .NET Framework Service Pack 1 (SP1) et les versions ultérieures.  
  
    > [!NOTE]
    >  Dans le .NET Framework version 1.0 et dans la version 1.1 sans SP1, lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image COFF, la preuve est combinée. `Zone`, `Url` et `Site` sont héritées de l’assembly appelant, et `Hash` et `StrongName` proviennent de l’assembly COFF.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un `Byte[]` paramètre et <xref:System.Security.Policy.Evidence> pour charger une image COFF, seule la preuve fournie est utilisée. Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.  
  
 La réflexion sur des fichiers exécutables C++ peut lever une <xref:System.BadImageFormatException>. Cela est probablement dû au fait généralement de la suppression des adresses de réadressage ou `.reloc` section à partir de votre fichier exécutable. Pour conserver le `.reloc` d’adresses de votre fichier exécutable C++, spécifiez `/fixed:no` lors de la liaison.  
  
 Si vous appelez cette méthode plusieurs fois sur le même assembly, mais avec une preuve spécifiée différente, le common language runtime ne lève pas une <xref:System.IO.FileLoadException> , car il est impossible de déterminer l’égalité et l’intégrité des différentes spécifications de preuve. La première preuve qui réussit est la preuve est utilisée.  
  
 Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly. Par exemple, « ProcessorArchitecture = msil ». Toutefois, la méthode recommandée pour spécifier un nom d’assembly consiste à créer un <xref:System.Reflection.AssemblyName> de l’objet et le passer à une surcharge appropriée de la <xref:System.Reflection.Assembly.Load%2A> (méthode). Consultez <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> n’est pas un assembly valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyString" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.  
  
ou 
Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">Méthode de localisation des assemblys par le runtime</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tableau d'octets qui est une image au format COFF contenant un assembly émis.</param>
        <param name="rawSymbolStore">Tableau d'octets qui contient les octets bruts représentant les symboles de l'assembly.</param>
        <param name="securityEvidence">Preuve de chargement de l'assembly.</param>
        <summary>Charge l'assembly avec une image COFF (Common Object File Format) contenant un assembly émis qui inclut éventuellement des symboles et des preuves de l'assembly. L'assembly est chargé dans le domaine d'application de l'appelant.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly est chargé dans le domaine de l'appelant à l'aide de la preuve fournie. Les octets bruts représentant les symboles de l’assembly sont également chargés.  
  
 L'octroi ou non de certaines autorisations à un assembly repose sur la preuve. Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode sans aucune <xref:System.Security.Policy.Evidence> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées. Preuves fournies en tant qu’argument à la <xref:System.Reflection.Assembly.Load%2A> méthode annulent et remplacent les preuves fournies par le chargeur.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image COFF, la preuve est héritée de l’assembly appelant. Cela s’applique à la version 1.1 du .NET Framework Service Pack 1 (SP1) et les versions ultérieures.  
  
    > [!NOTE]
    >  Dans le .NET Framework version 1.0 et dans la version 1.1 sans SP1, lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> surcharge de méthode avec un `Byte[]` paramètre pour charger une image COFF, la preuve est combinée. `Zone`, `Url` et `Site` sont héritées de l’assembly appelant, et `Hash` et `StrongName` proviennent de l’assembly COFF.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.Load%2A> méthode avec un `Byte[]` paramètre et <xref:System.Security.Policy.Evidence> pour charger une image COFF, seule la preuve fournie est utilisée. Preuve de l’assembly appelant et celle de l’image COFF sont ignorées.  
  
 La réflexion sur des fichiers exécutables C++ peut lever une <xref:System.BadImageFormatException>. Cela est probablement dû au fait généralement de la suppression des adresses de réadressage ou `.reloc` section à partir de votre fichier exécutable. Pour conserver le `.reloc` d’adresses de votre fichier exécutable C++, spécifiez `/fixed:no` lors de la liaison.  
  
 Si vous appelez le [\], octets\<xref:System.Reflection.Assembly.Load%2A > méthode plusieurs fois sur le même assembly, mais avec une preuve spécifiée différente, le common language runtime ne lève pas une <xref:System.IO.FileLoadException> , car le Impossible de déterminer l’égalité et l’intégrité des différentes spécifications de preuve. La première preuve qui réussit est la preuve est utilisée.  
  
 Notez que cette surcharge de méthode crée toujours un nouveau <xref:System.Reflection.Assembly> objet avec son propre mappage.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> est <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> n’est pas un assembly valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="rawAssembly" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="securityEvidence" /> n’est pas un <see langword="null" />.  Par défaut, la stratégie CAS héritée n’est pas activée dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ; quand elle n’est pas activée, <paramref name="securityEvidence" /> doit avoir la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacité à fournir une preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tableau d'octets qui est une image au format COFF contenant un assembly émis.</param>
        <param name="rawSymbolStore">Tableau d'octets qui contient les octets bruts représentant les symboles de l'assembly.</param>
        <param name="securityContextSource">Source du contexte de sécurité.</param>
        <summary>Charge l'assembly avec une image COFF (Common Object File Format) contenant un assembly émis qui inclut éventuellement des symboles et qui spécifie la source du contexte de sécurité. L'assembly est chargé dans le domaine d'application de l'appelant.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’assembly est chargé dans le domaine d’application de l’appelant à l’aide de la source spécifiée pour le contexte de sécurité. Si `rawSymbolStore` a été spécifié, les octets bruts représentant les symboles pour l’assembly sont également chargés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> est <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> n’est pas un assembly valide.  
  
ou 
 <paramref name="rawAssembly" /> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="securityContextSource" /> n’est pas l’une des valeurs d’énumération.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Charge le contenu d'un fichier d'assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès complet du fichier à charger.</param>
        <summary>Charge le contenu d’un fichier d’assembly sur le chemin d’accès spécifié.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Reflection.Assembly.LoadFile%2A> méthode pour charger et examiner des assemblys qui ont la même identité, mais se trouvent dans différents chemins d’accès. <xref:System.Reflection.Assembly.LoadFile%2A> ne pas charger des fichiers dans le contexte de chargement et ne résout pas les dépendances à l’aide du chemin de chargement, comme le <xref:System.Reflection.Assembly.LoadFrom%2A> méthode effectue. <xref:System.Reflection.Assembly.LoadFile%2A> est utile dans ce scénario spécifique, car <xref:System.Reflection.Assembly.LoadFrom%2A> ne peut pas être utilisé pour charger les assemblys qui ont la même identité mais différents chemins d’accès ; elle chargera uniquement le premier tel assembly.  

En commençant par le .NET Framework 4, si `path` spécifie un assembly dans un emplacement distant, le chargement d’assembly est désactivé par défaut et le `LoadFile` méthode lève un <xref:System.IO.FileLoadException>. Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’argument <paramref name="path" /> n’est pas un chemin absolu.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.

ou

La possibilité d’exécuter du code dans des assemblys distants est désactivée. Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le paramètre <paramref name="path" /> est une chaîne vide ("") ou n’existe pas.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="path" /> n’est pas un assembly valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="path" /> a été compilé avec une version ultérieure.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">Chemin complet du fichier d’assembly.</param>
        <param name="securityEvidence">Preuve de chargement de l'assembly.</param>
        <summary>Charge un assembly en fonction de son chemin d'accès, en le chargeant dans le domaine de l'appelant à l'aide de la preuve fournie.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Reflection.Assembly.LoadFile%2A> méthode pour charger et examiner des assemblys qui ont la même identité, mais se trouvent dans différents chemins d’accès. <xref:System.Reflection.Assembly.LoadFile%2A> ne pas charger des fichiers dans le <xref:System.Reflection.Assembly.LoadFrom%2A> contexte et ne résout pas les dépendances à l’aide du chemin de chargement, comme le <xref:System.Reflection.Assembly.LoadFrom%2A> méthode effectue. <xref:System.Reflection.Assembly.LoadFile%2A> est utile dans ce scénario spécifique, car <xref:System.Reflection.Assembly.LoadFrom%2A> ne peut pas être utilisé pour charger les assemblys qui ont la même identité mais différents chemins d’accès ; elle chargera uniquement le premier tel assembly.  

En commençant par le .NET Framework 4, si `path` spécifie un assembly dans un emplacement distant, le chargement d’assembly est désactivé par défaut et le `LoadFile` méthode lève un <xref:System.IO.FileLoadException>. Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’argument <paramref name="path" /> n’est pas un chemin absolu.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le paramètre <paramref name="path" /> est une chaîne vide ("") ou n’existe pas.</exception>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.

ou

La possibilité d’exécuter du code dans des assemblys distants est désactivée. Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="path" /> n’est pas un assembly valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="path" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="securityEvidence" /> n’est pas un <see langword="null" />. Par défaut, la stratégie CAS héritée n’est pas activée dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ; quand elle n’est pas activée, <paramref name="securityEvidence" /> doit avoir la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Charge un assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

À compter de .NET Framework 4, la possibilité d’exécuter du code dans les assemblys chargés à partir d’emplacements distants est désactivée par défaut et l’appel à la `LoadFrom` méthode lève un <xref:System.IO.FileLoadException>. Pour charger l’assembly et exécuter son code, vous devez :

- Créer explicitement un bac à sable pour l’assembly. (Consultez [Guide pratique pour Exécuter le Code de confiance partiel dans un bac à sable](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)

- Exécuter du code de l’assembly avec une confiance totale en définissant le `enabled` attribut de la [ `<loadFromRemoteSources>` élément de configuration](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) à `true`. Pour plus d’informations, consultez le [ `<loadFromRemoteSources>` élément de configuration](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) article.

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom ou chemin d’accès du fichier qui contient le manifeste d’assembly.</param>
        <summary>Charge un assembly en fonction de son nom de fichier ou de son chemin d'accès.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `assemblyFile` paramètre doit faire référence à un URI sans caractères d’échappement. Cette méthode fournit les caractères d’échappement pour tous les caractères non valides dans l’URI.  
  
> [!NOTE]
>  Protocole de transfert de fichiers (FTP) n’est pas pris en charge. Si l’URI fourni pour `assemblyFile` est une adresse FTP, l’assembly n’est pas chargé. Aucune exception n'est levée.  
  
 `assemblyFile` peut être absolu ou relatif au répertoire en cours, et l’assembly est chargé dans le domaine de l’appelant.  
  
 Les assemblys peuvent être chargés dans un des trois contextes, ou peuvent être chargés sans contexte :  
  
-   Le contexte de chargement contient des assemblys trouvés en recherchant : dans le GAC, dans un assembly hôte stocker si le runtime est hébergé, ou dans le <xref:System.AppDomainSetup.ApplicationBase%2A> et <xref:System.AppDomainSetup.PrivateBinPath%2A> du domaine d’application. La plupart des surcharges de la méthode <xref:System.Reflection.Assembly.Load%2A> chargent les assemblys dans ce contexte.  
  
-   Le contexte de chargement contient des assemblys pour lesquels l’utilisateur a fourni un chemin d’accès non inclus dans les répertoires de recherche par la détection. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> et <xref:System.AppDomain.ExecuteAssembly%2A> sont des exemples de méthodes qui sont chargées via un chemin. 

    En commençant par le .NET Framework 4, si l’URI de `assemblyFile` spécifie un emplacement distant, le chargement des assemblys sont désactivée par défaut et le `LoadFrom` méthode lève un <xref:System.IO.FileLoadException>. Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.    
  
-   Le contexte de réflexion uniquement contient des assemblys chargés avec le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> et <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> méthodes ; le code dans ces contextes ne peut pas être exécutées.  
  
-   Si l’utilisateur a généré ou trouvé l’assembly, il n’est pas dans n’importe quel contexte. Cela s’applique aux assemblys chargés à l’aide de surcharges de la <xref:System.Reflection.Assembly.Load%2A> méthode qui spécifient un tableau d’octets qui contient un assembly et aux assemblys dynamiques transitoires créés avec la réflexion l’émission et pas enregistré sur le disque.  
  
 Le contexte load-from permet à un assembly à charger à partir d’un chemin d’accès non inclus dans la détection et permet cependant de dépendances sur ce chemin d’accès pour trouver et de charger, car les informations de chemin d’accès sont conservées par le contexte.  
  
 Le <xref:System.Reflection.Assembly.LoadFrom%2A> méthode présente les inconvénients suivants. Utilisez <xref:System.Reflection.Assembly.Load%2A> à la place.  
  
-   Si un assembly avec la même identité est déjà chargé, <xref:System.Reflection.Assembly.LoadFrom%2A> retourne l’assembly chargé même si un autre chemin a été spécifié.  
  
-   Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>et ultérieurement un assembly dans le contexte de chargement essaie de charger le même assembly par nom d’affichage, la tentative de chargement échoue. Cela peut se produire lorsqu’un assembly est désérialisé.  
  
-   Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>, et le chemin de recherche inclut un assembly avec la même identité mais un emplacement différent, un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou tout autre comportement inattendu peut se produire.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> demande <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> et <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, sur le chemin spécifié.  
  
-   Si une image native existe pour `assemblyFile`, il n’est pas utilisé. L’assembly ne peut pas être chargé comme indépendant du domaine.  
  
-   Dans la version 1.0 et 1.1 du .NET Framework, la stratégie n’est pas appliquée.  
  
   
  
## Examples  
 L’exemple suivant charge un assembly en fonction de son nom de fichier ou le chemin d’accès.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> est introuvable ou le module que vous essayez de charger ne spécifie pas d’extension de nom de fichier.</exception>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.

ou

La possibilité d’exécuter du code dans des assemblys distants est désactivée. Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> n’est pas un assembly valide ; par exemple, un assembly 32 bits dans un processus 64 bits. Pour plus d’informations, consultez la rubrique sur les exceptions.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyFile" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.Security.SecurityException">Un code base qui ne commence pas par "file://" a été spécifié sans la <see cref="T:System.Net.WebPermission" /> requise.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="assemblyFile" /> est une chaîne vide ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Le nom de l’assembly dépasse la longueur maximale définie par le système.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire un URI qui commence par « file:// ». Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom ou chemin d’accès du fichier qui contient le manifeste d’assembly.</param>
        <param name="securityEvidence">Preuve de chargement de l'assembly.</param>
        <summary>Charge un assembly en fonction de son nom de fichier ou de son chemin d’accès et en fournissant la preuve de sécurité.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `assemblyFile` paramètre doit faire référence à un URI sans caractères d’échappement. Cette méthode fournit les caractères d’échappement pour tous les caractères non valides dans l’URI.  
  
> [!NOTE]
>  Protocole de transfert de fichiers (FTP) n’est pas pris en charge. Si l’URI fourni pour `assemblyFile` est une adresse FTP, l’assembly n’est pas chargé. Aucune exception n'est levée.  
  
 `assemblyFile` peut être absolu ou relatif au répertoire en cours, et l’assembly est chargé dans le domaine de l’appelant.  
  
 Les assemblys peuvent être chargés dans un des trois contextes, ou peuvent être chargés sans contexte :  
  
-   Le contexte de chargement contient des assemblys trouvés en recherchant : dans le GAC, dans un assembly hôte stocker si le runtime est hébergé, ou dans le <xref:System.AppDomainSetup.ApplicationBase%2A> et <xref:System.AppDomainSetup.PrivateBinPath%2A> du domaine d’application. La plupart des surcharges de la méthode <xref:System.Reflection.Assembly.Load%2A> chargent les assemblys dans ce contexte.  
  
-   Le contexte de chargement contient des assemblys pour lesquels l’utilisateur a fourni un chemin d’accès non inclus dans les répertoires de recherche par la détection. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> et <xref:System.AppDomain.ExecuteAssembly%2A> sont des exemples de méthodes qui sont chargées via un chemin.

    En commençant par le .NET Framework 4, si l’URI de `assemblyFile` spécifie un emplacement distant, le chargement des assemblys sont désactivée par défaut et le `LoadFrom` méthode lève un <xref:System.IO.FileLoadException>. Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.    
  
-   Le contexte de réflexion uniquement contient des assemblys chargés avec le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> et <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> méthodes ; le code dans ces contextes ne peut pas être exécutées.  
  
-   Si l’utilisateur a généré ou trouvé l’assembly, il n’est pas dans n’importe quel contexte. Cela s’applique aux assemblys chargés à l’aide de surcharges de la <xref:System.Reflection.Assembly.Load%2A> méthode qui spécifient un tableau d’octets qui contient un assembly et aux assemblys dynamiques transitoires créés avec la réflexion l’émission et pas enregistré sur le disque.  
  
 Le contexte load-from permet à un assembly à charger à partir d’un chemin d’accès non inclus dans la détection et permet cependant de dépendances sur ce chemin d’accès pour trouver et de charger, car les informations de chemin d’accès sont conservées par le contexte.  
  
 Le <xref:System.Reflection.Assembly.LoadFrom%2A> méthode présente les inconvénients suivants. Utilisez <xref:System.Reflection.Assembly.Load%2A> à la place.  
  
-   Si un assembly avec la même identité est déjà chargé, <xref:System.Reflection.Assembly.LoadFrom%2A> retourne l’assembly chargé même si un autre chemin a été spécifié.  
  
-   Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>et ultérieurement un assembly dans le contexte de chargement essaie de charger le même assembly par nom d’affichage, la tentative de chargement échoue. Ceci peut se produire quand un assembly est désérialisé.  
  
-   Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>, et le chemin de recherche inclut un assembly avec la même identité mais un emplacement différent, un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou tout autre comportement inattendu peut se produire.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> demande <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> et <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, sur le chemin spécifié.  
  
-   Si une image native existe pour `assemblyFile`, il n’est pas utilisé. L’assembly ne peut pas être chargé comme indépendant du domaine.  
  
-   Dans la version 1.0 et 1.1 du .NET Framework, la stratégie n’est pas appliquée.  
  
 L'octroi ou non de certaines autorisations à un assembly repose sur la preuve. Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode sans aucune <xref:System.Security.Policy.Evidence> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées. Preuves fournies en tant qu’argument à la <xref:System.Reflection.Assembly.LoadFrom%2A> méthode annulent et remplacent les preuves fournies par le chargeur.  
  
-   Si vous appelez cette méthode plusieurs fois sur le même assembly, mais avec une preuve spécifiée différente, le common language runtime ne lève pas une <xref:System.IO.FileLoadException> , car il est impossible de déterminer l’égalité et l’intégrité des différentes spécifications de preuve. La première preuve qui réussit est la preuve est utilisée.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode avec un `Byte[]` paramètre pour charger une image common object file format (COFF), la preuve est combinée. `Zone`, `Url` et `Site` sont héritées de l’assembly appelant, et `Hash` et `StrongName` proviennent de l’assembly COFF.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode avec un `Byte[]` paramètre et <xref:System.Security.Policy.Evidence> pour charger une image COFF, seule la preuve fournie est utilisée. Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> est introuvable ou le module que vous essayez de charger ne spécifie pas d’extension de nom de fichier.</exception>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.  
  
ou 
Le <paramref name="securityEvidence" /> n’est pas ambigu et est considéré comme étant non valide.

ou

La possibilité d’exécuter du code dans des assemblys distants est désactivée. Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> n’est pas un assembly valide ; par exemple, un assembly 32 bits dans un processus 64 bits. Pour plus d’informations, consultez la rubrique sur les exceptions.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyFile" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.Security.SecurityException">Un code base qui ne commence pas par "file://" a été spécifié sans la <see cref="T:System.Net.WebPermission" /> requise.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="assemblyFile" /> est une chaîne vide ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Le nom de l’assembly dépasse la longueur maximale définie par le système.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire un URI qui commence par « file:// ». Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom ou chemin d’accès du fichier qui contient le manifeste d’assembly.</param>
        <param name="hashValue">Valeur du code de hachage calculé.</param>
        <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les fichiers et pour générer le nom fort.</param>
        <summary>Charge un assembly en fonction de son nom de fichier ou de son chemin d'accès, de la valeur de hachage et de l'algorithme de hachage.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `assemblyFile` paramètre doit faire référence à un URI sans caractères d’échappement. Cette méthode fournit les caractères d’échappement pour tous les caractères non valides dans l’URI.  
  
> [!NOTE]
>  Protocole de transfert de fichiers (FTP) n’est pas pris en charge. Si l’URI fourni pour `assemblyFile` est une adresse FTP, l’assembly n’est pas chargé. Aucune exception n'est levée.  
  
 `assemblyFile` peut être absolu ou relatif au répertoire en cours, et l’assembly est chargé dans le domaine de l’appelant.  
  
 Les assemblys peuvent être chargés dans un des trois contextes, ou peuvent être chargés sans contexte :  
  
-   Le contexte de chargement contient des assemblys trouvés en recherchant : dans le global assembly cache, dans un assembly hôte stocker si le runtime est hébergé, ou dans le <xref:System.AppDomainSetup.ApplicationBase%2A> et <xref:System.AppDomainSetup.PrivateBinPath%2A> du domaine d’application. La plupart des surcharges de la méthode <xref:System.Reflection.Assembly.Load%2A> chargent les assemblys dans ce contexte.  
  
-   Le contexte de chargement contient des assemblys pour lesquels l’utilisateur a fourni un chemin d’accès n’est pas inclus dans la recherche. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> et <xref:System.AppDomain.ExecuteAssembly%2A> sont des exemples de méthodes qui sont chargées via un chemin.  

    En commençant par le .NET Framework 4, si l’URI de `assemblyFile` spécifie un emplacement distant, le chargement des assemblys sont désactivée par défaut et le `LoadFrom` méthode lève un <xref:System.IO.FileLoadException>. Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.    
  
-   Le contexte de réflexion uniquement contient des assemblys chargés avec le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> et <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> méthodes ; le code dans ces contextes ne peut pas être exécutées.  
  
-   Si l’utilisateur a généré ou trouvé l’assembly, il n’est pas dans n’importe quel contexte. Cela s’applique aux assemblys chargés à l’aide de surcharges de la <xref:System.Reflection.Assembly.Load%2A> méthode qui spécifient un tableau d’octets qui contient un assembly et aux assemblys dynamiques transitoires créés avec la réflexion l’émission et pas enregistré sur le disque.  
  
 Le contexte load-from permet à un assembly à charger à partir d’un chemin d’accès n’est pas inclus dans la détection et permet cependant de dépendances sur ce chemin d’accès pour trouver et de charger, car les informations de chemin d’accès sont conservées par le contexte.  
  
 Le <xref:System.Reflection.Assembly.LoadFrom%2A> méthode présente les inconvénients suivants. Utilisez <xref:System.Reflection.Assembly.Load%2A> à la place.  
  
-   Si un assembly avec la même identité est déjà chargé, <xref:System.Reflection.Assembly.LoadFrom%2A> retourne l’assembly chargé même si un autre chemin a été spécifié.  
  
-   Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>et ultérieurement un assembly dans le contexte de chargement essaie de charger le même assembly par nom d’affichage, la tentative de chargement échoue. Ceci peut se produire quand un assembly est désérialisé.  
  
-   Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>, et le chemin de recherche inclut un assembly avec la même identité mais un emplacement différent, un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou tout autre comportement inattendu peut se produire.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> demande <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> et <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, sur le chemin spécifié.  
  
-   Si une image native existe pour `assemblyFile`, il n’est pas utilisé. L’assembly ne peut pas être chargé comme étant indépendant du domaine.  
  
 L’assembly est chargé avec la preuve fournie par le chargeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> est introuvable ou le module que vous essayez de charger ne spécifie pas une extension de nom de fichier.</exception>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.

ou

La possibilité d’exécuter du code dans des assemblys distants est désactivée. Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> n’est pas un assembly valide ; par exemple, un assembly 32 bits dans un processus 64 bits. Pour plus d’informations, consultez la rubrique sur les exceptions.  
  
ou 
 <paramref name="assemblyFile" /> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</exception>
        <exception cref="T:System.Security.SecurityException">Un code base qui ne commence pas par "file://" a été spécifié sans la <see cref="T:System.Net.WebPermission" /> requise.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="assemblyFile" /> est une chaîne vide ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Le nom de l’assembly dépasse la longueur maximale définie par le système.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire un URI qui commence par « file:// ». Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom ou chemin d’accès du fichier qui contient le manifeste d’assembly.</param>
        <param name="securityEvidence">Preuve de chargement de l'assembly.</param>
        <param name="hashValue">Valeur du code de hachage calculé.</param>
        <param name="hashAlgorithm">Algorithme de hachage utilisé pour hacher les fichiers et pour générer le nom fort.</param>
        <summary>Charge un assembly en fonction de son nom de fichier ou de son chemin d'accès, de la preuve de sécurité, de la valeur de hachage et de l'algorithme de hachage.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `assemblyFile` paramètre doit faire référence à un URI sans caractères d’échappement. Cette méthode fournit les caractères d’échappement pour tous les caractères non valides dans l’URI.  
  
> [!NOTE]
>  Protocole de transfert de fichiers (FTP) n’est pas pris en charge. Si l’URI fourni pour `assemblyFile` est une adresse FTP, l’assembly n’est pas chargé. Aucune exception n'est levée.  
  
 `assemblyFile` peut être absolu ou relatif au répertoire en cours, et l’assembly est chargé dans le domaine de l’appelant.  
  
 Les assemblys peuvent être chargés dans un des trois contextes, ou peuvent être chargés sans contexte :  
  
-   Le contexte de chargement contient des assemblys trouvés en recherchant : dans le GAC, dans un assembly hôte stocker si le runtime est hébergé, ou dans le <xref:System.AppDomainSetup.ApplicationBase%2A> et <xref:System.AppDomainSetup.PrivateBinPath%2A> du domaine d’application. La plupart des surcharges de la méthode <xref:System.Reflection.Assembly.Load%2A> chargent les assemblys dans ce contexte.  
  
-   Le contexte de chargement contient des assemblys pour lesquels l’utilisateur a fourni un chemin d’accès non inclus dans les répertoires de recherche par la détection. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> et <xref:System.AppDomain.ExecuteAssembly%2A> sont des exemples de méthodes qui sont chargées via un chemin.  

    En commençant par le .NET Framework 4, si l’URI de `assemblyFile` spécifie un emplacement distant, le chargement des assemblys sont désactivée par défaut et le `LoadFrom` méthode lève un <xref:System.IO.FileLoadException>. Pour permettre l’exécution de code chargé à partir d’emplacements distants, vous pouvez utiliser la [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) élément de configuration.    
  
-   Le contexte de réflexion uniquement contient des assemblys chargés avec le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> et <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> méthodes ; le code dans ces contextes ne peut pas être exécutées.  
  
-   Si l’utilisateur a généré ou trouvé l’assembly, il n’est pas dans n’importe quel contexte. Cela s’applique aux assemblys chargés à l’aide de surcharges de la <xref:System.Reflection.Assembly.Load%2A> méthode qui spécifient un tableau d’octets qui contient un assembly et aux assemblys dynamiques transitoires créés avec la réflexion l’émission et pas enregistré sur le disque.  
  
 Le contexte load-from permet à un assembly à charger à partir d’un chemin d’accès non inclus dans la détection et permet cependant de dépendances sur ce chemin d’accès pour trouver et de charger, car les informations de chemin d’accès sont conservées par le contexte.  
  
 Le <xref:System.Reflection.Assembly.LoadFrom%2A> méthode présente les inconvénients suivants. Utilisez <xref:System.Reflection.Assembly.Load%2A> à la place.  
  
-   Si un assembly avec la même identité est déjà chargé, <xref:System.Reflection.Assembly.LoadFrom%2A> retourne l’assembly chargé même si un autre chemin a été spécifié.  
  
-   Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>et ultérieurement un assembly dans le contexte de chargement essaie de charger le même assembly par nom d’affichage, la tentative de chargement échoue. Ceci peut se produire quand un assembly est désérialisé.  
  
-   Si un assembly est chargé avec <xref:System.Reflection.Assembly.LoadFrom%2A>, et le chemin de recherche inclut un assembly avec la même identité mais un emplacement différent, un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou tout autre comportement inattendu peut se produire.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> demande <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> et <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, sur le chemin spécifié.  
  
-   Si une image native existe pour `assemblyFile`, il n’est pas utilisé. L’assembly ne peut pas être chargé comme indépendant du domaine.  
  
-   Dans la version 1.0 et 1.1 du .NET Framework, la stratégie n’est pas appliquée.  
  
 L'octroi ou non de certaines autorisations à un assembly repose sur la preuve. Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode sans aucune <xref:System.Security.Policy.Evidence> paramètre, l’assembly est chargé avec la preuve fournie par le chargeur.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées. Preuves fournies en tant qu’argument à la <xref:System.Reflection.Assembly.LoadFrom%2A> méthode annulent et remplacent les preuves fournies par le chargeur.  
  
-   Si vous appelez cette méthode plusieurs fois sur le même assembly, mais avec une preuve spécifiée différente, le common language runtime ne lève pas une <xref:System.IO.FileLoadException> , car il est impossible de déterminer l’égalité et l’intégrité des différentes spécifications de preuve. La première preuve qui réussit est la preuve est utilisée.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode avec un `Byte[]` paramètre pour charger une image common object file format (COFF), la preuve est combinée. `Zone`, `Url` et `Site` sont héritées de l’assembly appelant, et `Hash` et `StrongName` proviennent de l’assembly COFF.  
  
-   Lorsque vous utilisez un <xref:System.Reflection.Assembly.LoadFrom%2A> méthode avec un `Byte[]` paramètre et <xref:System.Security.Policy.Evidence> pour charger une image COFF, seule la preuve fournie est utilisée. Preuve de l’assembly appelant et celle de l’image COFF sont ignorés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> est introuvable ou le module que vous essayez de charger ne spécifie pas d’extension de nom de fichier.</exception>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.  
  
ou 
Le <paramref name="securityEvidence" /> n’est pas ambigu et est considéré comme étant non valide.

ou

La possibilité d’exécuter du code dans des assemblys distants est désactivée. Consultez <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> n’est pas un assembly valide ; par exemple, un assembly 32 bits dans un processus 64 bits. Pour plus d’informations, consultez la rubrique sur les exceptions.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyFile" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.Security.SecurityException">Un code base qui ne commence pas par "file://" a été spécifié sans la <see cref="T:System.Net.WebPermission" /> requise.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="assemblyFile" /> est une chaîne vide ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Le nom de l’assembly dépasse la longueur maximale définie par le système.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire un URI qui commence par « file:// ». Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Charge le module interne à cet assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">Nom du module. Cette chaîne doit correspondre à un nom de fichier du manifeste de cet assembly.</param>
        <param name="rawModule">Tableau d'octets qui est une image COFF contenant un module émis ou une ressource.</param>
        <summary>Charge le module, interne à cet assembly, avec une image COFF (Common Object File Format) contenant un module émis ou un fichier de ressources.</summary>
        <returns>Module chargé.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="moduleName" /> ou <paramref name="rawModule" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="moduleName" /> ne correspond pas à une entrée de fichier du manifeste de cet assembly.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawModule" /> n’est pas un module valide.</exception>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour fournir la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">Nom du module. Cette chaîne doit correspondre à un nom de fichier du manifeste de cet assembly.</param>
        <param name="rawModule">Tableau d'octets qui est une image COFF contenant un module émis ou une ressource.</param>
        <param name="rawSymbolStore">Tableau d'octets contenant les octets bruts représentant les symboles du module. Doit avoir la valeur <see langword="null" /> s'il s'agit d'un fichier de ressources.</param>
        <summary>Charge le module, interne à cet assembly, avec une image COFF (Common Object File Format) contenant un module émis ou un fichier de ressources. Les octets bruts représentant les symboles du module sont également chargés.</summary>
        <returns>Module chargé.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="moduleName" /> ou <paramref name="rawModule" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="moduleName" /> ne correspond pas à une entrée de fichier du manifeste de cet assembly.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawModule" /> n’est pas un module valide.</exception>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour fournir la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Charge un assembly à partir du répertoire de l'application ou du Global Assembly Cache en utilisant un nom partiel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Les surcharges de la <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> méthode sont obsolète et ont été conservés pour la compatibilité descendante. L'alternative non obsolète est <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">Nom complet de l'assembly.</param>
        <summary>Charge un assembly à partir du répertoire de l'application ou du Global Assembly Cache en utilisant un nom partiel.</summary>
        <returns>Assembly chargé. Si <paramref name="partialName" /> est introuvable, cette méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Le <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> méthode est obsolète et a été conservée pour la compatibilité descendante. L'alternative non obsolète est <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 Les applications qui chargent des assemblys avec cette méthode seront affectées par les mises à niveau de ces assemblys. Par conséquent, n’utilisez pas cette méthode ; reconcevez l’application pour utiliser le <xref:System.Reflection.Assembly.Load%28System.String%29> surcharge de méthode ou le <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> surcharge de méthode.  
  
 Cette méthode appelle d’abord <xref:System.Reflection.Assembly.Load%2A>. Si l’assembly est introuvable, cette méthode retourne l’assembly du global assembly cache qui a le même nom simple et le numéro de version le plus élevé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="partialName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="partialName" /> a été compilé avec une version ultérieure.</exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">Nom complet de l'assembly.</param>
        <param name="securityEvidence">Preuve de chargement de l'assembly.</param>
        <summary>Charge un assembly à partir du répertoire de l'application ou du Global Assembly Cache en utilisant un nom partiel. L'assembly est chargé dans le domaine de l'appelant à l'aide de la preuve fournie.</summary>
        <returns>Assembly chargé. Si <paramref name="partialName" /> est introuvable, cette méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Le <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> méthode est obsolète et a été conservée pour la compatibilité descendante. L'alternative non obsolète est <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 La preuve est le jeu d'informations qui alimente les décisions de stratégie de sécurité, telles que les autorisations qui peuvent être accordées au code.  
  
 Les applications qui chargent des assemblys avec cette méthode seront affectées par les mises à niveau de ces assemblys. Par conséquent, n’utilisez pas cette méthode ; reconcevez l’application pour utiliser le <xref:System.Reflection.Assembly.Load%2A> méthode ou le <xref:System.Reflection.Assembly.LoadFrom%2A> (méthode).  
  
 Cette méthode appelle d’abord <xref:System.Reflection.Assembly.Load%2A>. Si l’assembly est introuvable, cette méthode retourne l’assembly du global assembly cache qui a le même nom simple et le numéro de version le plus élevé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux ensembles de preuves différents.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="partialName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="partialName" /> a été compilé avec une version ultérieure.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé et charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le chemin d’accès complet ou l’emplacement UNC du fichier chargé qui contient le manifeste.</summary>
        <value>Emplacement du fichier chargé qui contient le manifeste. Si le fichier chargé était une copie fantôme, l'emplacement est celui du fichier après qu'il soit une copie fantôme. Si l'assembly est chargé à partir d'un tableau d'octets, par exemple lors de l'utilisation de la surcharge de méthode <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" />, la valeur retournée est une chaîne vide ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir l’emplacement avant que le fichier a été copié de clichés instantanés, utilisez le <xref:System.Reflection.Assembly.CodeBase%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant affiche l’emplacement du fichier chargé qui contient le manifeste.  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L’assembly actuel est un assembly dynamique représenté par un objet <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder au chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Clichés instantanés d'assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le module qui contient le manifeste de l'assembly actuel.</summary>
        <value>Module qui contient le manifeste d'assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit si le chargeur de classes du Common Language Runtime ne peut pas résoudre une référence à un module interne d'un assembly à l'aide des moyens normaux.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement permet le rappel pour rechercher et charger le module lui-même et renvoyez-le.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection qui contient les modules dans cet assembly.</summary>
        <value>Collection qui contient les modules dans cet assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">Assembly à comparer à <paramref name="right" />.</param>
        <param name="right">Assembly à comparer à <paramref name="left" />.</param>
        <summary>Indique si deux objets <see cref="T:System.Reflection.Assembly" /> sont égaux.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> est égal à <paramref name="right" /> ; sinon <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">Assembly à comparer à <paramref name="right" />.</param>
        <param name="right">Assembly à comparer à <paramref name="left" />.</param>
        <summary>Indique si deux objets <see cref="T:System.Reflection.Assembly" /> ne sont pas égaux.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> n'est pas égal à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le jeu accordé de l'assembly actuel.</summary>
        <value>Jeu accordé de l'assembly actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> les objets peuvent contenir des informations sensibles telles que des chemins d’accès. Par conséquent, une confiance totale est nécessaire pour accéder à ces objets.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur <see cref="T:System.Boolean" /> indiquant si cet assembly a été chargé dans le contexte de réflexion uniquement.</summary>
        <value><see langword="true" /> si l'assembly a été chargé dans le contexte de réflexion uniquement, plutôt que dans le contexte d'exécution ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un assembly a été chargé dans le contexte de réflexion uniquement, à l’aide du <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> (méthode), vous ne pouvez pas exécuter du code dans l’assembly. Pour exécuter du code, l’assembly doit être chargé dans le contexte d’exécution.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Charge un assembly dans le contexte de réflexion uniquement, où il peut être examiné mais pas exécuté.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tableau d'octets qui est une image au format COFF contenant un assembly émis.</param>
        <summary>Charge l'assembly à partir d'une image au format COFF (Common Object File Format) contenant un assembly émis. L'assembly est chargé dans le contexte de réflexion uniquement du domaine d'application de l'appelant.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne pouvez pas exécuter du code à partir d’un assembly chargé dans le contexte de réflexion uniquement. Pour exécuter du code, l’assembly doit être chargé dans le contexte d’exécution, à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode).  
  
 Le contexte de réflexion uniquement n’est pas différent d’autres contextes. Les assemblys sont chargés dans le contexte peuvent être déchargées seulement en déchargeant le domaine d’application.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> est <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> n’est pas un assembly valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="rawAssembly" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger <paramref name="rawAssembly" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nom complet de l'assembly, tel que retourné par la propriété <see cref="P:System.Reflection.AssemblyName.FullName" />.</param>
        <summary>Charge un assembly dans le contexte de réflexion uniquement, étant donné son nom complet.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dépendances ne sont pas chargés automatiquement dans le contexte de réflexion uniquement.  
  
 Vous ne pouvez pas exécuter du code à partir d’un assembly chargé dans le contexte de réflexion uniquement. Pour exécuter du code, l’assembly doit être chargé dans le contexte d’exécution, à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode).  
  
 L'octroi ou non de certaines autorisations à un assembly repose sur la preuve. Les règles d’assembly et de fusion de preuves de sécurité sont les suivantes :  
  
> [!NOTE]
>  La réflexion sur des fichiers exécutables compilés en C++ peut lever une <xref:System.IO.FileLoadException>. Cela est probablement causé par le compilateur C++ suppression des adresses de réadressage ou de la section .reloc de votre fichier exécutable. Pour conserver l’adresse .reloc, spécifiez `/fixed:no` lors de la liaison.  
  
 Le contexte de réflexion uniquement n’est pas différent d’autres contextes. Les assemblys sont chargés dans le contexte peuvent être déchargées seulement en déchargeant le domaine d’application.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le <paramref name="assemblyString" /> est une chaîne vide ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="assemblyString" /> a été trouvé, mais impossible de le charger.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> n’est pas un assembly valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyString" /> a été compilé avec une version ultérieure.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Chemin d'accès du fichier qui contient le manifeste d'assembly.</param>
        <summary>Charge un assembly dans le contexte de réflexion uniquement, étant donné son chemin d'accès.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dépendances ne sont pas chargés automatiquement dans le contexte de réflexion uniquement. Pour charger automatiquement les dépendances, gérer le <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> événement et charge la dépendance dans le Gestionnaire d’événements.  
  
 Vous ne pouvez pas exécuter du code à partir d’un assembly qui a été chargé dans le contexte de réflexion uniquement. Pour exécuter le code, chargez l’assembly avec le <xref:System.Reflection.Assembly.LoadFile%2A> (méthode).  
  
 Le `assemblyFile` paramètre doit faire référence à un URI sans caractères d’échappement. Cette méthode fournit les caractères d’échappement pour tous les caractères non valides dans l’URI.  
  
 Le chemin d’accès spécifié pour `assemblyFile` est relatif au répertoire actif. L’assembly est chargé dans le domaine de l’appelant.  
  
 Le contexte de réflexion uniquement n’est pas différent d’autres contextes. Les assemblys sont chargés dans le contexte peuvent être déchargées seulement en déchargeant le domaine d’application.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> est introuvable ou le module que vous essayez de charger ne spécifie pas une extension de nom de fichier.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="assemblyFile" /> a été trouvé, mais impossible de le charger.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyFile" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.Security.SecurityException">Un code base qui ne commence pas par "file://" a été spécifié sans la <see cref="T:System.Net.WebPermission" /> requise.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le nom de l’assembly dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.ArgumentException">Le <paramref name="assemblyFile" /> est une chaîne vide ("").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire un URI qui commence par « file:// ». Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique quel ensemble de règles de sécurité le Common Language Runtime (CLR) applique pour cet assembly.</summary>
        <value>Ensemble de règles de sécurité que le CLR applique pour cet assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, les assemblys que vous compilez avec le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ont une transparence, bien que vous puissiez utiliser explicitement à la place. Les assemblys qui ont été compilés avec les versions antérieures du .NET Framework ont la transparence de niveau 1.  
  
 Consultez [Changements en matière de sécurité](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/misc/security-transparent-code.md">Code transparent de sécurité (security-transparent)</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Modifications de sécurité dans le .NET Framework 4</related>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le type de l'instance actuelle.</summary>
        <returns>Objet qui représente le type <see cref="T:System.Reflection.Assembly" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le nom complet de l'assembly.</summary>
        <returns>Nom complet de l'assembly, ou nom de la classe si le nom complet de l'assembly ne peut pas être déterminé.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom ou chemin d’accès du fichier qui contient le manifeste d’assembly.</param>
        <summary>Charge un assembly dans le contexte de chargement, en ignorant des vérifications de sécurité.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour charger un assembly local que le système d’exploitation a signalé comme ayant été chargé à partir du Web (par exemple, un fichier temporaire a été téléchargé depuis Internet ou intranet). Avant du [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], ces assemblys ont été chargés automatiquement dans un domaine d’application sandbox. En commençant par le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], ils sont chargés avec une confiance totale.  
  
 Comme alternative à l’aide de cette méthode, vous pouvez appliquer le [ &lt;NetFx40_LegacySecurityPolicy&gt; élément](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) dans votre fichier de configuration d’application. Cela entraîne le common language runtime rétablir la stratégie de sécurité de le [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
> [!CAUTION]
>  Si vous utilisez une de ces solutions, vous devez être certain qu’elle est sécurisée pour charger `assemblyFile` avec une confiance totale.  
  
 Pour une présentation des contextes de chargement, y compris le contexte de chargement, consultez le <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> surcharge de méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> est introuvable ou le module que vous essayez de charger ne spécifie pas d’extension de nom de fichier.</exception>
        <exception cref="T:System.IO.FileLoadException">Impossible de charger l’un des fichiers trouvés.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
ou 
 <paramref name="assemblyFile" /> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</exception>
        <exception cref="T:System.Security.SecurityException">Un code base qui ne commence pas par "file://" a été spécifié sans la <see cref="T:System.Net.WebPermission" /> requise.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="assemblyFile" /> est une chaîne vide ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Le nom de l’assembly dépasse la longueur maximale définie par le système.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
