<Type Name="DesignSurface" FullName="System.ComponentModel.Design.DesignSurface">
  <Metadata><Meta Name="ms.openlocfilehash" Value="91c1c9208c715341f7cfdcfb2625788e76d20af2" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53471159" /></Metadata><TypeSignature Language="C#" Value="public class DesignSurface : IDisposable, IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DesignSurface extends System.Object implements class System.IDisposable, class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Design.DesignSurface" />
  <TypeSignature Language="VB.NET" Value="Public Class DesignSurface&#xA;Implements IDisposable, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DesignSurface : IDisposable, IServiceProvider" />
  <TypeSignature Language="F#" Value="type DesignSurface = class&#xA;    interface IDisposable&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Présente une interface utilisateur pour concevoir des composants.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.Design.DesignSurface> classe implémente ce que l’utilisateur perçoit comme un concepteur. <xref:System.ComponentModel.Design.DesignSurface> est que l’interface utilisateur de l’utilisateur manipule pour modifier les fonctionnalités au moment du design. <xref:System.ComponentModel.Design.DesignSurface> Fournit une aire de conception complètement autonome.  
  
 Le <xref:System.ComponentModel.Design.DesignSurface> classe peut être utilisée comme un concepteur autonome, ou il peut être associé à la <xref:System.ComponentModel.Design.DesignSurfaceManager> classe pour fournir une implémentation commune pour une application qui héberge plusieurs <xref:System.ComponentModel.Design.DesignSurface> objets.  
  
 Le <xref:System.ComponentModel.Design.DesignSurface> classe peut être utilisée par elle-même ou l’utilisateur peut dériver une nouvelle classe à partir de celle-ci et améliorer le comportement.  
  
 Le <xref:System.ComponentModel.Design.DesignSurface> classe fournit automatiquement plusieurs services au moment du design. Le <xref:System.ComponentModel.Design.DesignSurface> classe ajoute tous ses services dans son constructeur. La plupart de ces services permettre être substituée en les remplaçant dans l’élément protégé <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> propriété. Pour remplacer un service, substituez le constructeur, appelez la base et apporter des modifications via l’élément protégé <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> propriété. Tous les services qui sont ajoutés au conteneur de service et qui implémentent <xref:System.IDisposable> sont supprimés lorsque l’aire de conception est supprimé. L’ensemble de remplaçables par défaut des services qui la <xref:System.ComponentModel.Design.DesignSurface> classe fournit est indiqué dans le tableau suivant.  
  
|Service|Description |  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IExtenderProviderService>|Permet aux objets qui ne font pas partie de la collection de composants du conteneur pour fournir leurs propres fournisseurs d’extendeurs.|  
|<xref:System.ComponentModel.Design.IExtenderListService>|Utilisé par <xref:System.ComponentModel.TypeDescriptor> pour obtenir une liste de fournisseurs d’extendeurs. Avec ce service, les fournisseurs d’extendeurs peuvent résider en dehors du conteneur.|  
|<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>|Fournit des accroches de métadonnées du concepteur. Il s’agit de l’interface principale pour le filtrage des métadonnées.|  
|<xref:System.ComponentModel.Design.ISelectionService>|Fournit un moyen de sélectionner des composants dans le concepteur.|  
|<xref:System.ComponentModel.Design.IReferenceService>|Fournit un moyen d’obtenir un nom pour les objets, même lorsque ces objets ne sont pas sur site.|  
|<xref:System.ComponentModel.Design.DesignSurface>|Offre l’aire de conception elle-même en tant que service.|  
|<xref:System.ComponentModel.Design.DesignerOptionService>|Fournit une classe de base pour l'obtention et la définition des valeurs des options d'un concepteur.|  
  
 Le tableau suivant montre les services non remplaçables fournis par défaut.  
  
|Service|Description |  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IComponentChangeService>|Déclenche des événements lorsque des modifications sont apportées aux composants.|  
|<xref:System.ComponentModel.Design.IDesignerHost>|Contrôle l’accès aux types, les services et les transactions. Interface principale des concepteurs.|  
|<xref:System.ComponentModel.IContainer>|Propriétaire du jeu de composants qui sont en cours de conception. Chaque concepteur possède un <xref:System.ComponentModel.IContainer> qui possède les composants.|  
|<xref:System.ComponentModel.Design.IServiceContainer>|Dérive de <xref:System.IServiceProvider> et fournit un moyen d’ajouter et supprimer des services dans le concepteur.|  
  
 En plus de ces services, le <xref:System.ComponentModel.Design.DesignSurface> classe fournit également un service unique qui est disponible via le site d’un composant. Ce service est unique pour chaque composant. Le tableau suivant montre les services qui ne peut pas être remplacés.  
  
|Service|Description |  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IDictionaryService>|Un dictionnaire générique de paires clé/valeur qui peut être utilisé pour stocker des données arbitraires sur un composant.|  
|<xref:System.ComponentModel.INestedContainer>|Un conteneur qui permet à un composant à ajouter des composants enfants supplémentaires au concepteur. Ces composants feront partie de l’aire de conception, mais ne pourra pas participer de sérialisation. Cela est utile lorsque vous souhaitez concevoir un contrôle qui est capable d’exposer une zone de lui-même dans un concepteur, mais vous ne souhaitez pas la région de participer de sérialisation.|  
  
 En plus de <xref:System.ComponentModel.ISite>, le site implémente également les interfaces suivantes.  
  
> [!CAUTION]
>  Vérifier l’existence de ces interfaces, plutôt que d’utiliser un casting aveugle, car d’autres implémentations de site ne peuvent pas implémenter les.  
  
|Service|Description |  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IServiceContainer>|Fournit un moyen d’obtenir dans le conteneur de services spécifiques au site. Par exemple, <xref:System.ComponentModel.Design.IDictionaryService> est un service spécifique au site. Avec ce service, vous pouvez ajouter des services supplémentaires spécifiques au site.|  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">pour un accès complet aux ressources système. Valeurs de demande : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />, <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. État associé :</permission>
    <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
    <altmember cref="T:System.IServiceProvider" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.DesignerLoader" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderService" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.ComponentModel.Design.IDesignerHost" /> joint à <see cref="T:System.ComponentModel.Design.DesignSurface" /> a été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (IServiceProvider parentProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider parentProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parentProvider As IServiceProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(IServiceProvider ^ parentProvider);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.DesignSurface : IServiceProvider -&gt; System.ComponentModel.Design.DesignSurface" Usage="new System.ComponentModel.Design.DesignSurface parentProvider" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parentProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="parentProvider">Fournisseur de services parent ou valeur <see langword="null" /> si aucun parent n'est utilisé pour résoudre des services.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque `parentProvide` est présent, concepteurs contenus dans la surface peuvent récupérer des services de l’application.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.ComponentModel.Design.IDesignerHost" /> joint à <see cref="T:System.ComponentModel.Design.DesignSurface" /> a été supprimé.</exception>
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(Type ^ rootComponentType);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.DesignSurface : Type -&gt; System.ComponentModel.Design.DesignSurface" Usage="new System.ComponentModel.Design.DesignSurface rootComponentType" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="rootComponentType">Type du composant racine à créer.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez le <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> constructeur, il crée un chargeur de concepteur simple qui, à son tour, crée un composant du type donné, puis se termine le processus de chargement. Il s’agit d’une méthode simple pour créer un concepteur, en supposant que tout l’enregistrement de l’état est effectuée en externe. En interne, ce code appelle <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> et transmet le type de composant racine.  
  
> [!NOTE]
>  Le <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> surcharge n’est pas affectée par <xref:System.Windows.Forms.Design.DesignerOptions>. Le <xref:System.Windows.Forms.Design.DesignerOptions> doit être dans le conteneur de service avant le charge de l’aire de conception. Si vous devez accéder à <xref:System.Windows.Forms.Design.DesignerOptions>, appelez le constructeur vide, ajoutez le <xref:System.Windows.Forms.Design.DesignerOptions> à la <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> et appelez <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> avec `rootComponentType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rootComponent" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.ComponentModel.Design.IDesignerHost" /> joint à <see cref="T:System.ComponentModel.Design.DesignSurface" /> a été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (IServiceProvider parentProvider, Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider parentProvider, class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.IServiceProvider,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parentProvider As IServiceProvider, rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(IServiceProvider ^ parentProvider, Type ^ rootComponentType);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.DesignSurface : IServiceProvider * Type -&gt; System.ComponentModel.Design.DesignSurface" Usage="new System.ComponentModel.Design.DesignSurface (parentProvider, rootComponentType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parentProvider" Type="System.IServiceProvider" />
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parentProvider">Fournisseur de services parent ou valeur <see langword="null" /> si aucun parent n'est utilisé pour résoudre des services.</param>
        <param name="rootComponentType">Type du composant racine à créer.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À l’aide de la <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> le constructeur crée un chargeur de concepteur simple qui crée un composant du type donné, puis termine le processus de chargement. Il s’agit d’une méthode simple pour créer un concepteur, en supposant que tout l’enregistrement de l’état est effectuée en externe. En interne, ce code appelle <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> et transmet le type de composant racine.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rootComponent" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.ComponentModel.Design.IDesignerHost" /> joint à <see cref="T:System.ComponentModel.Design.DesignSurface" /> a été supprimé.</exception>
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginLoad">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Commence le processus de chargement.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public void BeginLoad (System.ComponentModel.Design.Serialization.DesignerLoader loader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoad(class System.ComponentModel.Design.Serialization.DesignerLoader loader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.BeginLoad(System.ComponentModel.Design.Serialization.DesignerLoader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoad (loader As DesignerLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoad(System::ComponentModel::Design::Serialization::DesignerLoader ^ loader);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.ComponentModel.Design.Serialization.DesignerLoader -&gt; unit" Usage="designSurface.BeginLoad loader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loader" Type="System.ComponentModel.Design.Serialization.DesignerLoader" />
      </Parameters>
      <Docs>
        <param name="loader">Chargeur de concepteur à utiliser pour le chargement du concepteur.</param>
        <summary>Commence le processus de chargement par le chargeur de concepteur donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chargement du concepteur peut être asynchrone, afin que le chargement peut continuer à progresser après le retour de cet appel. Attacher un gestionnaire d’événements pour le <xref:System.ComponentModel.Design.IDesignerHost.LoadComplete> événement pour être averti lorsque le chargement est terminé à l’aire de conception.  
  
 Après avoir <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> est appelée, vous pouvez obtenir immédiatement l’affichage pour le concepteur, car des chargeurs de concepteur doivent fournir au moins le composant racine lors du chargement de façon asynchrone.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="loader" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.ComponentModel.Design.IDesignerHost" /> joint à <see cref="T:System.ComponentModel.Design.DesignSurface" /> a été supprimé.</exception>
        <altmember cref="T:System.ComponentModel.Design.Serialization.DesignerLoader" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderService" />
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public void BeginLoad (Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoad(class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.BeginLoad(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoad (rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoad(Type ^ rootComponentType);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : Type -&gt; unit" Usage="designSurface.BeginLoad rootComponentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="rootComponentType">Type de composant à créer en mode design.</param>
        <summary>Commence le processus de chargement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque `rootComponentType` est spécifié, un chargeur de concepteur par défaut qui crée simplement une instance de `rootComponentType` sera utilisé. Chargement du concepteur peut être asynchrone, afin que le chargement peut continuer à progresser après le retour de cet appel. Attacher un gestionnaire d’événements pour le <xref:System.ComponentModel.Design.IDesignerHost.LoadComplete> événement pour être averti lorsque le chargement est terminé à l’aire de conception.  
  
 Après avoir <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> est appelée, vous pouvez obtenir immédiatement l’affichage pour le concepteur, car des chargeurs de concepteur doivent fournir au moins le composant racine lors du chargement de façon asynchrone.  
  
> [!NOTE]
>  Le <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> méthode crée une instance du type de composant et initialise un concepteur pour cette instance. Le <xref:System.ComponentModel.Design.DesignSurface.Loaded> événement est déclenché avant le retour de cette méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rootComponentType" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.ComponentModel.Design.IDesignerHost" /> joint à <see cref="T:System.ComponentModel.Design.DesignSurface" /> a été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="ComponentContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.IContainer ComponentContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.IContainer ComponentContainer" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.ComponentContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ComponentContainer As IContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::IContainer ^ ComponentContainer { System::ComponentModel::IContainer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ComponentContainer : System.ComponentModel.IContainer" Usage="System.ComponentModel.Design.DesignSurface.ComponentContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'implémentation de <see cref="T:System.ComponentModel.IContainer" /> dans l'aire de conception.</summary>
        <value>Implémentation de <see cref="T:System.ComponentModel.IContainer" /> dans l'aire de conception.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.Design.DesignSurface.ComponentContainer%2A> propriété contient tous les objets qui sont actuellement en mode Création. Lorsque les composants sont ajoutés à <xref:System.ComponentModel.Design.DesignSurface.ComponentContainer%2A>, leur concepteur, le cas échéant, est chargé. Le composant est installé avec un site qui fournit un accès complet à l’aire de conception.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.ComponentModel.Design.IDesignerHost" /> joint à <see cref="T:System.ComponentModel.Design.DesignSurface" /> a été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateComponent">
      <MemberSignature Language="C#" Value="protected internal virtual System.ComponentModel.IComponent CreateComponent (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ComponentModel.IComponent CreateComponent(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateComponent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateComponent (componentType As Type) As IComponent" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::ComponentModel::IComponent ^ CreateComponent(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="abstract member CreateComponent : Type -&gt; System.ComponentModel.IComponent&#xA;override this.CreateComponent : Type -&gt; System.ComponentModel.IComponent" Usage="designSurface.CreateComponent componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("CreateComponent has been replaced by CreateInstance and will be removed after Beta2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComponent</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">Type du composant à créer.</param>
        <summary>Crée une instance d'un composant.</summary>
        <returns>Nouveau composant qui vient d'être créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.Design.DesignSurface.CreateComponent%2A> méthode est appelée par l’aire de conception <xref:System.ComponentModel.Design.IDesignerHost.CreateComponent%2A> méthode pour créer une instance d’un composant. Le composant doit être créé et ajouté au conteneur public sur l’aire de conception.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="componentType" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.ComponentModel.Design.IDesignerHost" /> joint à <see cref="T:System.ComponentModel.Design.DesignSurface" /> a été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDesigner">
      <MemberSignature Language="C#" Value="protected internal virtual System.ComponentModel.Design.IDesigner CreateDesigner (System.ComponentModel.IComponent component, bool rootDesigner);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ComponentModel.Design.IDesigner CreateDesigner(class System.ComponentModel.IComponent component, bool rootDesigner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateDesigner(System.ComponentModel.IComponent,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateDesigner (component As IComponent, rootDesigner As Boolean) As IDesigner" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::ComponentModel::Design::IDesigner ^ CreateDesigner(System::ComponentModel::IComponent ^ component, bool rootDesigner);" />
      <MemberSignature Language="F#" Value="abstract member CreateDesigner : System.ComponentModel.IComponent * bool -&gt; System.ComponentModel.Design.IDesigner&#xA;override this.CreateDesigner : System.ComponentModel.IComponent * bool -&gt; System.ComponentModel.Design.IDesigner" Usage="designSurface.CreateDesigner (component, rootDesigner)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.IDesigner</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
        <Parameter Name="rootDesigner" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Composant pour lequel le concepteur doit être créé.</param>
        <param name="rootDesigner"><see langword="true" /> pour créer un concepteur racine ; <see langword="false" /> pour créer un concepteur normal.</param>
        <summary>Crée un concepteur lorsqu'un composant est ajouté au conteneur.</summary>
        <returns>Instance du concepteur demandé ou <see langword="null" /> si un concepteur correspondant est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.Design.DesignSurface.CreateDesigner%2A> méthode est appelée par l’aire de conception <xref:System.ComponentModel.IContainer> lorsqu’un composant est ajouté au conteneur. Cette méthode crée un concepteur, mais n’est pas initialise. Lorsqu’elle retourne, le concepteur est initialisé par le conteneur.  
  
 <xref:System.ComponentModel.Design.DesignSurface.CreateDesigner%2A> peut créer deux types de concepteurs différents : concepteurs racine et concepteurs normaux. Un concepteur racine est un concepteur pour le composant racine dans l’aire de conception, qui, par définition, est le premier composant ajouté au conteneur. Les concepteurs racine diffèrent des concepteurs normaux, car ils sont responsables de l’interface utilisateur présentée à l’utilisateur final. Généralement, les concepteurs racine coordonnent avec le reste des concepteurs sur une aire de conception pour fournir cette interface.  
  
 L’implémentation par défaut de cette méthode délègue à <xref:System.ComponentModel.TypeDescriptor>, en passant dans <xref:System.ComponentModel.Design.IRootDesigner> comme type de concepteur pour les concepteurs racine ou <xref:System.ComponentModel.Design.IDesigner> pour les concepteurs normaux. Vous pouvez substituer cette méthode pour demander un type spécifique de concepteur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="component" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.ComponentModel.Design.IDesignerHost" /> joint à <see cref="T:System.ComponentModel.Design.DesignSurface" /> a été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected internal virtual object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : Type -&gt; obj&#xA;override this.CreateInstance : Type -&gt; obj" Usage="designSurface.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Type à créer.</param>
        <summary>Crée une instance du type donné.</summary>
        <returns>Objet nouvellement créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `type` est un <xref:System.ComponentModel.IComponent>, <xref:System.ComponentModel.Design.DesignSurface.CreateInstance%2A> recherche un constructeur de type <xref:System.ComponentModel.IContainer> tout d’abord, suivie d’un constructeur vide.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.ComponentModel.Design.IDesignerHost" /> joint à <see cref="T:System.ComponentModel.Design.DesignSurface" /> a été supprimé.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNestedContainer">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un conteneur approprié à l'imbrication de contrôles ou de composants.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNestedContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.INestedContainer CreateNestedContainer (System.ComponentModel.IComponent owningComponent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.INestedContainer CreateNestedContainer(class System.ComponentModel.IComponent owningComponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateNestedContainer(System.ComponentModel.IComponent)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateNestedContainer (owningComponent As IComponent) As INestedContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::INestedContainer ^ CreateNestedContainer(System::ComponentModel::IComponent ^ owningComponent);" />
      <MemberSignature Language="F#" Value="member this.CreateNestedContainer : System.ComponentModel.IComponent -&gt; System.ComponentModel.INestedContainer" Usage="designSurface.CreateNestedContainer owningComponent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.INestedContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owningComponent" Type="System.ComponentModel.IComponent" />
      </Parameters>
      <Docs>
        <param name="owningComponent">Composant qui gère le conteneur imbriqué.</param>
        <summary>Crée un conteneur approprié à l'imbrication de contrôles ou de composants.</summary>
        <returns>Conteneur imbriqué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ajout d’un composant à un conteneur imbriqué crée son concepteur et le rend éligibles pour tous les services disponibles à partir de l’aire de conception. Composants ajoutés aux conteneurs imbriqués ne participent pas de sérialisation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="owningComponent" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.ComponentModel.Design.IDesignerHost" /> joint à <see cref="T:System.ComponentModel.Design.DesignSurface" /> a été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNestedContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.INestedContainer CreateNestedContainer (System.ComponentModel.IComponent owningComponent, string containerName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.INestedContainer CreateNestedContainer(class System.ComponentModel.IComponent owningComponent, string containerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateNestedContainer(System.ComponentModel.IComponent,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateNestedContainer (owningComponent As IComponent, containerName As String) As INestedContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::INestedContainer ^ CreateNestedContainer(System::ComponentModel::IComponent ^ owningComponent, System::String ^ containerName);" />
      <MemberSignature Language="F#" Value="member this.CreateNestedContainer : System.ComponentModel.IComponent * string -&gt; System.ComponentModel.INestedContainer" Usage="designSurface.CreateNestedContainer (owningComponent, containerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.INestedContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owningComponent" Type="System.ComponentModel.IComponent" />
        <Parameter Name="containerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="owningComponent">Composant qui gère le conteneur imbriqué.</param>
        <param name="containerName">Nom supplémentaire pour le conteneur imbriqué.</param>
        <summary>Crée un conteneur approprié à l'imbrication de contrôles ou de composants.</summary>
        <returns>Conteneur imbriqué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ajout d’un composant à un conteneur imbriqué crée son concepteur et le rend éligibles pour tous les services disponibles à partir de l’aire de conception. Composants ajoutés aux conteneurs imbriqués ne participent pas de sérialisation.  
  
 Vous pouvez fournir un nom supplémentaire pour le <xref:System.ComponentModel.Design.DesignSurface.CreateNestedContainer%2A> méthode en transmettant une valeur dans `containerName`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="owningComponent" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.ComponentModel.Design.IDesignerHost" /> joint à <see cref="T:System.ComponentModel.Design.DesignSurface" /> a été supprimé.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère les ressources utilisées par le <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="designSurface.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources utilisées par le <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Public <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> méthode respecte la norme <xref:System.IDisposable> modèle. Appel de cette méthode détruit l’aire de conception. La version protégée de cette méthode est `virtual` et suit la normale <xref:System.IDisposable> modèle.  
  
> [!NOTE]
>  Étant donné que <xref:System.ComponentModel.Design.DesignSurface> n’a pas de code natif à nettoyer, il n’a pas un finaliseur qui appelle la méthode <xref:System.ComponentModel.Design.DesignSurface.Dispose%28System.Boolean%29>. Si vous devez appeler <xref:System.ComponentModel.Design.DesignSurface.Dispose%28System.Boolean%29>, vous devez ajouter un finaliseur vous-même.  
  
 Appelez la méthode <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> une fois que vous avez terminé d'utiliser <xref:System.ComponentModel.Design.DesignSurface>. La méthode <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> rend le <xref:System.ComponentModel.Design.DesignSurface> inutilisable. Après avoir appelé <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>, vous devez libérer toutes les références à la <xref:System.ComponentModel.Design.DesignSurface> pour que le garbage collector puisse récupérer la mémoire qui le <xref:System.ComponentModel.Design.DesignSurface> occupée. Pour plus d’informations, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Appelez toujours <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> avant de libérer votre dernière référence à <xref:System.ComponentModel.Design.DesignSurface>. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.ComponentModel.Design.DesignSurface> de l'objet `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="designSurface.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources utilisées par le <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Public <xref:System.ComponentModel.Design.DesignSurface.Dispose> méthode respecte la norme <xref:System.IDisposable> modèle. Appel de cette méthode détruit l’aire de conception. La version protégée de cette méthode est `virtual` et suit la normale <xref:System.IDisposable> modèle.  
  
> [!NOTE]
>  Étant donné que <xref:System.ComponentModel.Design.DesignSurface> n’a pas de code natif à nettoyer, il n’a pas un finaliseur qui appelle la méthode <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>. Si vous devez appeler <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>, vous devez ajouter un finaliseur vous-même.  
  
 Cette méthode est appelée par le public `Dispose()` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose()` appelle la méthode protégée `Dispose(Boolean)` méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` défini sur `false`.  
  
 Lorsque le `disposing` paramètre est true, cette méthode libère toutes les ressources détenues par les objets managés par ce <xref:System.ComponentModel.Design.DesignSurface> références. Cette méthode appelle la méthode `Dispose()` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution <see langword="Dispose(Boolean)" /> veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Disposed;" />
      <MemberSignature Language="F#" Value="member this.Disposed : EventHandler " Usage="member this.Disposed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'aire de conception est supprimée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La surface n’est supprimé lorsque le public <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> méthode sur <xref:System.ComponentModel.Design.DesignSurface> est appelée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DtelLoading">
      <MemberSignature Language="C#" Value="public bool DtelLoading { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DtelLoading" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.DtelLoading" />
      <MemberSignature Language="VB.NET" Value="Public Property DtelLoading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DtelLoading { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DtelLoading : bool with get, set" Usage="System.ComponentModel.Design.DesignSurface.DtelLoading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la **Liste d’erreurs au moment du design** se charge.</summary>
        <value><see langword="true" /> Si le **liste d’erreurs au moment du Design** se charge ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ad408380-825a-46d8-9a4a-531b130b88ce">Erreurs au moment du design dans le Concepteur Windows Forms</related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="designSurface.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sérialise des modifications dans l'aire de conception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> méthode peut être appelée pour transmettre les modifications apportées à l’aire de conception dans le sérialiseur. Cela garantit que l’aire de conception et son état sérialisé sont synchronisés. L’implémentation réelle de cette méthode est transférée au chargeur de concepteur associé à surface de conception. Le chargeur de concepteur peut choisir de différer des modifications jusqu'à ce que <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> est appelée, ou il peut choisir de conserver les données sérialisées à jour avec toutes les modifications de l’utilisateur. Le <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> méthode garantit que, quel que soit le modèle que le chargeur de concepteur choisit d’utiliser, l’état sérialisé est synchronisé avec l’aire de conception réelle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flushed">
      <MemberSignature Language="C#" Value="public event EventHandler Flushed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Flushed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Flushed" />
      <MemberSignature Language="VB.NET" Value="Public Event Flushed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Flushed;" />
      <MemberSignature Language="F#" Value="member this.Flushed : EventHandler " Usage="member this.Flushed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la méthode <see cref="M:System.ComponentModel.Design.DesignSurface.Flush" /> de <see cref="T:System.ComponentModel.Design.DesignSurface" /> est appelée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le chargeur de concepteur est vidé tout d’abord, puis le <xref:System.ComponentModel.Design.DesignSurface.Flushed> événement est déclenché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="public object GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetService (serviceType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetService(Type ^ serviceType);" />
      <MemberSignature Language="F#" Value="abstract member GetService : Type -&gt; obj&#xA;override this.GetService : Type -&gt; obj" Usage="designSurface.GetService serviceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">Type de service à récupérer.</param>
        <summary>Obtient un service du conteneur de services.</summary>
        <returns>Objet qui implémente <paramref name="serviceType" /> ou en est une classe dérivée ou <see langword="null" /> si le service n'existe pas dans le conteneur de services.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.Design.DesignSurface.GetService%2A> méthode récupère un service dans le conteneur de service de l’aire de conception. En outre, il transmet à n’importe quel fournisseur de service qui a été donné à l’aire de conception au moment de la construction.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.ComponentModel.Design.DesignSurface.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'aire de conception est actuellement chargée.</summary>
        <value><see langword="true" /> si l'aire de conception est actuellement chargée ; <see langword="false" /> dans le cas contraire.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.Design.LoadedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.Design.LoadedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Event Loaded As LoadedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::Design::LoadedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.ComponentModel.Design.LoadedEventHandler " Usage="member this.Loaded : System.ComponentModel.Design.LoadedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.LoadedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le chargement du concepteur est terminé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.Design.DesignSurface.Loaded> événement est déclenché pour les chargements réussis ainsi que d’échec. Si le code dans ce gestionnaire d’événements lève une exception, le concepteur est déchargé.  
  
 Le <xref:System.ComponentModel.Design.LoadedEventArgs> objet peut être utilisé pour déterminer si le chargement a réussi, et il peut également fournir une liste d’erreurs qui se sont produites lors du chargement.  
  
> [!NOTE]
>  Erreurs peuvent se produire pour les chargements réussis, autant que le système de sérialisation peut tolérer des erreurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadErrors">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection LoadErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection LoadErrors" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.LoadErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LoadErrors As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ LoadErrors { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LoadErrors : System.Collections.ICollection" Usage="System.ComponentModel.Design.DesignSurface.LoadErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne une collection d'erreurs de chargement ou une collection vide.</summary>
        <value><see cref="T:System.Collections.ICollection" /> d'erreurs de chargement.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loading">
      <MemberSignature Language="C#" Value="public event EventHandler Loading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Loading" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Loading" />
      <MemberSignature Language="VB.NET" Value="Public Event Loading As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Loading;" />
      <MemberSignature Language="F#" Value="member this.Loading : EventHandler " Usage="member this.Loading : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le concepteur est sur le point d'être chargé.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoaded">
      <MemberSignature Language="C#" Value="protected virtual void OnLoaded (System.ComponentModel.Design.LoadedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoaded(class System.ComponentModel.Design.LoadedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnLoaded(System.ComponentModel.Design.LoadedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoaded (e As LoadedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoaded(System::ComponentModel::Design::LoadedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoaded : System.ComponentModel.Design.LoadedEventArgs -&gt; unit&#xA;override this.OnLoaded : System.ComponentModel.Design.LoadedEventArgs -&gt; unit" Usage="designSurface.OnLoaded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.Design.LoadedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.ComponentModel.Design.LoadedEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.Design.DesignSurface.Loaded" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoading">
      <MemberSignature Language="C#" Value="protected virtual void OnLoading (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoading(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnLoading(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoading (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoading(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoading : EventArgs -&gt; unit&#xA;override this.OnLoading : EventArgs -&gt; unit" Usage="designSurface.OnLoading e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.Design.DesignSurface.Loading" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnloaded">
      <MemberSignature Language="C#" Value="protected virtual void OnUnloaded (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUnloaded(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnUnloaded(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnUnloaded (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnUnloaded(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnloaded : EventArgs -&gt; unit&#xA;override this.OnUnloaded : EventArgs -&gt; unit" Usage="designSurface.OnUnloaded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.Design.DesignSurface.Unloaded" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnloading">
      <MemberSignature Language="C#" Value="protected virtual void OnUnloading (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUnloading(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnUnloading(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnUnloading (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnUnloading(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnloading : EventArgs -&gt; unit&#xA;override this.OnUnloading : EventArgs -&gt; unit" Usage="designSurface.OnUnloading e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.Design.DesignSurface.Unloading" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnViewActivate">
      <MemberSignature Language="C#" Value="protected virtual void OnViewActivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnViewActivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnViewActivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnViewActivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnViewActivate(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnViewActivate : EventArgs -&gt; unit&#xA;override this.OnViewActivate : EventArgs -&gt; unit" Usage="designSurface.OnViewActivate e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.Design.DesignSurface.ViewActivated" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceContainer">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.Design.ServiceContainer ServiceContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.Design.ServiceContainer ServiceContainer" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.ServiceContainer" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceContainer As ServiceContainer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::ComponentModel::Design::ServiceContainer ^ ServiceContainer { System::ComponentModel::Design::ServiceContainer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceContainer : System.ComponentModel.Design.ServiceContainer" Usage="System.ComponentModel.Design.DesignSurface.ServiceContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.ServiceContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le conteneur de services.</summary>
        <value>Conteneur de services qui fournit tous les services aux concepteurs contenus dans l'aire de conception.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au moment de la construction, <xref:System.ComponentModel.Design.DesignSurface> ajoute des services par défaut dans ce conteneur de service. Vous pouvez laisser les services par défaut dans leur état actuel, ou vous pouvez les supprimer et remplacez-les par les vôtres. Les services par défaut sont tout de création à la demande, il n’existe aucune perte des performances pour les ajouter au moment de la construction.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.ComponentModel.Design.IDesignerHost" /> joint à <see cref="T:System.ComponentModel.Design.DesignSurface" /> a été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event EventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Event Unloaded As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : EventHandler " Usage="member this.Unloaded : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un concepteur a terminé un déchargement.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unloading">
      <MemberSignature Language="C#" Value="public event EventHandler Unloading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unloading" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Unloading" />
      <MemberSignature Language="VB.NET" Value="Public Event Unloading As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unloading;" />
      <MemberSignature Language="F#" Value="member this.Unloading : EventHandler " Usage="member this.Unloading : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un concepteur est sur le point de décharger.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un concepteur décharge, l’état complet de ce concepteur est détruit, y compris la vue du concepteur. La vue doit être non apparentée à ce stade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="View">
      <MemberSignature Language="C#" Value="public object View { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object View" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.View" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property View As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ View { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.View : obj" Usage="System.ComponentModel.Design.DesignSurface.View" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'affichage du concepteur racine.</summary>
        <value>Affichage du concepteur racine.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> méthode doit être appelée à l’avance pour démarrer le processus de chargement. Il est possible de renvoyer un affichage avant que le chargeur de concepteur termine le chargement, car le concepteur racine, qui fournit l’affichage, est le premier objet créé par le chargeur de concepteur. Si une vue n’est pas disponible, <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> lève une exception.  
  
 La notion d’une technologie d’affichage est obsolète. Toutefois, il reste dans les interfaces pour les concepteurs racine pour la compatibilité descendante. Son utilisation est masquée à l’aide <xref:System.ComponentModel.Design.DesignSurface> objets. Le <xref:System.ComponentModel.Design.DesignSurface.View%2A> propriété masque les technologies d’affichage en passant les technologies prises en charge dans le concepteur racine.  
  
   
  
## Examples  
 Le code suivant montre l’exemple comment <xref:System.ComponentModel.Design.DesignSurface.View%2A> masque les technologies d’affichage.  
  
 ```csharp 
 IRootDesigner d;  
  
 ViewTechnology[] supported = d.SupportedTechnologies;  
  
 return d.GetView(supported[0]);
 ``` 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'aire de conception ne se charge pas, le chargeur du concepteur n'a pas encore créé de concepteur racine ou l'aire de conception a fini le chargement, mais ne l'a pas réussi. Plus d'informations sont disponibles dans <see cref="P:System.Exception.InnerException" />.</exception>
        <exception cref="T:System.NotSupportedException">Le concepteur est chargé mais n'offre aucune vue compatible avec cette aire de conception.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.ComponentModel.Design.IDesignerHost" /> joint à <see cref="T:System.ComponentModel.Design.DesignSurface" /> a été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ViewActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ViewActivated" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.ViewActivated" />
      <MemberSignature Language="VB.NET" Value="Public Event ViewActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ViewActivated;" />
      <MemberSignature Language="F#" Value="member this.ViewActivated : EventHandler " Usage="member this.ViewActivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la méthode <see cref="M:System.ComponentModel.Design.IDesignerHost.Activate" /> a été appelée sur <see cref="T:System.ComponentModel.Design.IDesignerHost" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous souhaitez prendre en charge le <xref:System.ComponentModel.Design.IDesignerHost.Activate%2A> (méthode), votre gestionnaire d’événements doit activer la fenêtre de cette aire de conception.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
      </Docs>
    </Member>
  </Members>
</Type>