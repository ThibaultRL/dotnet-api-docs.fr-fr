<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6eccab7743830eb390cf2966272244bf716e11b3" /><Meta Name="ms.sourcegitcommit" Value="75eca440f8f4d595506405f48961f38649e160d7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="06/01/2019" /><Meta Name="ms.locfileid" Value="66457974" /></Metadata><TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un objet qui gère les tâches de bas niveau de la mise en file d'attente de tâches sur des threads.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une instance de la <xref:System.Threading.Tasks.TaskScheduler> classe représente un planificateur de tâches. Un planificateur de tâches s’assure que le travail d’une tâche est finalement exécuté.  
  
 Le planificateur de tâches par défaut est basé sur le pool de threads .NET Framework 4, qui fournit le vol de travail pour l'équilibrage de charge, l'injection/retrait du thread  pour un débit maximal et une bonne performance globale. Ce doit être suffisant pour la plupart des scénarios.  
  
 Le <xref:System.Threading.Tasks.TaskScheduler> classe sert également le point d’extension pour toute logique de planification personnalisable.  Cela inclut des mécanismes tels que comment planifier une tâche pour l’exécution et les tâches planifiées comment doit être exposée aux débogueurs. Si vous avez besoin des fonctionnalités spéciales, vous pouvez créer un planificateur personnalisé et l’activer pour des tâches spécifiques ou des requêtes.  
  
 Dans cette rubrique :  
[Le Planificateur de tâches par défaut et le pool de threads](#Default)  
 [La file d’attente globale et les files d’attente locales](#Queues)  
 [Vol de travail](#Stealing)  
 [Tâches longues](#LongRunning)  
 [Incorporation de tâche](#Inlining)  
[Spécification d’un contexte de synchronisation](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a>Le Planificateur de tâches par défaut et le pool de threads  
 Le planificateur par défaut pour la bibliothèque parallèle de tâches et PLINQ utilise le pool de threads .NET Framework, qui est représenté par le <xref:System.Threading.ThreadPool> (classe), à la file d’attente et les exécuter. Le pool de threads utilise les informations fournies par le <xref:System.Threading.Tasks.Task> type à prendre en charge efficacement le parallélisme affiné (unités éphémères de travail) et les tâches parallèles requêtes souvent représentent.  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a>La file d’attente globale et les files d’attente locales  
 Le pool de threads gère une globale premier entré, premier sorti (FIFO) fonctionnent de la file d’attente pour les threads dans chaque domaine d’application. Chaque fois qu’un programme appelle la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (ou <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) (méthode), le travail est dans cette file d’attente partagée et finalement retirer en file d’attente vers le thread suivant qui devient disponible. À compter de .NET Framework 4, cette file d’attente a été améliorée pour utiliser un algorithme sans verrou qui ressemble à la <xref:System.Collections.Concurrent.ConcurrentQueue%601> classe. À l’aide de cette implémentation sans verrou, le pool de threads passe moins de temps quand il met et enlève les éléments de travail. Ce gain de performances est disponible pour tous les programmes qui utilisent le pool de threads.  
  
 Les tâches de niveau supérieur, qui ne sont pas créées dans le contexte d’une autre tâche, sont mises en file d’attente globale comme tout autre élément de travail. Toutefois, les tâches imbriquées ou enfants, créées dans le contexte d'une autre tâche, sont gérées tout à fait différemment. Une tâche enfant ou imbriquée est placée dans une file d'attente locale qui est spécifique au thread sur lequel s'exécute la tâche parente. La tâche parente peut être une tâche de niveau supérieur ou l'enfant d'une autre tâche. Quand ce thread est prêt pour exécuter davantage de travail, il regarde en premier dans la file d'attente locale. Les éléments de travail qui s’y trouvent éventuellement peuvent être récupérés rapidement. Les files d’attente locales sont accessibles par ordre dernier entré, premier sorti (LIFO) pour conserver la localité de cache et de réduire la contention. Pour plus d’informations sur les tâches enfants et imbriquées, consultez [détachée tâches enfants attachées et](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).  
  
 L’utilisation de files d’attente locales non seulement réduit la pression sur la file d’attente globale, mais tire également parti de la localité des données. Éléments de travail local de file d’attente fréquemment des structures de données de référence qui sont physiquement près d’eux en mémoire. Dans ce cas, les données sont déjà dans le cache après que la première tâche a exécuté et sont accessibles rapidement. Les deux [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) et <xref:System.Threading.Tasks.Parallel> largement de classe utilisent des tâches imbriquées et tâches enfants et accomplissent des accélérations significatives à l’aide de files d’attente de travail locale.  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a>Vol de travail  
 À compter de .NET Framework 4, le pool de threads propose également un algorithme de vol de travail pour s’assurer qu’aucun thread ne soit inactif alors que d’autres ont du travail dans leurs files d’attente. Quand un thread de pool de threads est prêt à effectuer davantage de travail, il regarde successivement en tête de sa file d'attente locale, dans la file d'attente globale, puis dans les files d'attente locales d'autres threads. S’il trouve un élément de travail dans la file d’attente locale d’un autre thread, il applique d’abord des méthodes heuristiques pour s’assurer qu’il peut exécuter le travail efficacement. Si possible, il enlève l’élément de travail à partir de la fin (dans l’ordre FIFO). Cela réduit les conflits sur chaque file d'attente locale et permet de conserver la localité des données. Cette architecture permet le thread pool équilibrer la charge de travailler de manière plus efficace que dans les versions précédentes.  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a>Tâches longues  
 Vous pouvez explicitement empêcher une tâche d’être mise en file d’attente locale. Par exemple, vous savez peut-être qu'un élément de travail particulier fonctionnera pour une durée relativement longue et sera à même de bloquer tous les autres éléments de travail sur la file d'attente locale. Dans ce cas, vous pouvez spécifier l’option <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>, qui indique au planificateur qu’un thread supplémentaire peut être nécessaire pour la tâche afin qu’elle n’entrave pas la progression d’autres threads ou éléments de travail sur la file d’attente locale. À l’aide de cette option vous évitez le pool de threads complètement, d’inclure les files d’attente locales et globales.  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a>Incorporation de tâche  
 Dans certains cas, quand un <xref:System.Threading.Tasks.Task> est attendue, elle peut être exécutée de façon synchrone sur le thread qui effectue l’opération d’attente. Cela améliore les performances en éliminant la nécessité d’un thread supplémentaire et à la place à l’aide du thread existant, qui aurait sinon bloqués. Pour éviter des erreurs en raison de la réentrance, incorporation de tâche se produit uniquement lorsque la cible d’attente se trouve dans la file d’attente locale du thread pertinent.  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a>Spécification d’un contexte de synchronisation  
 Vous pouvez utiliser la méthode <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> pour spécifier qu’une tâche doit être planifiée pour fonctionner sur un thread particulier. Cela s'avère utile dans les infrastructures telles que Windows Forms et Windows Presentation Foundation où l'accès aux objets d'interface utilisateur est souvent restreint au code qui s'exécute sur le thread sur lequel l'objet d'interface utilisateur a été créé.  
  
 L’exemple suivant utilise la <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> méthode dans une application Windows Presentation Foundation (WPF) pour planifier une tâche sur le même thread que le contrôle d’interface utilisateur utilisateur a été créé.   L’exemple crée une mosaïque d’images qui sont sélectionnées au hasard à partir d’un répertoire spécifié. Les objets WPF sont utilisés pour charger et redimensionner les images. Les pixels bruts sont ensuite transmis à une tâche qui utilise un <xref:System.Threading.Tasks.Parallel.For%2A> boucle pour écrire les données de pixels dans un grand tableau d’un octet. Aucune synchronisation n’est requise car aucun deux vignettes n’occupent les mêmes éléments de tableau. Les vignettes peuvent également être écrits dans n’importe quel ordre, car leur position est calculée indépendamment de toute autre vignette. Le grand tableau est ensuite transmis à une tâche qui s’exécute sur le thread d’interface utilisateur, dans lequel les données de pixels sont chargées dans un contrôle Image.  
  
 L’exemple déplace les données du thread d’interface utilisateur, il modifie à l’aide de boucles parallèles et <xref:System.Threading.Tasks.Task> objets et il repasse ensuite à une tâche qui s’exécute sur le thread d’interface utilisateur. Cette approche est utile lorsque vous devez utiliser la bibliothèque parallèle de tâches pour effectuer des opérations qui ne sont pas pris en charge par l’API WPF, ou ne sont pas suffisamment rapides. Une autre façon de créer une mosaïque d’images dans WPF consiste à utiliser un <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> contrôler et ajouter des images. Le <xref:System.Windows.Controls.WrapPanel> gère le travail de positionnement des mosaïques. Toutefois, ce travail peut uniquement être effectué sur le thread d’interface utilisateur.  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 Pour créer l’exemple, créez un projet d’application WPF dans Visual Studio et nommez-le WPF_CS1 (pour un C# projet WPF) ou WPF_VB1 (pour un projet WPF de Visual Basic). Procédez comme suit :  
  
1. En mode conception, faites glisser un <xref:System.Windows.Controls.Image> contrôle depuis la **boîte à outils** sur le coin supérieur gauche de l’aire de conception. Dans le **nom** zone de texte de la **propriétés** fenêtre, le nom de l’image « contrôle ».    
  
2. Faites glisser un <xref:System.Windows.Controls.Button> contrôle depuis la **boîte à outils** à la partie inférieure gauche de la fenêtre d’application. Dans la vue XAML, spécifiez la <xref:System.Windows.Controls.ContentControl.Content%2A> propriété du bouton comme « Make une mosaïque » et spécifiez son <xref:System.Windows.FrameworkElement.Width> propriété en tant que « 100 ». Connecter le <xref:System.Windows.Controls.Primitives.ButtonBase.Click> événement avec le `button_Click` Gestionnaire d’événements défini dans le code de cet exemple en ajoutant `Click="button_Click"` à la `<Button>` élément. Dans le **nom** zone de texte de la **propriétés** fenêtre, le nom du bouton « contrôle ».  
  
3. Remplacez tout le contenu du fichier MainWindow.xaml.cs ou MainWindow.xaml.vb par le code à partir de cet exemple. Pour un C# WPF de projet, assurez-vous que le nom de l’espace de travail correspond au nom de projet. 
  
4. L’exemple lit les images JPEG à partir d’un répertoire nommé C:\Users\Public\Pictures\Sample images\\. Créer le répertoire et placer des images qu’il contient ou modifier le chemin d’accès pour faire référence à un autre annuaire qui contient des images. 
  
Cet exemple présente certaines limitations. Par exemple, les images de seulement 32-bits par pixel sont prises en charge ; les images dans d’autres formats sont endommagées par le <xref:System.Windows.Media.Imaging.BitmapImage> l’objet au cours de l’opération de redimensionnement. En outre, les images de la source doivent tous être supérieure à la taille de vignette. En guise d’exercice supplémentaire, vous pouvez ajouter la fonctionnalité permettant de gérer plusieurs formats de pixels et tailles de fichiers.  
  
## Examples  
 L’exemple suivant provient de la [exemples de programmation parallèle avec .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) sur le site Web MSDN Code Gallery.  Il crée un planificateur de tâches personnalisée qui limite le nombre de threads utilisés par l’application. Ensuite, il lance les deux ensembles de tâches et affiche des informations sur la tâche et le thread sur lequel la tâche s’exécute.  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 En outre, plusieurs exemples de planificateurs de tâches sont disponibles dans la galerie de Code : [Exemples de programmation parallèle avec .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).  
  
 ]]></format>
    </remarks>
    <threadsafe>Tous les membres de l’abstraite <see cref="T:System.Threading.Tasks.TaskScheduler" /> type sont thread-safe et peuvent être utilisés à partir de plusieurs threads simultanément.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise la <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Threading.Tasks.TaskScheduler" /> associé à la tâche en cours d'exécution.</summary>
        <value>Retourne le <see cref="T:System.Threading.Tasks.TaskScheduler" /> associé à la tâche en cours d'exécution.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque ne pas appelé à partir d’une tâche, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> retournera le <xref:System.Threading.Tasks.TaskScheduler.Default%2A> planificateur.  
  
 Pour plus d'informations, consultez <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'instance de <see cref="T:System.Threading.Tasks.TaskScheduler" /> par défaut fournie par le .NET Framework.</summary>
        <value>Retourne l'instance par défaut de <see cref="T:System.Threading.Tasks.TaskScheduler" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations, consultez <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources associées à ce planificateur.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un <see cref="T:System.Threading.Tasks.TaskScheduler" /> associé au <see cref="T:System.Threading.SynchronizationContext" /> en cours.</summary>
        <returns><see cref="T:System.Threading.Tasks.TaskScheduler" /> associé au <see cref="T:System.Threading.SynchronizationContext" /> actuel, comme le détermine <see cref="P:System.Threading.SynchronizationContext.Current" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tous les <xref:System.Threading.Tasks.Task> en file d’attente des instances à retourné planificateur est exécuté via un appel à la <xref:System.Threading.SynchronizationContext.Post%2A> méthode sur ce contexte.  
  
 Pour plus d'informations, consultez <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le SynchronizationContext actuel ne peut pas être utilisé en tant que TaskScheduler.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pour la prise en charge du débogueur uniquement, génère un énumérateur d'instances de <see cref="T:System.Threading.Tasks.Task" /> actuellement en attente d'exécution dans la file d'attente sur le planificateur.</summary>
        <returns>Énumérateur qui autorise un débogueur à parcourir les tâches actuellement mises en file d'attente sur ce planificateur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une classe dérivée de <xref:System.Threading.Tasks.TaskScheduler> implémente cette méthode pour prendre en charge l’intégration avec les débogueurs. Cette méthode est uniquement être appelée par le .NET Framework lorsque le débogueur demande l’accès aux données. L’énumérable renvoyé seront parcourus par des utilitaires de débogage pour accéder aux tâches actuellement en file d’attente sur ce planificateur, l’activation du débogueur fournir une représentation de ces informations dans l’interface utilisateur.  
  
 Il est important de noter que, lorsque cette méthode est appelée, tous les autres threads dans le processus seront figées. Par conséquent, il est important d’éviter la synchronisation avec d’autres threads qui peuvent mener au blocage. Si la synchronisation est nécessaire, et vous ne pouvez pas acquérir le verrou dans cette méthode, vous devez lever une exception afin que le débogueur ne bloque pas. L’exemple suivant montre une approche possible en c# :
  
```csharp
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 En outre, cette méthode et l’énumérable retourné ne devez modifier n’importe quel état visible globalement.  
  
 L’énumérable retourné ne doit jamais être null. S’il n’y a actuellement aucune tâche en file d’attente, un énumérable vide doit être retourné à la place.  
  
 Les développeurs qui implémentent des débogueurs personnalisés ne doivent pas appeler cette méthode directement, mais devez utiliser la méthode de wrapper interne `GetScheduledTasksForDebugger` à la place : `internal Task[] GetScheduledTasksForDebugger()`. Cette méthode de wrapper retourne un tableau de tâches au lieu d’une collection énumérable. Pour récupérer une liste de planificateurs actifs, utilisez la méthode interne `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`. Cette méthode statique retourne un tableau de toutes les actives <xref:System.Threading.Tasks.TaskScheduler> instances. Vous pouvez ensuite utiliser `GetScheduledTasksForDebugger` sur chaque instance du planificateur pour récupérer sa liste de tâches planifiées.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ce planificateur ne peut pas générer une liste de tâches en file d'attente actuellement.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'ID unique pour ce <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <value>Retourne l'ID unique de ce <see cref="T:System.Threading.Tasks.TaskScheduler" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations, consultez <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique le niveau d'accès concurrentiel maximal que ce <see cref="T:System.Threading.Tasks.TaskScheduler" /> peut prendre en charge.</summary>
        <value>Retourne un entier qui représente le niveau d'accès concurrentiel maximal. Le planificateur par défaut retourne <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations, consultez <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><see cref="T:System.Threading.Tasks.Task" /> à mettre en file d'attente.</param>
        <summary>Met en file d'attente une <see cref="T:System.Threading.Tasks.Task" /> sur le planificateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une classe dérivée de <xref:System.Threading.Tasks.TaskScheduler> implémente cette méthode pour accepter les tâches planifiées sur le planificateur.  
  
 Une implémentation classique stockerait la tâche dans une structure de données interne, gérée par des threads qui s’exécuteraient ces tâches à un moment dans le futur.  
  
 Cette méthode est uniquement destinée à être appelé par le .NET Framework et ne doit pas être appelée directement par la classe dérivée. Cela est nécessaire pour conserver la cohérence du système.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="task" /> a la valeur null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><see cref="T:System.Threading.Tasks.Task" /> à sortir de la file d'attente.</param>
        <summary>Tente de sortir de la file d'attente une <see cref="T:System.Threading.Tasks.Task" /> qui était précédemment dans la file d'attente de ce planificateur.</summary>
        <returns>Valeur booléenne qui indique si l'argument <paramref name="task" /> a bien été retiré de la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations, consultez <xref:System.Threading.Tasks.TaskScheduler>.  
  
 Cette méthode peut s’exécuter dans un bloc finally ; Par conséquent, elle doit retourner aussi rapidement que possible afin que des ressources telles que <xref:System.Threading.CancellationTokenRegistration> objets puissent être supprimées en temps voulu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="task" /> a la valeur null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Objet <see cref="T:System.Threading.Tasks.Task" /> à exécuter.</param>
        <summary>Tente d'exécuter la <see cref="T:System.Threading.Tasks.Task" /> fournie sur ce planificateur.</summary>
        <returns>Valeur booléenne true si la <paramref name="task" /> a été exécutée avec succès ; false, dans le cas contraire. L'échec de l'exécution est souvent dû au fait que la tâche a déjà été exécutée ou qu'elle est en cours d'exécution par un autre thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les implémentations de planificateur sont fournies avec <xref:System.Threading.Tasks.Task> instances à exécuter via la <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> méthode ou le <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> (méthode). Lorsque le planificateur juge approprié d’exécuter la tâche fournie, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> doit être utilisé pour le faire. TryExecuteTask gère tous les aspects de l’exécution d’une tâche, y compris l’invocation d’action, la gestion des exceptions, la gestion d’état et contrôle du cycle de vie.  
  
 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> doit uniquement être utilisé pour les tâches fournies à ce planificateur par l’infrastructure .NET Framework. Il ne doit pas être utilisé pour exécuter des tâches arbitraires obtenues via des mécanismes personnalisés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="task" /> n'est pas associé à ce planificateur.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task"><see cref="T:System.Threading.Tasks.Task" /> à exécuter.</param>
        <param name="taskWasPreviouslyQueued">Valeur booléenne qui indique si une tâche a déjà été mise en file d'attente. Si ce paramètre a la valeur True, la tâche a pu être mise en file d'attente (par planification) précédemment ; s'il a la valeur False, cela signifie que la tâche a été mise en file d'attente et que cet appel est passé pour exécuter la tâche inline sans mise en file d'attente.</param>
        <summary>Détermine si la <see cref="T:System.Threading.Tasks.Task" /> fournie peut être exécutée de façon synchrone dans cet appel et, si c'est le cas, l'exécute.</summary>
        <returns>Valeur booléenne qui indique si la tâche a été exécutée inline.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une classe dérivée de <xref:System.Threading.Tasks.TaskScheduler> implémente cette fonction pour prendre en charge l’exécution inline d’une tâche sur un thread qui initialise une attente sur cet objet de tâche. L’exécution inline est facultative, et la demande peut être rejetée en retournant la valeur false. Toutefois, les plus de tâches pouvant être inline, plus le Planificateur de mise à l’échelle. En fait, un planificateur qui inlines trop peu peuvent être sujettes à des blocages. Une implémentation appropriée doit assurer qu’une demande s’exécutant sous les stratégies garanties par le planificateur peut fonctionner inline. Par exemple, si un planificateur utilise un thread dédié pour exécuter des tâches, toutes les demandes incorporation (inlining) à partir de ce thread doivent réussir.  
  
 Si un planificateur décide de procéder à l’exécution inline, il doit le faire en appelant le TaskScheduler base <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> méthode avec l’objet de tâche fourni, en propageant la valeur de retour. Il peut également être appropriée pour le planificateur supprimer une tâche inline de ses structures de données internes s’il est décidé d’honorer la requête d’incorporation (inlining). Toutefois, notez que dans certaines circonstances un peut être demandé au planificateur inline une tâche qui n’a pas été fournie précédemment à l’aide du <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> (méthode).  
  
 Le planificateur dérivé est chargé de s’assurer que le thread appelant est approprié pour l’exécution de la tâche donnée en ce qui concerne sa propre planification et ce qui concerne les stratégies d’exécution.  
  
 Pour plus d'informations, consultez <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="task" /> a la valeur null.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="task" /> a déjà été exécuté.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l’exception non prise en charge d’une tâche ayant échoué est sur le point de déclencher la stratégie de promotion d’exception, qui, par défaut, arrête le processus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement de l’échelle du domaine d’application fournit un mécanisme pour empêcher la stratégie de promotion d’exception (qui, par défaut, arrête le processus) à partir de déclenchement.  
  
 Pour le rendre plus facile pour les développeurs d’écrire du code asynchrone basé sur les tâches, le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] modifie le comportement d’exception par défaut pour les exceptions non prise en charge. Bien que les exceptions non prise en charge toujours déclenchent le <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, le processus ne se termine pas par défaut. Au lieu de cela, l’exception est gérée par l’exécution une fois que l’événement est déclenché, indépendamment de si un gestionnaire d’événements observe l’exception. Ce comportement peut être configuré. En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez utiliser la [ `<ThrowUnobservedTaskExceptions>` ](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md) élément de configuration à rétablir le comportement de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] et terminer le processus :  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md">&lt;ThrowUnobservedTaskExceptions&gt; élément</related>
      </Docs>
    </Member>
  </Members>
</Type>