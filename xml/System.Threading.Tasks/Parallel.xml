<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c79cb35183f9b18d797d03ea6d340e1c45cd3903" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57952554" /></Metadata><TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit une prise en charge pour les boucles et les régions parallèles.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Tasks.Parallel> classe fournit des remplacements parallèles de données basées sur une bibliothèque pour les opérations courantes telles que les boucles, pour chaque boucle et exécution d’un ensemble d’instructions.  
  
   
  
## Examples  
 Cet exemple montre plusieurs approches pour implémenter une boucle parallèle à l’aide de plusieurs constructions de langage.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tous les membres publics et protégés de <see cref="T:System.Threading.Tasks.Parallel" /> sont thread-safe et peuvent être utilisés simultanément par plusieurs threads.</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md">Parallélisme de données (bibliothèque parallèle de tâches)</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Exemples de programmation parallèle avec .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) dans laquelle des itérations peuvent s'exécuter en parallèle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Index de début, inclus.</param>
        <param name="toExclusive">Index de fin, exclusif.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`). Il est fourni avec deux arguments :  
  
-   Un <xref:System.Int32> valeur qui représente le nombre d’itérations.  
  
-   Un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisé pour quitter la boucle prématurément. Le <xref:System.Threading.Tasks.ParallelLoopState> objet est créé par le compilateur ; elle ne peut pas être instanciée dans le code utilisateur.  
  
 Appelant le <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> méthode informe le `for` opération itérations après celle en cours n’êtes pas obligé d’exécuter. Toutefois, toutes les itérations avant actuel une sera toujours doivent être exécutées si elles ne sont déjà fait.  
  
 Par conséquent, l’appel <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> est similaire à l’utilisation d’une opération d’arrêt dans un conventionnel `for` boucle dans un langage comme C#, mais il n’est pas un substitut parfait : Par exemple, il n’est aucune garantie que les itérations une fois que l’objet actuel ne s’exécuteront pas.  
  
 Si l’exécution de toutes les itérations avant que l’objet actuel n’est pas nécessaire, utilisez le <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> méthode au lieu d’utiliser <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. Appel <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informe le `for` boucle qu’elle peut abandonner tous les autres itérations, qu’ils soient avant ou après l’itération actuelle, car tous les requis travail auront déjà été complétée. Toutefois, comme avec <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, il n’existe aucune garantie concernant les autres itérations seront exécutera pas.  
  
 Si une boucle se termine prématurément, le <xref:System.Threading.Tasks.ParallelLoopResult> structure retournée contient les informations pertinentes sur l’achèvement de la boucle.  
  
 Si `fromInclusive` est supérieur ou égal à `toExclusive`, la méthode retourne immédiatement sans exécuter d’itérations.  
  
   
  
## Examples  
 L’exemple suivant exécute jusqu'à 100 itérations d’une boucle en parallèle. Chaque itération s’interrompt pendant un intervalle aléatoire compris entre 1 et 1 000 millisecondes. Une valeur générée de manière aléatoire détermine sur quelle itération de la boucle la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> méthode est appelée. Comme la sortie de l’exemple, aucune itération dont l’index est supérieur à la <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> début de valeur de propriété après l’appel à la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Étant donné que les itérations de la boucle sont encore susceptibles d’être l’exécution lorsque le <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> méthode est appelée, les appels de chaque itération le <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> propriété pour vérifier si une autre itération a appelé le <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> (méthode). Si la valeur de propriété est `true`, l’itération vérifie la valeur de la <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> propriété et, si elle est supérieure à la valeur d’index de l’itération actuelle, retourne immédiatement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Index de début, inclus.</param>
        <param name="toExclusive">Index de fin, exclusif.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) dans laquelle des itérations peuvent s'exécuter en parallèle.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`). Il est fourni avec le nombre d’itérations (<xref:System.Int32>) en tant que paramètre.  
  
 Si `fromInclusive` est supérieur ou égal à `toExclusive`, la méthode retourne immédiatement sans exécuter d’itérations.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Threading.Tasks.Parallel.For%2A> méthode 100 appels d’un délégué qui génère des octets aléatoires de valeurs et calcule leur somme.  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Index de début, inclus.</param>
        <param name="toExclusive">Index de fin, exclusif.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des index 64 bits dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> qui contient des informations indiquant quelle partie de la boucle est terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`). Il est fourni avec les paramètres suivants : le nombre d’itérations (<xref:System.Int64>) et un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément.  
  
 Appelant le <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> méthode informe le `for` opération itérations après celle en cours n’êtes pas obligé d’être exécutées, mais toutes les itérations avant celui en cours.  
  
 Par conséquent, l’appel de Break est semblable à l’utilisation d’une opération d’arrêt dans un conventionnel `for` boucle dans un langage comme C#, mais il n’est pas un substitut parfait : Par exemple, il n’est aucune garantie que les itérations une fois que l’objet actuel ne s’exécuteront pas.  
  
 Si l’exécution de toutes les itérations avant que l’objet actuel n’est pas nécessaire, utilisez le <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> méthode au lieu d’utiliser <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. Appel <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informe le `for` boucle qu’elle peut abandonner tous les autres itérations, qu’ils soient avant ou après l’itération actuelle, car tous les requis travail auront déjà été complétée. Toutefois, comme avec <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, il n’existe aucune garantie concernant les autres itérations seront exécutera pas.  
  
 Si une boucle se termine prématurément, le <xref:System.Threading.Tasks.ParallelLoopResult> structure retournée contient les informations pertinentes sur l’achèvement de la boucle.  
  
 Si `fromInclusive` est supérieur ou égal à `toExclusive`, puis la méthode retourne immédiatement sans exécuter d’itérations.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Index de début, inclus.</param>
        <param name="toExclusive">Index de fin, exclusif.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des index 64 bits dans laquelle les itérations peuvent s'exécuter en parallèle.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`). Il est fourni avec le nombre d’itérations (<xref:System.Int64>) en tant que paramètre.  
  
 Si `fromInclusive` est supérieur ou égal à `toExclusive`, la méthode retourne immédiatement sans exécuter d’itérations.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Index de début, inclus.</param>
        <param name="toExclusive">Index de fin, exclusif.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`). Il est fourni avec les paramètres suivants : le nombre d’itérations (<xref:System.Int32>) et un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément.  
  
 Si `fromInclusive` est supérieur ou égal à `toExclusive`, la méthode retourne immédiatement sans exécuter d’itérations.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Index de début, inclus.</param>
        <param name="toExclusive">Index de fin, exclusif.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) dans laquelle les itérations peuvent s'exécuter en parallèle et les options de la boucle peuvent être configurées.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`). Il est fourni avec le nombre d’itérations (<xref:System.Int32>) en tant que paramètre.  
  
 Si `fromInclusive` est supérieur ou égal à `toExclusive`, puis la méthode retourne immédiatement sans exécuter d’itérations.  
  
   
  
## Examples  
 L’exemple suivant montre comment annuler une boucle parallèle :  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Index de début, inclus.</param>
        <param name="toExclusive">Index de fin, exclusif.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des index 64 bits dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`). Il est fourni avec les paramètres suivants : le nombre d’itérations (<xref:System.Int64>) et un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément.  
  
 Si `fromInclusive` est supérieur ou égal à `toExclusive`, la méthode retourne immédiatement sans exécuter d’itérations.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> méthode avec un <xref:System.Threading.Tasks.ParallelOptions> objet :  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Index de début, inclus.</param>
        <param name="toExclusive">Index de fin, exclusif.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des index 64 bits dans laquelle les itérations peuvent s’exécuter en parallèle et les options de la boucle peuvent être configurées.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prend en charge des index 64 bits. Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`). Il est fourni avec le nombre d’itérations (<xref:System.Int64>) en tant que paramètre.  
  
 Si `fromInclusive` est supérieur ou égal à `toExclusive`, puis la méthode retourne immédiatement sans exécuter d’itérations.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser <xref:System.Threading.Tasks.ParallelOptions> pour spécifier un planificateur de tâches personnalisé :  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Type des données locales de thread.</typeparam>
        <param name="fromInclusive">Index de début, inclus.</param>
        <param name="toExclusive">Index de fin, exclusif.</param>
        <param name="localInit">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <param name="localFinally">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</param>
        <summary>Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des données locales de thread dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`). Il est fourni avec les paramètres suivants : le nombre d’itérations (<xref:System.Int32>), un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et un état local qui peut être partagé parmi les itérations qui s’exécutent sur le même thread.  
  
 Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches. Ces états initiaux sont passés à la première `body` appels sur chaque tâche. Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant. Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer. Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche. Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.  
  
 Le <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches. Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.  
  
 Si `fromInclusive` est supérieur ou égal à `toExclusive`, puis la méthode retourne immédiatement sans exécuter d’itérations.  
  
 Pour obtenir un exemple qui utilise cette méthode, consultez [Comment : écrire une boucle Parallel.For avec des variables locales de thread](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Type des données locales de thread.</typeparam>
        <param name="fromInclusive">Index de début, inclus.</param>
        <param name="toExclusive">Index de fin, exclusif.</param>
        <param name="localInit">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <param name="localFinally">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</param>
        <summary>Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des index 64 bits et des données locales de thread dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`). Il est fourni avec les paramètres suivants : le nombre d’itérations (<xref:System.Int64>), un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et un état local qui peut être partagé parmi les itérations qui s’exécutent sur la même tâche.  
  
 Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches. Ces états initiaux sont passés à la première `body` appels sur chaque tâche. Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant. Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer. Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche. Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.  
  
 Le <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches. Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.  
  
 Si `fromInclusive` est supérieur ou égal à `toExclusive`, puis la méthode retourne immédiatement sans exécuter d’itérations.  
  
 Pour obtenir un exemple qui utilise cette méthode, consultez [Comment : écrire une boucle Parallel.For avec des variables locales de thread](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Type des données locales de thread.</typeparam>
        <param name="fromInclusive">Index de début, inclus.</param>
        <param name="toExclusive">Index de fin, exclusif.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="localInit">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <param name="localFinally">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</param>
        <summary>Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des données locales de thread dans laquelle les itérations peuvent s’exécuter en parallèle, les options de la boucle peuvent être configurées et l’état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`). Il est fourni avec les paramètres suivants : le nombre d’itérations (<xref:System.Int32>), un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et un état local qui peut être partagé parmi les itérations qui s’exécutent sur la même tâche.  
  
 Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches. Ces états initiaux sont passés à la première `body` appels sur chaque tâche. Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant. Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer. Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche. Ce délégué peut être appelé simultanément sur plusieurs threads ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.  
  
 Le <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches. Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.  
  
 Si `fromInclusive` est supérieur ou égal à `toExclusive`, puis la méthode retourne immédiatement sans exécuter d’itérations.  
  
   
  
## Examples  
 L’exemple suivant utilise des variables locales de thread pour calculer la somme des résultats de nombreuses opérations de longue durée. Cet exemple limite le degré de parallélisme à quatre.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Type des données locales de thread.</typeparam>
        <param name="fromInclusive">Index de début, inclus.</param>
        <param name="toExclusive">Index de fin, exclusif.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="localInit">Délégué de fonction qui retourne l'état initial des données locales pour chaque thread.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <param name="localFinally">Délégué qui exécute une dernière action sur l'état local de chaque thread.</param>
        <summary>Exécute une boucle <see langword="for" /> (<see langword="For" /> en Visual Basic) avec des index 64 bits et des données locales de thread dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque valeur dans la plage de l’itération (`fromInclusive`, `toExclusive`). Il est fourni avec les paramètres suivants : le nombre d’itérations (<xref:System.Int64>), un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et un état local qui peut être partagé parmi les itérations qui s’exécutent sur le même thread.  
  
 Le `localInit` délégué est appelé une fois pour chaque thread qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces threads. Ces états initiaux sont passés à la première `body` appels sur chaque thread. Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant. Enfin, le dernier appel du corps sur chaque thread renvoie une valeur d’état qui est passée à la `localFinally` déléguer. Le `localFinally` délégué est appelé une fois par thread pour exécuter une dernière action sur l’état local de chaque thread. Ce délégué peut être appelé simultanément sur plusieurs threads ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.  
  
 Le <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches. Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.  
  
 Si `fromInclusive` est supérieur ou égal à `toExclusive`, puis la méthode retourne immédiatement sans exécuter d’itérations.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each " /> en Visual Basic) dans laquelle les itérations peuvent s'exécuter en parallèle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments dans <paramref name="source" />.</typeparam>
        <param name="source">Partitionneur classable qui contient la source de données d'origine.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement. Par exemple, les petits corps de boucles tire parti du partitionnement de la plage. Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique. Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : implémenter des partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> dans le partitionneur classable <paramref name="source" /> retourne la valeur <see langword="false" />.  
  
ou 
La propriété <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> dans le partitionneur classable de source retourne <see langword="false" />.  
  
ou 
Toutes les méthodes dans le partitionneur classable source retournent <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments dans <paramref name="source" />.</typeparam>
        <param name="source">Partitionneur qui contient la source de données d'origine.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.Concurrent.Partitioner" /> dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement. Par exemple, les petits corps de boucles tire parti du partitionnement de la plage. Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique. Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : implémenter des partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> du partitionneur <paramref name="source" /> retourne <see langword="false" />.  
  
ou 
Une méthode du partitioneur <paramref name="source" /> retourne <see langword="null" />.  
  
ou 
La méthode <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> dans le <paramref name="source" /> ne retourne pas le nombre correct de partitions.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments dans <paramref name="source" />.</typeparam>
        <param name="source">Partitionneur qui contient la source de données d'origine.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.Concurrent.Partitioner" /> dans laquelle les itérations peuvent s'exécuter en parallèle.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement. Par exemple, les petits corps de boucles tire parti du partitionnement de la plage. Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique. Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : implémenter des partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment implémenter un partitionneur de plage pour une utilisation avec <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> du partitionneur <paramref name="source" /> retourne <see langword="false" />.  
  
ou 
Exception levée lorsque toutes les méthodes dans le partitionneur <paramref name="source" /> retournent la valeur <see langword="null" />.  
  
ou 
La méthode <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> dans le <paramref name="source" /> ne retourne pas le nombre correct de partitions.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des données contenues dans la source.</typeparam>
        <param name="source">Source de données énumérable.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des index 64 bits sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable. Il est fourni avec les paramètres suivants : l’élément actuel, un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et l’index de l’élément actuel (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des données contenues dans la source.</typeparam>
        <param name="source">Source de données énumérable.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable. Il est fourni avec les paramètres suivants : l’élément actuel et un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des données contenues dans la source.</typeparam>
        <param name="source">Source de données énumérable.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable. Il est fourni avec l’élément actuel en tant que paramètre.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> méthode pour compter le nombre de caractères d’autre qu’un espace blanc dans un fichier texte et des voyelles. Dans ce cas, le <xref:System.Threading.Tasks.ParallelLoopResult> valeur retournée par la méthode est ignoré. Notez que, étant donné que les opérations peuvent s’exécuter en parallèle, vous devez vous assurer que l’incrémentation les variables de compteur est une opération atomique, et que plusieurs threads n’essayez pas à accéder aux variables compteur simultanément. Pour cela, l’exemple utilise le `lock` instruction (c#) et la `SyncLock` instruction (en Visual Basic).  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments dans <paramref name="source" />.</typeparam>
        <param name="source">Partitionneur classable qui contient la source de données d'origine.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement. Par exemple, les petits corps de boucles tire parti du partitionnement de la plage. Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique. Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : implémenter des partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> dans le partitionneur classable <paramref name="source" /> retourne la valeur <see langword="false" />.  
  
ou 
La propriété <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> dans le partitionneur classable <paramref name="source" /> retourne la valeur <see langword="false" />.  
  
ou 
L'exception levée lorsque toute méthode dans l'OrderablePartitioner <paramref name="source" /> retourne une valeur <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments dans <paramref name="source" />.</typeparam>
        <param name="source">Partitionneur qui contient la source de données d'origine.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.Concurrent.Partitioner" /> dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement. Par exemple, les petits corps de boucles tire parti du partitionnement de la plage. Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique. Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : implémenter des partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> du partitionneur <paramref name="source" /> retourne <see langword="false" />.  
  
ou 
Exception levée lorsque toutes les méthodes dans le partitionneur <paramref name="source" /> retournent la valeur <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments dans <paramref name="source" />.</typeparam>
        <param name="source">Partitionneur qui contient la source de données d'origine.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.Concurrent.Partitioner" /> dans laquelle les itérations peuvent s'exécuter en parallèle et les options de la boucle peuvent être configurées.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement. Par exemple, les petits corps de boucles tire parti du partitionnement de la plage. Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique. Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : implémenter des partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> du partitionneur <paramref name="source" /> retourne <see langword="false" />.  
  
ou 
Exception levée lorsque toutes les méthodes dans le partitionneur <paramref name="source" /> retournent la valeur <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des données contenues dans la source.</typeparam>
        <param name="source">Source de données énumérable.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des index 64 bits sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle, les options de boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable. Il est fourni avec les paramètres suivants : l’élément actuel, un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et l’index de l’élément actuel (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des données contenues dans la source.</typeparam>
        <param name="source">Source de données énumérable.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable. Il est fourni avec les paramètres suivants : l’élément actuel et un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des données contenues dans la source.</typeparam>
        <param name="source">Source de données énumérable.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle et les options de la boucle peuvent être configurées.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable. Il est fourni avec l’élément actuel en tant que paramètre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments dans <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Type des données locales de thread.</typeparam>
        <param name="source">Partitionneur classable qui contient la source de données d'origine.</param>
        <param name="localInit">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <param name="localFinally">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des données locales de thread sur <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement. Par exemple, les petits corps de boucles tire parti du partitionnement de la plage. Le <xref:System.Threading.Tasks.Parallel.ForEach%2A> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique. Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : implémenter des partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches. Ces états initiaux sont passés à la première `body` appels sur chaque tâche. Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant. Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer. Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche. Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.  
  
 Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches. Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> dans <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retourne <see langword="false" /> ou le partitionneur retourne des partitions <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments dans <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Type des données locales de thread.</typeparam>
        <param name="source">Partitionneur qui contient la source de données d'origine.</param>
        <param name="localInit">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <param name="localFinally">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des données locales de thread sur <see cref="T:System.Collections.Concurrent.Partitioner" /> dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement. Par exemple, les petits corps de boucles tire parti du partitionnement de la plage. Le <xref:System.Threading.Tasks.Parallel.ForEach%2A> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique. Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : implémenter des partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Le `localInit` délégué est appelé une fois pour chaque thread qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches. Ces états initiaux sont passés à la première `body` appels sur chaque tâche. Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant. Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer. Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche. Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.  
  
 Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches. Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> dans <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retourne <see langword="false" /> ou le partitionneur retourne des partitions <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des données contenues dans la source.</typeparam>
        <typeparam name="TLocal">Type des données locales de thread.</typeparam>
        <param name="source">Source de données énumérable.</param>
        <param name="localInit">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <param name="localFinally">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des données locales de thread sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable. Il est fourni avec les paramètres suivants : l’élément actuel, un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément, les index de l’élément actuel (<xref:System.Int64>) et un état local qui peut être partagé parmi les itérations qui s’exécutent sur le même thread.  
  
 Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches. Ces états initiaux sont passés à la première `body` appels sur chaque tâche. Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant. Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer. Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche. Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.  
  
 Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches. Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des données contenues dans la source.</typeparam>
        <typeparam name="TLocal">Type des données locales de thread.</typeparam>
        <param name="source">Source de données énumérable.</param>
        <param name="localInit">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <param name="localFinally">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des données locales de thread sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable. Il est fourni avec les paramètres suivants : l’élément actuel, un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et un état local qui peut être partagé parmi les itérations qui s’exécutent sur le même thread.  
  
 Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches. Ces états initiaux sont passés à la première `body` appels sur chaque tâche. Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant. Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer. Le `localFinally` délégué est appelé une fois par thread pour exécuter une dernière action sur l’état local de chaque tâche. Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.  
  
 Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches. Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser un <xref:System.Threading.Tasks.Parallel.ForEach%2A> méthode avec l’état local :  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments dans <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Type des données locales de thread.</typeparam>
        <param name="source">Partitionneur classable qui contient la source de données d'origine.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="localInit">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <param name="localFinally">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des index 64 bits et des données locales de thread sur <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement. Par exemple, les petits corps de boucles tire parti du partitionnement de la plage. Le <xref:System.Threading.Tasks.Parallel.ForEach%2A> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique. Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : implémenter des partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches. Ces états initiaux sont passés à la première `body` appels sur chaque tâche. Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant. Enfin, le dernier appel du corps sur chaque thread renvoie une valeur d’état qui est passée à la `localFinally` déléguer. Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche. Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.  
  
 Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches. Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localInit" /> ou <paramref name="localFinally" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> dans <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retourne <see langword="false" /> ou le partitionneur retourne des partitions <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des éléments dans <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Type des données locales de thread.</typeparam>
        <param name="source">Partitionneur qui contient la source de données d'origine.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="localInit">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <param name="localFinally">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des données locales de thread sur <see cref="T:System.Collections.Concurrent.Partitioner" /> dans laquelle les itérations peuvent s’exécuter en parallèle, les options de la boucle peuvent être configurées et l’état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge est fournie pour les scénarios où vous souhaitez remplacer la valeur par défaut, le schéma de partitionnement. Par exemple, les petits corps de boucles tire parti du partitionnement de la plage. Le <xref:System.Threading.Tasks.Parallel.ForEach%2A> méthode attend les partitionneurs personnalisés pour prendre en charge le partitionnement dynamique. Cette surcharge est fournie pour les scénarios avec les petits corps de boucles qui pourraient tirer profit de partitionnement par plage statique. Partitionneurs doivent prendre en charge des partitions dynamiques.  Pour plus d’informations, consultez [Partitionneurs personnalisés pour PLINQ et TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) et [Comment : implémenter des partitions dynamiques](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches. Ces états initiaux sont passés à la première `body` appels sur chaque tâche. Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant. Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer. Le `localFinally` délégué est appelé pour chaque tâche à effectuer une dernière action sur l’état local de chaque tâche. Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.  
  
 Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches. Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> dans <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retourne <see langword="false" /> ou le partitionneur retourne des partitions <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des données contenues dans la source.</typeparam>
        <typeparam name="TLocal">Type des données locales de thread.</typeparam>
        <param name="source">Source de données énumérable.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="localInit">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <param name="localFinally">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des données locales de thread et des index 64 bits sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s'exécuter en parallèle, les options de la boucle peuvent être configurées et l'état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable. Il est fourni avec les paramètres suivants : l’élément actuel, un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément, les index de l’élément actuel (<xref:System.Int64>) et un état local qui peut être partagé parmi les itérations qui s’exécutent sur le même thread.  
  
 Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches. Ces états initiaux sont passés à la première `body` appels sur chaque tâche. Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant. Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer. Le `localFinally` délégué est appelé une fois par thread pour exécuter une dernière action sur l’état local de chaque tâche. Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.  
  
 Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches. Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Type des données contenues dans la source.</typeparam>
        <typeparam name="TLocal">Type des données locales de thread.</typeparam>
        <param name="source">Source de données énumérable.</param>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="localInit">Délégué de fonction qui retourne l'état initial des données locales pour chaque tâche.</param>
        <param name="body">Délégué appelé une fois par itération.</param>
        <param name="localFinally">Délégué qui exécute une dernière action sur l'état local de chaque tâche.</param>
        <summary>Exécute une opération <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) avec des données locales de thread sur <see cref="T:System.Collections.IEnumerable" /> dans laquelle les itérations peuvent s’exécuter en parallèle, les options de la boucle peuvent être configurées et l’état de la boucle peut être surveillé et manipulé.</summary>
        <returns>Structure qui contient des informations sur la partie de la boucle terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `body` délégué est appelé une fois pour chaque élément dans le `source` énumérable. Il est fourni avec les paramètres suivants : l’élément actuel, un <xref:System.Threading.Tasks.ParallelLoopState> instance qui peut être utilisée pour quitter la boucle prématurément et un état local qui peut être partagé parmi les itérations qui s’exécutent sur le même thread.  
  
 Le `localInit` délégué est appelé une fois pour chaque tâche qui participe à l’exécution de la boucle et retourne l’état local initial pour chacun de ces tâches. Ces états initiaux sont passés à la première `body` appels sur chaque tâche. Ensuite, chaque appel de corps suivant retourne une valeur d’état éventuellement modifiée qui est passée à l’appel de corps suivant. Enfin, le dernier appel du corps sur chaque tâche retourne une valeur d’état qui est passée à la `localFinally` déléguer. Le `localFinally` délégué est appelé une fois par thread pour exécuter une dernière action sur l’état local de chaque tâche. Ce délégué peut être appelé simultanément sur plusieurs tâches ; Par conséquent, vous devez synchroniser l’accès à toutes les variables partagées.  
  
 Le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode peut utiliser des tâches plus que de threads de la durée de vie de son exécution, réalisation des tâches existantes et sont remplacés par les nouvelles tâches. Cela donne sous-jacent <xref:System.Threading.Tasks.TaskScheduler> objet la possibilité d’ajouter, modifier ou supprimer des threads qui gèrent la boucle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="source" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="body" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localInit" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="localFinally" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> dans l'argument <paramref name="parallelOptions" /> est annulé.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
        <exception cref="T:System.AggregateException">Exception qui contient toutes les exceptions individuelles levées sur tous les threads.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Boucles parallèles</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute chacune des actions fournies, éventuellement en parallèle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">Tableau des <see cref="T:System.Action" /> à exécuter.</param>
        <summary>Exécute chacune des actions fournies, éventuellement en parallèle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour exécuter un ensemble d’opérations, potentiellement en parallèle.  
  
 Aucune garantie n’est donnée sur l’ordre dans lequel les opérations s’exécutent, ou si elles s’exécutent en parallèle. Cette méthode ne retourne pas jusqu'à ce que chacune des opérations fournies est terminée, indépendamment de si la saisie semi-automatique se produit en raison de l’arrêt normal ou exceptionnel.  
  
 Pour plus d’informations, consultez [Comment : utiliser parallel_invoke pour exécuter des opérations parallèles](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
   
  
## Examples  
 Cet exemple montre comment utiliser le <xref:System.Threading.Tasks.Parallel.Invoke%2A> méthode avec d’autres méthodes, les délégués anonymes et les expressions lambda.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="actions" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">L'exception levée lorsque toute action dans le tableau <paramref name="actions" /> lève une exception.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="actions" /> contient un élément <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">Objet qui configure le comportement de cette opération.</param>
        <param name="actions">Tableau des actions à exécuter.</param>
        <summary>Exécute chacune des actions fournies, éventuellement en parallèle, sauf si l'opération est annulée par l'utilisateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour exécuter un ensemble d’opérations, potentiellement en parallèle. Le jeton d’annulation passé avec la <xref:System.Threading.Tasks.ParallelOptions> structure permet à l’appelant annuler l’opération entière. Pour plus d’informations, consultez [Annulation dans les threads managés](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
 Aucune garantie n’est donnée sur l’ordre dans lequel les opérations s’exécutent, ou si elles s’exécutent en parallèle. Cette méthode ne retourne pas jusqu'à ce que chacune des opérations fournies est terminée, indépendamment de si la saisie semi-automatique se produit en raison de l’arrêt normal ou exceptionnel.  
  
 Pour plus d’informations, consultez [Comment : utiliser parallel_invoke pour exécuter des opérations parallèles](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Objet <see cref="T:System.Threading.CancellationToken" /> dans <paramref name="parallelOptions" /> est défini.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="actions" /> a la valeur <see langword="null" />.  
  
ou 
L'argument <paramref name="parallelOptions" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">L'exception levée lorsque toute action dans le tableau <paramref name="actions" /> lève une exception.</exception>
        <exception cref="T:System.ArgumentException">Le tableau <paramref name="actions" /> contient un élément <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Objet <see cref="T:System.Threading.CancellationTokenSource" /> associé à <see cref="T:System.Threading.CancellationToken" /> dans l'objet <paramref name="parallelOptions" /> a été supprimé.</exception>
      </Docs>
    </Member>
  </Members>
</Type>