<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4845c0ed859423bf909c0fd95b7d29f966086850" /><Meta Name="ms.sourcegitcommit" Value="dadbb338a88266714d03fdd31e3616e7c61682e7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/05/2019" /><Meta Name="ms.locfileid" Value="57427079" /></Metadata><TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="F#" Value="type Task = class&#xA;    interface IAsyncResult&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une opération asynchrone.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 Le <xref:System.Threading.Tasks.Task> classe représente une opération unique qui ne retourne pas une valeur et qui généralement exécute de façon asynchrone. <xref:System.Threading.Tasks.Task> les objets sont l’un des composants centrales de la [modèle asynchrone basé sur les tâches](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) introduite dans .NET Framework 4. Étant donné que le travail effectué par un <xref:System.Threading.Tasks.Task> objet généralement exécute de façon asynchrone sur un thread de pool de threads plutôt que de façon synchrone sur le thread principal de l’application, vous pouvez utiliser la <xref:System.Threading.Tasks.Task.Status%2A> propriété, ainsi que le <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, et <xref:System.Threading.Tasks.Task.IsFaulted%2A> propriétés, pour déterminer l’état d’une tâche. En règle générale, une expression lambda est utilisée pour spécifier le travail de la tâche consiste à effectuer.  
  
 Pour les opérations qui retournent des valeurs, vous utilisez la <xref:System.Threading.Tasks.Task%601> classe.  
  
 Dans cette section :  
  
 [Exemples d’instanciation de tâche](#Instant)   
 [Création et exécution d’une tâche](#Creating)   
 [Séparation de la création de tâches et de l’exécution](#Separating)   
 [En attente d’une ou plusieurs tâches](#WaitingForOne)   
 [Tâches et la culture](#Culture)   
 [Pour les développeurs de débogueur](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a>Instanciation de la tâche  
 L’exemple suivant crée et exécute les quatre tâches. Les trois tâches exécutent une <xref:System.Action%601> délégué nommé `action`, qui accepte un argument de type <xref:System.Object>. Une quatrième tâche exécute une expression lambda (un <xref:System.Action> délégué) qui est défini inline dans l’appel à la méthode de création de tâche. Chaque tâche est instanciée et exécutée dans une autre manière :  
  
-   Tâche `t1` est instanciée en appelant un constructeur de classe de tâche, mais est lancée en appelant son <xref:System.Threading.Tasks.Task.Start> méthode uniquement après la tâche `t2` a démarré.  
  
-   Tâche `t2` est instancié et démarrée dans un seul appel de méthode en appelant le <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> (méthode).  
  
-   Tâche `t3` est instancié et démarrée dans un seul appel de méthode en appelant le <xref:System.Threading.Tasks.Task.Run%28System.Action%29> (méthode).  
  
-   Tâche `t4` est exécutée de façon synchrone sur le thread principal en appelant le <xref:System.Threading.Tasks.Task.RunSynchronously> (méthode).  
  
 Étant donné que tâche `t4` exécute de façon synchrone, elle s’exécute sur le thread principal de l’application. Les tâches restantes exécutent de façon asynchrone généralement sur un ou plusieurs threads du pool.  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a>Création et exécution d’une tâche  
 <xref:System.Threading.Tasks.Task> instances peuvent être créées de plusieurs façons. L’approche la plus courante, qui est disponible à partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], consiste à appeler la méthode statique <xref:System.Threading.Tasks.Task.Run%2A> (méthode). Le <xref:System.Threading.Tasks.Task.Run%2A> méthode fournit un moyen simple pour démarrer une tâche à l’aide des valeurs par défaut et sans nécessiter des paramètres supplémentaires. L’exemple suivant utilise la <xref:System.Threading.Tasks.Task.Run%28System.Action%29> méthode pour démarrer une tâche qui effectue une itération, puis affiche le nombre d’itérations de boucle :  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 Une alternative et la méthode la plus courante pour démarrer une tâche dans [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], est la méthode statique <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> (méthode). Le <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> propriété retourne un <xref:System.Threading.Tasks.TaskFactory> objet. Les surcharges de la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> méthode vous permettre de spécifier des paramètres à passer aux options de création de tâche et un planificateur de tâches. L’exemple suivant utilise la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> méthode pour démarrer une tâche. Il est fonctionnellement équivalent au code dans l’exemple précédent.  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 Pour obtenir des exemples plus complets, consultez [basé sur des tâches de programmation asynchrone](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a>Séparation de la création de tâches et de l’exécution  
 Le <xref:System.Threading.Tasks.Task> classe fournit également des constructeurs qui initialisent la tâche mais qui ne le planifiez pas pour l’exécution. Pour des raisons de performances, le <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> méthode est le mécanisme recommandé pour la création et la planification des tâches de calculs, mais pour les scénarios où la création et la planification doivent être séparés, vous pouvez utiliser les constructeurs et appelez ensuite la <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> méthode pour planifier la tâche pour l’exécution à un moment ultérieur.  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a>En attente d’une ou plusieurs tâches  
 Étant donné que les tâches généralement exécutent de façon asynchrone sur un thread de pool de thread, le thread qui crée et démarre la tâche continue l’exécution dès que la tâche a été instanciée. Dans certains cas, lorsque le thread appelant est le thread principal de l’application, l’application peut se fermer avant tout la tâche commence réellement l’exécution. Dans d’autres cas, la logique de votre application peut nécessiter que le thread appelant poursuivre l’exécution uniquement lorsqu’une ou plusieurs tâches a terminé son exécution. Vous pouvez synchroniser l’exécution du thread appelant et asynchrone tâches il lance en appelant un `Wait` méthode pour attendre un ou plusieurs tâches à effectuer.  
  
 Pour attendre une tâche unique se termine, vous pouvez appeler son <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> (méthode). Un appel à la <xref:System.Threading.Tasks.Task.Wait%2A> méthode bloque le thread appelant jusqu'à ce que l’instance de classe unique a terminé son exécution.  
  
 L’exemple suivant appelle Next sans paramètre <xref:System.Threading.Tasks.Task.Wait> méthode attendre sans condition une tâche se termine. La tâche simule le travail en appelant le <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> méthode en veille pendant deux secondes.  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 Vous pouvez également de manière conditionnelle attendre une tâche se termine. Le <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> et <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> méthodes bloquent le thread appelant jusqu'à ce que la tâche se termine ou un intervalle de délai d’expiration est écoulé, le premier prévalant. Étant donné que l’exemple suivant lance une tâche qui se met en veille pendant deux secondes, mais définit une valeur de délai d’attente d’une seconde, le thread appelant se bloque jusqu'à ce que le délai d’attente expire et avant la tâche de fin de l’exécution.  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 Vous pouvez également fournir un jeton d’annulation en appelant le <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> et <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> méthodes. Si le jeton <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> propriété est `true` ou devient `true` tandis que le <xref:System.Threading.Tasks.Task.Wait%2A> méthode s’exécute, la méthode lève un <xref:System.OperationCanceledException>.  
  
 Dans certains cas, vous souhaiterez peut-être attendre pour le premier d’une série de l’exécution de tâches à terminer, mais ne les soins de tâches qu’il est.  Pour cela, vous pouvez appeler une des surcharges de la <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> (méthode).  L’exemple suivant crée trois tâches, chacune d’elles est en veille pour un intervalle déterminent par un générateur de nombres aléatoires. Le <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> méthode attend que la première tâche se termine. L’exemple affiche ensuite des informations sur l’état de toutes les trois tâches.  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 Vous pouvez également attendre pour l’ensemble d’une série de tâches à effectuer en appelant le <xref:System.Threading.Tasks.Task.WaitAll%2A> (méthode). L’exemple suivant crée dix tâches, attend que toutes les dix terminer, puis affiche leur état.  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 Notez que lorsque vous attendez une ou plusieurs tâches à effectuer, toutes les exceptions levées dans les tâches en cours d’exécution sont propagées sur le thread qui appelle le `Wait` méthode, comme le montre l’exemple suivant. Il lance des 12 tâches, trois d'entre eux se terminer normalement et trois des qui lève une exception. Le reste des six tâches, trois sont annulées avant le début de trois sont annulées lors de leur exécution. Les exceptions sont levées dans le <xref:System.Threading.Tasks.Task.WaitAll%2A> appel de méthode et sont gérées par un `try` / `catch` bloc.  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 Pour plus d’informations sur la gestion des exceptions dans les opérations asynchrones basées sur des tâches, consultez [gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a>Tâches et la culture  
 À partir des applications de bureau qui ciblent le [!INCLUDE[net_v46](~/includes/net-v46-md.md)], la culture du thread qui crée et appelle une tâche devient partie intégrante du contexte du thread. Autrement dit, quel que soit la culture actuelle du thread sur lequel la tâche s’exécute, la culture actuelle de la tâche est la culture du thread appelant. Pour les applications qui ciblent des versions du .NET Framework antérieures à la [!INCLUDE[net_v46](~/includes/net-v46-md.md)], la culture de la tâche est la culture du thread sur lequel la tâche s’exécute. Pour plus d’informations, consultez la section « Culture et opérations asynchrones basées sur une tâche » dans le <xref:System.Globalization.CultureInfo> rubrique.  
  
> [!NOTE]
>  Applications de Store suivent l’exécution de Windows dans la définition et obtention de la culture par défaut.  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a>Pour les développeurs de débogueur  
 Pour les développeurs qui implémentent des débogueurs personnalisés, plusieurs membres internes et privés de tâche peuvent être utiles (ils peuvent changer à partir d’une version à l’autre). Le `m_taskId` champ sert de magasin de stockage pour le <xref:System.Threading.Tasks.Task.Id%2A> propriété, toutefois l’accès à ce champ directement à partir d’un débogueur peut être plus efficace que l’accès à la même valeur via la méthode d’accesseur Get de la propriété (la `s_taskIdCounter` compteur est permet de récupérer le prochain ID disponible pour une tâche). De même, le `m_stateFlags` champ stocke des informations sur l’étape du cycle de vie actuelle de la tâche, informations également accessibles via le <xref:System.Threading.Tasks.Task.Status%2A> propriété. Le `m_action` champ stocke une référence au délégué de la tâche et le `m_stateObject` champ stocke l’état asynchrone passé à la tâche par le développeur. Enfin, pour les débogueurs qui analysent des frames de pile, le `InternalWait` méthode sert un marqueur potentiel pour quand une tâche entre dans une opération d’attente.   
  
 ]]></format>
    </remarks>
    <threadsafe>Tous les membres de <see cref="T:System.Threading.Tasks.Task" />, à l’exception de <see cref="M:System.Threading.Tasks.Task.Dispose" />, sont thread-safe et peuvent être utilisés à partir de plusieurs threads simultanément.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Bibliothèque parallèle de tâches</related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programmation asynchrone basée sur les tâches</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Exemples de programmation parallèle avec .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise un nouveau <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Délégué qui représente le code à exécuter dans la tâche.</param>
        <summary>Initialise un nouveau <see cref="T:System.Threading.Tasks.Task" /> avec l'action spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> (méthode). Le seul avantage offert par ce constructeur est qu’elle autorise l’instanciation d’objet séparés à partir de l’appel de tâche.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> constructeur pour créer des tâches qui récupèrent les noms de fichiers dans les répertoires spécifiés. Toutes les tâches écrivent les noms de fichiers dans un seul <xref:System.Collections.Concurrent.ConcurrentBag%601> objet. L’exemple appelle ensuite la <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> pour s’assurer que toutes les tâches terminées et affiche le nombre total de noms de fichiers écrits dans le <xref:System.Collections.Concurrent.ConcurrentBag%601> objet.  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 L’exemple suivant est identique, sauf qu’il a utilisé la <xref:System.Threading.Tasks.Task.Run%28System.Action%29> méthode pour instancier et exécuter la tâche en une seule opération. La méthode retourne la <xref:System.Threading.Tasks.Task> objet qui représente la tâche.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="action" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Délégué qui représente le code à exécuter dans la tâche.</param>
        <param name="cancellationToken">Le <see cref="T:System.Threading.CancellationToken" /> que la nouvelle tâche observera.</param>
        <summary>Initialise un nouveau <see cref="T:System.Threading.Tasks.Task" /> avec l'action spécifiée et <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> et <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> méthodes. Le seul avantage offert par ce constructeur est qu’elle autorise l’instanciation d’objet séparés à partir de l’appel de tâche.  
  
 Pour plus d’informations, consultez [parallélisme des tâches (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) et [l’annulation dans les Threads managés](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> constructeur pour créer une tâche qui effectue une itération de fichiers dans le répertoire C:\Windows\System32. L’expression lambda appelle la <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode pour ajouter des informations sur chaque fichier à un <xref:System.Collections.Generic.List%601> objet. Chaque détachée tâche imbriquée appelée par le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> boucle vérifie l’état du jeton d’annulation et, si l’annulation est demandée, appelle le <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> (méthode). Le <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> méthode lève une exception une <xref:System.OperationCanceledException> exception est gérée dans un `catch` bloquer lorsque le thread appelant appelle la <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> (méthode).  Le <xref:System.Threading.Tasks.Task.Start%2A> méthode est ensuite appelée pour démarrer la tâche.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="action" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Délégué qui représente le code à exécuter dans la tâche.</param>
        <param name="creationOptions"><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> utilisé pour personnaliser le comportement de la tâche.</param>
        <summary>Initialise une nouvelle <see cref="T:System.Threading.Tasks.Task" /> avec l'action et les options de création spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> (méthode). Le seul avantage offert par ce constructeur est qu’elle autorise l’instanciation d’objet séparés à partir de l’appel de tâche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="action" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="creationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">Délégué qui représente le code à exécuter dans la tâche.</param>
        <param name="state">Objet représentant les données que l'action doit utiliser.</param>
        <summary>Initialise une nouvelle <see cref="T:System.Threading.Tasks.Task" /> avec l'action et l'état spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> (méthode). Le seul avantage offert par ce constructeur est qu’elle autorise l’instanciation d’objet séparés à partir de l’appel de tâche.  
  
   
  
## Examples  
 L’exemple suivant définit un tableau de mots de la lettre de 6. Chaque mot est ensuite transmis en tant qu’argument à la <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> constructeur, dont <xref:System.Action%601> délégué brouille les caractères du mot, puis affiche le mot d’origine et sa version brouillée.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="action" /> a la valeur null.</exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Délégué qui représente le code à exécuter dans la tâche.</param>
        <param name="cancellationToken">Le <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que la nouvelle tâche observera.</param>
        <param name="creationOptions"><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> utilisé pour personnaliser le comportement de la tâche.</param>
        <summary>Initialise une nouvelle <see cref="T:System.Threading.Tasks.Task" /> avec l'action et les options de création spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> (méthode). Le seul avantage offert par ce constructeur est qu’elle autorise l’instanciation d’objet séparés à partir de l’appel de tâche.  
  
 Pour plus d’informations, consultez [parallélisme des tâches (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) et [l’annulation de tâche](~/docs/standard/parallel-programming/task-cancellation.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="action" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="creationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Délégué qui représente le code à exécuter dans la tâche.</param>
        <param name="state">Objet représentant les données que l'action doit utiliser.</param>
        <param name="cancellationToken">Le <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que la nouvelle tâche observera.</param>
        <summary>Initialise une nouvelle <see cref="T:System.Threading.Tasks.Task" /> avec l'action, l'état et les options spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> (méthode). Le seul avantage offert par ce constructeur est qu’elle autorise l’instanciation d’objet séparés à partir de l’appel de tâche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="action" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Délégué qui représente le code à exécuter dans la tâche.</param>
        <param name="state">Objet représentant les données que l'action doit utiliser.</param>
        <param name="creationOptions"><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> utilisé pour personnaliser le comportement de la tâche.</param>
        <summary>Initialise une nouvelle <see cref="T:System.Threading.Tasks.Task" /> avec l'action, l'état et les options spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> (méthode). Le seul avantage offert par ce constructeur est qu’elle autorise l’instanciation d’objet séparés à partir de l’appel de tâche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="action" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="creationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Délégué qui représente le code à exécuter dans la tâche.</param>
        <param name="state">Objet représentant les données que l'action doit utiliser.</param>
        <param name="cancellationToken">Le <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que la nouvelle tâche observera.</param>
        <param name="creationOptions"><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> utilisé pour personnaliser le comportement de la tâche.</param>
        <summary>Initialise une nouvelle <see cref="T:System.Threading.Tasks.Task" /> avec l'action, l'état et les options spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu d’appeler ce constructeur, la méthode la plus courante pour instancier un <xref:System.Threading.Tasks.Task> objet et lancer une tâche est en appelant la méthode statique <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> (méthode). Le seul avantage offert par ce constructeur est qu’elle autorise l’instanciation d’objet séparés à partir de l’appel de tâche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="action" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="creationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet d'état fourni quand la <see cref="T:System.Threading.Tasks.Task" /> a été créée, ou null si aucune n'a été fournie.</summary>
        <value><see cref="T:System.Object" /> représentant les données d'état passées à la tâche lors de sa création.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Effectuer un cast de l’objet vers le type d’origine pour récupérer ses données.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedTask : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une tâche qui s’est déjà terminée correctement.</summary>
        <value>Tâche terminée avec succès.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne une tâche dont <xref:System.Threading.Tasks.Task.Status%2A> propriété est définie sur <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Pour créer la tâche qui retourne une valeur et s’exécute jusqu'à son achèvement, appelez le <xref:System.Threading.Tasks.Task.FromResult%2A> (méthode).  
  
 Les tentatives répétées pour récupérer la valeur de cette propriété ne retournent pas toujours la même instance.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="member this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext"><see langword="true" /> en cas de tentative de marshaling de la continuation vers le contexte d'origine capturé ; sinon, <see langword="false" />.</param>
        <summary>Configure un élément awaiter utilisé pour attendre cette <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Objet utilisé pour attendre cette tâche.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une continuation qui s'exécute de façon asynchrone quand la <see cref="T:System.Threading.Tasks.Task" /> cible se termine.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand <see cref="T:System.Threading.Tasks.Task" /> se termine. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <summary>Crée une continuation qui s'exécute de façon asynchrone quand la <see cref="T:System.Threading.Tasks.Task" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
   
  
## Examples  
 L’exemple suivant définit une tâche qui remplit un tableau avec 100 aléatoire valeurs de date et heure. Il utilise le <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> méthode afin de sélectionner dès que possible les dernières valeurs de date et une fois que le tableau est entièrement rempli.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 Car une application de console peut se fermer avant l’exécution de la tâche de continuation, la <xref:System.Threading.Tasks.Task.Wait> méthode est appelée pour s’assurer que la continuation termine l’exécution avant la fin de l’exemple.  
  
 Pour obtenir un exemple supplémentaire, consultez [chaînage des tâches à l’aide de tâches de Continuation](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand la tâche se termine. Lors de l’exécution, la tâche achevée et l’objet d’état fourni par l’appelant sont passés comme arguments au délégué.</param>
        <param name="state">Objet représentant les données que l'action de continuation doit utiliser.</param>
        <summary>Crée une continuation qui reçoit des informations d'état fournies par l'appelant et s'exécute quand le <see cref="T:System.Threading.Tasks.Task" /> cible se termine.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou quitter tôt en raison de l’annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand <see cref="T:System.Threading.Tasks.Task" /> se termine. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <summary>Crée une continuation qui reçoit un jeton d'annulation et s'exécute de façon asynchrone quand le <see cref="T:System.Threading.Tasks.Task" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé le jeton a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationAction" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter selon le <paramref name="continuationOptions" />spécifié. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d'exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crée une continuation qui s’exécute quand la tâche cible se termine conformément au <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> spécifié.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée. Si les critères de continuation spécifiés via le `continuationOptions` paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser <xref:System.Threading.Tasks.TaskContinuationOptions> pour spécifier qu’une tâche de continuation doit exécuter de façon synchrone lorsque la tâche antécédente est terminée. (Si la tâche spécifiée est déjà terminée au moment où <xref:System.Threading.Tasks.Task.ContinueWith%2A> est appelée, synchrones continuation s’exécutera sur la thread appelant la méthode <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationAction" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand <see cref="T:System.Threading.Tasks.Task" /> se termine. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui s'exécute de façon asynchrone quand la <see cref="T:System.Threading.Tasks.Task" /> cible se termine. La continuation utilise un planificateur spécifié.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.  
  
ou 
L’argument <paramref name="scheduler" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand <see cref="T:System.Threading.Tasks.Task" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que l'action de continuation doit utiliser.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <summary>Crée une continuation qui reçoit des informations d'état fournies par l'appelant et un jeton d'annulation, et qui s'exécute de façon asynchrone quand le <see cref="T:System.Threading.Tasks.Task" /> cible se termine.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand <see cref="T:System.Threading.Tasks.Task" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que l'action de continuation doit utiliser.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d'exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crée une continuation qui reçoit des informations d'état fournies par l'appelant et s'exécute quand le <see cref="T:System.Threading.Tasks.Task" /> cible se termine. La continuation s'exécute selon un ensemble de conditions spécifiées.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée. Si les critères de continuation spécifiés via le `continuationOptions` paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="continuationAction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand <see cref="T:System.Threading.Tasks.Task" /> se termine.  Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que l'action de continuation doit utiliser.</param>
        <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui reçoit des informations d'état fournies par l'appelant et s'exécute de façon asynchrone quand le <see cref="T:System.Threading.Tasks.Task" /> cible se termine. La continuation utilise un planificateur spécifié.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="scheduler" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter selon le <paramref name="continuationOptions" />spécifié. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d'exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui s’exécute quand la tâche cible se termine conformément au <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> spécifié. La continuation reçoit un jeton d'annulation et utilise un planificateur spécifié.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée. Si les critères spécifiés par le biais du `continuationOptions` paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.  
  
   
  
## Examples  
 Voici un exemple d’utilisation de ContinueWith pour exécuter des travaux en arrière-plan et sur l’utilisateur threads d’interface.  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé le jeton a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationAction" /> a la valeur null.  
  
ou 
L’argument <paramref name="scheduler" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Action à exécuter quand <see cref="T:System.Threading.Tasks.Task" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que l'action de continuation doit utiliser.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d'exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui reçoit des informations d'état fournies par l'appelant et un jeton d'annulation, et qui s'exécute quand le <see cref="T:System.Threading.Tasks.Task" /> cible se termine. La continuation s'exécute selon un ensemble de conditions spécifiées et utilise un planificateur spécifié.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée. Si les critères spécifiés par le biais du `continuationOptions` paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="scheduler" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task`1" /> se termine. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <summary>Crée une continuation qui s'exécute de façon asynchrone quand le <see cref="T:System.Threading.Tasks.Task`1" /> cible se termine et retourne une valeur.</summary>
        <returns>Nouvelle tâche de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser la méthode ContinueWith :  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationFunction" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que la fonction de continuation doit utiliser.</param>
        <summary>Crée une continuation qui reçoit des informations d'état fournies par l'appelant et s'exécute de façon asynchrone quand le <see cref="T:System.Threading.Tasks.Task" /> cible se termine et retourne une valeur.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="continuationFunction" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task" /> se termine. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <summary>Crée une continuation qui s'exécute de façon asynchrone quand le <see cref="T:System.Threading.Tasks.Task" /> cible se termine et retourne une valeur. La continuation reçoit un jeton d'annulation.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.  
  
ou 
Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé le jeton a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationFunction" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter selon la condition spécifiée dans <paramref name="continuationOptions" />. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d'exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crée une continuation qui s'exécute en fonction des options de continuation spécifiées et retourne une valeur.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée. Si les critères de continuation spécifiés via le `continuationOptions` paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationFunction" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task" /> se termine. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui s'exécute de façon asynchrone quand le <see cref="T:System.Threading.Tasks.Task" /> cible se termine et retourne une valeur. La continuation utilise un planificateur spécifié.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationFunction" /> a la valeur null.  
  
ou 
L’argument <paramref name="scheduler" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que la fonction de continuation doit utiliser.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <summary>Crée une continuation qui s'exécute de façon asynchrone quand le <see cref="T:System.Threading.Tasks.Task" /> cible se termine et retourne une valeur. La continuation reçoit des informations d'état fournies par l'appelant et un jeton d'annulation.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="continuationFunction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que la fonction de continuation doit utiliser.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d'exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crée une continuation qui s’exécute en fonction des options de continuation de tâche spécifiées quand le <see cref="T:System.Threading.Tasks.Task" /> cible se termine. La continuation reçoit des informations d'état fournies par l'appelant.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée. Si les critères de continuation spécifiés via le `continuationOptions` paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="continuationFunction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task" /> se termine.  Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que la fonction de continuation doit utiliser.</param>
        <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui s'exécute de façon asynchrone quand la <see cref="T:System.Threading.Tasks.Task" /> cible se termine. La continuation reçoit des informations d'état fournies par l'appelant et utilise un planificateur spécifié.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> n’est plus planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée, si elle se termine en raison de s’exécuter complètement avec succès, provoquer une erreur en raison d’une exception non gérée ou la sortie de tôt suite à son annulation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="scheduler" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter selon le <c>continuationOptions</c>spécifié. Quand elle est exécutée, la tâche achevée est passée au délégué en tant qu'argument.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d'exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui s'exécute en fonction des options de continuation spécifiées et retourne une valeur. La continuation reçoit un jeton d'annulation et utilise un planificateur spécifié.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée. Si les critères spécifiés par le biais du `continuationOptions` paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser la méthode ContinueWith avec les options de continuation :  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.  
  
ou 
Le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé le jeton a déjà été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="continuationFunction" /> a la valeur null.  
  
ou 
L’argument <paramref name="scheduler" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat produit par la continuation.</typeparam>
        <param name="continuationFunction">Fonction à exécuter quand <see cref="T:System.Threading.Tasks.Task" /> se termine. Lors de l'exécution, la tâche achevée et l'objet d'état fourni par l'appelant sont passés au délégué sous la forme d'arguments.</param>
        <param name="state">Objet représentant les données que la fonction de continuation doit utiliser.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> qui sera assigné à la nouvelle tâche de continuation.</param>
        <param name="continuationOptions">Options applicables lorsque la continuation est planifiée et qui en régissent le comportement. Cela inclut des critères, tels que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, ainsi que des options d'exécution, telles que <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> à associer à la tâche de continuation et à utiliser pour son exécution.</param>
        <summary>Crée une continuation qui s’exécute en fonction des options de continuation de tâche spécifiées quand le <see cref="T:System.Threading.Tasks.Task" /> cible se termine et retourne une valeur. La continuation reçoit des informations d'état fournies par l'appelant et un jeton d'annulation et elle utilise un planificateur spécifié.</summary>
        <returns>Nouvelle <see cref="T:System.Threading.Tasks.Task`1" /> de continuation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourné <xref:System.Threading.Tasks.Task%601> ne sera pas planifié pour l’exécution jusqu'à ce que la tâche en cours est terminée. Si les critères spécifiés par le biais du `continuationOptions` paramètre ne sont pas remplies, la tâche de continuation sera annulée au lieu d’être planifiée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="scheduler" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="continuationOptions" /> spécifie une valeur non valide pour <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Threading.CancellationToken" /> fourni a déjà été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> utilisées pour créer cette tâche.</summary>
        <value><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> utilisées pour créer cette tâche.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentId : Nullable&lt;int&gt;" Usage="System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne l'ID de la <see cref="T:System.Threading.Tasks.Task" /> en cours d'exécution.</summary>
        <value>Entier assigné par le système à la tâche en cours d’exécution.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.CurrentId%2A> est un `static` (`Shared` en Visual Basic) propriété qui est utilisée pour obtenir l’identificateur de la tâche en cours d’exécution à partir du code en cours d’exécution de la tâche. Il diffère de la <xref:System.Threading.Tasks.Task.Id%2A> propriété, qui retourne l’identificateur d’un particulier <xref:System.Threading.Tasks.Task> instance. Si vous tentez de récupérer le <xref:System.Threading.Tasks.Task.CurrentId%2A> la propriété retourne la valeur à partir d’en dehors du code en cours d’exécution d’une tâche, `null`.  
  
 Notez que bien que les collisions sont très rares, les identificateurs de tâche ne sont pas garantis pour être unique.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une tâche qui ne se termine qu'après un certain délai.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="static member Delay : int -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay millisecondsDelay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Nombre de millisecondes à attendre avant la fin de la tâche retournée ou -1 pour attendre indéfiniment.</param>
        <summary>Crée une tâche qui se termine après un nombre spécifié de millisecondes.</summary>
        <returns>Tâche qui représente le délai.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Tasks.Task.Delay%2A> méthode est généralement utilisée pour retarder le fonctionnement de tous les ou une partie d’une tâche pour un intervalle de temps spécifié. En règle générale, le délai est introduit :  
  
-   Au début de la tâche, comme dans l’exemple suivant montre.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   Plus tard pendant l’exécution de la tâche. Dans ce cas, l’appel à la <xref:System.Threading.Tasks.Task.Delay%2A> méthode s’exécute comme une tâche enfant au sein d’une tâche, comme le montre l’exemple suivant. Notez que depuis la tâche qui appelle le <xref:System.Threading.Tasks.Task.Delay%2A> méthode s’exécute de façon asynchrone, la tâche parente doit attendre qu’elle se termine à l’aide de la `await` mot clé.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 Après le délai imparti, la tâche est terminée dans le <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> état.  
  
 Cette méthode dépend de l’horloge système. Cela signifie que le délai est approximativement égale à la résolution de l’horloge système si le `millisecondsDelay` argument est inférieure à la résolution de l’horloge système, qui est d’environ 15 millisecondes sur les systèmes Windows.  
  
   
  
## Examples  
 L’exemple suivant montre une utilisation simple du <xref:System.Threading.Tasks.Task.Delay%2A> (méthode).  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L’argument <paramref name="millisecondsDelay" /> est inférieur à -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">Intervalle de temps à attendre avant la fin de la tâche retournée ou <see langword="TimeSpan.FromMilliseconds(-1)" /> pour attendre indéfiniment.</param>
        <summary>Crée une tâche qui se termine après un intervalle de temps spécifié.</summary>
        <returns>Tâche qui représente le délai.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Après le délai imparti, la tâche est terminée dans <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> état.  
  
 Pour les scénarios d’utilisation et des exemples supplémentaires, consultez la documentation pour le <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> de surcharge.  
  
 Cette méthode dépend de l’horloge système. Cela signifie que le délai est approximativement égale à la résolution de l’horloge système si le `delay` argument est inférieure à la résolution de l’horloge système, qui est d’environ 15 millisecondes sur les systèmes Windows.  
  
   
  
## Examples  
 L’exemple suivant montre une utilisation simple du <xref:System.Threading.Tasks.Task.Delay%2A> (méthode).  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="delay" /> représente un intervalle de temps négatif autre que <see langword="TimeSpan.FromMillseconds(-1)" />.  
  
ou 
La propriété <see cref="P:System.TimeSpan.TotalMilliseconds" /> de l’argument <paramref name="delay" /> est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (millisecondsDelay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Nombre de millisecondes à attendre avant la fin de la tâche retournée ou -1 pour attendre indéfiniment.</param>
        <param name="cancellationToken">Jeton d’annulation à observer en attendant que la tâche se termine.</param>
        <summary>Crée une tâche pouvant être annulée qui se termine après un nombre spécifié de millisecondes.</summary>
        <returns>Tâche qui représente le délai.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le jeton d’annulation est signalé avant le délai spécifié, un <xref:System.Threading.Tasks.TaskCanceledException> résultats de l’exception et la tâche est terminée dans le <xref:System.Threading.Tasks.TaskStatus.Canceled> état.  Sinon, la tâche est terminée dans le <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> état une fois que le délai spécifié écoulé.  
  
 Pour les scénarios d’utilisation et des exemples supplémentaires, consultez la documentation pour le <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> de surcharge.  
  
 Cette méthode dépend de l’horloge système. Cela signifie que le délai est approximativement égale à la résolution de l’horloge système si le `millisecondsDelay` argument est inférieure à la résolution de l’horloge système, qui est d’environ 15 millisecondes sur les systèmes Windows.  
  
   
  
## Examples  
 L’exemple suivant lance une tâche qui inclut un appel à la <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> méthode avec un délai d’une seconde. Avant que l’intervalle du délai s’écoule, le jeton est annulé. La sortie de l’exemple montre que, par conséquent, un <xref:System.Threading.Tasks.TaskCanceledException> est levée et les tâches <xref:System.Threading.Tasks.Task.Status%2A> propriété est définie sur <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L’argument <paramref name="millisecondsDelay" /> est inférieur à -1.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">La tâche a été annulée.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <paramref name="cancellationToken" /> fourni a déjà été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (delay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="delay">Intervalle de temps à attendre avant la fin de la tâche retournée ou <see langword="TimeSpan.FromMilliseconds(-1)" /> pour attendre indéfiniment.</param>
        <param name="cancellationToken">Jeton d’annulation à observer en attendant que la tâche se termine.</param>
        <summary>Crée une tâche pouvant être annulée qui se termine après un intervalle de temps spécifié.</summary>
        <returns>Tâche qui représente le délai.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le jeton d’annulation est signalé avant le délai spécifié, un <xref:System.Threading.Tasks.TaskCanceledException> résultats de l’exception et la tâche est terminée dans le <xref:System.Threading.Tasks.TaskStatus.Canceled> état.  Sinon, la tâche est terminée dans le <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> état une fois que le délai spécifié écoulé.  
  
 Pour les scénarios d’utilisation et des exemples supplémentaires, consultez la documentation pour le <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> de surcharge.  
  
 Cette méthode dépend de l’horloge système. Cela signifie que le délai est approximativement égale à la résolution de l’horloge système si le `delay` argument est inférieure à la résolution de l’horloge système, qui est d’environ 15 millisecondes sur les systèmes Windows.  
  
   
  
## Examples  
 L’exemple suivant lance une tâche qui inclut un appel à la <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> méthode avec un délai de 1,5 secondes. Avant que l’intervalle du délai s’écoule, le jeton est annulé. La sortie de l’exemple montre que, par conséquent, un <xref:System.Threading.Tasks.TaskCanceledException> est levée et les tâches <xref:System.Threading.Tasks.Task.Status%2A> propriété est définie sur <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 Notez que cet exemple inclut une condition de concurrence potentielle : elle dépend de la tâche exécute de façon asynchrone le délai lorsque le jeton est annulé. Bien que la seconde 1,5 différer de l’appel à la <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> méthode rend cette hypothèse probable, il est néanmoins possible que l’appel à la <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> méthode peut retourner avant que le jeton est annulé. Dans ce cas, l’exemple génère la sortie suivante :  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="delay" /> représente un intervalle de temps négatif autre que <see langword="TimeSpan.FromMillseconds(-1)" />.  
  
ou 
La propriété <see cref="P:System.TimeSpan.TotalMilliseconds" /> de l’argument <paramref name="delay" /> est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">La tâche a été annulée.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <paramref name="cancellationToken" /> fourni a déjà été supprimé.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="task.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Tasks.Task> la classe implémente le <xref:System.IDisposable> , car il utilise en interne des ressources qui implémentent également l’interface <xref:System.IDisposable>. Toutefois, en particulier si votre application cible le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ou une version ultérieure, il n’est pas nécessaire d’appeler <xref:System.Threading.Tasks.Task.Dispose%2A> , sauf si les tests d’évolutivité ou de performances indique que, en fonction de vos modèles d’utilisation, les performances de votre application seraient amélioré en supprimant des tâches. Pour plus d’informations, consultez [ai-je besoin de supprimer des tâches ?](https://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) dans le blog programmation parallèle avec .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La tâche n’est pas dans un des états finaux : <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> ou <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="task.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Valeur booléenne qui indique si cette méthode est appelée en raison d'un appel à <see cref="M:System.Threading.Tasks.Task.Dispose" />.</param>
        <summary>Supprime la <see cref="T:System.Threading.Tasks.Task" />, en libérant toutes ses ressources non managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Tasks.Task> la classe implémente le <xref:System.IDisposable> , car il utilise en interne des ressources qui implémentent également l’interface <xref:System.IDisposable>. Toutefois, en particulier si votre application cible le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ou une version ultérieure, il n’est pas nécessaire d’appeler <xref:System.Threading.Tasks.Task.Dispose%2A> , sauf si les tests d’évolutivité ou de performances indique que, en fonction de vos modèles d’utilisation, les performances de votre application seraient amélioré en supprimant des tâches. Pour plus d’informations, consultez [ai-je besoin de supprimer des tâches ?](https://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) dans le blog programmation parallèle avec .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La tâche n’est pas dans un des états finaux : <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> ou <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <threadsafe>Contrairement à la plupart des membres de la <see cref="T:System.Threading.Tasks.Task" /> (classe), cette méthode n’est pas thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Exception : AggregateException" Usage="System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.AggregateException" /> qui a provoqué l'arrêt prématuré de <see cref="T:System.Threading.Tasks.Task" />. Si la <see cref="T:System.Threading.Tasks.Task" /> s'est terminée avec succès ou n'a pas encore levé d'exception, la valeur <see langword="null" /> est retournée.</summary>
        <value><see cref="T:System.AggregateException" /> qui a provoqué la fin prématurée de <see cref="T:System.Threading.Tasks.Task" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tâches qui lèvent des exceptions non gérées stockent l’exception résultante et propager encapsulée dans un <xref:System.AggregateException> dans les appels à <xref:System.Threading.Tasks.Task.Wait%2A> ou dans les accès à la <xref:System.Threading.Tasks.Task.Exception%2A> propriété. Les exceptions non observées au moment où que l’instance de tâche est le garbage collecté seront propagées sur le thread finaliseur. Pour plus d’informations et un exemple, consultez [(bibliothèque parallèle de tâches) de gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory" Usage="System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fournit l'accès aux méthodes de fabrique pour la création d'instances de <see cref="T:System.Threading.Tasks.Task" /> et de <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <value>Objet de fabrique pouvant créer une variété d'objets <see cref="T:System.Threading.Tasks.Task" /> et <see cref="T:System.Threading.Tasks.Task`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne une instance par défaut de la <xref:System.Threading.Tasks.TaskFactory> classe qui est identique à celui créé par un appel sans paramètre <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> constructeur. Il a les valeurs de propriété suivantes :  
  
|Property|Value|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|`null`, ou <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 L’utilisation la plus courante de cette propriété consiste à créer et démarrer une nouvelle tâche dans un seul appel à la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> (méthode).  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], le <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> méthode fournit le moyen le plus simple de créer un <xref:System.Threading.Tasks.Task> objet avec les valeurs de configuration par défaut.  
  
 L’exemple suivant utilise la méthode statique <xref:System.Threading.Tasks.Task.Factory%2A> propriété afin que les deux appels à la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> (méthode). La première remplit un tableau avec les noms des fichiers dans le répertoire Mes documents, tandis que la seconde remplit un tableau avec les noms des sous-répertoires du répertoire Mes documents de l’utilisateur. Il appelle ensuite la <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> (méthode), qui affiche des informations sur le nombre de fichiers et des répertoires dans les deux tableaux après les deux premières tâches terminées à l’exécution.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Jeton d’annulation avec lequel terminer la tâche.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task" /> qui s'est terminée en raison de l'annulation avec un jeton d'annulation spécifié.</summary>
        <returns>Tâche annulée.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L’annulation n’a pas été demandée pour <paramref name="cancellationToken" /> ; sa propriété <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> est <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat retourné par la tâche.</typeparam>
        <param name="cancellationToken">Jeton d’annulation avec lequel terminer la tâche.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task`1" /> qui s'est terminée en raison de l'annulation avec un jeton d'annulation spécifié.</summary>
        <returns>Tâche annulée.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L’annulation n’a pas été demandée pour <paramref name="cancellationToken" /> ; sa propriété <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> est <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">Exception avec laquelle terminer la tâche.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task" /> qui s'est terminée avec une exception spécifiée.</summary>
        <returns>Tâche ayant échoué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée un <xref:System.Threading.Tasks.Task> de l’objet dont la propriété <xref:System.Threading.Tasks.Task.Status%2A> propriété est <xref:System.Threading.Tasks.TaskStatus.Faulted> et dont <xref:System.Threading.Tasks.Task.Exception%2A> contient de la propriété `exception`. La méthode est couramment utilisée lorsque vous savez immédiatement que le travail qui effectue une tâche lève une exception avant l’exécution d’un chemin d’accès du code plus long. Pour obtenir un exemple, consultez le <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> de surcharge.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat retourné par la tâche.</typeparam>
        <param name="exception">Exception avec laquelle terminer la tâche.</param>
        <summary>Crée une <see cref="T:System.Threading.Tasks.Task`1" /> qui s'est terminée avec une exception spécifiée.</summary>
        <returns>Tâche ayant échoué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée un <xref:System.Threading.Tasks.Task%601> de l’objet dont la propriété <xref:System.Threading.Tasks.Task.Status%2A> propriété est <xref:System.Threading.Tasks.TaskStatus.Faulted> et dont <xref:System.Threading.Tasks.Task.Exception%2A> contient de la propriété `exception`. La méthode est couramment utilisée lorsque vous savez immédiatement que le travail qui effectue une tâche lève une exception avant l’exécution d’un chemin d’accès du code plus long. Cet exemple en fournit une illustration.  
  
   
  
## Examples  
 L’exemple suivant est un utilitaire de ligne de commande qui calcule le nombre d’octets dans les fichiers dans chaque annuaire dont le nom est passé comme un argument de ligne de commande. Au lieu de l’exécution d’un plus long chemin d’accès de code qui instancie un <xref:System.IO.FileInfo> de l’objet et récupère la valeur de son <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> propriété pour chaque fichier dans le répertoire, l’exemple appelle simplement la <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> méthode pour créer une tâche ayant généré une erreur si un particulier sous-répertoire n’existe pas.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberSignature Language="F#" Value="static member FromResult : 'Result -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat retourné par la tâche.</typeparam>
        <param name="result">Résultat à enregistrer dans la tâche terminée.</param>
        <summary>Crée un <see cref="T:System.Threading.Tasks.Task`1" /> qui s'est terminé avec succès avec le résultat spécifié.</summary>
        <returns>Tâche terminée avec succès.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée un <xref:System.Threading.Tasks.Task%601> de l’objet dont la propriété <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> propriété est `result` et dont <xref:System.Threading.Tasks.Task.Status%2A> propriété est <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. La méthode est couramment utilisée quand la valeur de retour d’une tâche est connue immédiatement sans exécuter un chemin d’accès du code plus long. Cet exemple en fournit une illustration.  
  
 Pour créer un objet de tâche qui ne retourne pas de valeur, récupérer l’objet de tâche à partir de la <xref:System.Threading.Tasks.Task.CompletedTask%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant est un utilitaire de ligne de commande qui calcule le nombre d’octets dans les fichiers dans chaque annuaire dont le nom est passé comme un argument de ligne de commande. Au lieu de l’exécution d’un plus long chemin d’accès de code qui instancie un <xref:System.IO.FileStream> de l’objet et récupère la valeur de son <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> propriété pour chaque fichier dans le répertoire, l’exemple appelle simplement la <xref:System.Threading.Tasks.Task.FromResult%2A> méthode pour créer une tâche dont <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> propriété est zéro (0) si un répertoire ne comporte aucun fichier.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberSignature Language="F#" Value="member this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un élément awaiter utilisé pour attendre cette <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Une instance d'élément awaiter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est conçue pour une utilisation du compilateur, plutôt que pour une utilisation dans le code d’application.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un ID pour cette instance de <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <value>Entier assigné par le système à cette instance de <see cref="T:System.Threading.Tasks.Task" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ID de tâche sont affectés à la demande et ne représentent pas nécessairement l’ordre d’affichage des tâches instances sont créées. Notez que bien que les collisions sont très rares, les identificateurs de tâche ne sont pas garantis pour être unique.  
  
 Pour obtenir l’ID de tâche de la tâche en cours d’exécution à partir de code que la tâche s’exécute, utilisez le <xref:System.Threading.Tasks.Task.CurrentId%2A> propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCanceled : bool" Usage="System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si cette instance <see cref="T:System.Threading.Tasks.Task" /> s'est exécutée avec succès suite à une annulation.</summary>
        <value><see langword="true" /> si la tâche s'est terminée suite à son annulation ; sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Threading.Tasks.Task> se terminera à la <xref:System.Threading.Tasks.TaskStatus.Canceled> état si l’une des conditions suivantes :  
  
-   Son <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> a été marqué pour l’annulation avant l’exécution, le démarrage de la tâche  
  
-   La tâche a accepté la demande d’annulation sur son déjà signalé <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> en levant un <xref:System.OperationCanceledException> qui porte le même <xref:System.Threading.CancellationToken>.  
  
-   La tâche a accepté la demande d’annulation sur son déjà signalé <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> en appelant le <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> méthode sur le <xref:System.Threading.CancellationToken>.  
  
> [!IMPORTANT]
>  Récupération de la valeur de la <xref:System.Threading.Tasks.Task.IsCanceled%2A> propriété ne bloque pas le thread appelant jusqu'à ce que la tâche est terminée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la tâche est terminée.</summary>
        <value><see langword="true" /> Si la tâche est terminée (autrement dit, la tâche est dans un des trois états définitifs : <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, ou <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />) ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> Récupération de la valeur de la <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> propriété ne bloque pas le thread appelant jusqu'à ce que la tâche est terminée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompletedSuccessfully : bool" Usage="System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFaulted : bool" Usage="System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si <see cref="T:System.Threading.Tasks.Task" /> s'est achevé suite à une exception non gérée.</summary>
        <value><see langword="true" /> si la tâche a levé une exception non gérée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Threading.Tasks.Task.IsFaulted%2A> est `true`, de la tâche <xref:System.Threading.Tasks.Task.Status%2A> est égal à <xref:System.Threading.Tasks.TaskStatus.Faulted>et son <xref:System.Threading.Tasks.Task.Exception%2A> propriété sera non null.  
  
> [!IMPORTANT]
>  Récupération de la valeur de la <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> propriété ne bloque pas le thread appelant jusqu'à ce que la tâche est terminée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Met en file d'attente le travail spécifié à exécuter dans le ThreadPool et retourne une tâche ou un handle de <see cref="T:System.Threading.Tasks.Task`1" /> pour ce travail.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Tasks.Task.Run%2A> méthode fournit un ensemble de surcharges qui facilitent la démarrer une tâche à l’aide des valeurs par défaut. Il est une alternative légère à la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> surcharges.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberSignature Language="F#" Value="static member Run : Action -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Travail à exécuter de façon asynchrone</param>
        <summary>Met en file d'attente le travail spécifié à exécuter dans le pool de threads et retourne un objet <see cref="T:System.Threading.Tasks.Task" /> qui représente ce travail.</summary>
        <returns>Tâche qui représente le travail mis en file d'attente à exécuter dans le ThreadPool.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Tasks.Task.Run%2A> méthode vous permet de créer et exécuter une tâche dans un seul appel de méthode et constitue une alternative plus simple à la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> (méthode). Il crée une tâche avec les valeurs par défaut suivantes :  
  
-   Le jeton d’annulation est <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Son <xref:System.Threading.Tasks.Task.CreationOptions%2A> valeur de propriété est <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Elle utilise le Planificateur de tâches par défaut.  
  
 Pour plus d’informations sur la gestion des exceptions levées par les opérations de la tâche, consultez [gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 L’exemple suivant définit un `ShowThreadInfo` méthode qui affiche le <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> du thread actuel. Elle est appelée directement à partir du thread d’application et est appelée à partir de la <xref:System.Action> délégué transmis à la <xref:System.Threading.Tasks.Task.Run%28System.Action%29> (méthode).  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 L’exemple suivant est similaire au précédent, sauf qu’elle utilise une expression lambda pour définir le code de la tâche consiste à exécuter.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 Les exemples montrent que la tâche asynchrone s’exécute sur un thread différent du thread principal de l’application.  
  
 L’appel à la <xref:System.Threading.Tasks.Task.Wait%2A> méthode garantit que la tâche se termine et affiche sa sortie avant la fin de l’application. Sinon, il est possible que le `Main` méthode se termine avant que la tâche se termine.  
  
 L’exemple suivant illustre la <xref:System.Threading.Tasks.Task.Run%28System.Action%29> (méthode). Il définit un tableau de noms de répertoires et démarre une tâche distincte pour récupérer les noms de fichiers dans chaque répertoire. Toutes les tâches écrivent les noms de fichiers dans un seul <xref:System.Collections.Concurrent.ConcurrentBag%601> objet. L’exemple appelle ensuite la <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> pour s’assurer que toutes les tâches terminées et affiche le nombre total de noms de fichiers écrits dans le <xref:System.Collections.Concurrent.ConcurrentBag%601> objet.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur du paramètre <paramref name="action" /> était <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestion des exceptions (bibliothèque parallèle de tâches)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Travail à exécuter de façon asynchrone</param>
        <summary>Met en file d’attente le travail spécifié à exécuter sur le pool de threads et retourne un proxy pour la tâche retournée par <paramref name="function" />.</summary>
        <returns>Tâche qui représente un proxy de la tâche retournée par <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la gestion des exceptions levées par les opérations de la tâche, consultez [gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur du paramètre <paramref name="function" /> était <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestion des exceptions (bibliothèque parallèle de tâches)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Travail à exécuter de façon asynchrone</param>
        <param name="cancellationToken">Jeton d’annulation qui peut être utilisé pour annuler le travail</param>
        <summary>Met en file d'attente le travail spécifié à exécuter dans le pool de threads et retourne un objet <see cref="T:System.Threading.Tasks.Task" /> qui représente ce travail. Un jeton d’annulation permet l’annulation du travail.</summary>
        <returns>Tâche qui représente le travail mis en file d’attente à exécuter dans le pool de threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’annulation est demandée avant le début de la tâche d’exécution, la tâche ne s’exécute pas. Au lieu de cela, il est défini sur le <xref:System.Threading.Tasks.TaskStatus.Canceled> état et lève un <xref:System.Threading.Tasks.TaskCanceledException> exception.  
  
 Le <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> méthode constitue une alternative plus simple à la <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> (méthode). Il crée une tâche avec les valeurs par défaut suivantes :  
  
-   Son <xref:System.Threading.Tasks.Task.CreationOptions%2A> valeur de propriété est <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Elle utilise le Planificateur de tâches par défaut.  
  
 Pour plus d’informations sur la gestion des exceptions levées par les opérations de la tâche, consultez [gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> méthode pour créer une tâche qui effectue une itération de fichiers dans le répertoire C:\Windows\System32. L’expression lambda appelle la <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> méthode pour ajouter des informations sur chaque fichier à un <xref:System.Collections.Generic.List%601> objet. Chaque détachée tâche imbriquée appelée par le <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> boucle vérifie l’état du jeton d’annulation et, si l’annulation est demandée, appelle le <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> (méthode). Le <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> méthode lève une exception une <xref:System.OperationCanceledException> exception est gérée dans un `catch` bloquer lorsque le thread appelant appelle la <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur du paramètre <paramref name="action" /> était <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">La tâche a été annulée.</exception>
        <exception cref="T:System.ObjectDisposedException">La <see cref="T:System.Threading.CancellationTokenSource" /> associée au <paramref name="cancellationToken" /> a été supprimée.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestion des exceptions (bibliothèque parallèle de tâches)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">Travail à exécuter de façon asynchrone.</param>
        <param name="cancellationToken">Jeton d'annulation qui doit être utilisé pour annuler le travail.</param>
        <summary>Met en file d’attente le travail spécifié à exécuter sur le pool de threads et retourne un proxy pour la tâche retournée par <paramref name="function" />.</summary>
        <returns>Tâche qui représente un proxy de la tâche retournée par <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la gestion des exceptions levées par les opérations de la tâche, consultez [gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur du paramètre <paramref name="function" /> était <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">La tâche a été annulée.</exception>
        <exception cref="T:System.ObjectDisposedException">La <see cref="T:System.Threading.CancellationTokenSource" /> associée au <paramref name="cancellationToken" /> a été supprimée.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestion des exceptions (bibliothèque parallèle de tâches)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat retourné par la tâche de proxy.</typeparam>
        <param name="function">Travail à exécuter de façon asynchrone</param>
        <summary>Met en file d’attente le travail spécifié à exécuter dans le pool de threads et retourne un proxy pour le <see langword="Task(TResult)" /> retourné par <paramref name="function" />.</summary>
        <returns><see langword="Task(TResult)" /> qui représente un proxy de la <see langword="Task(TResult)" /> retournée par <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la gestion des exceptions levées par les opérations de la tâche, consultez [gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur du paramètre <paramref name="function" /> était <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestion des exceptions (bibliothèque parallèle de tâches)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type de retour de la tâche.</typeparam>
        <param name="function">Travail à exécuter de façon asynchrone.</param>
        <summary>Met en file d'attente le travail spécifié à exécuter dans le pool de threads et retourne un objet <see cref="T:System.Threading.Tasks.Task`1" /> qui représente ce travail.</summary>
        <returns>Objet de tâche qui représente le travail mis en file d’attente à exécuter dans le pool de threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Tasks.Task.Run%2A> méthode constitue une alternative plus simple à la <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> (méthode). Il crée une tâche avec les valeurs par défaut suivantes :  
  
-   Le jeton d’annulation est <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Son <xref:System.Threading.Tasks.Task.CreationOptions%2A> valeur de propriété est <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Elle utilise le Planificateur de tâches par défaut.  
  
 Pour plus d’informations sur la gestion des exceptions levées par les opérations de la tâche, consultez [gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 L’exemple suivant compte le nombre approximatif de mots contenus dans les fichiers texte qui représentent la documentation publiée. Chaque tâche est chargée d’ouvrir un fichier, lire son contenu entier de manière asynchrone et calculer le nombre de mots à l’aide d’une expression régulière. Le <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> méthode est appelée pour vous assurer que toutes les tâches terminées avant d’afficher le nombre de mots de chaque ouvrage sur la console.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 L’expression régulière `\p{P}*\s+` correspond à zéro, une ou plusieurs caractères de ponctuation suivis d’un ou plusieurs caractères d’espace blanc. Il suppose que le nombre total de correspondances est égale au nombre approximatif de word.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="function" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestion des exceptions (bibliothèque parallèle de tâches)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type du résultat retourné par la tâche de proxy.</typeparam>
        <param name="function">Travail à exécuter de façon asynchrone</param>
        <param name="cancellationToken">Jeton d'annulation qui doit être utilisé pour annuler le travail</param>
        <summary>Met en file d’attente le travail spécifié à exécuter dans le pool de threads et retourne un proxy pour le <see langword="Task(TResult)" /> retourné par <paramref name="function" />.</summary>
        <returns><see langword="Task(TResult)" /> qui représente un proxy de la <see langword="Task(TResult)" /> retournée par <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la gestion des exceptions levées par les opérations de la tâche, consultez [gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur du paramètre <paramref name="function" /> était <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">La tâche a été annulée.</exception>
        <exception cref="T:System.ObjectDisposedException">La <see cref="T:System.Threading.CancellationTokenSource" /> associée au <paramref name="cancellationToken" /> a été supprimée.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestion des exceptions (bibliothèque parallèle de tâches)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type de résultat de la tâche.</typeparam>
        <param name="function">Travail à exécuter de façon asynchrone</param>
        <param name="cancellationToken">Jeton d'annulation qui doit être utilisé pour annuler le travail</param>
        <summary>Met en file d'attente le travail spécifié à exécuter dans le pool de threads et retourne un objet <see langword="Task(TResult)" /> qui représente ce travail. Un jeton d’annulation permet l’annulation du travail.</summary>
        <returns><see langword="Task(TResult)" /> qui représente le travail mis en file d’attente à exécuter dans le pool de threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’annulation est demandée avant le début de la tâche d’exécution, la tâche ne s’exécute pas. Au lieu de cela, il est défini sur le <xref:System.Threading.Tasks.TaskStatus.Canceled> état et lève un <xref:System.Threading.Tasks.TaskCanceledException> exception.  
  
 Le <xref:System.Threading.Tasks.Task.Run%2A> méthode constitue une alternative plus simple à la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> (méthode). Il crée une tâche avec les valeurs par défaut suivantes :  
  
-   Son <xref:System.Threading.Tasks.Task.CreationOptions%2A> valeur de propriété est <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Elle utilise le Planificateur de tâches par défaut.  
  
 Pour plus d’informations sur la gestion des exceptions levées par les opérations de la tâche, consultez [gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 L’exemple suivant crée 20 tâches qui fait une boucle jusqu'à ce qu’un compteur est incrémenté à une valeur de 2 millions. Lorsque les 10 premières tâches atteignent 2 millions, le jeton d’annulation est annulé, et toutes les tâches dont les compteurs n’ont pas atteint 2 millions sont annulées. L’exemple montre les résultats éventuels.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 Au lieu d’utiliser le <xref:System.AggregateException.InnerExceptions%2A> propriété à examiner les exceptions, l’exemple itère toutes les tâches pour déterminer qui ont abouti et qui ont été annulé. Pour ceux qui s’est terminé, il affiche la valeur retournée par la tâche.  
  
 Étant donné que l’annulation est coopérative, chaque tâche peut décider comment répondre à l’annulation. L’exemple suivant est comme la première, sauf que, une fois que le jeton est annulé, les tâches de retourner le nombre d’itérations ils terminée au lieu de lever une exception.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 L’exemple doit toujours gérer le <xref:System.AggregateException> exception, dans la mesure où toutes les tâches qui n’ont pas démarré lors de l’annulation est demandée lèvent toujours une exception.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="function" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">La tâche a été annulée.</exception>
        <exception cref="T:System.ObjectDisposedException">La <see cref="T:System.Threading.CancellationTokenSource" /> associée au <paramref name="cancellationToken" /> a été supprimée.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestion des exceptions (bibliothèque parallèle de tâches)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute de façon synchrone la <see cref="T:System.Threading.Tasks.Task" /> sur le <see cref="T:System.Threading.Tasks.TaskScheduler" /> en cours.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : unit -&gt; unit" Usage="task.RunSynchronously " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exécute de façon synchrone la <see cref="T:System.Threading.Tasks.Task" /> sur le <see cref="T:System.Threading.Tasks.TaskScheduler" /> en cours.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, les tâches sont exécutées de façon asynchrone sur un thread de pool de threads et ne bloquent pas le thread appelant. Tâches exécutées en appelant le <xref:System.Threading.Tasks.Task.RunSynchronously> méthode associés actuel <xref:System.Threading.Tasks.TaskScheduler> et sont exécutés sur le thread appelant. Si le planificateur cible ne prend pas en charge cette tâche en cours d’exécution sur le thread appelant, la tâche sera planifiée pour s’exécuter sur le planificateur et bloque le thread appelant jusqu'à ce que la tâche a terminé son exécution. Même si la tâche s’exécute de façon synchrone, le thread appelant doit toujours appeler <xref:System.Threading.Tasks.Task.Wait%2A> pour gérer les exceptions susceptibles de lever la tâche.  Pour plus d’informations sur la gestion des exceptions, consultez [gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 Tâches exécutées en appelant le <xref:System.Threading.Tasks.Task.RunSynchronously%2A> méthode sont instanciés en appelant un <xref:System.Threading.Tasks.Task> ou <xref:System.Threading.Tasks.Task%601> constructeur de classe. La tâche à exécuter de façon synchrone doit être dans le <xref:System.Threading.Tasks.TaskStatus.Created> état. Une tâche peut être démarrée et exécutée qu’une seule fois. Toute tentative pour planifier une tâche une deuxième fois entraîne une exception.  
  
   
  
## Examples  
 L’exemple suivant compare une tâche exécutée en appelant le <xref:System.Threading.Tasks.Task.RunSynchronously%2A> méthode avec un exécutées de façon asynchrone. Dans les deux cas, les tâches s’exécutent les expressions lambda identiques qui affichent l’ID de tâche et l’ID du thread sur lequel la tâche s’exécute. La tâche calcule la somme des entiers compris entre 1 et 1 000 000. Comme le montre la sortie de l’exemple, la tâche exécutée en appelant le <xref:System.Threading.Tasks.Task.RunSynchronously%2A> méthode s’exécute sur le thread d’application, contrairement à la tâche asynchrone.  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance <see cref="T:System.Threading.Tasks.Task" /> a été supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">La <see cref="T:System.Threading.Tasks.Task" /> n’est pas dans un état valide pour être démarrée. Elle peut avoir déjà été démarrée, exécutée ou annulée, ou créée d’une manière qui ne prend pas en charge la planification directe.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestion des exceptions (bibliothèque parallèle de tâches)</related>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.RunSynchronously scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Planificateur sur lequel tenter d'exécuter cette tâche inline.</param>
        <summary>Exécute de façon synchrone le <see cref="T:System.Threading.Tasks.Task" /> sur le <see cref="T:System.Threading.Tasks.TaskScheduler" /> fourni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tâches exécutées en appelant le <xref:System.Threading.Tasks.Task.RunSynchronously%2A> méthode sont instanciés en appelant un <xref:System.Threading.Tasks.Task> ou <xref:System.Threading.Tasks.Task%601> constructeur de classe. La tâche à exécuter de façon synchrone doit être dans le <xref:System.Threading.Tasks.TaskStatus.Created> état. Une tâche peut être démarrée et exécutée qu’une seule fois. Toute tentative pour planifier une tâche une deuxième fois entraîne une exception.  
  
 Si le planificateur cible ne prend pas en charge cette tâche en cours d’exécution sur le thread actuel, la tâche sera planifiée pour s’exécuter sur le planificateur et bloque le thread actuel jusqu'à ce que la tâche a terminé son exécution. Pour cette raison, le thread appelant est inutile d’appeler une méthode telle que <xref:System.Threading.Tasks.Task.Wait%2A> pour vous assurer que la tâche de fin de l’exécution. Pour plus d’informations sur la gestion des exceptions pour les opérations de tâche, consultez [gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance <see cref="T:System.Threading.Tasks.Task" /> a été supprimée.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="scheduler" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La <see cref="T:System.Threading.Tasks.Task" /> n’est pas dans un état valide pour être démarrée. Elle peut avoir déjà été démarrée, exécutée ou annulée, ou créée d’une manière qui ne prend pas en charge la planification directe.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestion des exceptions (bibliothèque parallèle de tâches)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Démarre <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="task.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Démarre la <see cref="T:System.Threading.Tasks.Task" />, en planifiant son exécution selon le <see cref="T:System.Threading.Tasks.TaskScheduler" /> en cours.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une tâche peut être démarrée et exécutée qu’une seule fois. Toute tentative pour planifier une tâche une deuxième fois provoquera une exception.  
  
 Le <xref:System.Threading.Tasks.Task.Start%2A> est utilisée pour exécuter une tâche qui a été créée en appelant une de le <xref:System.Threading.Tasks.Task> constructeurs. En règle générale, cela lorsque vous avez besoin séparer la création de la tâche à partir de son exécution, notamment lorsque vous exécutez conditionnellement des tâches que vous avez créé. Dans le cas plus courant dans lequel vous n’avez pas besoin de séparer l’instanciation de tâches à partir de l’exécution, nous vous recommandons d’appeler une surcharge de la <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> (méthode).  
  
 Pour plus d’informations sur la gestion des exceptions levées par les opérations de la tâche, consultez [gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> constructeur pour instancier un nouvel <xref:System.Threading.Tasks.Task> objet qui affiche sa tâche ID et l’ID de thread managé, puis exécute une boucle. Il appelle ensuite la <xref:System.Threading.Tasks.Task.Start%2A> méthode à exécuter la tâche.  Dans la mesure où il s’agit d’une application console, l’appel à la <xref:System.Threading.Tasks.Task.Wait%2A> méthode est nécessaire pour empêcher l’application de se terminer avant que la tâche termine l’exécution.  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’instance <see cref="T:System.Threading.Tasks.Task" /> a été supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">La <see cref="T:System.Threading.Tasks.Task" /> n’est pas dans un état valide pour être démarrée. Elle peut avoir déjà été démarrée, exécutée ou annulée, ou créée d’une manière qui ne prend pas en charge la planification directe.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestion des exceptions (bibliothèque parallèle de tâches)</related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.Start : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.Start scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> avec lequel associer et exécuter cette tâche.</param>
        <summary>Démarre la <see cref="T:System.Threading.Tasks.Task" />, en planifiant son exécution sur le <see cref="T:System.Threading.Tasks.TaskScheduler" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une tâche peut uniquement être démarrée et exécutée qu’une seule fois. Toute tentative pour planifier une tâche une deuxième fois provoquera une exception.  
  
 Pour plus d’informations sur la gestion des exceptions levées par les opérations de la tâche, consultez [gestion des exceptions](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="scheduler" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La <see cref="T:System.Threading.Tasks.Task" /> n’est pas dans un état valide pour être démarrée. Elle peut avoir déjà été démarrée, exécutée ou annulée, ou créée d’une manière qui ne prend pas en charge la planification directe.</exception>
        <exception cref="T:System.ObjectDisposedException">L’instance <see cref="T:System.Threading.Tasks.Task" /> a été supprimée.</exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException">Le Planificateur n’a pas pu mettre cette tâche en file d’attente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Gestion des exceptions (bibliothèque parallèle de tâches)</related>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberSignature Language="F#" Value="member this.Status : System.Threading.Tasks.TaskStatus" Usage="System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Threading.Tasks.TaskStatus" /> de cette tâche.</summary>
        <value><see cref="T:System.Threading.Tasks.TaskStatus" /> actuel de cette instance de tâche.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Récupération de la valeur de la <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> propriété ne bloque pas le thread appelant jusqu'à ce que la tâche est terminée.  
  
 Pour plus d’informations et un exemple, consultez [chaînage des tâches à l’aide de tâches de Continuation](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) et [Comment : annuler une tâche et ses enfants](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).  
  
   
  
## Examples  
 L’exemple suivant crée 20 tâches qui fait une boucle jusqu'à ce qu’un compteur est incrémenté à une valeur de 2 millions. Lorsque les 10 premières tâches atteignent 2 millions, le jeton d’annulation est annulé, et toutes les tâches dont les compteurs n’ont pas atteint 2 millions sont annulées. L’exemple examine ensuite le <xref:System.Threading.Tasks.Task.Status%2A> propriété de chaque tâche pour indiquer s’il s’est terminée correctement ou a été annulée. Pour ceux qui terminée, il affiche la valeur retournée par la tâche.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System::IAsyncResult::AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Threading.WaitHandle" /> qui peut être utilisé en attendant la fin de la tâche.</summary>
        <value><see cref="T:System.Threading.WaitHandle" /> qui peut être utilisé pour attendre la fin de la tâche.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À l’aide de la fonctionnalité d’attente fournie par <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> est préférable à l’utilisation <xref:System.IAsyncResult.AsyncWaitHandle%2A> pour une fonctionnalité similaire. Pour plus d’informations, consultez la section « En attente de tâches » dans [basé sur des tâches de programmation asynchrone](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) et [à l’aide de la TPL avec d’autres modèles asynchrones](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System::IAsyncResult::CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une indication précisant si l'opération s'est terminée de manière synchrone.</summary>
        <value><see langword="true" /> si l'opération s'est exécutée de manière synchrone ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attend la fin de l'exécution de <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="task.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attend la fin de l'exécution de <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%2A> est une méthode de synchronisation qui bloque le thread appelant à attendre la fin de la tâche en cours. Si la tâche en cours n’a pas démarré l’exécution, la méthode Wait tente de supprimer la tâche du planificateur et exécutez-la inline sur le thread actuel. S’il est impossible pour ce faire, ou si la tâche en cours a déjà démarré l’exécution, elle bloque le thread appelant jusqu'à ce que la tâche se termine. Pour plus d’informations, consultez [Task.Wait et la fonctionnalité « inline »](https://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx) dans le blog programmation parallèle avec .NET.   
  
## Examples  
 L’exemple suivant démarre une tâche qui génère un million d’entiers aléatoires compris entre 0 et 100 et calcule leur moyenne. L’exemple utilise le <xref:System.Threading.Tasks.Task.Wait%2A> pour s’assurer que la tâche se termine avant que l’application se termine. Sinon, car il s’agit d’une application console, l’exemple se terminerait avant que la tâche peut calculer et afficher la moyenne.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.</exception>
        <exception cref="T:System.AggregateException">La tâche a été annulée. La collection <see cref="P:System.AggregateException.InnerExceptions" /> contient un objet <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
ou 
Une exception a été levée pendant l’exécution de la tâche. La collection <see cref="P:System.AggregateException.InnerExceptions" /> contient des informations sur l’exception ou les exceptions.</exception>
        <related type="ExternalDocumentation" href="https://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx">Task.Wait et « Inline »</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="task.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <summary>Attend la fin de l'exécution de la <see cref="T:System.Threading.Tasks.Task" /> en un nombre de millisecondes spécifié.</summary>
        <returns><see langword="true" /> si l'exécution de <see cref="T:System.Threading.Tasks.Task" /> s'est terminée dans le délai imparti ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> est une méthode de synchronisation qui bloque le thread appelant à attendre pour l’instance actuelle de la tâche effectuer jusqu'à ce qu’une des actions suivantes se produit :  
  
-   La tâche se termine correctement.  
  
-   La tâche elle-même est annulée ou lève une exception. Dans ce cas, vous gérez un <xref:System.AggregateException> exception. Le <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> propriété contient des détails sur l’exception ou les exceptions.  
  
-   L’intervalle défini par `millisecondsTimeout` s’écoule. Dans ce cas, le thread actuel reprend l’exécution et la méthode retourne `false`.  
  
   
  
## Examples  
 L’exemple suivant démarre une tâche qui génère des entiers aléatoires de cinq millions comprise entre 0 et 100 et calcule leur moyenne. L’exemple utilise le <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> méthode pour attendre l’application terminée dans 150 millisecondes. Si l’application se termine normalement, la tâche affiche la somme et moyenne des nombres aléatoires qui il a généré. Si l’intervalle de délai d’expiration est écoulé, l’exemple affiche un message avant sa fermeture.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.AggregateException">La tâche a été annulée. La collection <see cref="P:System.AggregateException.InnerExceptions" /> contient un objet <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
ou 
Une exception a été levée pendant l’exécution de la tâche. La collection <see cref="P:System.AggregateException.InnerExceptions" /> contient des informations sur l’exception ou les exceptions.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="task.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Jeton d’annulation à observer en attendant que la tâche se termine.</param>
        <summary>Attend la fin de l'exécution de <see cref="T:System.Threading.Tasks.Task" />. L'attente se termine si un jeton d'annulation est annulé avant la fin de la tâche.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> méthode crée une attente annulable ; autrement dit, il oblige le thread actuel attendre qu’une des actions suivantes se produit :  
  
-   La tâche se termine.  
  
-   Le jeton d’annulation est annulé. Dans ce cas, l’appel à la <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> méthode lève un <xref:System.OperationCanceledException>.  
  
> [!NOTE]
>  Annulation de la `cancellationToken` jeton d’annulation n’a aucun effet sur la tâche en cours d’exécution, sauf si elle a également été le jeton d’annulation passé et est prêt à gérer l’annulation. En passant le `cancellationToken` objet à cette méthode permet simplement de l’attente d’être annulée.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation d’un jeton d’annulation pour annuler l’attente de fin d’une tâche simple. Une tâche est lancée, appelle le <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> méthode pour annuler toute la source de jeton jetons d’annulation, puis des retards pendant cinq secondes. Notez que la tâche proprement dite n’a pas été passée le jeton d’annulation et s’il n’est pas annulable. Le thread d’application appelle la tâche <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> méthode pour attendre la tâche se termine, mais que l’attente est annulée une fois que le jeton d’annulation est annulé et qu’un <xref:System.OperationCanceledException> est levée. Le Gestionnaire d’exceptions signale l’exception et puis se met en veille pendant six secondes. Comme le montre la sortie de l’exemple, ce délai permet à la tâche se termine dans le <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> état.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> a été annulé.</exception>
        <exception cref="T:System.ObjectDisposedException">La tâche a été supprimée.</exception>
        <exception cref="T:System.AggregateException">La tâche a été annulée. La collection <see cref="P:System.AggregateException.InnerExceptions" /> contient un objet <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
ou 
Une exception a été levée pendant l’exécution de la tâche. La collection <see cref="P:System.AggregateException.InnerExceptions" /> contient des informations sur l’exception ou les exceptions.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="task.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <summary>Attend la fin de l'exécution de la <see cref="T:System.Threading.Tasks.Task" /> dans un intervalle de temps spécifié.</summary>
        <returns><see langword="true" /> si l'exécution de <see cref="T:System.Threading.Tasks.Task" /> s'est terminée dans le délai imparti ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> est une méthode de synchronisation qui bloque le thread appelant à attendre pour l’instance actuelle de la tâche effectuer jusqu'à ce qu’une des actions suivantes se produit :  
  
-   La tâche se termine correctement.  
  
-   La tâche elle-même est annulée ou lève une exception. Dans ce cas, vous gérez un <xref:System.AggregateException> exception. Le <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> propriété contient des détails sur l’exception ou les exceptions.  
  
-   L’intervalle défini par `timeout` s’écoule. Dans ce cas, le thread actuel reprend l’exécution et la méthode retourne `false`.  
  
   
  
## Examples  
 L’exemple suivant démarre une tâche qui génère des entiers aléatoires de cinq millions comprise entre 0 et 100 et calcule leur moyenne. L’exemple utilise le <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> méthode pour attendre l’application terminée dans 150 millisecondes. Si l’application se termine normalement, la tâche affiche la somme et moyenne des nombres aléatoires qui il a généré. Si l’intervalle de délai d’expiration est écoulé, l’exemple affiche un message avant sa fermeture.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini. 
ou 
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">La tâche a été annulée. La collection <see cref="P:System.AggregateException.InnerExceptions" /> contient un objet <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
ou 
Une exception a été levée pendant l’exécution de la tâche. La collection <see cref="P:System.AggregateException.InnerExceptions" /> contient des informations sur l’exception ou les exceptions.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="task.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <param name="cancellationToken">Jeton d’annulation à observer en attendant que la tâche se termine.</param>
        <summary>Attend la fin de l'exécution de <see cref="T:System.Threading.Tasks.Task" />. L'attente se termine si un intervalle de délai est écoulé ou si un jeton d'annulation est annulé avant la fin de la tâche.</summary>
        <returns><see langword="true" /> si l'exécution de <see cref="T:System.Threading.Tasks.Task" /> s'est terminée dans le délai imparti ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> est une méthode de synchronisation qui bloque le thread appelant à attendre pour l’instance actuelle de la tâche effectuer jusqu'à ce qu’une des actions suivantes se produit :  
  
-   La tâche se termine correctement.  
  
-   La tâche elle-même est annulée ou lève une exception. Dans ce cas, vous gérez un <xref:System.AggregateException> exception. Le <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> propriété contient des détails sur l’exception ou les exceptions.  
  
-   Le `cancellationToken` jeton d’annulation est annulé. Dans ce cas, l’appel à la <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> méthode lève un <xref:System.OperationCanceledException>.  
  
-   L’intervalle défini par `millisecondsTimeout` s’écoule. Dans ce cas, le thread actuel reprend l’exécution et la méthode retourne `false`.  
  
> [!NOTE]
>  Annulation de la `cancellationToken` jeton d’annulation n’a aucun effet sur la tâche en cours d’exécution, sauf si elle a également été le jeton d’annulation passé et est prêt à gérer l’annulation. En passant le `cancellationToken` objet à cette méthode permet simplement l’attente d’être annulée en fonction de certaines conditions.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> méthode pour fournir une valeur de délai d’attente et une annulation de jeton qui peut se terminer l’attente de fin d’une tâche. Un nouveau thread est démarré et qu’il exécute le `CancelToken` (méthode), qui met en pause et appelle ensuite la <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> méthode pour annuler les jetons d’annulation. Une tâche est alors lancée et retarde pendant 5 secondes. Le <xref:System.Threading.Tasks.Task.Wait%2A> méthode est ensuite appelée pour attendre la fin de la tâche et n’est fournie à la fois un bref délai et un jeton d’annulation.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 Notez que la sortie précise à partir de l’exemple dépend de si l’attente a été annulée en raison du jeton d’annulation ou parce que l’intervalle de délai d’expiration est écoulé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> a été annulé.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.AggregateException">La tâche a été annulée. La collection <see cref="P:System.AggregateException.InnerExceptions" /> contient un objet <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  
  
ou 
Une exception a été levée pendant l’exécution de la tâche. La collection <see cref="P:System.AggregateException.InnerExceptions" /> contient des informations sur l’exception ou les exceptions.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attend la fin de l'exécution de tous les objets <see cref="T:System.Threading.Tasks.Task" /> fournis.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Tableau d'instances de <see cref="T:System.Threading.Tasks.Task" /> sur lesquelles attendre.</param>
        <summary>Attend la fin de l'exécution de tous les objets <see cref="T:System.Threading.Tasks.Task" /> fournis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant démarre les tâches de 10, chacun d’eux est passé à un index en tant qu’un objet d’état. Tâches avec un index de deux à cinq lever des exceptions. L’appel à la <xref:System.Threading.Tasks.Task.WaitAll%2A> méthode encapsule toutes les exceptions dans un <xref:System.AggregateException> de l’objet et se propage vers le thread appelant.  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Un ou plusieurs objets <see cref="T:System.Threading.Tasks.Task" /> de <paramref name="tasks" /> ont été supprimés.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L’argument <paramref name="tasks" /> contient un élément Null.  
  
ou 
L’argument <paramref name="tasks" /> est un tableau vide.</exception>
        <exception cref="T:System.AggregateException">Au moins une des instances de <see cref="T:System.Threading.Tasks.Task" /> a été annulée. Si une tâche a été annulée, l’exception <see cref="T:System.AggregateException" /> contient une exception <see cref="T:System.OperationCanceledException" /> dans sa collection <see cref="P:System.AggregateException.InnerExceptions" />.  
  
ou 
Une exception a été levée pendant l’exécution d’au moins une des instances de <see cref="T:System.Threading.Tasks.Task" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau d'instances de <see cref="T:System.Threading.Tasks.Task" /> sur lesquelles attendre.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <summary>Attend la fin de l'exécution de tous les objets <see cref="T:System.Threading.Tasks.Task" /> fournis en un nombre de millisecondes spécifié.</summary>
        <returns><see langword="true" /> si l'exécution de toutes les instances <see cref="T:System.Threading.Tasks.Task" /> s'est terminée dans le délai imparti ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Un ou plusieurs objets <see cref="T:System.Threading.Tasks.Task" /> de <paramref name="tasks" /> ont été supprimés.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Au moins une des instances de <see cref="T:System.Threading.Tasks.Task" /> a été annulée. Si une tâche a été annulée, <see cref="T:System.AggregateException" /> contient <see cref="T:System.OperationCanceledException" /> dans sa collection <see cref="P:System.AggregateException.InnerExceptions" />.  
  
ou 
Une exception a été levée pendant l’exécution d’au moins une des instances de <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.ArgumentException">L’argument <paramref name="tasks" /> contient un élément Null.  
  
ou 
L’argument <paramref name="tasks" /> est un tableau vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau d'instances de <see cref="T:System.Threading.Tasks.Task" /> sur lesquelles attendre.</param>
        <param name="cancellationToken">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> à observer en attendant que les tâches se terminent.</param>
        <summary>Attend la fin de l'exécution de tous les objets <see cref="T:System.Threading.Tasks.Task" /> fournis sauf si l'attente est annulée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `cancellationToken` argument est utilisé pour annuler l’opération d’attente. L’annulation des tâches est une opération distincte et est signalée par le <xref:System.AggregateException> comme indiqué ci-dessus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> a été annulé.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Au moins une des instances de <see cref="T:System.Threading.Tasks.Task" /> a été annulée. Si une tâche a été annulée, <see cref="T:System.AggregateException" /> contient <see cref="T:System.OperationCanceledException" /> dans sa collection <see cref="P:System.AggregateException.InnerExceptions" />.  
  
ou 
Une exception a été levée pendant l’exécution d’au moins une des instances de <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentException">L’argument <paramref name="tasks" /> contient un élément Null.  
  
ou 
L’argument <paramref name="tasks" /> est un tableau vide.</exception>
        <exception cref="T:System.ObjectDisposedException">Un ou plusieurs objets <see cref="T:System.Threading.Tasks.Task" /> de <paramref name="tasks" /> ont été supprimés.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * TimeSpan -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau d'instances de <see cref="T:System.Threading.Tasks.Task" /> sur lesquelles attendre.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <summary>Attend la fin de l'exécution de tous les objets <see cref="T:System.Threading.Tasks.Task" /> pouvant être annulés fournis dans un intervalle de temps spécifié.</summary>
        <returns><see langword="true" /> si l'exécution de toutes les instances <see cref="T:System.Threading.Tasks.Task" /> s'est terminée dans le délai imparti ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Un ou plusieurs objets <see cref="T:System.Threading.Tasks.Task" /> de <paramref name="tasks" /> ont été supprimés.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Au moins une des instances de <see cref="T:System.Threading.Tasks.Task" /> a été annulée. Si une tâche a été annulée, <see cref="T:System.AggregateException" /> contient <see cref="T:System.OperationCanceledException" /> dans sa collection <see cref="P:System.AggregateException.InnerExceptions" />.  
  
ou 
Une exception a été levée pendant l’exécution d’au moins une des instances de <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d’attente infini. 
ou 
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">L’argument <paramref name="tasks" /> contient un élément Null.  
  
ou 
L’argument <paramref name="tasks" /> est un tableau vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau d'instances de <see cref="T:System.Threading.Tasks.Task" /> sur lesquelles attendre.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <param name="cancellationToken">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> à observer en attendant que les tâches se terminent.</param>
        <summary>Attend la fin de l'exécution de tous les objets <see cref="T:System.Threading.Tasks.Task" /> fournis en un nombre de millisecondes spécifié ou jusqu'à ce que l'attente soit annulée.</summary>
        <returns><see langword="true" /> si l'exécution de toutes les instances <see cref="T:System.Threading.Tasks.Task" /> s'est terminée dans le délai imparti ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `cancellationToken` argument est utilisé pour annuler l’opération d’attente. L’annulation des tâches est une opération distincte et est signalée par le <xref:System.AggregateException> indiqué ci-dessus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Un ou plusieurs objets <see cref="T:System.Threading.Tasks.Task" /> de <paramref name="tasks" /> ont été supprimés.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Au moins une des instances de <see cref="T:System.Threading.Tasks.Task" /> a été annulée. Si une tâche a été annulée, <see cref="T:System.AggregateException" /> contient <see cref="T:System.OperationCanceledException" /> dans sa collection <see cref="P:System.AggregateException.InnerExceptions" />.  
  
ou 
Une exception a été levée pendant l’exécution d’au moins une des instances de <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.ArgumentException">L’argument <paramref name="tasks" /> contient un élément Null.  
  
ou 
L’argument <paramref name="tasks" /> est un tableau vide.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> a été annulé.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attend la fin de l'exécution de l'un des objets <see cref="T:System.Threading.Tasks.Task" /> fournis.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Tableau d'instances de <see cref="T:System.Threading.Tasks.Task" /> sur lesquelles attendre.</param>
        <summary>Attend la fin de l'exécution de l'un des objets <see cref="T:System.Threading.Tasks.Task" /> fournis.</summary>
        <returns>Index de l’objet <see cref="T:System.Threading.Tasks.Task" /> terminé dans le tableau <paramref name="tasks" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant lance cinq tâches, chacun d’eux se met en veille pour un minimum de 50 millisecondes ou un maximum de 1,050 millisecondes. Le <xref:System.Threading.Tasks.Task.WaitAny%2A> méthode attend ensuite les tâches à effectuer. L’exemple affiche l’ID de tâche de la tâche de fin de l’attente, ainsi que l’état actuel de toutes les tâches.  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L’argument <paramref name="tasks" /> contient un élément Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau d'instances de <see cref="T:System.Threading.Tasks.Task" /> sur lesquelles attendre.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <summary>Attend la fin de l'exécution de l'un des objets <see cref="T:System.Threading.Tasks.Task" /> fournis en un nombre de millisecondes spécifié.</summary>
        <returns>Index de la tâche achevée dans l'argument de tableau <paramref name="tasks" /> ou -1, si le délai a expiré.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.ArgumentException">L’argument <paramref name="tasks" /> contient un élément Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau d'instances de <see cref="T:System.Threading.Tasks.Task" /> sur lesquelles attendre.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> à observer en attendant qu'une tâche se termine.</param>
        <summary>Attend la fin de l'exécution de l'un des objets <see cref="T:System.Threading.Tasks.Task" /> fournis sauf si l'attente est annulée.</summary>
        <returns>Index de la tâche achevée dans l'argument de tableau <paramref name="tasks" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L’argument <paramref name="tasks" /> contient un élément Null.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> a été annulé.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * TimeSpan -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau d'instances de <see cref="T:System.Threading.Tasks.Task" /> sur lesquelles attendre.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <summary>Attend la fin de l'exécution de n'importe lequel des objets <see cref="T:System.Threading.Tasks.Task" /> fournis dans un intervalle de temps spécifié.</summary>
        <returns>Index de la tâche achevée dans l'argument de tableau <paramref name="tasks" /> ou -1, si le délai a expiré.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La propriété <see cref="P:System.TimeSpan.TotalMilliseconds" /> de l’argument <paramref name="timeout" /> est un nombre négatif autre que -1, qui représente un délai d'attente infini. 
ou 
La propriété <see cref="P:System.TimeSpan.TotalMilliseconds" /> de l’argument <paramref name="timeout" /> est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">L’argument <paramref name="tasks" /> contient un élément Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tableau d'instances de <see cref="T:System.Threading.Tasks.Task" /> sur lesquelles attendre.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> à observer en attendant qu'une tâche se termine.</param>
        <summary>Attend la fin de l'exécution de l'un des objets <see cref="T:System.Threading.Tasks.Task" /> fournis en un nombre de millisecondes spécifié ou jusqu'à ce qu'un jeton d'annulation soit annulé.</summary>
        <returns>Index de la tâche achevée dans l'argument de tableau <paramref name="tasks" /> ou -1, si le délai a expiré.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.ArgumentException">L’argument <paramref name="tasks" /> contient un élément Null.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> a été annulé.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une tâche qui s'achève lorsque toutes les tâches fournies sont terminées.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Tâches restantes à exécuter avant la fin.</param>
        <summary>Crée une tâche qui s’achève quand tous les objets <see cref="T:System.Threading.Tasks.Task" /> d’une collection énumérable sont terminés.</summary>
        <returns>Tâche qui représente l'achèvement de toutes les tâches fournies.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de la <xref:System.Threading.Tasks.Task.WhenAll%2A> méthode qui retourne un <xref:System.Threading.Tasks.Task> objet sont généralement appelées lorsque vous vous intéressez dans l’état d’un ensemble de tâches ou dans les exceptions levées par un ensemble de tâches.  
  
> [!NOTE]
>  L’appel à <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> méthode ne bloque pas le thread appelant.  
  
 Si une des tâches fournies se termine dans un état d’erreur, la tâche retournée se termine également dans un <xref:System.Threading.Tasks.TaskStatus.Faulted> état, où ses exceptions contiendra l’agrégation de l’ensemble des exceptions non encapsulées à partir de chacune des tâches fournies.  
  
 Si aucune des tâches fournis a généré une erreur, mais au moins un d’eux a été annulé, la tâche retournée se termine dans le <xref:System.Threading.Tasks.TaskStatus.Canceled> état.  
  
 Si aucune des tâches a échoué et aucune des tâches ont été annulées, la tâche qui en résulte se termine dans le <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> état.  
  
 Si le fourni tableau/énumérable ne contient aucune tâche, la tâche retournée sera immédiatement passer à un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> état avant d’être retournée à l’appelant.  
  
   
  
## Examples  
 L’exemple suivant crée un ensemble de tâches qui un test ping sur les URL dans un tableau. Les tâches sont stockées dans un `List<Task>` collection qui est passée à la <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> (méthode). Après l’appel à la <xref:System.Threading.Tasks.Task.Wait%2A> méthode garantit que tous les threads sont terminés, l’exemple examine la <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> propriété afin de déterminer si toutes les tâches ont généré une erreur.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> était <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La collection de <paramref name="tasks" /> contenait une tâche <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Tâches restantes à exécuter avant la fin.</param>
        <summary>Crée une tâche qui s’achève quand tous les objets <see cref="T:System.Threading.Tasks.Task" /> d’un tableau sont terminés.</summary>
        <returns>Tâche qui représente l'achèvement de toutes les tâches fournies.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de la <xref:System.Threading.Tasks.Task.WhenAll%2A> méthode qui retourne un <xref:System.Threading.Tasks.Task> objet sont généralement appelées lorsque vous vous intéressez dans l’état d’un ensemble de tâches ou dans les exceptions levées par un ensemble de tâches.  
  
> [!NOTE]
>  L’appel à <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> méthode ne bloque pas le thread appelant.  
  
 Si une des tâches fournies se termine dans un état d’erreur, la tâche retournée se termine également dans un <xref:System.Threading.Tasks.TaskStatus.Faulted> état, où ses exceptions contiendra l’agrégation de l’ensemble des exceptions non encapsulées à partir de chacune des tâches fournies.  
  
 Si aucune des tâches fournis a généré une erreur, mais au moins un d’eux a été annulé, la tâche retournée se termine dans le <xref:System.Threading.Tasks.TaskStatus.Canceled> état.  
  
 Si aucune des tâches a échoué et aucune des tâches ont été annulées, la tâche qui en résulte se termine dans le <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> état.  
  
 Si le fourni tableau/énumérable ne contient aucune tâche, la tâche retournée sera immédiatement passer à un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> état avant d’être retournée à l’appelant.  
  
   
  
## Examples  
 L’exemple suivant crée un ensemble de tâches qui un test ping sur les URL dans un tableau. Les tâches sont stockées dans un `List<Task>` collection qui est convertie en un tableau et transmise à la <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> (méthode). Après l’appel à la <xref:System.Threading.Tasks.Task.Wait%2A> méthode garantit que tous les threads sont terminés, l’exemple examine la <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> propriété afin de déterminer si toutes les tâches ont généré une erreur.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> était <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau de <paramref name="tasks" /> contenait une tâche <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type de la tâche terminée.</typeparam>
        <param name="tasks">Tâches restantes à exécuter avant la fin.</param>
        <summary>Crée une tâche qui s’achève quand tous les objets <see cref="T:System.Threading.Tasks.Task`1" /> d’une collection énumérable sont terminés.</summary>
        <returns>Tâche qui représente l'achèvement de toutes les tâches fournies.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’appel à <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> méthode ne bloque pas le thread appelant. Toutefois, un appel à retourné <xref:System.Threading.Tasks.Task%601.Result%2A> propriété ne bloque le thread appelant.  
  
 Si une des tâches fournies se termine dans un état d’erreur, la tâche retournée se termine également dans un <xref:System.Threading.Tasks.TaskStatus.Faulted> état, où ses exceptions contiendra l’agrégation de l’ensemble des exceptions non encapsulées à partir de chacune des tâches fournies.  
  
 Si aucune des tâches fournis a généré une erreur, mais au moins un d’eux a été annulé, la tâche retournée se termine dans le <xref:System.Threading.Tasks.TaskStatus.Canceled> état.  
  
 Si aucune des tâches a échoué et aucune des tâches ont été annulées, la tâche qui en résulte se termine dans le <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> état.  Le <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> propriété de la tâche retournée est fixée à un tableau contenant tous les résultats des tâches fournies dans le même ordre, car elles ont été fournies (par exemple, si l’entrée des tâches tableau contenu t1, t2, t3, la tâche de sortie <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> propriété retournera un `TResult[]` où `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Si le `tasks` argument ne contient aucune tâche, la tâche retournée passe immédiatement à un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> état avant d’être retournée à l’appelant. Retourné `TResult[]` sera un tableau d’éléments de 0.  
  
   
  
## Examples  
 L’exemple suivant crée dix tâches, chacun d’eux instancie un générateur de nombres aléatoires qui crée les 1 000 nombres aléatoires compris entre 1 et 1 000 et calcule leur moyenne. Le <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> méthode est utilisée pour retarder l’instanciation de générateurs de nombres aléatoires afin qu’ils ne sont pas créés avec les mêmes valeurs initiales. L’appel à la <xref:System.Threading.Tasks.Task.WhenAll%2A> méthode renvoie alors un <xref:System.Int64> tableau qui contient la moyenne calculée par chaque tâche. Ceux-ci sont ensuite utilisés pour calculer la moyenne globale.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 Dans ce cas, les dix tâches individuelles sont stockés dans un <xref:System.Collections.Generic.List%601> objet. <xref:System.Collections.Generic.List%601> implémente l'interface <xref:System.Collections.Generic.IEnumerable%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> était <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La collection de <paramref name="tasks" /> contenait une tâche <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type de la tâche terminée.</typeparam>
        <param name="tasks">Tâches restantes à exécuter avant la fin.</param>
        <summary>Crée une tâche qui s’achève quand tous les objets <see cref="T:System.Threading.Tasks.Task`1" /> d’un tableau sont terminés.</summary>
        <returns>Tâche qui représente l'achèvement de toutes les tâches fournies.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’appel à <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> méthode ne bloque pas le thread appelant. Toutefois, un appel à retourné <xref:System.Threading.Tasks.Task%601.Result%2A> propriété ne bloque le thread appelant.  
  
 Si une des tâches fournies se termine dans un état d’erreur, la tâche retournée se termine également dans un <xref:System.Threading.Tasks.TaskStatus.Faulted> état, où ses exceptions contiendra l’agrégation de l’ensemble des exceptions non encapsulées à partir de chacune des tâches fournies.  
  
 Si aucune des tâches fournis a généré une erreur, mais au moins un d’eux a été annulé, la tâche retournée se termine dans le <xref:System.Threading.Tasks.TaskStatus.Canceled> état.  
  
 Si aucune des tâches a échoué et aucune des tâches ont été annulées, la tâche qui en résulte se termine dans le <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> état.  Le <xref:System.Threading.Tasks.Task%601.Result%2A> de la tâche retournée est défini sur un tableau contenant tous les résultats des tâches fournies dans le même ordre, car elles ont été fournies (par exemple, si l’entrée des tâches tableau contenu t1, t2, t3, la tâche de sortie <xref:System.Threading.Tasks.Task%601.Result%2A> retournera un `TResult[]` où `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Si le fourni tableau/énumérable ne contient aucune tâche, la tâche retournée sera immédiatement passer à un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> état avant d’être retournée à l’appelant.  Retourné `TResult[]` sera un tableau d’éléments de 0.  
  
   
  
## Examples  
 L’exemple suivant crée dix tâches, chacun d’eux instancie un générateur de nombres aléatoires qui crée les 1 000 nombres aléatoires compris entre 1 et 1 000 et calcule leur moyenne. Dans ce cas, les dix tâches individuelles sont stockés dans un `Task<Int64>` tableau.  Le <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> méthode est utilisée pour retarder l’instanciation de générateurs de nombres aléatoires afin qu’ils ne sont pas créés avec les mêmes valeurs initiales. L’appel à la <xref:System.Threading.Tasks.Task.WhenAll%2A> méthode renvoie alors un <xref:System.Int64> tableau qui contient la moyenne calculée par chaque tâche. Ceux-ci sont ensuite utilisés pour calculer la moyenne globale.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> était <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le tableau de <paramref name="tasks" /> contenait une tâche <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une tâche qui s'achève lorsque l'une des tâches fournies est terminée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Tâches restantes à exécuter avant la fin.</param>
        <summary>Crée une tâche qui s'achève lorsque l'une des tâches fournies est terminée.</summary>
        <returns>Tâche qui représente l'achèvement de l'une des tâches fournies.  Le résultat de la tâche de retour est la tâche qui s'est terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tâche retournée se termine lorsque une des tâches fournies est terminée.  La tâche retournée se terminera toujours dans le `RanToCompletion` état avec son jeu de résultats à la première tâche à effectuer.  Cela est vrai même si la première tâche se termine s’est terminée sur le `Canceled` ou `Faulted` état.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> était <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contenait une tâche null ou était vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Tâches restantes à exécuter avant la fin.</param>
        <summary>Crée une tâche qui s'achève lorsque l'une des tâches fournies est terminée.</summary>
        <returns>Tâche qui représente l'achèvement de l'une des tâches fournies.  Le résultat de la tâche de retour est la tâche qui s'est terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tâche retournée se termine lorsque une des tâches fournies est terminée.  La tâche retournée se terminera toujours dans le `RanToCompletion` état avec son `Result` définie pour la première tâche à effectuer.  Cela est vrai même si la première tâche se termine s’est terminée sur le `Canceled` ou `Faulted` état.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> avait la valeur null.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contenait une tâche null ou était vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type de la tâche terminée.</typeparam>
        <param name="tasks">Tâches restantes à exécuter avant la fin.</param>
        <summary>Crée une tâche qui s'achève lorsque l'une des tâches fournies est terminée.</summary>
        <returns>Tâche qui représente l'achèvement de l'une des tâches fournies.  Le résultat de la tâche de retour est la tâche qui s'est terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tâche retournée se termine lorsque une des tâches fournies est terminée.  La tâche retournée se termine toujours dans un état RanToCompletion par son jeu de résultats à la première tâche à effectuer. Cela est vrai même si la première tâche se termine terminée dans l’état annulé ou Faulted.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> était <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contenait une tâche null ou était vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Type de la tâche terminée.</typeparam>
        <param name="tasks">Tâches restantes à exécuter avant la fin.</param>
        <summary>Crée une tâche qui s'achève lorsque l'une des tâches fournies est terminée.</summary>
        <returns>Tâche qui représente l'achèvement de l'une des tâches fournies.  Le résultat de la tâche de retour est la tâche qui s'est terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tâche retournée se termine lorsque une des tâches fournies est terminée.  La tâche retournée se termine toujours dans un état RanToCompletion par son jeu de résultats à la première tâche à effectuer. Cela est vrai même si la première tâche se termine terminée dans l’état annulé ou Faulted.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">L'argument <paramref name="tasks" /> avait la valeur null.</exception>
        <exception cref="T:System.ArgumentException">La matrice <paramref name="tasks" /> contenait une tâche null ou était vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Runtime.CompilerServices.YieldAwaitable" Usage="System.Threading.Tasks.Task.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une tâche awaitable qui cède de manière asynchrone sur le contexte actuel une fois attendu.</summary>
        <returns>Contexte qui, une fois attendu, reviendra de façon asynchrone au contexte qui était le sien au moment de l'attente. Si le <see cref="T:System.Threading.SynchronizationContext" /> actuel n'a pas la valeur null, il est traité comme le contexte actuel. Sinon, le planificateur de tâches associé à la tâche en cours est traité comme le contexte actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser `await Task.Yield();` dans une méthode asynchrone pour forcer la méthode se termine de façon asynchrone. S’il existe un contexte de synchronisation actuel (<xref:System.Threading.SynchronizationContext> objet), cela permet de valider le reste de l’exécution de la méthode vers ce contexte. Toutefois, le contexte décide comment hiérarchiser ce travail par rapport à d’autres tâches qui peuvent être en attente. Le contexte de synchronisation qui est présent sur un thread d’interface utilisateur dans la plupart des environnements de l’interface utilisateur sera souvent hiérarchiser les tâches publiées sur le contexte supérieur de l’entrée et de travail de rendu. Pour cette raison, ne comptez pas sur `await Task.Yield();` pour conserver une interface utilisateur réactive.  Pour plus d’informations, consultez l’entrée [utile Abstractions activé avec ContinueWith](https://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx) dans le blog programmation parallèle avec .NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>