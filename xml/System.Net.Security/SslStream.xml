<Type Name="SslStream" FullName="System.Net.Security.SslStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="118493763856ee6d3548c08f5ca70738432eecd8" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52210177" /></Metadata><TypeSignature Language="C#" Value="public class SslStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SslStream extends System.Net.Security.AuthenticatedStream implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.SslStream" />
  <TypeSignature Language="VB.NET" Value="Public Class SslStream&#xA;Inherits AuthenticatedStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class SslStream : System::Net::Security::AuthenticatedStream" />
  <TypeSignature Language="F#" Value="type SslStream = class&#xA;    inherit AuthenticatedStream&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fournit un flux utilisé pour la communication client-serveur qui passe par le protocole de sécurité Secure Socket Layer (SSL) pour authentifier le serveur et éventuellement le client.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protocole SSL permet d’assurer la confidentialité et vérifier l’intégrité des messages transmis à l’aide un <xref:System.Net.Security.SslStream>. Une connexion SSL, telle que celle fournie par <xref:System.Net.Security.SslStream>, doit être utilisé lorsque communiquer des informations sensibles entre un client et un serveur. À l’aide un <xref:System.Net.Security.SslStream> contribue à empêcher la lecture et la falsification d’informations en transit sur le réseau.  
  
 Un <xref:System.Net.Security.SslStream> instance transmet des données à l’aide d’un flux que vous fournissez lors de la création du <xref:System.Net.Security.SslStream>. Lorsque vous fournissez ce flux sous-jacent, vous avez l’option pour spécifier si la fermeture de la <xref:System.Net.Security.SslStream> ferme également le flux sous-jacent. En règle générale, le <xref:System.Net.Security.SslStream> classe est utilisée avec la <xref:System.Net.Sockets.TcpClient> et <xref:System.Net.Sockets.TcpListener> classes. Le <xref:System.Net.Sockets.TcpClient.GetStream%2A> méthode fournit un <xref:System.Net.Sockets.NetworkStream> pouvant être utilisé avec la <xref:System.Net.Security.SslStream> classe.  
  
 Après avoir créé un <xref:System.Net.Security.SslStream>, le serveur et éventuellement, le client doivent être authentifiées. Le serveur doit fournir un X509 certificat qui établit la preuve de son identité et vous pouvez demander que le client également le faire. L’authentification doit être effectuée avant de transmettre des informations à l’aide un <xref:System.Net.Security.SslStream>. Les clients initient l’authentification à l’aide de la commande synchrone <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> méthodes, qui se bloquent jusqu'à ce que l’authentification terminée, ou asynchrone <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> méthodes, qui ne bloquent pas en attente pour l’authentification. Serveurs initialisent l’authentification à l’aide de la commande synchrone <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> ou asynchrone <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> méthodes. Client et le serveur doivent lancer l’authentification.  
  
 L’authentification est gérée par le fournisseur de canal de prise en charge SSPI (Security Provider). Le client est la possibilité de contrôler la validation du certificat du serveur en spécifiant un <xref:System.Net.Security.RemoteCertificateValidationCallback> délégué lorsque vous créez un <xref:System.Net.Security.SslStream>. Le serveur peut également contrôler la validation en fournissant un <xref:System.Net.Security.RemoteCertificateValidationCallback> déléguer. La méthode référencée par le délégué inclut le certificat du tiers distant et les erreurs SSPI rencontrée pendant la validation du certificat. Notez que si le serveur Spécifie un délégué, la méthode du délégué est appelée indépendamment de si le serveur a demandé l’authentification du client. Si le serveur n’a pas demandé l’authentification du client, la méthode du serveur délégué reçoit un certificat nul et un tableau vide d’erreurs de certificat.  
  
 Si le serveur requiert l’authentification du client, le client doit spécifier un ou plusieurs certificats pour l’authentification. Si le client possède plusieurs certificats, le client peut fournir un <xref:System.Net.Security.LocalCertificateSelectionCallback> délégué pour sélectionner le certificat approprié pour le serveur. Les certificats du client doivent se trouver dans « Mon » magasin de certificats l’utilisateur actuel. L’authentification du client via des certificats n’est pas pris en charge pour le <xref:System.Security.Authentication.SslProtocols.Ssl2> protocole (SSL version 2).  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException>et le <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
 Lorsque le processus d’authentification, également connu sous la négociation SSL, réussit, l’identité du serveur (et éventuellement, le client) est établie et les <xref:System.Net.Security.SslStream> peut être utilisé par le client et le serveur pour échanger des messages. Avant d’envoyer ou recevoir des informations, le client et le serveur doivent vérifier les services de sécurité et les niveaux fournies par le <xref:System.Net.Security.SslStream> pour déterminer si le protocole, les algorithmes et les forces sélectionnées répondent aux exigences d’intégrité et confidentialité. Si les paramètres actuels ne sont pas suffisantes, le flux doit être fermé. Vous pouvez vérifier les services de sécurité fournis par le <xref:System.Net.Security.SslStream> à l’aide de la <xref:System.Net.Security.SslStream.IsEncrypted%2A> et <xref:System.Net.Security.SslStream.IsSigned%2A> propriétés. Le tableau suivant présente les éléments qui signalent les paramètres de chiffrement utilisés pour l’authentification, chiffrement et signature de données.  
  
|Élément|Membres|  
|-------------|-------------|  
|Le protocole de sécurité utilisé pour authentifier le serveur et, éventuellement, le client.|Le <xref:System.Net.Security.SslStream.SslProtocol%2A> associé et propriété <xref:System.Security.Authentication.SslProtocols> énumération.|  
|L’algorithme d’échange de clés.|Le <xref:System.Net.Security.SslStream.KeyExchangeAlgorithm%2A> associé et propriété <xref:System.Security.Authentication.ExchangeAlgorithmType> énumération.|  
|L’algorithme d’intégrité de message.|Le <xref:System.Net.Security.SslStream.HashAlgorithm%2A> associé et propriété <xref:System.Security.Authentication.HashAlgorithmType> énumération.|  
|L’algorithme de confidentialité de message.|Le <xref:System.Net.Security.SslStream.CipherAlgorithm%2A> associé et propriété <xref:System.Security.Authentication.CipherAlgorithmType> énumération.|  
|Les avantages offerts par les algorithmes sélectionnés.|Le <xref:System.Net.Security.SslStream.KeyExchangeStrength%2A>, <xref:System.Net.Security.SslStream.HashStrength%2A>, et <xref:System.Net.Security.SslStream.CipherStrength%2A> propriétés.|  
  
 Après une authentification réussie, vous pouvez envoyer des données à l’aide de la commande synchrone <xref:System.Net.Security.SslStream.Write%2A> ou asynchrone <xref:System.Net.Security.SslStream.BeginWrite%2A> méthodes. Vous pouvez recevoir des données à l’aide de la commande synchrone <xref:System.Net.Security.SslStream.Read%2A> ou asynchrone <xref:System.Net.Security.SslStream.BeginRead%2A> méthodes.  
  
 Si vous avez spécifié pour le <xref:System.Net.Security.SslStream.%23ctor%2A> que le flux sous-jacent doit être laissé ouvert, vous êtes chargé de fermer ce flux de données lorsque vous avez terminé l’utiliser.  
  
> [!NOTE]
>  Si l’application qui crée le <xref:System.Net.Security.SslStream> objet s’exécute avec les informations d’identification d’un utilisateur Normal, l’application ne sera pas en mesure d’accéder aux certificats installés dans le magasin ordinateur local, sauf si l’autorisation a été explicitement accordée à l’utilisateur à le faire.  
  
 <xref:System.Net.Security.SslStream> suppose qu’un délai d’expiration, ainsi que n’importe quel autre <xref:System.IO.IOException> quand une exception est levée à partir du flux interne est traitée comme fatales par son appelant. Réutiliser un <xref:System.Net.Security.SslStream> après un délai d’expiration retournera garbage de l’instance. Une application doit <xref:System.IO.Stream.Close%2A> le <xref:System.Net.Security.SslStream> et lever une exception dans ce cas.  
  
 Le .NET Framework 4.6 inclut une nouvelle fonctionnalité de sécurité qui bloque les algorithmes pour les connexions de hachage et de chiffrement non sécurisé. Applications à l’aide de TLS/SSL via des API telles que HttpClient HttpWebRequest, FTPClient, SmtpClient, SslStream, etc. et ciblant .NET Framework 4.6 Obtient le comportement plus sécurisés par défaut.  
  
 Les développeurs veulent peuvent désactiver ce comportement afin de maintenir l’interopérabilité avec leurs services SSL3 existants ou TLS avec les services de RC4. [Cet article](https://support.microsoft.com/kb/3069494) explique comment modifier votre code afin que le nouveau comportement est désactivé.  
  
 Le .NET Framework 4.7 ajoute de nouvelles surcharges pour les méthodes qui s’authentifient SslStreams qui ne spécifient pas une version TLS, mais à la place utiliser la version TLS définie comme la valeur par défaut du système dans [SCHANNEL](https://msdn.microsoft.com/library/windows/desktop/aa380123.aspx). Utiliser ces méthodes dans votre application comme un moyen pour être en mesure de modifier ultérieurement les valeurs par défaut en tant que TLS version meilleures pratiques change au fil du temps, sans avoir à recréer et redéployer votre application.

 Consultez également [sécurité TLS (Transport Layer) meilleures pratiques avec le .NET Framework](~/docs/framework/network-programming/tls.md).
  
   
  
## Examples  
 L’exemple de code suivant illustre la création d’un <xref:System.Net.Sockets.TcpListener> qui utilise le <xref:System.Net.Security.SslStream> classe pour communiquer avec les clients.  
  
 [!code-cpp[NclSslServerSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#0)]
 [!code-csharp[NclSslServerSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#0)]  
  
 L’exemple de code suivant illustre la création d’un <xref:System.Net.Sockets.TcpClient> qui utilise le <xref:System.Net.Security.SslStream> classe pour communiquer avec un serveur.  
  
 [!code-cpp[NclSslClientSync#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#0)]
 [!code-csharp[NclSslClientSync#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#0)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.Security.NegotiateStream" />
    <altmember cref="T:System.Net.Security.AuthenticatedStream" />
    <altmember cref="T:System.IO.IOException" />
    <altmember cref="T:System.IO.Stream" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Security.SslStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour empêcher le <xref:System.Net.Security.SslStream> de fermer le flux que vous fournissez, utilisez le <xref:System.Net.Security.SslStream.%23ctor%2A> constructeur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.SslStream : System.IO.Stream -&gt; System.Net.Security.SslStream" Usage="new System.Net.Security.SslStream innerStream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="innerStream">Objet <see cref="T:System.IO.Stream" /> utilisé par <see cref="T:System.Net.Security.SslStream" /> pour envoyer et recevoir des données.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Security.SslStream" /> à l'aide du <see cref="T:System.IO.Stream" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une valeur n’est pas spécifiée dans le fichier de configuration d’encryptionpolicy, les <xref:System.Net.Security.EncryptionPolicy> par défaut est <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> pour le <xref:System.Net.Security.SslStream> instance qui est construit.  
  
 L’utilisation du chiffrement Null est nécessaire lorsque la stratégie de chiffrement est définie sur <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="innerStream" /> n’est pas accessible en lecture.  
  
- ou - 
 <paramref name="innerStream" /> n’est pas accessible en écriture.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="innerStream" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="innerStream" /> est égal à <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.SslStream : System.IO.Stream * bool -&gt; System.Net.Security.SslStream" Usage="new System.Net.Security.SslStream (innerStream, leaveInnerStreamOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="innerStream">Objet <see cref="T:System.IO.Stream" /> utilisé par <see cref="T:System.Net.Security.SslStream" /> pour envoyer et recevoir des données.</param>
        <param name="leaveInnerStreamOpen">Valeur booléenne qui indique le comportement de fermeture de l'objet <see cref="T:System.IO.Stream" /> utilisé par <see cref="T:System.Net.Security.SslStream" /> pour l'envoi et la réception de données. Ce paramètre indique si le flux interne est resté ouvert.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Security.SslStream" /> en utilisant le <see cref="T:System.IO.Stream" /> et le comportement de clôture de flux spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous spécifiez `true` pour le `leaveStreamOpen` paramètre, la fermeture de la <xref:System.Net.Security.SslStream> n’a aucun effet le `innerStream` diffuser en continu ; vous devez fermer explicitement `innerStream` lorsque vous n’avez plus besoin.  
  
 Si une valeur n’est pas spécifiée dans le fichier de configuration d’encryptionpolicy, les <xref:System.Net.Security.EncryptionPolicy> par défaut est <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> pour le <xref:System.Net.Security.SslStream> instance qui est construit.  
  
 L’utilisation du chiffrement Null est nécessaire lorsque la stratégie de chiffrement est définie sur <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’appel de ce constructeur.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="innerStream" /> n’est pas accessible en lecture.  
  
- ou - 
 <paramref name="innerStream" /> n’est pas accessible en écriture.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="innerStream" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="innerStream" /> est égal à <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean, userCertificateValidationCallback As RemoteCertificateValidationCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.SslStream : System.IO.Stream * bool * System.Net.Security.RemoteCertificateValidationCallback -&gt; System.Net.Security.SslStream" Usage="new System.Net.Security.SslStream (innerStream, leaveInnerStreamOpen, userCertificateValidationCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
      </Parameters>
      <Docs>
        <param name="innerStream">Objet <see cref="T:System.IO.Stream" /> utilisé par <see cref="T:System.Net.Security.SslStream" /> pour envoyer et recevoir des données.</param>
        <param name="leaveInnerStreamOpen">Valeur booléenne qui indique le comportement de fermeture de l'objet <see cref="T:System.IO.Stream" /> utilisé par <see cref="T:System.Net.Security.SslStream" /> pour l'envoi et la réception de données. Ce paramètre indique si le flux interne est resté ouvert.</param>
        <param name="userCertificateValidationCallback">Délégué <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> responsable de la validation du certificat fourni par le tiers distant.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Security.SslStream" /> en utilisant <see cref="T:System.IO.Stream" />, le comportement de clôture de flux et le délégué de validation de certificat spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous spécifiez `true` pour le `leaveStreamOpen` paramètre, la fermeture de la <xref:System.Net.Security.SslStream> n’a aucun effet le `innerStream` diffuser en continu ; vous devez fermer explicitement `innerStream` lorsque vous n’avez plus besoin.  
  
 Le `userCertificateValidationCallback` du délégué `certificateErrors` argument contient les codes d’erreur Windows retournées par le canal de prise en charge Interface SSPI (Security Provider). La valeur de retour de la méthode appelée par le `userCertificateValidationCallback` délégué détermine si l’authentification réussit.  
  
 Le protocole de sécurité et les algorithmes de chiffrement sont déjà sélectionné lorsque la `userCertificateValidationCallback` méthode du délégué est appelé. Vous pouvez utiliser la méthode pour déterminer si les algorithmes de chiffrement sélectionnés et les forces sont suffisantes pour votre application. Si non, la méthode doit retourner `false` pour empêcher le <xref:System.Net.Security.SslStream> d’être créé.  
  
 Si une valeur n’est pas spécifiée dans le fichier de configuration d’encryptionpolicy, les <xref:System.Net.Security.EncryptionPolicy> par défaut est <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> pour le <xref:System.Net.Security.SslStream> instance qui est construit.  
  
 L’utilisation du chiffrement Null est nécessaire lorsque la stratégie de chiffrement est définie sur <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Le Framework met en cache les sessions SSL lors de leur création et tente de réutiliser une session de mise en cache pour une nouvelle demande, si possible. Lorsque vous tentez de réutiliser une session SSL, le Framework utilise le premier élément du <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (s’il en existe un), ou tente de réutiliser une session anonyme si <xref:System.Net.HttpWebRequest.ClientCertificates%2A> est vide.  
  
> [!NOTE]
>  Les certificats clients ne sont pas pris en charge dans la version 2 du protocole SSL.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.Security.SslStream> et initialise la partie cliente de l’authentification.  
  
 [!code-cpp[NclSslClientSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#4)]
 [!code-csharp[NclSslClientSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="innerStream" /> n’est pas accessible en lecture.  
  
- ou - 
 <paramref name="innerStream" /> n’est pas accessible en écriture.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="innerStream" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="innerStream" /> est égal à <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, class System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean, userCertificateValidationCallback As RemoteCertificateValidationCallback, userCertificateSelectionCallback As LocalCertificateSelectionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback, System::Net::Security::LocalCertificateSelectionCallback ^ userCertificateSelectionCallback);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.SslStream : System.IO.Stream * bool * System.Net.Security.RemoteCertificateValidationCallback * System.Net.Security.LocalCertificateSelectionCallback -&gt; System.Net.Security.SslStream" Usage="new System.Net.Security.SslStream (innerStream, leaveInnerStreamOpen, userCertificateValidationCallback, userCertificateSelectionCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
        <Parameter Name="userCertificateSelectionCallback" Type="System.Net.Security.LocalCertificateSelectionCallback" />
      </Parameters>
      <Docs>
        <param name="innerStream">Objet <see cref="T:System.IO.Stream" /> utilisé par <see cref="T:System.Net.Security.SslStream" /> pour envoyer et recevoir des données.</param>
        <param name="leaveInnerStreamOpen">Valeur booléenne qui indique le comportement de fermeture de l'objet <see cref="T:System.IO.Stream" /> utilisé par <see cref="T:System.Net.Security.SslStream" /> pour l'envoi et la réception de données. Ce paramètre indique si le flux interne est resté ouvert.</param>
        <param name="userCertificateValidationCallback">Délégué <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> responsable de la validation du certificat fourni par le tiers distant.</param>
        <param name="userCertificateSelectionCallback">Délégué <see cref="T:System.Net.Security.LocalCertificateSelectionCallback" /> responsable de la sélection du certificat utilisé pour l'authentification.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Security.SslStream" /> en utilisant <see cref="T:System.IO.Stream" />, le comportement de clôture de flux, le délégué de validation de certificat et le délégué de sélection de certificat spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous spécifiez `true` pour le `leaveStreamOpen` paramètre, la fermeture de la <xref:System.Net.Security.SslStream> n’a aucun effet le `innerStream` diffuser en continu ; vous devez fermer explicitement `innerStream` lorsque vous n’avez plus besoin.  
  
 Le `userCertificateValidationCallback` du délégué `certificateErrors` argument contient les codes d’erreur Windows retournées par le canal de prise en charge Interface SSPI (Security Provider). La valeur de retour de la méthode appelée par le `userCertificateValidationCallback` délégué détermine si l’authentification réussit.  
  
 Le protocole de sécurité et les algorithmes de chiffrement sont déjà sélectionné lorsque la `userCertificateValidationCallback` méthode du délégué est appelé. Vous pouvez utiliser la méthode pour déterminer si les algorithmes de chiffrement sélectionnés et les forces sont suffisantes pour votre application. Si non, la méthode doit retourner `false` pour empêcher le <xref:System.Net.Security.SslStream> d’être créé.  
  
 Le `userCertificateSelectionCallback` délégué est utile lorsque votre application possède plusieurs certificats et doit en choisir un de manière dynamique. Certificats dans le magasin « MY » sont passés à la méthode appelée par le délégué.  
  
 Si une valeur n’est pas spécifiée dans le fichier de configuration d’encryptionpolicy, les <xref:System.Net.Security.EncryptionPolicy> par défaut est <xref:System.Net.Security.EncryptionPolicy.RequireEncryption?displayProperty=nameWithType> pour le <xref:System.Net.Security.SslStream> instance qui est construit.  
  
 L’utilisation du chiffrement Null est nécessaire lorsque la stratégie de chiffrement est définie sur <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Le Framework met en cache les sessions SSL lors de leur création et tente de réutiliser une session de mise en cache pour une nouvelle demande, si possible. Lorsque vous tentez de réutiliser une session SSL, le Framework utilise le premier élément du P:System.Net.HttpWebRequest.ClientCertificates (le cas échéant), ou essaie de réutiliser une session anonyme si P:System.Net.HttpWebRequest.ClientCertificates est vide.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’appel de ce constructeur. Cet exemple fait partie d’un exemple plus complet fourni pour la <xref:System.Net.Security.SslStream> classe.  
  
 [!code-cpp[NclSslClientAsync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#6)]
 [!code-csharp[NclSslClientAsync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="innerStream" /> n’est pas accessible en lecture.  
  
- ou - 
 <paramref name="innerStream" /> n’est pas accessible en écriture.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="innerStream" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="innerStream" /> est égal à <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback, System.Net.Security.EncryptionPolicy encryptionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen, class System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, class System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback, valuetype System.Net.Security.EncryptionPolicy encryptionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback,System.Net.Security.EncryptionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SslStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen, System::Net::Security::RemoteCertificateValidationCallback ^ userCertificateValidationCallback, System::Net::Security::LocalCertificateSelectionCallback ^ userCertificateSelectionCallback, System::Net::Security::EncryptionPolicy encryptionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.SslStream : System.IO.Stream * bool * System.Net.Security.RemoteCertificateValidationCallback * System.Net.Security.LocalCertificateSelectionCallback * System.Net.Security.EncryptionPolicy -&gt; System.Net.Security.SslStream" Usage="new System.Net.Security.SslStream (innerStream, leaveInnerStreamOpen, userCertificateValidationCallback, userCertificateSelectionCallback, encryptionPolicy)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("encryptionPolicy is ignored")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
        <Parameter Name="userCertificateValidationCallback" Type="System.Net.Security.RemoteCertificateValidationCallback" />
        <Parameter Name="userCertificateSelectionCallback" Type="System.Net.Security.LocalCertificateSelectionCallback" />
        <Parameter Name="encryptionPolicy" Type="System.Net.Security.EncryptionPolicy" />
      </Parameters>
      <Docs>
        <param name="innerStream">Objet <see cref="T:System.IO.Stream" /> utilisé par <see cref="T:System.Net.Security.SslStream" /> pour envoyer et recevoir des données.</param>
        <param name="leaveInnerStreamOpen">Valeur booléenne qui indique le comportement de fermeture de l'objet <see cref="T:System.IO.Stream" /> utilisé par <see cref="T:System.Net.Security.SslStream" /> pour l'envoi et la réception de données. Ce paramètre indique si le flux interne est resté ouvert.</param>
        <param name="userCertificateValidationCallback">Délégué <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" /> responsable de la validation du certificat fourni par le tiers distant.</param>
        <param name="userCertificateSelectionCallback">Délégué <see cref="T:System.Net.Security.LocalCertificateSelectionCallback" /> responsable de la sélection du certificat utilisé pour l'authentification.</param>
        <param name="encryptionPolicy"><see cref="T:System.Net.Security.EncryptionPolicy" /> à utiliser.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Security.SslStream" /> à l'aide du <see cref="T:System.IO.Stream" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’utilisation du chiffrement Null est requise lorsque la `encryptionPolicy` paramètre est défini sur <xref:System.Net.Security.EncryptionPolicy.NoEncryption?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="innerStream" /> n’est pas accessible en lecture.  
  
- ou - 
 <paramref name="innerStream" /> n’est pas accessible en écriture.  
  
- ou - 
 <paramref name="encryptionPolicy" /> n'est pas valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="innerStream" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="innerStream" /> est égal à <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Authentifiez le côté client d'une connexion client-serveur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : string -&gt; unit&#xA;override this.AuthenticateAsClient : string -&gt; unit" Usage="sslStream.AuthenticateAsClient targetHost" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClient(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetHost">Le nom du serveur qui partage ce <see cref="T:System.Net.Security.SslStream" />.</param>
        <summary>Appelé par les clients pour authentifier le serveur et éventuellement le client dans une connexion client-serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Aucun certificat client est utilisé dans l’authentification. La liste de révocation de certificat n’est pas vérifiée lors de l’authentification. La valeur spécifiée pour `targetHost` doit correspondre au nom sur le certificat du serveur.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.SslStream.IsEncrypted%2A> et <xref:System.Net.Security.SslStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.SslStream>. Vérifier le <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException>et cela <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetHost" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué et a laissé cet objet dans un état inutilisable.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
- ou - 
L’authentification du serveur avec cette <see cref="T:System.Net.Security.SslStream" /> a déjà été tentée.  
  
- ou - 
L’authentification est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String, clientCertificates As X509CertificateCollection, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool -&gt; unit&#xA;override this.AuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool -&gt; unit" Usage="sslStream.AuthenticateAsClient (targetHost, clientCertificates, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Le nom du serveur qui partagera ce <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates"><see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> contenant les certificats clients.</param>
        <param name="checkCertificateRevocation">Valeur <see cref="T:System.Boolean" /> qui spécifie si la liste de révocation des certificats est vérifiée pendant l’authentification.</param>
        <summary>Appelé par les clients pour authentifier le serveur et éventuellement le client dans une connexion client-serveur. Le processus d’authentification utilise la collection de certificats spécifiée et le protocole SSL par défaut du système.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.SslStream.IsEncrypted%2A> et <xref:System.Net.Security.SslStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.SslStream>. Vérifier le <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException>et cela <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
> [!NOTE]
>  Les certificats clients ne sont pas pris en charge dans la version 2 du protocole SSL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (targetHost As String, clientCertificates As X509CertificateCollection, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool -&gt; unit&#xA;override this.AuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool -&gt; unit" Usage="sslStream.AuthenticateAsClient (targetHost, clientCertificates, enabledSslProtocols, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Le nom du serveur qui partagera ce <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates"><see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> contenant les certificats clients.</param>
        <param name="enabledSslProtocols">Valeur <see cref="T:System.Security.Authentication.SslProtocols" /> qui représente le protocole utilisé pour l'authentification.</param>
        <param name="checkCertificateRevocation">Valeur <see cref="T:System.Boolean" /> qui spécifie si la liste de révocation des certificats est vérifiée pendant l’authentification.</param>
        <summary>Appelé par les clients pour authentifier le serveur et éventuellement le client dans une connexion client-serveur. Le processus d'authentification utilise la collection de certificats spécifiée et le protocole SSL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.SslStream.IsEncrypted%2A> et <xref:System.Net.Security.SslStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.SslStream>. Vérifier le <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException>et cela <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
> [!NOTE]
>  Les certificats clients ne sont pas pris en charge dans la version 2 du protocole SSL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClientAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Authentifier le côté client d'une connexion client-serveur sous forme d'opération asynchrone.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : string -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : string -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsClientAsync targetHost" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClientAsync(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetHost">Le nom du serveur qui partage ce <see cref="T:System.Net.Security.SslStream" />.</param>
        <summary>Appelé par les clients pour authentifier le serveur et éventuellement le client dans une connexion client-serveur en tant qu’opération asynchrone.</summary>
        <returns>Retourne <see cref="T:System.Threading.Tasks.Task" />.  
  
Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Aucun certificat client est utilisé dans l’authentification. La liste de révocation de certificat n’est pas vérifiée lors de l’authentification. La valeur spécifiée pour `targetHost` doit correspondre au nom sur le certificat du serveur.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.SslStream.IsEncrypted%2A> et <xref:System.Net.Security.SslStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.SslStream>. Vérifier le <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException>et cela <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetHost" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué et a laissé cet objet dans un état inutilisable.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
- ou - 
L’authentification du serveur avec cette <see cref="T:System.Net.Security.SslStream" /> a déjà été tentée.  
  
- ou - 
L’authentification est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.Security.SslClientAuthenticationOptions sslClientAuthenticationOptions, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.Security.SslClientAuthenticationOptions sslClientAuthenticationOptions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.Net.Security.SslClientAuthenticationOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::Security::SslClientAuthenticationOptions ^ sslClientAuthenticationOptions, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.AuthenticateAsClientAsync : System.Net.Security.SslClientAuthenticationOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsClientAsync (sslClientAuthenticationOptions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sslClientAuthenticationOptions" Type="System.Net.Security.SslClientAuthenticationOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="sslClientAuthenticationOptions">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String, clientCertificates As X509CertificateCollection, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsClientAsync (targetHost, clientCertificates, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Le nom du serveur qui partagera ce <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates"><see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> contenant les certificats clients.</param>
        <param name="checkCertificateRevocation">Valeur <see cref="T:System.Boolean" /> qui spécifie si la liste de révocation des certificats est vérifiée pendant l’authentification.</param>
        <summary>Appelé par les clients pour authentifier le serveur et éventuellement le client dans une connexion client-serveur en tant qu’opération asynchrone. Le processus d’authentification utilise la collection de certificats spécifiée et le protocole SSL par défaut du système.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.SslStream.IsEncrypted%2A> et <xref:System.Net.Security.SslStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.SslStream>. Vérifier le <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException>et cela <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
> [!NOTE]
>  Les certificats clients ne sont pas pris en charge dans la version 2 du protocole SSL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (targetHost As String, clientCertificates As X509CertificateCollection, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsClientAsync (targetHost, clientCertificates, enabledSslProtocols, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="targetHost">Le nom du serveur qui partagera ce <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates"><see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> contenant les certificats clients.</param>
        <param name="enabledSslProtocols">Valeur <see cref="T:System.Security.Authentication.SslProtocols" /> qui représente le protocole utilisé pour l'authentification.</param>
        <param name="checkCertificateRevocation">Valeur <see cref="T:System.Boolean" /> qui spécifie si la liste de révocation des certificats est vérifiée pendant l’authentification.</param>
        <summary>Appelé par les clients pour authentifier le serveur et éventuellement le client dans une connexion client-serveur en tant qu’opération asynchrone. Le processus d'authentification utilise la collection de certificats spécifiée et le protocole SSL.</summary>
        <returns>Retourne <see cref="T:System.Threading.Tasks.Task" />.  
  
Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.SslStream.IsEncrypted%2A> et <xref:System.Net.Security.SslStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.SslStream>. Vérifier le <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException>et cela <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
> [!NOTE]
>  Les certificats clients ne sont pas pris en charge dans la version 2 du protocole SSL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Appelé par les serveurs pour authentifier le serveur, et éventuellement le client, dans une connexion client-serveur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate -&gt; unit&#xA;override this.AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate -&gt; unit" Usage="sslStream.AuthenticateAsServer serverCertificate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certificat utilisé pour authentifier le serveur.</param>
        <summary>Appelé par les serveurs pour authentifier le serveur, et éventuellement le client, dans une connexion client-serveur à l'aide du certificat spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] La liste de révocation de certificat n’est pas vérifiée lors de l’authentification. Le client n’est pas obligé de fournir un certificat pour l’authentification.  
  
 Cette méthode se bloque jusqu'à ce que l’opération se termine. Pour éviter un blocage jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> surcharges de méthode.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException>et cela <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serverCertificate" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué et a laissé cet objet dans un état inutilisable.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
- ou - 
L’authentification du client avec ce <see cref="T:System.Net.Security.SslStream" /> a déjà été tentée.  
  
- ou - 
L’authentification est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La méthode <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" /> n’est pas prise en charge sur Windows 95, Windows 98 et Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool -&gt; unit&#xA;override this.AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool -&gt; unit" Usage="sslStream.AuthenticateAsServer (serverCertificate, clientCertificateRequired, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Le X509Certificate utilisé pour authentifier le serveur.</param>
        <param name="clientCertificateRequired">Valeur <see cref="T:System.Boolean" /> qui spécifie si le client est invité à fournir un certificat d’authentification. Notez qu’il s’agit uniquement d’une demande : si aucun certificat n’est fourni, le serveur accepte tout de même la demande de connexion.</param>
        <param name="checkCertificateRevocation">Valeur <see cref="T:System.Boolean" /> qui spécifie si la liste de révocation des certificats est vérifiée pendant l’authentification.</param>
        <summary>Appelé par les serveurs pour authentifier le serveur et éventuellement le client dans une connexion client-serveur à l’aide des certificats spécifiés, de la configuration requise et avec le protocole de sécurité par défaut du système.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Cette méthode se bloque jusqu'à ce que l’opération se termine. Pour éviter un blocage jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> surcharges de méthode.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException>et cela <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serverCertificate" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué et a laissé cet objet dans un état inutilisable.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
- ou - 
L’authentification du client avec ce <see cref="T:System.Net.Security.SslStream" /> a déjà été tentée.  
  
- ou - 
L’authentification est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La méthode <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" /> n’est pas prise en charge sur Windows 95, Windows 98 et Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool -&gt; unit&#xA;override this.AuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool -&gt; unit" Usage="sslStream.AuthenticateAsServer (serverCertificate, clientCertificateRequired, enabledSslProtocols, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Le X509Certificate utilisé pour authentifier le serveur.</param>
        <param name="clientCertificateRequired">Valeur <see cref="T:System.Boolean" /> qui spécifie si le client est invité à fournir un certificat d’authentification. Notez qu’il s’agit uniquement d’une demande : si aucun certificat n’est fourni, le serveur accepte tout de même la demande de connexion.</param>
        <param name="enabledSslProtocols">Valeur <see cref="T:System.Security.Authentication.SslProtocols" /> qui représente le protocole utilisé pour l'authentification.</param>
        <param name="checkCertificateRevocation">Valeur <see cref="T:System.Boolean" /> qui spécifie si la liste de révocation des certificats est vérifiée pendant l’authentification.</param>
        <summary>Appelé par les serveurs pour authentifier le serveur et éventuellement le client dans une connexion client-serveur à l’aide des certificats spécifiés, de la configuration requise et du protocole de sécurité.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Cette méthode se bloque jusqu'à ce que l’opération se termine. Pour éviter un blocage jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> surcharges de méthode.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException>et cela <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serverCertificate" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enabledSslProtocols" /> n’est pas une valeur de <see cref="T:System.Security.Authentication.SslProtocols" /> valide.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué et a laissé cet objet dans un état inutilisable.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
- ou - 
L’authentification du client avec ce <see cref="T:System.Net.Security.SslStream" /> a déjà été tentée.  
  
- ou - 
L’authentification est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La méthode <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" /> n’est pas prise en charge sur Windows 95, Windows 98 et Windows Millennium.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServerAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Appelé par les serveurs pour authentifier le serveur, et éventuellement le client, dans une connexion client-serveur sous forme d'opération asynchrone.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsServerAsync serverCertificate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Certificat utilisé pour authentifier le serveur.</param>
        <summary>Appelé par les serveurs pour authentifier le serveur, et éventuellement le client, dans une connexion client-serveur en utilisant le certificat spécifié sous forme d'opération asynchrone.</summary>
        <returns>Retourne <see cref="T:System.Threading.Tasks.Task" />.  
  
Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Cette méthode s’authentifie à l’aide de <xref:System.Security.Authentication.SslProtocols.Default>. La liste de révocation de certificat n’est pas vérifiée lors de l’authentification. Le client n’est pas obligé de fournir un certificat pour l’authentification.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException>et cela <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serverCertificate" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué et a laissé cet objet dans un état inutilisable.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
- ou - 
L’authentification du client avec ce <see cref="T:System.Net.Security.SslStream" /> a déjà été tentée.  
  
- ou - 
L’authentification est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La méthode <see cref="Overload:System.Net.Security.SslStream.AuthenticateAsServerAsync" /> n’est pas prise en charge sur Windows 95, Windows 98 et Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.Security.SslServerAuthenticationOptions sslServerAuthenticationOptions, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.Security.SslServerAuthenticationOptions sslServerAuthenticationOptions, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Net.Security.SslServerAuthenticationOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::Security::SslServerAuthenticationOptions ^ sslServerAuthenticationOptions, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.AuthenticateAsServerAsync : System.Net.Security.SslServerAuthenticationOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsServerAsync (sslServerAuthenticationOptions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sslServerAuthenticationOptions" Type="System.Net.Security.SslServerAuthenticationOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="sslServerAuthenticationOptions">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsServerAsync (serverCertificate, clientCertificateRequired, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Le X509Certificate utilisé pour authentifier le serveur.</param>
        <param name="clientCertificateRequired">Valeur <see cref="T:System.Boolean" /> qui spécifie si le client est invité à fournir un certificat d’authentification. Notez qu’il s’agit uniquement d’une demande : si aucun certificat n’est fourni, le serveur accepte tout de même la demande de connexion.</param>
        <param name="checkCertificateRevocation">Valeur <see cref="T:System.Boolean" /> qui spécifie si la liste de révocation des certificats est vérifiée pendant l’authentification.</param>
        <summary>Appelé par les serveurs pour authentifier le serveur et éventuellement le client dans une connexion client-serveur à l’aide des certificats spécifiés, de la configuration requise et du protocole de sécurité au cours d’une opération asynchrone.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException>et cela <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (serverCertificate As X509Certificate, clientCertificateRequired As Boolean, enabledSslProtocols As SslProtocols, checkCertificateRevocation As Boolean) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool -&gt; System.Threading.Tasks.Task" Usage="sslStream.AuthenticateAsServerAsync (serverCertificate, clientCertificateRequired, enabledSslProtocols, checkCertificateRevocation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Le X509Certificate utilisé pour authentifier le serveur.</param>
        <param name="clientCertificateRequired">Valeur <see cref="T:System.Boolean" /> qui spécifie si le client est invité à fournir un certificat d’authentification. Notez qu’il s’agit uniquement d’une demande : si aucun certificat n’est fourni, le serveur accepte tout de même la demande de connexion.</param>
        <param name="enabledSslProtocols">Valeur <see cref="T:System.Security.Authentication.SslProtocols" /> qui représente le protocole utilisé pour l'authentification.</param>
        <param name="checkCertificateRevocation">Valeur <see cref="T:System.Boolean" /> qui spécifie si la liste de révocation des certificats est vérifiée pendant l’authentification.</param>
        <summary>Appelé par les serveurs pour authentifier le serveur et éventuellement le client dans une connexion client-serveur à l’aide des certificats spécifiés, de la configuration requise et du protocole de sécurité au cours d’une opération asynchrone.</summary>
        <returns>Retourne <see cref="T:System.Threading.Tasks.Task" />.  
  
Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException>et cela <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Commence une opération pour authentifier le côté client d'une connexion client-serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de cette méthode ne bloquent pas lorsque l’authentification est en cours d’exécution. Pour bloquer en attendant que l’authentification, utilisez une de la <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> méthodes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : string * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsClient (targetHost, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">Le nom du serveur qui partage ce <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’authentification est terminée.</param>
        <param name="asyncState">Objet défini par l'utilisateur qui comporte des informations sur l'opération. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Appelé par les clients pour commencer une opération asynchrone pour authentifier le serveur et, éventuellement, le client.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui indique l'état de l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] Aucun certificat client est utilisé dans l’authentification. La liste de révocation de certificat n’est pas vérifiée lors de l’authentification.  
  
 La valeur spécifiée pour `targetHost` doit correspondre au nom sur le certificat du serveur.  
  
 L’opération asynchrone d’authentification doit être effectuée en appelant le <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer.  
  
 Cette méthode ne bloque pas pendant que l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> surcharges de méthode.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si vous recevez un <xref:System.Security.Authentication.AuthenticationException>, cette <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetHost" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué et a laissé cet objet dans un état inutilisable.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
- ou - 
L’authentification du serveur avec cette <see cref="T:System.Net.Security.SslStream" /> a déjà été tentée.  
  
- ou - 
L’authentification est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsClient (targetHost, clientCertificates, checkCertificateRevocation, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">Le nom du serveur qui partage ce <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates"><see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> contenant les certificats clients.</param>
        <param name="checkCertificateRevocation">Valeur <see cref="T:System.Boolean" /> qui spécifie si la liste de révocation des certificats est vérifiée pendant l’authentification.</param>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’authentification est terminée.</param>
        <param name="asyncState">Objet défini par l'utilisateur qui comporte des informations sur l'opération. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Appelé par les clients pour lancer une opération asynchrone d’authentification du serveur et éventuellement du client à l’aide des certificats spécifiés et du protocole de sécurité par défaut du système.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui indique l'état de l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 La valeur spécifiée pour `targetHost` doit correspondre au nom sur le certificat du serveur.  
  
 L’opération asynchrone d’authentification doit être effectuée en appelant le <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer.  
  
 Cette méthode ne bloque pas pendant que l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> surcharges de méthode.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si vous recevez un <xref:System.Security.Authentication.AuthenticationException>, cette <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
> [!NOTE]
>  Les certificats clients ne sont pas pris en charge dans la version 2 du protocole SSL.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetHost" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué et a laissé cet objet dans un état inutilisable.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
- ou - 
L’authentification du serveur avec cette <see cref="T:System.Net.Security.SslStream" /> a déjà été tentée.  
  
- ou - 
L’authentification est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(string targetHost, class System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::String ^ targetHost, System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ clientCertificates, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : string * System.Security.Cryptography.X509Certificates.X509CertificateCollection * System.Security.Authentication.SslProtocols * bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsClient (targetHost, clientCertificates, enabledSslProtocols, checkCertificateRevocation, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetHost" Type="System.String" />
        <Parameter Name="clientCertificates" Type="System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="targetHost">Le nom du serveur qui partage ce <see cref="T:System.Net.Security.SslStream" />.</param>
        <param name="clientCertificates"><see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> contenant les certificats clients.</param>
        <param name="enabledSslProtocols">Valeur <see cref="T:System.Security.Authentication.SslProtocols" /> qui représente le protocole utilisé pour l'authentification.</param>
        <param name="checkCertificateRevocation">Valeur <see cref="T:System.Boolean" /> qui spécifie si la liste de révocation des certificats est vérifiée pendant l’authentification.</param>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’authentification est terminée.</param>
        <param name="asyncState">Objet défini par l'utilisateur qui comporte des informations sur l'opération. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Appelé par les clients pour commencer une opération asynchrone pour authentifier le serveur et éventuellement le client à l'aide des certificats spécifiés et du protocole de sécurité.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui indique l'état de l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 La valeur spécifiée pour `targetHost` doit correspondre au nom sur le certificat du serveur.  
  
 L’opération asynchrone d’authentification doit être effectuée en appelant le <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer.  
  
 Cette méthode ne bloque pas pendant que l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> surcharges de méthode.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si vous recevez un <xref:System.Security.Authentication.AuthenticationException>, cette <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
> [!NOTE]
>  Les certificats clients ne sont pas pris en charge dans la version 2 du protocole SSL.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetHost" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enabledSslProtocols" /> n’est pas une valeur de <see cref="T:System.Security.Authentication.SslProtocols" /> valide.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué et a laissé cet objet dans un état inutilisable.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
- ou - 
L’authentification du serveur avec cette <see cref="T:System.Net.Security.SslStream" /> a déjà été tentée.  
  
- ou - 
L’authentification est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Commence une opération asynchrone pour gérer le côté serveur de l'authentification d'une connexion client-serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de cette méthode ne bloquent pas lorsque l’authentification est en cours d’exécution. Pour bloquer en attendant que l’authentification, utilisez une de la <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> méthodes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsServer (serverCertificate, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Le X509Certificate utilisé pour authentifier le serveur.</param>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’authentification est terminée.</param>
        <param name="asyncState">Objet défini par l'utilisateur qui comporte des informations sur l'opération. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Appelé par les serveurs pour commencer une opération asynchrone d'authentification du client, et éventuellement du serveur, dans une connexion client-serveur.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> indiquant l'état de l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)] La liste de révocation de certificat n’est pas vérifiée lors de l’authentification. Le client n’est pas obligé de fournir un certificat pour l’authentification.  
  
 L’opération asynchrone d’authentification doit être effectuée en appelant le <xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer.  
  
 Cette méthode ne bloque pas pendant que l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> surcharges de méthode.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si vous recevez un <xref:System.Security.Authentication.AuthenticationException>, cette <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serverCertificate" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué et a laissé cet objet dans un état inutilisable.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
- ou - 
L’authentification du client avec ce <see cref="T:System.Net.Security.SslStream" /> a déjà été tentée.  
  
- ou - 
L’authentification est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La méthode <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> n’est pas prise en charge sur Windows 95, Windows 98 et Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsServer (serverCertificate, clientCertificateRequired, checkCertificateRevocation, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Le X509Certificate utilisé pour authentifier le serveur.</param>
        <param name="clientCertificateRequired">Valeur <see cref="T:System.Boolean" /> qui spécifie si le client est invité à fournir un certificat d’authentification. Notez qu’il s’agit uniquement d’une demande : si aucun certificat n’est fourni, le serveur accepte tout de même la demande de connexion.</param>
        <param name="checkCertificateRevocation">Valeur <see cref="T:System.Boolean" /> qui spécifie si la liste de révocation des certificats est vérifiée pendant l’authentification.</param>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’authentification est terminée.</param>
        <param name="asyncState">Objet défini par l'utilisateur qui comporte des informations sur l'opération. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Appelé par les serveurs pour lancer une opération asynchrone d’authentification du serveur et éventuellement du client à l’aide des certificats spécifiés, de la configuration requise et du protocole de sécurité par défaut du système.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui indique l'état de l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 L’opération asynchrone d’authentification doit être effectuée en appelant le <xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer.  
  
 Cette méthode ne bloque pas pendant que l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> surcharges de méthode.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si vous recevez un <xref:System.Security.Authentication.AuthenticationException>, cette <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serverCertificate" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué et a laissé cet objet dans un état inutilisable.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
- ou - 
L’authentification du serveur avec cette <see cref="T:System.Net.Security.SslStream" /> a déjà été tentée.  
  
- ou - 
L’authentification est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La méthode <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> n’est pas prise en charge sur Windows 95, Windows 98 et Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, valuetype System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Cryptography::X509Certificates::X509Certificate ^ serverCertificate, bool clientCertificateRequired, System::Security::Authentication::SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Security.Cryptography.X509Certificates.X509Certificate * bool * System.Security.Authentication.SslProtocols * bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginAuthenticateAsServer (serverCertificate, clientCertificateRequired, enabledSslProtocols, checkCertificateRevocation, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serverCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
        <Parameter Name="clientCertificateRequired" Type="System.Boolean" />
        <Parameter Name="enabledSslProtocols" Type="System.Security.Authentication.SslProtocols" />
        <Parameter Name="checkCertificateRevocation" Type="System.Boolean" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serverCertificate">Le X509Certificate utilisé pour authentifier le serveur.</param>
        <param name="clientCertificateRequired">Valeur <see cref="T:System.Boolean" /> qui spécifie si le client est invité à fournir un certificat d’authentification. Notez qu’il s’agit uniquement d’une demande : si aucun certificat n’est fourni, le serveur accepte tout de même la demande de connexion.</param>
        <param name="enabledSslProtocols">Valeur <see cref="T:System.Security.Authentication.SslProtocols" /> qui représente le protocole utilisé pour l'authentification.</param>
        <param name="checkCertificateRevocation">Valeur <see cref="T:System.Boolean" /> qui spécifie si la liste de révocation des certificats est vérifiée pendant l’authentification.</param>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’authentification est terminée.</param>
        <param name="asyncState">Objet défini par l'utilisateur qui comporte des informations sur l'opération. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Appelé par les serveurs pour lancer une opération asynchrone d’authentification du serveur et éventuellement du client à l’aide des certificats spécifiés, de la configuration requise et du protocole de sécurité.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui indique l'état de l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sslprotocols-none](~/includes/sslprotocols-none-md.md)]
 
 L’opération asynchrone d’authentification doit être effectuée en appelant le <xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer.  
  
 Cette méthode ne bloque pas pendant que l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> surcharges de méthode.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si vous recevez un <xref:System.Security.Authentication.AuthenticationException>, cette <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serverCertificate" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enabledSslProtocols" /> n’est pas une valeur de <see cref="T:System.Security.Authentication.SslProtocols" /> valide.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué et a laissé cet objet dans un état inutilisable.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
- ou - 
L’authentification du serveur avec cette <see cref="T:System.Net.Security.SslStream" /> a déjà été tentée.  
  
- ou - 
L’authentification est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La méthode <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" /> n’est pas prise en charge sur Windows 95, Windows 98 et Windows Millennium.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginRead (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau <see cref="T:System.Byte" /> qui reçoit les octets lus dans le flux de données.</param>
        <param name="offset">Emplacement de base zéro dans <paramref name="buffer" />, à partir duquel commencer l'enregistrement des données lues dans ce flux.</param>
        <param name="count">Nombre maximal d'octets à lire dans le flux.</param>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler lorsque l'opération de lecture est terminée.</param>
        <param name="asyncState">Objet défini par l'utilisateur qui comporte des informations sur l'opération de lecture. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Commence une opération de lecture asynchrone qui lit des données du flux et les stocke dans le tableau spécifié.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui indique l'état de l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le chiffrement et ou la signature est activés, l’opération de lecture lit les données dans le flux sous-jacent, vérifie l’intégrité des données et/ou déchiffre. L’opération de lecture asynchrone doit être terminée en appelant le <xref:System.Net.Security.SslStream.EndRead%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer.  
  
 Cette méthode ne bloque pas pendant que l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez le <xref:System.Net.Security.SslStream.Read%2A> (méthode).  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Le <xref:System.Net.Security.SslStream> classe ne prend pas en charge simultanée de plusieurs opérations de lecture.  
  
 Vous ne pouvez pas appeler cette méthode jusqu'à ce que vous avez été authentifié. Pour authentifier un appel de la <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, ou <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> méthodes.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le démarrage d’une opération de lecture asynchrone.  
  
 [!code-cpp[NclSslClientAsync#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#8)]
 [!code-csharp[NclSslClientAsync#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#8)]  
  
 [!code-cpp[NclSslClientAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#4)]
 [!code-csharp[NclSslClientAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#4)]  
  
 La méthode suivante est appelée lorsque la lecture est terminée.  
  
 [!code-cpp[NclSslClientAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#5)]
 [!code-csharp[NclSslClientAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; longueur de <paramref name="buffer" />.  
  
- ou - 
 <paramref name="offset" /> + nombre &gt; longueur de <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">L'opération de lecture a échoué.  
  
- ou - 
Le chiffrement est utilisé, mais les données n'ont pas pu être déchiffrées.</exception>
        <exception cref="T:System.NotSupportedException">Une opération de lecture est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L'authentification n'a pas été effectuée.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="sslStream.BeginWrite (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de <see cref="T:System.Byte" /> qui fournit les octets à écrire dans le flux.</param>
        <param name="offset">Emplacement de base zéro dans <paramref name="buffer" /> à partir duquel commencer la lecture des octets à écrire dans le flux.</param>
        <param name="count">Valeur <see cref="T:System.Int32" /> qui spécifie le nombre d'octets à lire dans <paramref name="buffer" />.</param>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler lorsque l'opération d'écriture est terminée.</param>
        <param name="asyncState">Objet défini par l'utilisateur qui comporte des informations sur l'opération d'écriture. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Commence une opération d'écriture asynchrone qui écrit des <see cref="T:System.Byte" />s de la mémoire tampon spécifiée vers le flux.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> indiquant l'état de l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’appel de cette méthode.  
  
 [!code-cpp[NclSslServerAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerAsync/CPP/NclSslServerAsync.cpp#5)]
 [!code-csharp[NclSslServerAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerAsync/CS/serverasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; longueur de <paramref name="buffer" />.  
  
- ou - 
 <paramref name="offset" /> + nombre &gt; longueur de <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">L'opération d'écriture a échoué.</exception>
        <exception cref="T:System.NotSupportedException">Une opération d'écriture est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L'authentification n'a pas été effectuée.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Net.Security.SslStream.CanRead" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanRead</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur <see cref="T:System.Boolean" /> qui indique si le flux sous-jacent est accessible en lecture.</summary>
        <value><see langword="true" /> si l'authentification s'est produite et que le flux sous-jacent est accessible en lecture ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’authentification réussie a eu lieu, cette propriété retourne la valeur retournée en appelant <xref:System.IO.Stream.CanRead%2A> sur le flux sous-jacent.  
  
 Le flux sous-jacent est spécifié lorsque vous créez une instance de la <xref:System.Net.Security.SslStream> classe.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Net.Security.SslStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur <see cref="T:System.Boolean" /> qui indique si le flux sous-jacent peut faire l'objet d'une recherche.</summary>
        <value>Cette propriété retourne toujours <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 N’essayez pas de définir la position de la <xref:System.Net.Security.SslStream> objet ou son flux sous-jacent.  
  
 Le flux sous-jacent est spécifié lorsque vous créez une instance de la <xref:System.Net.Security.SslStream> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.Stream.CanSeek" />
        <altmember cref="P:System.Net.Security.SslStream.Position" />
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Net.Security.SslStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur <see cref="T:System.Boolean" /> qui indique si le flux sous-jacent prend en charge les délais d'attente.</summary>
        <value><see langword="true" /> si le flux de données prend en charge les délais d'attente ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne la valeur retournée en appelant <xref:System.IO.Stream.CanTimeout%2A> sur le flux sous-jacent.  
  
 Le flux sous-jacent est spécifié lorsque vous créez une instance de la <xref:System.Net.Security.SslStream> classe.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Net.Security.SslStream.CanWrite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CanWrite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur <see cref="T:System.Boolean" /> qui indique si le flux sous-jacent est accessible en écriture.</summary>
        <value><see langword="true" /> si l'authentification s'est produite et que le flux sous-jacent est accessible en écriture ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’authentification réussie a eu lieu, cette propriété retourne la valeur retournée en appelant <xref:System.IO.Stream.CanWrite%2A> sur le flux sous-jacent.  
  
 Le flux sous-jacent est spécifié lorsque vous créez une instance de la <xref:System.Net.Security.SslStream> classe.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckCertRevocationStatus">
      <MemberSignature Language="C#" Value="public virtual bool CheckCertRevocationStatus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CheckCertRevocationStatus" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CheckCertRevocationStatus" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CheckCertRevocationStatus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CheckCertRevocationStatus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CheckCertRevocationStatus : bool" Usage="System.Net.Security.SslStream.CheckCertRevocationStatus" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CheckCertRevocationStatus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur <see cref="T:System.Boolean" /> qui indique si la liste de révocation de certificats est vérifiée au cours du processus de validation des certificats.</summary>
        <value><see langword="true" /> si la liste de révocation de certificats est vérifiée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La liste de révocation de certificats contient des certificats qui ont été révoqués par l’émetteur. Vérification de la liste négativement affecte les performances mais améliore la sécurité de l’application.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclSslServerSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#5)]
 [!code-csharp[NclSslServerSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CipherAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.CipherAlgorithmType CipherAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.CipherAlgorithmType CipherAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CipherAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CipherAlgorithm As CipherAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::CipherAlgorithmType CipherAlgorithm { System::Security::Authentication::CipherAlgorithmType get(); };" />
      <MemberSignature Language="F#" Value="member this.CipherAlgorithm : System.Security.Authentication.CipherAlgorithmType" Usage="System.Net.Security.SslStream.CipherAlgorithm" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CipherAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.CipherAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui identifie l'algorithme de chiffrement en bloc utilisé par ce <see cref="T:System.Net.Security.SslStream" />.</summary>
        <value>Valeur <see cref="T:System.Security.Authentication.CipherAlgorithmType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur <xref:System.Security.Authentication.CipherAlgorithmType.Null> est requis pour le <xref:System.Net.Security.SslStream.CipherAlgorithm%2A> propriété lorsque le <xref:System.Net.Security.EncryptionPolicy.NoEncryption> valeur d’énumération est utilisée pour construire un <xref:System.Net.Security.SslStream> instance.  
  
 [!INCLUDE[winxpsvr](~/includes/winxpsvr-md.md)] et [!INCLUDE[winxp](~/includes/winxp-md.md)] ne gèrent pas la <xref:System.Security.Authentication.CipherAlgorithmType.Null> valeur. Par conséquent, même si le <xref:System.Security.Authentication.CipherAlgorithmType.Null> valeur est utilisée pour construire le <xref:System.Net.Security.SslStream> instance, le <xref:System.Net.Security.EncryptionPolicy> propriété sera <xref:System.Security.Authentication.CipherAlgorithmType.None>. Le <xref:System.Security.Authentication.CipherAlgorithmType.Null> valeur est retournée uniquement sur Windows Vista et versions ultérieures.  
  
   
  
## Examples  
 L’exemple de code suivant affiche les paramètres de chiffrement pour le flux spécifié.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'accès à la propriété <see cref="P:System.Net.Security.SslStream.CipherAlgorithm" /> a été effectué avant la fin du processus d'authentification ou le processus d'authentification a échoué.</exception>
      </Docs>
    </Member>
    <Member MemberName="CipherStrength">
      <MemberSignature Language="C#" Value="public virtual int CipherStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CipherStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.CipherStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CipherStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CipherStrength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CipherStrength : int" Usage="System.Net.Security.SslStream.CipherStrength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.CipherStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui identifie la puissance de l'algorithme de chiffrement utilisé par ce <see cref="T:System.Net.Security.SslStream" />.</summary>
        <value>Valeur <see cref="T:System.Int32" /> qui spécifie la puissance de l'algorithme, en bits.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette propriété est zéro jusqu'à ce que l’authentification se produit.  
  
 Cette propriété retourne une des valeurs suivantes :  
  
-   0  
  
-   40  
  
-   56  
  
-   80  
  
-   128  
  
-   168  
  
-   192  
  
-   256  
  
   
  
## Examples  
 L’exemple de code suivant affiche les paramètres de chiffrement pour le flux spécifié.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="sslStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.Net.Security.SslStream" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose()` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose()` appelle la méthode protégée `Dispose(Boolean)` méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` défini sur `false`.  
  
 Lorsque le `disposing` paramètre est true, cette méthode libère toutes les ressources détenues par les objets managés par ce <xref:System.Net.Security.SslStream> références. Cette méthode appelle la méthode `Dispose()` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution <see langword="Dispose(Boolean)" /> veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndAuthenticateAsClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsClient (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsClient(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsClient : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsClient : IAsyncResult -&gt; unit" Usage="sslStream.EndAuthenticateAsClient asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndAuthenticateAsClient(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Instance de <see cref="T:System.IAsyncResult" /> retournée par un appel à <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</param>
        <summary>Termine une opération d'authentification du serveur asynchrone en attente, démarrée avec un appel précédent à <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération n’est pas terminée, cette méthode se bloque jusqu'à ce que c’est le cas. Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.SslStream.IsEncrypted%2A> et <xref:System.Net.Security.SslStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.SslStream>. Vérifier le <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException>et cela <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
 Pour effectuer cette opération de manière synchrone, utilisez une de la <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> méthodes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été créé par un appel à la méthode <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué et a laissé cet objet dans un état inutilisable.</exception>
        <exception cref="T:System.InvalidOperationException">Aucune authentification de serveur n'est en attente d'achèvement.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndAuthenticateAsServer(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsServer (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsServer(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsServer : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsServer : IAsyncResult -&gt; unit" Usage="sslStream.EndAuthenticateAsServer asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndAuthenticateAsServer(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Instance de <see cref="T:System.IAsyncResult" /> retournée par un appel à <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</param>
        <summary>Termine une opération d'authentification du client asynchrone en attente, démarrée avec un appel précédent à <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération n’est pas terminée, cette méthode se bloque jusqu'à ce que c’est le cas. Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.SslStream.IsEncrypted%2A> et <xref:System.Net.Security.SslStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.SslStream>. Vérifier le <xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException>et cela <xref:System.Net.Security.SslStream> n’est plus utilisable. Vous devez fermer cet objet et supprimer toutes les références à ce dernier afin qu’il peut être collectée par le garbage collector.  
  
 Pour effectuer cette opération de manière synchrone, utilisez une de la <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été créé par un appel à la méthode <see cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsClient" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué et a laissé cet objet dans un état inutilisable.</exception>
        <exception cref="T:System.InvalidOperationException">Aucune authentification de client n'est en attente d'achèvement.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="sslStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndRead(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Instance de <see cref="T:System.IAsyncResult" /> retournée par un appel à <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</param>
        <summary>Termine une opération de lecture asynchrone démarrée avec un appel précédent à <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <returns>Valeur <see cref="T:System.Int32" /> qui spécifie le nombre d'octets lus dans le flux sous-jacent.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération n’est pas terminée, cette méthode se bloque jusqu'à ce que c’est le cas.  
  
 Pour effectuer cette opération de façon synchrone, utilisez la <xref:System.Net.Security.SslStream.Read%2A> (méthode).  
  
 Vous ne pouvez pas appeler cette méthode jusqu'à ce que vous avez été authentifié. Pour authentifier un appel de la <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, ou <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> méthodes.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’opération de lecture asynchrone de fin.  
  
 [!code-cpp[NclSslClientAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientAsync/CPP/NclSslClientAsync.cpp#5)]
 [!code-csharp[NclSslClientAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientAsync/CS/clientasync.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été créé par un appel à la méthode <see cref="M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'authentification n'a pas été effectuée.</exception>
        <exception cref="T:System.IO.IOException">L'opération de lecture a échoué.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="sslStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.EndWrite(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Instance de <see cref="T:System.IAsyncResult" /> retournée par un appel à <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</param>
        <summary>Termine une opération d'écriture asynchrone démarrée avec un appel précédent à <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération n’est pas terminée, cette méthode se bloque jusqu'à ce que c’est le cas.  
  
 Une application ne peut pas appeler cette méthode jusqu'à ce que vous avez été authentifié. Pour l’authentification, appelez une de la <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, ou <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> méthodes.  
  
 Pour effectuer cette opération de façon synchrone, utilisez la <xref:System.Net.Security.SslStream.Write%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’arrêt d’une opération d’écriture asynchrone.  
  
 [!code-cpp[NclSslServerAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerAsync/CPP/NclSslServerAsync.cpp#4)]
 [!code-csharp[NclSslServerAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerAsync/CS/serverasync.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n'a pas été créé par un appel à la méthode <see cref="M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'authentification n'a pas été effectuée.</exception>
        <exception cref="T:System.IO.IOException">L'opération d'écriture a échoué.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="sslStream.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provoque l'écriture des données mises en mémoire tampon sur le périphérique sous-jacent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle <xref:System.IO.Stream.Flush%2A> sur le flux sous-jacent.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’appel de cette méthode.  
  
 [!code-cpp[NclSslClientSync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#5)]
 [!code-csharp[NclSslClientSync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="sslStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.HashAlgorithmType HashAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.HashAlgorithmType HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HashAlgorithm As HashAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::HashAlgorithmType HashAlgorithm { System::Security::Authentication::HashAlgorithmType get(); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Security.Authentication.HashAlgorithmType" Usage="System.Net.Security.SslStream.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.HashAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.HashAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'algorithme utilisé pour générer des codes d'authentification de messages (MAC).</summary>
        <value>Valeur <see cref="T:System.Security.Authentication.HashAlgorithmType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algorithmes d’authentification de message génèrent des hachages de message et les signatures permet de détecter la falsification et la falsification.  
  
   
  
## Examples  
 L’exemple de code suivant affiche les paramètres de chiffrement pour le flux spécifié.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'accès à la propriété <see cref="P:System.Net.Security.SslStream.HashAlgorithm" /> a été effectué avant la fin du processus d'authentification ou le processus d'authentification a échoué.</exception>
      </Docs>
    </Member>
    <Member MemberName="HashStrength">
      <MemberSignature Language="C#" Value="public virtual int HashStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HashStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.HashStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HashStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int HashStrength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HashStrength : int" Usage="System.Net.Security.SslStream.HashStrength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.HashStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui identifie la puissance de l'algorithme de hachage utilisé par cette instance.</summary>
        <value>Valeur <see cref="T:System.Int32" /> qui spécifie la puissance de l'algorithme <see cref="T:System.Security.Authentication.HashAlgorithmType" />, en bits. Les valeurs autorisées sont 128 ou 160.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette propriété est zéro jusqu'à ce que l’authentification se produit.  
  
   
  
## Examples  
 L’exemple de code suivant affiche les paramètres de chiffrement pour le flux spécifié.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Net.Security.SslStream.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsAuthenticated</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur <see cref="T:System.Boolean" /> qui indique si l'authentification a réussi.</summary>
        <value><see langword="true" /> si l'authentification réalisée a réussi ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les clients s’authentifient en appelant le <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> ou <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> méthodes. Authentifieront des serveurs en appelant le <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> ou <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> méthodes.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsEncrypted" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEncrypted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEncrypted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEncrypted : bool" Usage="System.Net.Security.SslStream.IsEncrypted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsEncrypted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur <see cref="T:System.Boolean" /> qui indique si ce <see cref="T:System.Net.Security.SslStream" /> utilise le chiffrement de données.</summary>
        <value><see langword="true" /> si les données sont chiffrées avant d'être transmises sur le réseau et déchiffrées lorsqu'elles atteignent le point de terminaison distant ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiffrement vous aide à protéger la confidentialité des données, à savoir qu’il permet de garantir que, lorsque les données sont en transit, il ne peut pas être déchiffrée par des tiers.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsMutuallyAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsMutuallyAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMutuallyAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMutuallyAuthenticated : bool" Usage="System.Net.Security.SslStream.IsMutuallyAuthenticated" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsMutuallyAuthenticated</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur <see cref="T:System.Boolean" /> qui indique si le serveur et le client ont tous les deux été authentifiés.</summary>
        <value><see langword="true" /> si le serveur a été authentifié ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’authentification mutuelle est spécifiée par le serveur lorsque le serveur souhaite que le client fournisse un certificat pour l’authentification.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Net.Security.SslStream.AuthenticateAsServer" />
        <altmember cref="Overload:System.Net.Security.SslStream.BeginAuthenticateAsServer" />
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsServer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsServer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsServer : bool" Usage="System.Net.Security.SslStream.IsServer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsServer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur <see cref="T:System.Boolean" /> qui indique si le côté local de la connexion utilisée par ce <see cref="T:System.Net.Security.SslStream" /> a été authentifié comme serveur.</summary>
        <value><see langword="true" /> si le point de terminaison local a été authentifié avec succès comme côté serveur de la connexion authentifiée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’authentification a échoué ou n’a été réalisée, cette propriété retourne `false`.  
  
 Pour vous authentifier en tant que le serveur, appelez le <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> ou <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> méthodes.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.IsSigned" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSigned As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSigned { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSigned : bool" Usage="System.Net.Security.SslStream.IsSigned" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.IsSigned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur <see cref="T:System.Boolean" /> qui indique si les données envoyées à l'aide de ce flux sont signées.</summary>
        <value><see langword="true" /> si les données sont signées avant d'être transmises ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Permet de protéger l’intégrité des données de la signature des données, à savoir qu’il vous aide au destinataire déterminer si les données a été falsifiées lors de leur transit.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclSslServerSync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#4)]
 [!code-csharp[NclSslServerSync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.ExchangeAlgorithmType KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.ExchangeAlgorithmType KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property KeyExchangeAlgorithm As ExchangeAlgorithmType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::ExchangeAlgorithmType KeyExchangeAlgorithm { System::Security::Authentication::ExchangeAlgorithmType get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyExchangeAlgorithm : System.Security.Authentication.ExchangeAlgorithmType" Usage="System.Net.Security.SslStream.KeyExchangeAlgorithm" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.KeyExchangeAlgorithm</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExchangeAlgorithmType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'algorithme d'échange de clé utilisé par ce <see cref="T:System.Net.Security.SslStream" />.</summary>
        <value>Valeur <see cref="T:System.Security.Authentication.ExchangeAlgorithmType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette propriété est <xref:System.Security.Authentication.ExchangeAlgorithmType.None> jusqu'à ce que l’authentification se produit.  
  
 L’algorithme d’échange de clés protège les informations utilisées pour générer des clés partagées.  
  
   
  
## Examples  
 L’exemple de code suivant affiche les paramètres de chiffrement pour le flux spécifié.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeStrength">
      <MemberSignature Language="C#" Value="public virtual int KeyExchangeStrength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 KeyExchangeStrength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.KeyExchangeStrength" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property KeyExchangeStrength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int KeyExchangeStrength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyExchangeStrength : int" Usage="System.Net.Security.SslStream.KeyExchangeStrength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.KeyExchangeStrength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui identifie la puissance de l'algorithme d'échange de clé utilisé par cette instance.</summary>
        <value>Valeur <see cref="T:System.Int32" /> qui spécifie la puissance de l'algorithme <see cref="T:System.Security.Authentication.ExchangeAlgorithmType" />, en bits.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette propriété est zéro jusqu'à ce que l’authentification se produit.  
  
 Dans les scénarios courants, la valeur de cette propriété est une des opérations suivantes :  
  
-   512  
  
-   768  
  
-   1024  
  
-   2048  
  
   
  
## Examples  
 L’exemple de code suivant affiche les paramètres de chiffrement pour le flux spécifié.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Net.Security.SslStream.Length" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.Length</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la longueur du flux sous-jacent.</summary>
        <value><see cref="T:System.Int64" />  
  
Longueur du flux sous-jacent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne la valeur retournée en appelant <xref:System.IO.Stream.Length%2A> sur le flux sous-jacent. Si le flux sous-jacent n’est pas identifiable, cette méthode lève généralement une exception. Le type au moment de l’exécution du flux sous-jacent détermine le type au moment de l’exécution de l’exception est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L'obtention de la valeur de cette propriété n'est pas prise en charge lorsque le flux sous-jacent est <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate LocalCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate LocalCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.LocalCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LocalCertificate As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::X509Certificates::X509Certificate ^ LocalCertificate { System::Security::Cryptography::X509Certificates::X509Certificate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalCertificate : System.Security.Cryptography.X509Certificates.X509Certificate" Usage="System.Net.Security.SslStream.LocalCertificate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.LocalCertificate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le certificat utilisé pour authentifier le point de terminaison local.</summary>
        <value>Objet X509Certificate qui représente le certificat fourni pour l'authentification ou <see langword="null" /> si aucun certificat n'a été fourni.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’affichage du certificat retourné par cette propriété.  
  
 [!code-cpp[NclSslServerSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#6)]
 [!code-csharp[NclSslServerSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'authentification a échoué ou n'a pas été effectuée.</exception>
      </Docs>
    </Member>
    <Member MemberName="NegotiatedApplicationProtocol">
      <MemberSignature Language="C#" Value="public System.Net.Security.SslApplicationProtocol NegotiatedApplicationProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.SslApplicationProtocol NegotiatedApplicationProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.NegotiatedApplicationProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NegotiatedApplicationProtocol As SslApplicationProtocol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::SslApplicationProtocol NegotiatedApplicationProtocol { System::Net::Security::SslApplicationProtocol get(); };" />
      <MemberSignature Language="F#" Value="member this.NegotiatedApplicationProtocol : System.Net.Security.SslApplicationProtocol" Usage="System.Net.Security.SslStream.NegotiatedApplicationProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.SslApplicationProtocol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Net.Security.SslStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position actuelle dans le flux sous-jacent.</summary>
        <value><see cref="T:System.Int64" />  
  
Position actuelle dans le flux sous-jacent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne la valeur retournée en appelant <xref:System.IO.Stream.Position%2A> sur le flux sous-jacent. Si le flux sous-jacent n’est pas identifiable, cette méthode lève généralement une exception. Le type au moment de l’exécution du flux sous-jacent détermine le type au moment de l’exécution de l’exception est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La définition de cette propriété n'est pas prise en charge.  
  
- ou - 
L'obtention de la valeur de cette propriété n'est pas prise en charge lorsque le flux sous-jacent est <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="sslStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Read(System.Byte[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau <see cref="T:System.Byte" /> qui reçoit les octets lus dans ce flux.</param>
        <param name="offset"><see cref="T:System.Int32" /> contenant l'emplacement de base zéro dans <paramref name="buffer" />, à partir duquel commencer l'enregistrement des données lues dans ce flux.</param>
        <param name="count"><see cref="T:System.Int32" /> contenant le nombre maximal d'octets à lire dans ce flux.</param>
        <summary>Lit les données de ce flux et les stocke dans le tableau spécifié.</summary>
        <returns>Valeur <see cref="T:System.Int32" /> qui indique le nombre d'octets lus. Lorsqu'il n'y a plus de données à lire, retourne 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode lit un maximum de `count` octets à partir du flux et les stocke dans `buffer` commençant à `offset`. Impossible d’effectuer plusieurs opérations de lecture simultanées.  
  
 Vous ne pouvez pas appeler cette méthode jusqu'à ce que vous avez été authentifié. Pour authentifier un appel de la <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, ou <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> méthodes.  
  
 Pour effectuer cette opération de façon asynchrone, utilisez la <xref:System.Net.Security.SslStream.BeginRead%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant illustre la lecture à partir d’un <xref:System.Net.Security.SslStream>.  
  
 [!code-cpp[NclSslClientSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslClientSync/CPP/clientsync.cpp#6)]
 [!code-csharp[NclSslClientSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslClientSync/CS/clientsync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; longueur de <paramref name="buffer" />.  
  
- ou - 
 <paramref name="offset" /> + nombre &gt; longueur de <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">L'opération de lecture a échoué. Vérifiez l'exception interne, si elle permet de déterminer la cause de la défaillance.</exception>
        <exception cref="T:System.NotSupportedException">Une opération de lecture est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L'authentification n'a pas été effectuée.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Net.Security.SslStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.ReadTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la durée pendant laquelle une opération de lecture reste bloquée en attendant des données.</summary>
        <value><see cref="T:System.Int32" /> spécifiant le temps qui doit s'écouler avant l'échec d'une opération de lecture synchrone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne la valeur retournée en appelant <xref:System.IO.Stream.ReadTimeout%2A> sur le flux sous-jacent. Lorsque vous définissez cette propriété, le <xref:System.IO.Stream.ReadTimeout%2A> sur le flux sous-jacent a la valeur à la valeur spécifiée.  
  
 Si le flux sous-jacent est un <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.SslStream.ReadTimeout%2A> est exprimée en millisecondes et a la valeur <xref:System.Threading.Timeout.Infinite> par défaut, de sorte que les opérations ne dépassent pas le délai de lecture.  
  
   
  
## Examples  
 L’exemple de code suivant illustre la définition de la valeur de cette propriété.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate RemoteCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate RemoteCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.RemoteCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RemoteCertificate As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::X509Certificates::X509Certificate ^ RemoteCertificate { System::Security::Cryptography::X509Certificates::X509Certificate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteCertificate : System.Security.Cryptography.X509Certificates.X509Certificate" Usage="System.Net.Security.SslStream.RemoteCertificate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.RemoteCertificate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le certificat utilisé pour authentifier le point de terminaison distant.</summary>
        <value>Objet X509Certificate qui représente le certificat fourni pour l'authentification ou <see langword="null" /> si aucun certificat n'a été fourni.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’affichage du certificat retourné par cette propriété.  
  
 [!code-cpp[NclSslServerSync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#6)]
 [!code-csharp[NclSslServerSync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'authentification a échoué ou n'a pas été effectuée.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="sslStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Cette valeur est ignorée.</param>
        <param name="origin">Cette valeur est ignorée.</param>
        <summary>Lève un <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Lève toujours une exception <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 N'appelez pas cette méthode. Il est hérité, mais n’est pas pris en charge par le <xref:System.Net.Security.SslStream> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La recherche n'est pas prise en charge par les objets <see cref="T:System.Net.Security.SslStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="sslStream.SetLength value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.SetLength(System.Int64)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valeur <see cref="T:System.Int64" /> qui spécifie la longueur du flux.</param>
        <summary>Définit la longueur du flux sous-jacent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle <xref:System.IO.Stream.SetLength%2A?displayProperty=nameWithType> sur le flux sous-jacent spécifié lorsque ce <xref:System.Net.Security.SslStream> a été créé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task ShutdownAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task ShutdownAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.ShutdownAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ShutdownAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ ShutdownAsync();" />
      <MemberSignature Language="F#" Value="abstract member ShutdownAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.ShutdownAsync : unit -&gt; System.Threading.Tasks.Task" Usage="sslStream.ShutdownAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arrête ce SslStream.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SslProtocol">
      <MemberSignature Language="C#" Value="public virtual System.Security.Authentication.SslProtocols SslProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.SslProtocols SslProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.SslProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SslProtocol As SslProtocols" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Authentication::SslProtocols SslProtocol { System::Security::Authentication::SslProtocols get(); };" />
      <MemberSignature Language="F#" Value="member this.SslProtocol : System.Security.Authentication.SslProtocols" Usage="System.Net.Security.SslStream.SslProtocol" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.SslProtocol</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.SslProtocols</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique le protocole de sécurité utilisé pour authentifier cette connexion.</summary>
        <value>Valeur <see cref="T:System.Security.Authentication.SslProtocols" /> qui représente le protocole utilisé pour l'authentification.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les protocoles de sécurité prises en charge sont spécifiés lorsque le <xref:System.Net.Security.SslStream> est créé. Si aucun protocole de sécurité a été passé au constructeur, l’instance est créée à l’aide de <xref:System.Security.Authentication.SslProtocols.Default>. Le protocole utilisé pour l’authentification est sélectionné selon les protocoles pris en charge par le client et le serveur.  
  
   
  
## Examples  
 L’exemple suivant affiche les propriétés de sécurité du flux spécifié.  
  
 [!code-cpp[NclSslServerSync#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#3)]
 [!code-csharp[NclSslServerSync#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransportContext">
      <MemberSignature Language="C#" Value="public System.Net.TransportContext TransportContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.TransportContext TransportContext" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.TransportContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransportContext As TransportContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::TransportContext ^ TransportContext { System::Net::TransportContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransportContext : System.Net.TransportContext" Usage="System.Net.Security.SslStream.TransportContext" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.TransportContext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.TransportContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Net.TransportContext" /> utilisé pour l'authentification à l'aide de la protection étendue.</summary>
        <value>Objet <see cref="T:System.Net.TransportContext" /> qui contient le jeton de liaison de canal (FAO) utilisé comme protection étendue.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit des données dans ce flux.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Write(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] -&gt; unit" Usage="sslStream.Write buffer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Write(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de <see cref="T:System.Byte" /> qui fournit les octets écrits dans le flux.</param>
        <summary>Écrit les données spécifiées dans ce flux.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se bloque pendant que l’opération se termine. Pour éviter un blocage pendant l’opération est terminée, utilisez le <xref:System.Net.Security.SslStream.BeginWrite%2A> (méthode).  
  
 Vous ne pouvez pas appeler cette méthode jusqu'à ce que vous avez été authentifié. Pour authentifier un appel de la <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, ou <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> méthodes.  
  
 Le <xref:System.Net.Security.SslStream> classe ne prend pas en charge plusieurs opérations d’écriture simultanées.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’écriture dans un authentifié <xref:System.Net.Security.SslStream>.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">L'opération d'écriture a échoué.</exception>
        <exception cref="T:System.NotSupportedException">Une opération d'écriture est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L'authentification n'a pas été effectuée.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.SslStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="sslStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Mono.Net.Security.IMonoSslStream.Write(System.Byte[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de <see cref="T:System.Byte" /> qui fournit les octets écrits dans le flux.</param>
        <param name="offset"><see cref="T:System.Int32" /> qui contient l'emplacement de base zéro dans<paramref name="buffer" /> auquel commencer la lecture des octets à écrire dans le flux.</param>
        <param name="count"><see cref="T:System.Int32" /> qui contient le nombre d'octets à lire dans <paramref name="buffer" />.</param>
        <summary>Écrivez le nombre spécifié de <see cref="T:System.Byte" />s dans le flux sous-jacent à l'aide de la mémoire tampon et de l'offset spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se bloque pendant que l’opération se termine. Pour éviter un blocage pendant l’opération termine l’opération est terminée, utilisez le <xref:System.Net.Security.SslStream.BeginWrite%2A> (méthode).  
  
 Vous ne pouvez pas appeler cette méthode jusqu'à ce que vous avez été authentifié. Pour authentifier un appel de la <xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>, ou <xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>, <xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> méthodes.  
  
 Le <xref:System.Net.Security.SslStream> classe ne prend pas en charge plusieurs opérations d’écriture simultanées.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" />
          <paramref name="&lt;" />
          <paramref name="0" />.  
  
 <paramref name="-or-" /><paramref name="offset" /> &gt; longueur de <paramref name="buffer" />.  
  
- ou - 
 <paramref name="offset" /> + nombre &gt; longueur de <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">L'opération d'écriture a échoué.</exception>
        <exception cref="T:System.NotSupportedException">Une opération d'écriture est déjà en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L'authentification n'a pas été effectuée.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.SslStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Net.Security.SslStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Mono.Net.Security.IMonoSslStream.WriteTimeout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la durée pendant laquelle une opération d'écriture reste bloquée en attendant des données.</summary>
        <value><see cref="T:System.Int32" /> spécifiant le temps qui doit s'écouler avant l'échec d'une opération d'écriture synchrone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne la valeur retournée en appelant <xref:System.IO.Stream.WriteTimeout%2A> sur le flux sous-jacent. Pour les opérations de jeu, définit la valeur spécifiée la <xref:System.IO.Stream.WriteTimeout%2A> valeur sur le flux sous-jacent.  
  
 Si le flux sous-jacent est un <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.SslStream.WriteTimeout%2A> est exprimée en millisecondes et a la valeur <xref:System.Threading.Timeout.Infinite> par défaut, de sorte que les opérations ne dépassent pas le délai d’écriture.  
  
   
  
## Examples  
 L’exemple de code suivant illustre la définition de la valeur de cette propriété.  
  
 [!code-cpp[NclSslServerSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclSslServerSync/CPP/NclSslServerSync.cpp#1)]
 [!code-csharp[NclSslServerSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclSslServerSync/CS/serversync.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>