<Type Name="NegotiateStream" FullName="System.Net.Security.NegotiateStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9576497d90ed0f9e90d734cedc9957a2d7d66942" /><Meta Name="ms.sourcegitcommit" Value="5ebd9691c6f7d50c4730e997fba69e54bdd7cc0c" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/17/2019" /><Meta Name="ms.locfileid" Value="65829965" /></Metadata><TypeSignature Language="C#" Value="public class NegotiateStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NegotiateStream extends System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.NegotiateStream" />
  <TypeSignature Language="VB.NET" Value="Public Class NegotiateStream&#xA;Inherits AuthenticatedStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NegotiateStream : System::Net::Security::AuthenticatedStream" />
  <TypeSignature Language="F#" Value="type NegotiateStream = class&#xA;    inherit AuthenticatedStream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit un flux qui utilise le protocole de sécurité Negotiate pour authentifier le client et éventuellement le serveur, dans les communications client-serveur.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Net.Security.NegotiateStream> classe pour l’authentification et pour aider à sécuriser les informations transmises entre un client et un serveur. À l’aide de <xref:System.Net.Security.NegotiateStream>, vous pouvez procédez comme suit.  
  
-   Envoyer des informations d’identification du client au serveur pour l’emprunt d’identité ou la délégation.  
  
-   Exiger une authentification de serveur.  
  
-   Chiffrer et/ou signer les données avant de les transmettre.  
  
 L’authentification doit être effectuée avant de transmettre des informations. Les clients demandent l’authentification à l’aide de la commande synchrone <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> méthodes, qui se bloquent jusqu'à ce que l’authentification terminée, ou asynchrone <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> méthodes, qui ne bloquent pas lors de l’attente pour l’authentification. Serveurs de demandent une authentification à l’aide de la commande synchrone <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> ou asynchrone <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> méthodes. Le client et éventuellement le serveur, est authentifié à l’aide du protocole de sécurité Negotiate. Sur les systèmes Windows 95/98, Windows NT LAN Manager (NTLM) est le protocole utilisé pour l’authentification. Sur d’autres plateformes Kerberos protocole est utilisé pour l’authentification si le client et le serveur le prennent en charge ; Sinon, NTLM est utilisé. Pour obtenir une description détaillée de ces protocoles, consultez la documentation Platform SDK sur MSDN, à msdn.microsoft.com/library/. Le <xref:System.Net.Security.NegotiateStream> classe effectue l’authentification à l’aide de la prise en charge Interface SSPI (Security Provider).  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité seront utilisées par le <xref:System.Net.Security.NegotiateStream> pour aider à sécuriser vos données pendant la transmission. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite. Vous pouvez obtenir des informations sur le client distant ou serveur à l’aide du <xref:System.Net.Security.NegotiateStream.RemoteIdentity%2A> propriété.  
  
 Si l’authentification échoue, vous recevrez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 Envoyer des données à l’aide de la commande synchrone <xref:System.Net.Security.NegotiateStream.Write%2A> ou asynchrone <xref:System.Net.Security.NegotiateStream.BeginWrite%2A> méthodes. Vous recevez des données à l’aide de la commande synchrone <xref:System.Net.Security.NegotiateStream.Read%2A> ou asynchrone <xref:System.Net.Security.NegotiateStream.BeginRead%2A> méthodes. Si les services de sécurité telles que le chiffrement ou la signature sont activés, ils sont automatiquement appliqués à vos données par le <xref:System.Net.Security.NegotiateStream>.  
  
 Le <xref:System.Net.Security.NegotiateStream> transmet des données à l’aide d’un flux que vous fournissez lors de la création du <xref:System.Net.Security.NegotiateStream>. Lorsque vous fournissez ce flux sous-jacent, vous avez l’option pour spécifier si la fermeture de la <xref:System.Net.Security.NegotiateStream> ferme également le flux sous-jacent.  
  
   
  
## Examples  
L’exemple suivant montre le côté client d’une connexion client-serveur qui utilise le <xref:System.Net.Security.NegotiateStream>. Le client s’authentifie et envoie un message au serveur de façon asynchrone.  
  
[!code-cpp[NclNegoAsyncClient#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#0)]
[!code-csharp[NclNegoAsyncClient#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#0)]  
[!code-vb[NclNegoAsyncClient#0](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#0)] 

L’exemple de code suivant montre le côté serveur d’une connexion client-serveur qui utilise le <xref:System.Net.Security.NegotiateStream> pour authentifier le client et de lire un message envoyé par le client.  
  
[!code-cpp[NclNegoAsyncServer#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#0)]
[!code-csharp[NclNegoAsyncServer#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#0)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Modifications apportées à l’authentification NTLM pour HTTPWebRequest dans la Version 3.5 SP1</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Security.NegotiateStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour empêcher le <xref:System.Net.Security.NegotiateStream> de fermer le flux que vous fournissez, utilisez le <xref:System.Net.Security.NegotiateStream.%23ctor%28System.IO.Stream%2CSystem.Boolean%29> constructeur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateStream(System::IO::Stream ^ innerStream);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.NegotiateStream : System.IO.Stream -&gt; System.Net.Security.NegotiateStream" Usage="new System.Net.Security.NegotiateStream innerStream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="innerStream">Un <see cref="T:System.IO.Stream" /> objet utilisé par le <see cref="T:System.Net.Security.NegotiateStream" /> pour envoyer et recevoir des données.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.Security.NegotiateStream" /> à l'aide du <see cref="T:System.IO.Stream" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’appel de ce constructeur.  
  
 [!code-cpp[NclNegoSyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#3)]
 [!code-csharp[NclNegoSyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.NegotiateStream : System.IO.Stream * bool -&gt; System.Net.Security.NegotiateStream" Usage="new System.Net.Security.NegotiateStream (innerStream, leaveInnerStreamOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="innerStream">Un <see cref="T:System.IO.Stream" /> objet utilisé par le <see cref="T:System.Net.Security.NegotiateStream" /> pour envoyer et recevoir des données.</param>
        <param name="leaveInnerStreamOpen"><see langword="true" /> pour indiquer que la fermeture de ce <see cref="T:System.Net.Security.NegotiateStream" /> n’a aucun effet <paramref name="innerStream" />; <see langword="false" /> pour indiquer que la fermeture de ce <see cref="T:System.Net.Security.NegotiateStream" /> ferme également <paramref name="innerStream" />.</param>
        <summary>Initialise une nouvelle instance de la <see cref="T:System.Net.Security.NegotiateStream" /> à l’aide de l’élément spécifié de la classe <see cref="T:System.IO.Stream" /> et comportement de clôture de flux.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous spécifiez `true` pour le `leaveStreamOpen` paramètre, la fermeture de la <xref:System.Net.Security.NegotiateStream> n’a aucun effet le `innerStream` diffuser en continu ; vous devez fermer explicitement `innerStream` lorsque vous n’avez plus besoin.  
  
   
  
## Examples  
L’exemple suivant illustre l’appel de ce constructeur. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Net.Security.NegotiateStream> classe.  
  
[!code-cpp[NclNegoAsyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#1)]
[!code-csharp[NclNegoAsyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#1)]  
[!code-vb[NclNegoAsyncClient#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#1)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="innerStream" /> a la valeur <see langword="null" />.  
  
ou 
 <paramref name="innerStream" /> est égal à <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Appelé par les clients pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : unit -&gt; unit&#xA;override this.AuthenticateAsClient : unit -&gt; unit" Usage="negotiateStream.AuthenticateAsClient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appelé par les clients pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’authentification utilise le client <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Aucun nom de Principal du Service (SPN) est spécifié pour le serveur. Le niveau d’emprunt d’identité est <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, le niveau de sécurité est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, et l’authentification mutuelle est demandée. Le <xref:System.Net.Security.NegotiateStream> classe construit le SPN utilisé pour l’authentification mutuelle.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le serveur. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le client.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser l’explicite <see cref="T:System.Net.NetworkCredential" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, targetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * string -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * string -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="targetName">Le Service de nom Principal (SPN) qui identifie de façon unique le serveur pour s’authentifier.</param>
        <summary>Appelé par les clients pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Le processus d’authentification utilise les informations d’identification du client spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le niveau d’emprunt d’identité est <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, le niveau de sécurité est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, et l’authentification mutuelle est demandée. Le <xref:System.Net.Security.NegotiateStream> classe construit le SPN utilisé pour l’authentification mutuelle.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le serveur. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le client.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser l’explicite <see cref="T:System.Net.NetworkCredential" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, binding As ChannelBinding, targetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, binding, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="binding">Le <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> qui est utilisé pour la protection étendue.</param>
        <param name="targetName">Le Service de nom Principal (SPN) qui identifie de façon unique le serveur pour s’authentifier.</param>
        <summary>Appelé par les clients pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Le processus d’authentification utilise les informations d’identification de client spécifié et la liaison de canal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le niveau d’emprunt d’identité est <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, le niveau de sécurité est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, et l’authentification mutuelle est demandée. Le <xref:System.Net.Security.NegotiateStream> classe construit le SPN utilisé pour l’authentification mutuelle.  
  
 Le <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> utilisé pour la protection étendue qui est passée à cette méthode dans le `binding` paramètre sera récupéré par une application à partir de <xref:System.Net.Security.SslStream.TransportContext%2A> propriété sur associé <xref:System.Net.Security.SslStream>.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="credential" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le serveur. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le client.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="targetName">Le Service de nom Principal (SPN) qui identifie de façon unique le serveur pour s’authentifier.</param>
        <param name="requiredProtectionLevel">Parmi les <see cref="T:System.Net.Security.ProtectionLevel" /> valeurs indiquant les services de sécurité pour le flux.</param>
        <param name="allowedImpersonationLevel">Parmi les <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> valeurs indiquant comment le serveur peut utiliser les informations d’identification du client pour accéder aux ressources.</param>
        <summary>Appelé par les clients pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Le processus d’authentification utilise les options d’authentification et les informations d’identification spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `requiredProtectionLevel` paramètre pour demander des services de sécurité pour les données transmises à l’aide du flux authentifié. Par exemple, pour que les données chiffrées et signées, spécifiez la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valeur. Authentification réussie ne garantit pas que demandé <xref:System.Net.Security.ProtectionLevel> a été accordé. Vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="allowedImpersonationLevel" /> n’est pas une valeur valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> a la valeur null.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le serveur. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le client.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser l’explicite <see cref="T:System.Net.NetworkCredential" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, binding As ChannelBinding, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="binding">Le <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> qui est utilisé pour la protection étendue.</param>
        <param name="targetName">Le Service de nom Principal (SPN) qui identifie de façon unique le serveur pour s’authentifier.</param>
        <param name="requiredProtectionLevel">Parmi les <see cref="T:System.Net.Security.ProtectionLevel" /> valeurs indiquant les services de sécurité pour le flux.</param>
        <param name="allowedImpersonationLevel">Parmi les <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> valeurs indiquant comment le serveur peut utiliser les informations d’identification du client pour accéder aux ressources.</param>
        <summary>Appelé par les clients pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Le processus d’authentification utilise les informations d’identification spécifiées, options d’authentification et la liaison de canal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `requiredProtectionLevel` paramètre pour demander des services de sécurité pour les données transmises à l’aide du flux authentifié. Par exemple, pour que les données chiffrées et signées, spécifiez la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valeur. Authentification réussie ne garantit pas que demandé <xref:System.Net.Security.ProtectionLevel> a été accordé. Vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>.  
  
 Le <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> utilisé pour la protection étendue qui est passée à cette méthode dans le `binding` paramètre sera récupéré par une application à partir de <xref:System.Net.Security.SslStream.TransportContext%2A> propriété sur associé <xref:System.Net.Security.SslStream>.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="credential" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="allowedImpersonationLevel" /> n’est pas une valeur valide.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le serveur. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le client.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClientAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Appelé par les clients pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur en tant qu’une opération asynchrone.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : unit -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appelé par les clients pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur en tant qu’une opération asynchrone.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’authentification utilise le client <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Aucun nom de Principal du Service (SPN) est spécifié pour le serveur. Le niveau d’emprunt d’identité est <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, le niveau de sécurité est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, et l’authentification mutuelle est demandée. Le <xref:System.Net.Security.NegotiateStream> classe construit le SPN utilisé pour l’authentification mutuelle.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le serveur. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le client.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser l’explicite <see cref="T:System.Net.NetworkCredential" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, targetName As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * string -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * string -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="targetName">Le Service de nom Principal (SPN) qui identifie de façon unique le serveur pour s’authentifier.</param>
        <summary>Appelé par les clients pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur en tant qu’une opération asynchrone. Le processus d’authentification utilise les informations d’identification du client spécifié.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le niveau d’emprunt d’identité est <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, le niveau de sécurité est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, et l’authentification mutuelle est demandée. Le <xref:System.Net.Security.NegotiateStream> classe construit le SPN utilisé pour l’authentification mutuelle.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le serveur. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le client.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser l’explicite <see cref="T:System.Net.NetworkCredential" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, binding As ChannelBinding, targetName As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, binding, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="binding">Le <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> qui est utilisé pour la protection étendue.</param>
        <param name="targetName">Le Service de nom Principal (SPN) qui identifie de façon unique le serveur pour s’authentifier.</param>
        <summary>Appelé par les clients pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur en tant qu’une opération asynchrone. Le processus d’authentification utilise les informations d’identification de client spécifié et la liaison de canal.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le niveau d’emprunt d’identité est <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, le niveau de sécurité est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, et l’authentification mutuelle est demandée. Le <xref:System.Net.Security.NegotiateStream> classe construit le SPN utilisé pour l’authentification mutuelle.  
  
 Le <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> utilisé pour la protection étendue qui est passée à cette méthode dans le `binding` paramètre sera récupéré par une application à partir de <xref:System.Net.Security.SslStream.TransportContext%2A> propriété sur associé <xref:System.Net.Security.SslStream>.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="credential" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le serveur. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le client.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="targetName">Le Service de nom Principal (SPN) qui identifie de façon unique le serveur pour s’authentifier.</param>
        <param name="requiredProtectionLevel">Parmi les <see cref="T:System.Net.Security.ProtectionLevel" /> valeurs indiquant les services de sécurité pour le flux.</param>
        <param name="allowedImpersonationLevel">Parmi les <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> valeurs indiquant comment le serveur peut utiliser les informations d’identification du client pour accéder aux ressources.</param>
        <summary>Appelé par les clients pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur en tant qu’une opération asynchrone. Le processus d’authentification utilise les options d’authentification et les informations d’identification spécifiées.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `requiredProtectionLevel` paramètre pour demander des services de sécurité pour les données transmises à l’aide du flux authentifié. Par exemple, pour que les données chiffrées et signées, spécifiez la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valeur. Authentification réussie ne garantit pas que demandé <xref:System.Net.Security.ProtectionLevel> a été accordé. Vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="allowedImpersonationLevel" /> n’est pas une valeur valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> a la valeur null.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le serveur. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le client.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser l’explicite <see cref="T:System.Net.NetworkCredential" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, binding As ChannelBinding, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="binding">Le <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> qui est utilisé pour la protection étendue.</param>
        <param name="targetName">Le Service de nom Principal (SPN) qui identifie de façon unique le serveur pour s’authentifier.</param>
        <param name="requiredProtectionLevel">Parmi les <see cref="T:System.Net.Security.ProtectionLevel" /> valeurs indiquant les services de sécurité pour le flux.</param>
        <param name="allowedImpersonationLevel">Parmi les <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> valeurs indiquant comment le serveur peut utiliser les informations d’identification du client pour accéder aux ressources.</param>
        <summary>Appelé par les clients pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur en tant qu’une opération asynchrone. Le processus d’authentification utilise les informations d’identification spécifiées, options d’authentification et la liaison de canal.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `requiredProtectionLevel` paramètre pour demander des services de sécurité pour les données transmises à l’aide du flux authentifié. Par exemple, pour que les données chiffrées et signées, spécifiez la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valeur. Authentification réussie ne garantit pas que demandé <xref:System.Net.Security.ProtectionLevel> a été accordé. Vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>.  
  
 Le <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> utilisé pour la protection étendue qui est passée à cette méthode dans le `binding` paramètre sera récupéré par une application à partir de <xref:System.Net.Security.SslStream.TransportContext%2A> propriété sur associé <xref:System.Net.Security.SslStream>.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetName" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="credential" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="allowedImpersonationLevel" /> n’est pas une valeur valide.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le serveur. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le client.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gère le côté serveur d’une authentification pour une connexion client-serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ces méthodes bloquent pendant que l’authentification est en cours d’exécution. Pour empêcher l’application à partir de blocage en attendant que l’authentification, utilisez le <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : unit -&gt; unit&#xA;override this.AuthenticateAsServer : unit -&gt; unit" Usage="negotiateStream.AuthenticateAsServer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appelé par les serveurs pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’authentification utilise le serveur <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Aucun nom de Principal du Service (SPN) est spécifié pour le serveur. Le niveau d’emprunt d’identité est <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, et le niveau de sécurité est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Cette méthode se bloque jusqu'à ce que l’opération se termine. Pour éviter un blocage jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> surcharges de méthode.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 et Windows 98 ne sont pas pris en charge.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser l’explicite <see cref="T:System.Net.NetworkCredential" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (policy As ExtendedProtectionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; unit&#xA;override this.AuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; unit" Usage="negotiateStream.AuthenticateAsServer policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="policy">Le <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> qui est utilisé pour la protection étendue.</param>
        <summary>Appelé par les serveurs pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Le processus d’authentification utilise la stratégie de protection étendue spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’authentification utilise le serveur <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Aucun nom de Principal du Service (SPN) est spécifié pour le serveur. Le niveau d’emprunt d’identité est <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, et le niveau de sécurité est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Si le `policy` paramètre est `null`, puis une stratégie de protection étendue utilisée est <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> défini sur <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Cette méthode se bloque jusqu'à ce que l’opération se termine. Pour éviter un blocage jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> surcharges de méthode.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> et <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> sur la stratégie de protection étendue passée dans le <paramref name="policy" /> paramètre sont tous deux <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 et Windows 98 ne sont pas pris en charge.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le <paramref name="policy" /> paramètre a été défini sur <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> sur une plateforme qui ne prend pas en charge la protection étendue.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (credential As NetworkCredential, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsServer (credential, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du serveur.</param>
        <param name="requiredProtectionLevel">Parmi les <see cref="T:System.Net.Security.ProtectionLevel" /> valeurs indiquant les services de sécurité pour le flux.</param>
        <param name="requiredImpersonationLevel">Parmi les <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> valeurs indiquant comment le serveur peut utiliser les informations d’identification du client pour accéder aux ressources.</param>
        <summary>Appelé par les serveurs pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Le processus d’authentification utilise les options d’authentification et les informations d’identification du serveur spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Cette méthode se bloque jusqu'à ce que l’opération se termine. Pour éviter un blocage jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> surcharges de méthode.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" /> doit être <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, ou <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour tenter de s’authentifier de r.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le client. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le serveur.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 et Windows 98 ne sont pas pris en charge.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser l’explicite <see cref="T:System.Net.NetworkCredential" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (credential As NetworkCredential, policy As ExtendedProtectionPolicy, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsServer (credential, policy, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="policy">Le <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> qui est utilisé pour la protection étendue.</param>
        <param name="requiredProtectionLevel">Parmi les <see cref="T:System.Net.Security.ProtectionLevel" /> valeurs indiquant les services de sécurité pour le flux.</param>
        <param name="requiredImpersonationLevel">Parmi les <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> valeurs indiquant comment le serveur peut utiliser les informations d’identification du client pour accéder aux ressources.</param>
        <summary>Appelé par les serveurs pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Le processus d’authentification utilise les informations d’identification du serveur spécifié, les options d’authentification et stratégie de protection étendue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `policy` paramètre est `null`, puis une stratégie de protection étendue utilisée est <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> défini sur <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Cette méthode se bloque jusqu'à ce que l’opération se termine. Pour éviter un blocage jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> surcharges de méthode.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> et <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> sur la stratégie de protection étendue passée dans le <paramref name="policy" /> paramètre sont tous deux <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" /> doit être <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, ou <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour tenter de s’authentifier de r.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le client. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le serveur.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 et Windows 98 ne sont pas pris en charge.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le <paramref name="policy" /> paramètre a été défini sur <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> sur une plateforme qui ne prend pas en charge la protection étendue.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServerAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gère le côté serveur d’une authentification pour une connexion client-serveur en tant qu’une opération asynchrone.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : unit -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appelé par les serveurs pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur en tant qu’une opération asynchrone.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’authentification utilise le serveur <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Aucun nom de Principal du Service (SPN) est spécifié pour le serveur. Le niveau d’emprunt d’identité est <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, et le niveau de sécurité est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 et Windows 98 ne sont pas pris en charge.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser l’explicite <see cref="T:System.Net.NetworkCredential" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (policy As ExtendedProtectionPolicy) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="policy">Le <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> qui est utilisé pour la protection étendue.</param>
        <summary>Appelé par les serveurs pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur en tant qu’une opération asynchrone. Le processus d’authentification utilise la stratégie de protection étendue spécifiée.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’authentification utilise le serveur <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Aucun nom de Principal du Service (SPN) est spécifié pour le serveur. Le niveau d’emprunt d’identité est <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, et le niveau de sécurité est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Si le `policy` paramètre est `null`, puis une stratégie de protection étendue utilisée est <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> défini sur <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> et <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> sur la stratégie de protection étendue passée dans le <paramref name="policy" /> paramètre sont tous deux <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 et Windows 98 ne sont pas pris en charge.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le <paramref name="policy" /> paramètre a été défini sur <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> sur une plateforme qui ne prend pas en charge la protection étendue.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (credential As NetworkCredential, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync (credential, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du serveur.</param>
        <param name="requiredProtectionLevel">Parmi les <see cref="T:System.Net.Security.ProtectionLevel" /> valeurs indiquant les services de sécurité pour le flux.</param>
        <param name="requiredImpersonationLevel">Parmi les <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> valeurs indiquant comment le serveur peut utiliser les informations d’identification du client pour accéder aux ressources.</param>
        <summary>Appelé par les serveurs pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur en tant qu’une opération asynchrone. Le processus d’authentification utilise les options d’authentification et les informations d’identification du serveur spécifié.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" /> doit être <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, ou <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour tenter de s’authentifier de r.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le client. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le serveur.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 et Windows 98 ne sont pas pris en charge.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser l’explicite <see cref="T:System.Net.NetworkCredential" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (credential As NetworkCredential, policy As ExtendedProtectionPolicy, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync (credential, policy, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="policy">Le <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> qui est utilisé pour la protection étendue.</param>
        <param name="requiredProtectionLevel">Parmi les <see cref="T:System.Net.Security.ProtectionLevel" /> valeurs indiquant les services de sécurité pour le flux.</param>
        <param name="requiredImpersonationLevel">Parmi les <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> valeurs indiquant comment le serveur peut utiliser les informations d’identification du client pour accéder aux ressources.</param>
        <summary>Appelé par les serveurs pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur en tant qu’une opération asynchrone. Le processus d’authentification utilise les informations d’identification du serveur spécifié, les options d’authentification et stratégie de protection étendue.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `policy` paramètre est `null`, puis une stratégie de protection étendue utilisée est <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> défini sur <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> et <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> sur la stratégie de protection étendue passée dans le <paramref name="policy" /> paramètre sont tous deux <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" /> doit être <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, ou <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour tenter de s’authentifier de r.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le client. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le serveur.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 et Windows 98 ne sont pas pris en charge.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le <paramref name="policy" /> paramètre a été défini sur <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> sur une plateforme qui ne prend pas en charge la protection étendue.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Commence une opération asynchrone pour authentifier le côté client d’une connexion client-serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de cette méthode ne bloquent pas lorsque l’authentification est en cours d’exécution. Pour bloquer en attendant que l’authentification, utilisez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> méthodes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’authentification est terminée.</param>
        <param name="asyncState">Un objet défini par l’utilisateur contenant des informations sur l’opération. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Appelé par les clients pour commencer une opération asynchrone pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Cette méthode ne bloque pas.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> objet indiquant l’état de l’opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’authentification utilise le client <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Aucun nom de Principal du Service (SPN) est spécifié pour le serveur. Le niveau d’emprunt d’identité est <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, et le niveau de sécurité est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>. Le <xref:System.Net.Security.NegotiateStream> classe construit le SPN utilisé pour l’authentification mutuelle.  
  
 Cette méthode est asynchrone et ne bloque pas pendant l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> surcharges de méthode.  
  
 L’opération asynchrone d’authentification doit être effectuée en appelant le <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer. Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
   
  
## Examples  
L’exemple suivant illustre l’appel de cette méthode pour commencer une authentification asynchrone pour le client.  
  
[!code-cpp[NclNegoAsyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#2)]
[!code-csharp[NclNegoAsyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#2)]  
[!code-vb[NclNegoAsyncClient#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#2)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le serveur. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le client.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser l’explicite <see cref="T:System.Net.NetworkCredential" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * string * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * string * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, targetName, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="targetName">Le Service de nom Principal (SPN) qui identifie de façon unique le serveur pour s’authentifier.</param>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’authentification est terminée.</param>
        <param name="asyncState">Un objet défini par l’utilisateur contenant des informations sur l’opération d’écriture. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Appelé par les clients pour commencer une opération asynchrone pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Le processus d’authentification utilise les informations d’identification spécifiées. Cette méthode ne bloque pas.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> objet indiquant l’état de l’opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est asynchrone et ne bloque pas pendant l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> surcharges de méthode.  
  
 L’opération asynchrone d’authentification doit être effectuée en appelant le <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer. Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="targetName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le serveur. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le client.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser l’explicite <see cref="T:System.Net.NetworkCredential" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, binding, targetName, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="binding">Le <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> qui est utilisé pour la protection étendue.</param>
        <param name="targetName">Le Service de nom Principal (SPN) qui identifie de façon unique le serveur pour s’authentifier.</param>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’authentification est terminée.</param>
        <param name="asyncState">Un objet défini par l’utilisateur contenant des informations sur l’opération d’écriture. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Appelé par les clients pour commencer une opération asynchrone pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Le processus d’authentification utilise les informations d’identification spécifiées et de la liaison de canal. Cette méthode ne bloque pas.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> objet indiquant l’état de l’opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est asynchrone et ne bloque pas pendant l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> surcharges de méthode.  
  
 L’opération asynchrone d’authentification doit être effectuée en appelant le <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer. Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="targetName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le serveur. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le client.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="targetName">Le Service de nom Principal (SPN) qui identifie de façon unique le serveur pour s’authentifier.</param>
        <param name="requiredProtectionLevel">Parmi les <see cref="T:System.Net.Security.ProtectionLevel" /> valeurs indiquant les services de sécurité pour le flux.</param>
        <param name="allowedImpersonationLevel">Parmi les <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> valeurs indiquant comment le serveur peut utiliser les informations d’identification du client pour accéder aux ressources.</param>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’authentification est terminée.</param>
        <param name="asyncState">Un objet défini par l’utilisateur contenant des informations sur l’opération d’écriture. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Appelé par les clients pour commencer une opération asynchrone pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Le processus d’authentification utilise les options d’authentification et les informations d’identification spécifiées. Cette méthode ne bloque pas.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> objet indiquant l’état de l’opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `requiredProtectionLevel` paramètre pour demander des services de sécurité pour les données transmises à l’aide du flux authentifié. Par exemple, pour que les données chiffrées et signées, spécifiez la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valeur. Authentification réussie ne garantit pas que demandé <xref:System.Net.Security.ProtectionLevel> a été accordé. Vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>.  
  
 Cette méthode est asynchrone et ne bloque pas pendant l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> surcharges de méthode.  
  
 L’opération asynchrone d’authentification doit être effectuée en appelant le <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer. Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="targetName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le serveur. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le client.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser l’explicite <see cref="T:System.Net.NetworkCredential" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="targetName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="binding">Le <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> qui est utilisé pour la protection étendue.</param>
        <param name="targetName">Le Service de nom Principal (SPN) qui identifie de façon unique le serveur pour s’authentifier.</param>
        <param name="requiredProtectionLevel">Parmi les <see cref="T:System.Net.Security.ProtectionLevel" /> valeurs indiquant les services de sécurité pour le flux.</param>
        <param name="allowedImpersonationLevel">Parmi les <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> valeurs indiquant comment le serveur peut utiliser les informations d’identification du client pour accéder aux ressources.</param>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’authentification est terminée.</param>
        <param name="asyncState">Un objet défini par l’utilisateur contenant des informations sur l’opération d’écriture. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Appelé par les clients pour commencer une opération asynchrone pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Le processus d’authentification utilise les informations d’identification spécifiées, options d’authentification et la liaison de canal. Cette méthode ne bloque pas.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> objet indiquant l’état de l’opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `requiredProtectionLevel` paramètre pour demander des services de sécurité pour les données transmises à l’aide du flux authentifié. Par exemple, pour que les données chiffrées et signées, spécifiez la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valeur. Authentification réussie ne garantit pas que demandé <xref:System.Net.Security.ProtectionLevel> a été accordé. Vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>.  
  
 Cette méthode est asynchrone et ne bloque pas pendant l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> surcharges de méthode.  
  
 L’opération asynchrone d’authentification doit être effectuée en appelant le <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer. Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="targetName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le serveur. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le client.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Commence une opération asynchrone pour gérer le côté serveur d’authentification d’une connexion client-serveur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de cette méthode ne bloquent pas alors que l’authentification est en cours d’exécution. Pour bloquer en attendant que l’authentification, utilisez le <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’authentification est terminée.</param>
        <param name="asyncState">Un objet défini par l’utilisateur contenant des informations sur l’opération. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Appelé par les serveurs pour commencer une opération asynchrone pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Cette méthode ne bloque pas.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> objet indiquant l’état de l’opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’authentification utilise le serveur <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Aucun nom de Principal du Service (SPN) est spécifié pour le serveur. Le niveau d’emprunt d’identité est <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, le niveau de sécurité est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> surcharges de méthode.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 et Windows 98 ne sont pas pris en charge.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser l’explicite <see cref="T:System.Net.NetworkCredential" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (policy, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="policy">Le <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> qui est utilisé pour la protection étendue.</param>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’authentification est terminée.</param>
        <param name="asyncState">Un objet défini par l’utilisateur contenant des informations sur l’opération d’écriture. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Appelé par les serveurs pour commencer une opération asynchrone pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Le processus d’authentification utilise la stratégie de protection étendue spécifiée. Cette méthode ne bloque pas.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> objet indiquant l’état de l’opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’authentification utilise le serveur <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Aucun nom de Principal du Service (SPN) est spécifié pour le serveur. Le niveau d’emprunt d’identité est <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, le niveau de sécurité est <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Si le `policy` paramètre est `null`, puis une stratégie de protection étendue utilisée est <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> défini sur <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> surcharges de méthode.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> et <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> sur la stratégie de protection étendue passée dans le <paramref name="policy" /> paramètre sont tous deux <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 et Windows 98 ne sont pas pris en charge.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le <paramref name="policy" /> paramètre a été défini sur <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> sur une plateforme qui ne prend pas en charge la protection étendue.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (credential, requiredProtectionLevel, requiredImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="requiredProtectionLevel">Parmi les <see cref="T:System.Net.Security.ProtectionLevel" /> valeurs indiquant les services de sécurité pour le flux.</param>
        <param name="requiredImpersonationLevel">Parmi les <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> valeurs indiquant comment le serveur peut utiliser les informations d’identification du client pour accéder aux ressources.</param>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’authentification est terminée.</param>
        <param name="asyncState">Un objet défini par l’utilisateur contenant des informations sur l’opération. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Appelé par les serveurs pour commencer une opération asynchrone pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Le processus d’authentification utilise les options d’authentification et les informations d’identification du serveur spécifié. Cette méthode ne bloque pas.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> objet indiquant l’état de l’opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `requiredProtectionLevel` paramètre pour demander des services de sécurité pour les données transmises à l’aide du flux authentifié. Par exemple, pour que les données chiffrées et signées, spécifiez la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valeur. Authentification réussie ne garantit pas que, demandé <xref:System.Net.Security.ProtectionLevel> a été accordé. Vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>.  
  
 Cette méthode est asynchrone et ne bloque pas pendant l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> surcharges de méthode.  
  
 L’opération asynchrone d’authentification doit être effectuée en appelant le <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer. Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" /> doit être <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, ou <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le client. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le serveur.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 et Windows 98 ne sont pas pris en charge.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour utiliser l’explicite <see cref="T:System.Net.NetworkCredential" />. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (credential, policy, requiredProtectionLevel, requiredImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="credential">Le <see cref="T:System.Net.NetworkCredential" /> qui est utilisé pour établir l’identité du client.</param>
        <param name="policy">Le <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> qui est utilisé pour la protection étendue.</param>
        <param name="requiredProtectionLevel">Parmi les <see cref="T:System.Net.Security.ProtectionLevel" /> valeurs indiquant les services de sécurité pour le flux.</param>
        <param name="requiredImpersonationLevel">Parmi les <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> valeurs indiquant comment le serveur peut utiliser les informations d’identification du client pour accéder aux ressources.</param>
        <param name="asyncCallback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand l’authentification est terminée.</param>
        <param name="asyncState">Un objet défini par l’utilisateur contenant des informations sur l’opération d’écriture. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Appelé par les serveurs pour commencer une opération asynchrone pour authentifier le client et éventuellement le serveur, dans une connexion client-serveur. Le processus d’authentification utilise les informations d’identification du serveur spécifié, les options d’authentification et stratégie de protection étendue. Cette méthode ne bloque pas.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> objet indiquant l’état de l’opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `requiredProtectionLevel` paramètre pour demander des services de sécurité pour les données transmises à l’aide du flux authentifié. Par exemple, pour que les données chiffrées et signées, spécifiez la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valeur. Authentification réussie ne garantit pas que, demandé <xref:System.Net.Security.ProtectionLevel> a été accordé. Vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>.  
  
 Si le `policy` paramètre est `null`, puis une stratégie de protection étendue utilisée est <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> défini sur <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Cette méthode est asynchrone et ne bloque pas pendant l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> surcharges de méthode.  
  
 L’opération asynchrone d’authentification doit être effectuée en appelant le <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer. Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> et <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> sur la stratégie de protection étendue passée dans le <paramref name="policy" /> paramètre sont tous deux <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="credential" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="requiredImpersonationLevel" /> doit être <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, ou <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification a déjà eu lieu.  
  
ou 
Ce flux a été utilisé précédemment pour tenter l’authentification en tant que le client. Vous ne pouvez pas utiliser le flux de nouvelles tentatives d’authentification que le serveur.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 et Windows 98 ne sont pas pris en charge.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le <paramref name="policy" /> paramètre a été défini sur <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> sur une plateforme qui ne prend pas en charge la protection étendue.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginRead (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Un <see cref="T:System.Byte" /> tableau qui reçoit les octets lus à partir du flux.</param>
        <param name="offset">Emplacement de base zéro dans <paramref name="buffer" /> à partir duquel commencer l’enregistrement des données lues à partir de ce flux.</param>
        <param name="count">Le nombre maximal d’octets à lire à partir du flux.</param>
        <param name="asyncCallback">Un <see cref="T:System.AsyncCallback" /> délégué qui référence la méthode à appeler lorsque l’opération de lecture est terminée.</param>
        <param name="asyncState">Un objet défini par l’utilisateur contenant des informations sur l’opération de lecture. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Commence une opération de lecture asynchrone qui lit les données à partir du flux et le stocke dans le tableau spécifié.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> objet indiquant l’état de l’opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le chiffrement, la signature, ou le chiffrement et la signature sont activés, l’opération de lecture lit les données dans le flux sous-jacent, vérifie l’intégrité des données et les déchiffre. Si aucun service de sécurité telles que la signature ou le chiffrement de données sont en cours d’utilisation, cette méthode démarre une opération de lecture asynchrone sur le flux sous-jacent.  
  
 Cette méthode est asynchrone et ne bloque pas pendant l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez le <xref:System.Net.Security.NegotiateStream.Read%2A> (méthode).  
  
 L’opération de lecture asynchrone doit être terminée en appelant le <xref:System.Net.Security.NegotiateStream.EndRead%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer. Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Le <xref:System.Net.Security.NegotiateStream> classe ne prend pas en charge simultanée de plusieurs opérations de lecture. Si vous essayez de démarrer une opération de lecture pendant la lecture des autre opération s’exécute déjà sur le même flux, un <xref:System.NotSupportedException> exception sera levée.  
  
 Vous ne pouvez pas appeler cette méthode jusqu'à ce que vous avez été authentifié. Pour l’authentification, appelez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, ou <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> méthodes.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le démarrage d’une opération de lecture asynchrone. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.Net.Security.NegotiateStream> classe.  
  
 [!code-cpp[NclNegoAsyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#1)]
 [!code-csharp[NclNegoAsyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> est inférieur à 0.  
  
ou 
 <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="offset" /> plus <paramref name="count" /> est supérieur à la longueur d’<paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Échec de l’opération de lecture.  
  
ou 
Le chiffrement est en cours d’utilisation, mais les données n’a pas pu être déchiffrées.</exception>
        <exception cref="T:System.NotSupportedException">Il existe déjà une opération de lecture en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification n’a pas eu lieu.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginWrite (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncState" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Un <see cref="T:System.Byte" /> tableau qui fournit les octets à écrire dans le flux de données.</param>
        <param name="offset">Emplacement de base zéro dans <paramref name="buffer" /> à partir duquel commencer la lecture des octets à écrire dans le flux.</param>
        <param name="count">Un <see cref="T:System.Int32" /> valeur qui spécifie le nombre d’octets à lire à partir de <paramref name="buffer" />.</param>
        <param name="asyncCallback">Un <see cref="T:System.AsyncCallback" /> délégué qui référence la méthode à appeler lorsque l’opération d’écriture est terminée.</param>
        <param name="asyncState">Un objet défini par l’utilisateur contenant des informations sur l’opération d’écriture. Cet objet est passé au délégué <paramref name="asyncCallback" /> quand l'opération se termine.</param>
        <summary>Commence une opération d’écriture asynchrone qui écrit <see cref="T:System.Byte" />s à partir de la mémoire tampon spécifiée dans le flux.</summary>
        <returns>Un <see cref="T:System.IAsyncResult" /> objet indiquant l’état de l’opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le chiffrement, la signature, ou le chiffrement et la signature sont activés, cette méthode lit les données à partir de la mémoire tampon, chiffre, se connecte, ou chiffre et signe et transmet à l’aide du flux sous-jacent. Si aucun service de sécurité telles que la signature ou le chiffrement de données sont en cours d’utilisation, cette méthode démarre une opération d’écriture asynchrone sur le flux sous-jacent.  
  
 Cette méthode est asynchrone et ne bloque pas pendant l’opération se termine. Pour bloquer jusqu'à ce que l’opération est terminée, utilisez le <xref:System.Net.Security.NegotiateStream.Read%2A> (méthode).  
  
 L’opération de lecture asynchrone doit être terminée en appelant le <xref:System.Net.Security.NegotiateStream.EndWrite%2A> (méthode). En règle générale, la méthode est appelée par le `asyncCallback` déléguer. Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Le <xref:System.Net.Security.NegotiateStream> classe ne prend pas en charge plusieurs opérations d’écriture simultanées. Si vous essayez de démarrer une opération d’écriture lorsqu’une autre opération d’écriture est déjà exécutée sur le même flux, un <xref:System.NotSupportedException> exception sera levée.  
  
 Vous ne pouvez pas appeler cette méthode jusqu'à ce que vous avez été authentifié. Pour l’authentification, appelez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, ou <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> méthodes.  
  
   
  
## Examples  
L’exemple suivant montre le début d’une opération d’écriture asynchrone.  
  
[!code-cpp[NclNegoAsyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#3)]
[!code-csharp[NclNegoAsyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#3)]  
[!code-vb[NclNegoAsyncClient#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#3)] 

La méthode suivante est appelée lorsque l’opération se termine.  
  
[!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
[!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
[!code-vb[NclNegoAsyncClient#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#4)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset is less than 0" />.  
  
ou 
 <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="offset" /> plus count est supérieur à la longueur de <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Échec de l’opération d’écriture.  
  
ou 
Le chiffrement est en cours d’utilisation, mais les données n’a pas pu être chiffrées.</exception>
        <exception cref="T:System.NotSupportedException">Il existe déjà une opération d’écriture en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification n’a pas eu lieu.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Net.Security.NegotiateStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Boolean" /> valeur qui indique si le flux sous-jacent est accessible en lecture.</summary>
        <value><see langword="true" /> Si l’authentification s’est produite et le flux sous-jacent est accessible en lecture ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’authentification réussie a eu lieu, cette propriété retourne la valeur retournée en appelant le <xref:System.IO.Stream.CanRead%2A> propriété sur le flux sous-jacent. Le flux sous-jacent est spécifié lorsque vous créez une instance de la <xref:System.Net.Security.NegotiateStream> classe.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Net.Security.NegotiateStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Boolean" /> valeur qui indique si le flux sous-jacent est identifiable.</summary>
        <value>Cette propriété retourne toujours <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne devez pas tenter de définir la position de la <xref:System.Net.Security.NegotiateStream> objet ou son flux sous-jacent. Le flux sous-jacent est spécifié lorsque vous créez une instance de la <xref:System.Net.Security.NegotiateStream> classe.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Security.NegotiateStream.Position" />
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Net.Security.NegotiateStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Boolean" /> valeur qui indique si le flux sous-jacent prend en charge les délais d’attente.</summary>
        <value><see langword="true" /> Si le flux sous-jacent prend en charge les délais d’attente ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne la valeur retournée en appelant le <xref:System.IO.Stream.CanTimeout%2A> propriété sur le flux sous-jacent. Le flux sous-jacent est spécifié lorsque vous créez une instance de la <xref:System.Net.Security.NegotiateStream> classe.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Net.Security.NegotiateStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Boolean" /> valeur qui indique si le flux sous-jacent est accessible en écriture.</summary>
        <value><see langword="true" /> Si l’authentification s’est produite et le flux sous-jacent est accessible en écriture ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’authentification réussie a eu lieu, cette propriété retourne la valeur retournée en appelant le <xref:System.IO.Stream.CanWrite%2A> propriété sur le flux sous-jacent. Le flux sous-jacent est spécifié lorsque vous créez une instance de la <xref:System.Net.Security.NegotiateStream> classe.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="negotiateStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.Net.Security.NegotiateStream" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose()` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose()` appelle la méthode protégée `Dispose(Boolean)` méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` défini sur `false`.  
  
 Lorsque le `disposing` paramètre est true, cette méthode libère toutes les ressources détenues par les objets managés par ce <xref:System.Net.Security.NegotiateStream> références. Cette méthode appelle la méthode `Dispose()` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution <see langword="Dispose(Boolean)" /> veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="negotiateStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsClient (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsClient(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsClient : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsClient : IAsyncResult -&gt; unit" Usage="negotiateStream.EndAuthenticateAsClient asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Un <see cref="T:System.IAsyncResult" /> instance retournée par un appel à <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</param>
        <summary>Termine une opération de l’authentification du client asynchrone en attente qui a été démarrée avec un appel à <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération n’est pas terminée, cette méthode se bloque jusqu'à ce que c’est le cas. Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 Pour effectuer cette opération de manière synchrone, utilisez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n’a pas été créé par un appel à <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.InvalidOperationException">Il n’existe aucune authentification de client en attente pour terminer.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsServer (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsServer(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsServer : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsServer : IAsyncResult -&gt; unit" Usage="negotiateStream.EndAuthenticateAsServer asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Un <see cref="T:System.IAsyncResult" /> instance retournée par un appel à <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</param>
        <summary>Termine une opération de l’authentification du client asynchrone en attente qui a été démarrée avec un appel à <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération n’est pas terminée, cette méthode se bloque jusqu'à ce que c’est le cas.  
  
 Lorsque l’authentification réussit, vous devez vérifier le <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> et <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propriétés pour déterminer quels services de sécurité sont utilisés par le <xref:System.Net.Security.NegotiateStream>. Vérifier le <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propriété afin de déterminer si l’authentification mutuelle s’est produite.  
  
 Si l’authentification échoue, vous recevez un <xref:System.Security.Authentication.AuthenticationException> ou un <xref:System.Security.Authentication.InvalidCredentialException>. Dans ce cas, vous pouvez réessayer l’authentification avec les informations d’identification différentes.  
  
 Pour effectuer cette opération de façon synchrone, utilisez la <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n’a pas été créé par un appel à <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">L’authentification a échoué. Vous pouvez utiliser cet objet pour l’authentification de nouvelle tentative.</exception>
        <exception cref="T:System.InvalidOperationException">Il n’existe aucune authentification en attente pour terminer.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="negotiateStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Un <see cref="T:System.IAsyncResult" /> instance retournée par un appel à <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Se termine une opération de lecture asynchrone qui a été démarrée avec un appel à <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <returns>Un <see cref="T:System.Int32" /> valeur qui spécifie le nombre d’octets lus à partir du flux sous-jacent.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération n’est pas terminée, cette méthode se bloque jusqu'à ce que c’est le cas.  
  
 Pour effectuer cette opération de façon synchrone, utilisez la <xref:System.Net.Security.NegotiateStream.Read%2A> (méthode).  
  
 Vous ne pouvez pas appeler cette méthode jusqu'à ce que vous avez été authentifié. Pour l’authentification, appelez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, ou <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> méthodes.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’opération de lecture asynchrone de fin. Pour obtenir un exemple qui illustre le démarrage de l’opération, consultez <xref:System.Net.Security.NegotiateStream.BeginRead%2A>.  
  
 [!code-cpp[NclNegoAsyncServer#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#3)]
 [!code-csharp[NclNegoAsyncServer#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">AsyncResult n’a pas été créé par un appel à <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il n’existe aucune opération de lecture en attente se termine.

ou

L’authentification n’a pas eu lieu.</exception>
        <exception cref="T:System.IO.IOException">Échec de l’opération de lecture.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="negotiateStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Un <see cref="T:System.IAsyncResult" /> instance retournée par un appel à <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Termine une opération d’écriture asynchrone qui a été démarrée avec un appel à <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’opération n’est pas terminée, cette méthode se bloque jusqu'à ce que c’est le cas.  
  
 Vous ne pouvez pas appeler cette méthode jusqu'à ce que vous avez été authentifié. Pour l’authentification, appelez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, ou <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> méthodes.  
  
 Pour effectuer cette opération de façon synchrone, utilisez la <xref:System.Net.Security.NegotiateStream.Write%2A> (méthode).  
  
   
  
## Examples  
L’exemple suivant montre une méthode qui est appelée pour terminer l’opération d’écriture asynchrone. Pour obtenir un exemple qui illustre le démarrage de l’opération, consultez <xref:System.Net.Security.NegotiateStream.BeginWrite%2A>.  
  
[!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
[!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
[!code-vb[NclNegoAsyncClient#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NclNegoasyncClient/VB/client.vb#4)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">AsyncResult n’a pas été créé par un appel à <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il n’existe aucune opération d’écriture en attente pour terminer.

ou

L’authentification n’a pas eu lieu.</exception>
        <exception cref="T:System.IO.IOException">Échec de l’opération d’écriture.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="negotiateStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provoque des données mises en mémoire tampon à écrire sur l’appareil sous-jacent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle <xref:System.IO.Stream.Flush%2A> sur le flux sous-jacent.  
  
   
  
## Examples  
 L’exemple de code suivant montre le flux de données de consommation.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); };" />
      <MemberSignature Language="F#" Value="member this.ImpersonationLevel : System.Security.Principal.TokenImpersonationLevel" Usage="System.Net.Security.NegotiateStream.ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique comment le serveur peut utiliser les informations d’identification du client.</summary>
        <value>Une des valeurs de <see cref="T:System.Security.Principal.TokenImpersonationLevel" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez vous authentifier avec succès avant d’appeler cette méthode. Les clients spécifient le niveau d’emprunt d’identité lorsqu’ils demandent l’authentification en appelant une de le <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> ou <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> méthodes. Si vous vous authentifiez sans spécifier un <xref:System.Security.Principal.TokenImpersonationLevel> , <xref:System.Security.Principal.TokenImpersonationLevel.Identification> est utilisé.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L’authentification a échoué ou n’a pas eu lieu.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Net.Security.NegotiateStream.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Boolean" /> valeur qui indique si l’authentification a réussi.</summary>
        <value><see langword="true" /> Si l’authentification réussie s’est produite ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les clients s’authentifient en appelant le <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> ou <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> méthodes. Authentifieront des serveurs en appelant le <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> ou <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> méthodes.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsEncrypted" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEncrypted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEncrypted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEncrypted : bool" Usage="System.Net.Security.NegotiateStream.IsEncrypted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Boolean" /> valeur qui indique si ce <see cref="T:System.Net.Security.NegotiateStream" /> utilise le chiffrement de données.</summary>
        <value><see langword="true" /> Si les données sont chiffrées avant d’être transmis sur le réseau et déchiffrées lorsqu’il atteint le point de terminaison distant ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le chiffrement permet de protéger la confidentialité des données ; à savoir, il permet de garantir que, lorsque les données sont en transit qu’il ne peut pas être déchiffré par des tiers.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Security.ProtectionLevel" />
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsMutuallyAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMutuallyAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMutuallyAuthenticated : bool" Usage="System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Boolean" /> valeur qui indique si le serveur et le client ont été authentifiés.</summary>
        <value><see langword="true" /> Si le serveur a été authentifié ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’authentification mutuelle est spécifiée par le client lorsque le client souhaite que le serveur de fournir des informations d’identification pour l’authentification. Par défaut, les clients demandent l’authentification mutuelle.  
  
 Le protocole Negotiate sélectionne NTLM ou Kerberos selon les protocoles de sécurité pris en charge par le client et le serveur. NTLM ne prend pas en charge l’authentification mutuelle.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsServer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsServer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsServer : bool" Usage="System.Net.Security.NegotiateStream.IsServer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Boolean" /> valeur qui indique si le côté local de la connexion utilisée par ce <see cref="T:System.Net.Security.NegotiateStream" /> a été authentifié comme serveur.</summary>
        <value><see langword="true" /> Si le point de terminaison local a été authentifié avec succès comme côté serveur de la connexion authentifiée ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’authentification a échoué ou n’a été réalisée, cette propriété retourne `false`.  
  
 Pour vous authentifier en tant que le serveur, appelez le <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> ou <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> méthodes.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsSigned" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSigned As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSigned { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSigned : bool" Usage="System.Net.Security.NegotiateStream.IsSigned" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Boolean" /> valeur qui indique si les données envoyées à l’aide de ce flux de données sont signées.</summary>
        <value><see langword="true" /> Si les données sont signées avant d’être transmises ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Signature des données permet de protéger l’intégrité des données. à savoir, il permet le destinataire de déterminer si les données a été falsifiées lors de leur transit.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Net.Security.NegotiateStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la longueur du flux sous-jacent.</summary>
        <value>Un <see cref="T:System.Int64" /> qui spécifie la longueur du flux sous-jacent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne la valeur retournée en appelant le <xref:System.IO.Stream.Length%2A> propriété sur le flux sous-jacent. Si le flux sous-jacent n’est pas identifiable, cette propriété lève généralement une exception. Le type au moment de l’exécution du flux sous-jacent détermine le type au moment de l’exécution de l’exception est levée.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Obtention de la valeur de cette propriété n’est pas pris en charge lorsque le flux sous-jacent est un <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Net.Security.NegotiateStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position actuelle dans le flux sous-jacent.</summary>
        <value>Un <see cref="T:System.Int64" /> qui spécifie la position actuelle dans le flux sous-jacent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne la valeur retournée en appelant le <xref:System.IO.Stream.Position%2A> propriété sur le flux sous-jacent. Si le flux sous-jacent n’est pas identifiable, cette propriété lève généralement une exception. Le type au moment de l’exécution du flux sous-jacent détermine le type au moment de l’exécution de l’exception est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Définition de cette propriété n’est pas pris en charge.  
  
ou 
Obtention de la valeur de cette propriété n’est pas pris en charge lorsque le flux sous-jacent est un <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="negotiateStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Un <see cref="T:System.Byte" /> tableau qui reçoit les octets lus à partir du flux.</param>
        <param name="offset">Un <see cref="T:System.Int32" /> contenant l’emplacement de base zéro dans <paramref name="buffer" /> à partir duquel commencer l’enregistrement des données lues à partir de ce flux.</param>
        <param name="count">Un <see cref="T:System.Int32" /> contenant le nombre maximal d’octets à lire à partir du flux.</param>
        <summary>Lit les données à partir de ce flux et le stocke dans le tableau spécifié.</summary>
        <returns>Un <see cref="T:System.Int32" /> valeur qui spécifie le nombre d’octets lus à partir du flux sous-jacent. Lorsqu’il n’existe plus aucune donnée à lire, retourne 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode lit un maximum de `count` octets à partir du flux et les stocke dans `buffer` commençant à `offset`.  
  
 Vous ne pouvez pas appeler cette méthode jusqu'à ce que vous avez été authentifié. Pour l’authentification, appelez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, ou <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> méthodes.  
  
 Pour effectuer cette opération de façon asynchrone, utilisez la <xref:System.Net.Security.NegotiateStream.BeginRead%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant illustre la lecture à partir d’un <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncServer/CPP/NclNegoSyncServer.cpp#1)]
 [!code-csharp[NclNegoSyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Échec de l’opération de lecture.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification n’a pas eu lieu.</exception>
        <exception cref="T:System.NotSupportedException">Un <see cref="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" /> opération est déjà en cours.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Net.Security.NegotiateStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la durée pendant laquelle qu'une opération de lecture reste bloquée en attendant des données.</summary>
        <value>Un <see cref="T:System.Int32" /> qui spécifie la quantité de temps qui doit s’écouler avant l’échec d’une opération de lecture.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne la valeur retournée en appelant le <xref:System.IO.Stream.ReadTimeout%2A> propriété sur le flux sous-jacent. Lorsque vous définissez cette propriété, le <xref:System.IO.Stream.ReadTimeout%2A> sur le flux sous-jacent a la valeur à la valeur spécifiée.  
  
 Si le flux sous-jacent est un <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.NegotiateStream.ReadTimeout%2A> est exprimée en millisecondes et a la valeur <xref:System.Threading.Timeout.Infinite> par défaut, de sorte que les opérations n’expirent pas de lecture.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteIdentity">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.IIdentity RemoteIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity RemoteIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.RemoteIdentity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RemoteIdentity As IIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::IIdentity ^ RemoteIdentity { System::Security::Principal::IIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteIdentity : System.Security.Principal.IIdentity" Usage="System.Net.Security.NegotiateStream.RemoteIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient des informations sur l’identité du tiers distant qui partage ce flux authentifié.</summary>
        <value>Un <see cref="T:System.Security.Principal.IIdentity" /> objet qui décrit l’identité du point de terminaison distant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors de l’accès par le client, cette propriété retourne un <xref:System.Security.Principal.GenericIdentity> contenant le nom Principal de Service (SPN) du serveur et le protocole d’authentification utilisé. Lors de l’accès par le serveur, cette propriété retourne un <xref:System.Security.Principal.WindowsIdentity> qui décrit le client. Si le <xref:System.Security.Principal.WindowsIdentity> est non disponible, les informations sur le client sont retournées au serveur dans un <xref:System.Security.Principal.GenericIdentity>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclNegoAsyncServer#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#2)]
 [!code-csharp[NclNegoAsyncServer#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L’authentification a échoué ou n’a pas eu lieu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="negotiateStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Cette valeur est ignorée.</param>
        <param name="origin">Cette valeur est ignorée.</param>
        <summary>Lève <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Lève toujours une exception <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 N'appelez pas cette méthode. Il est hérité, mais n’est pas pris en charge par <xref:System.Net.Security.NegotiateStream>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Recherche n’est pas pris en charge sur <see cref="T:System.Net.Security.NegotiateStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="negotiateStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Un <see cref="T:System.Int64" /> valeur qui spécifie la longueur du flux.</param>
        <summary>Définit la longueur du flux sous-jacent.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="negotiateStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Un <see cref="T:System.Byte" /> tableau qui fournit les octets écrits dans le flux.</param>
        <param name="offset"><see cref="T:System.Int32" /> contenant l’emplacement de base zéro dans <paramref name="buffer" /> à partir duquel commencer à lire les octets devant être écrits dans le flux de données.</param>
        <param name="count">Un <see cref="T:System.Int32" /> contenant le nombre d’octets à lire à partir de <paramref name="buffer" />.</param>
        <summary>Écrivez le nombre spécifié de <see cref="T:System.Byte" />s dans le flux sous-jacent à l’aide de la mémoire tampon spécifiée et le décalage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le chiffrement, la signature, ou le chiffrement et la signature sont activés, cette méthode lit les données à partir de la mémoire tampon, chiffre, se connecte, ou chiffre et signe et transmet à l’aide du flux sous-jacent. Si aucun service de sécurité telles que la signature ou le chiffrement de données sont en cours d’utilisation, cette méthode appelle <xref:System.IO.Stream.Write%2A> sur le flux sous-jacent.  
  
 Cette méthode se bloque pendant que l’opération d’écriture se termine. Pour éviter un blocage pendant l’opération est terminée, utilisez le <xref:System.Net.Security.NegotiateStream.Write%2A> (méthode).  
  
 Vous ne pouvez pas appeler cette méthode jusqu'à ce que vous avez été authentifié. Pour l’authentification, appelez une de la <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, ou <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> méthodes.  
  
 Le <xref:System.Net.Security.NegotiateStream> classe ne prend pas en charge plusieurs opérations d’écriture simultanées. Si vous essayez de démarrer une opération d’écriture lorsqu’une autre opération d’écriture est déjà exécutée sur le même flux, un <xref:System.NotSupportedException> exception sera levée.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’écriture dans un <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset is less than 0" />.  
  
ou 
 <paramref name="offset" /> est supérieur à la longueur de <paramref name="buffer" />.  
  
ou 
 <paramref name="offset" /> plus count est supérieur à la longueur de <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Échec de l’opération d’écriture.  
  
ou 
Le chiffrement est en cours d’utilisation, mais les données n’a pas pu être chiffrées.</exception>
        <exception cref="T:System.NotSupportedException">Il existe déjà une opération d’écriture en cours.</exception>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <exception cref="T:System.InvalidOperationException">L’authentification n’a pas eu lieu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Net.Security.NegotiateStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la durée pendant laquelle qu'une opération d’écriture reste bloquée en attendant des données.</summary>
        <value>Un <see cref="T:System.Int32" /> qui spécifie la quantité de temps qui doit s’écouler avant l’échec d’une opération d’écriture.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne la valeur retournée en appelant le <xref:System.IO.Stream.WriteTimeout%2A> propriété sur le flux sous-jacent. Pour les opérations de jeu, définit la valeur spécifiée la <xref:System.IO.Stream.WriteTimeout%2A> valeur sur le flux sous-jacent.  
  
 Si le flux sous-jacent est un <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.NegotiateStream.WriteTimeout%2A> est exprimée en millisecondes et a la valeur <xref:System.Threading.Timeout.Infinite> par défaut, de sorte que les opérations n’expirent pas d’écriture.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’affichage de la valeur de cette propriété.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>