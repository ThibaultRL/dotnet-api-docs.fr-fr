<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7667163fb0b63119d853e05a3a0f724427f256d2" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53300646" /></Metadata><TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une expression régulière immuable.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex> classe représente le moteur des expressions régulières du .NET Framework. Il peut être utilisé pour analyser rapidement de grandes quantités de texte pour rechercher des modèles de caractères spécifiques ; pour extraire, modifier, remplacer ou supprimer des sous-chaînes de texte ; et d’ajouter les chaînes extraites à une collection pour générer un rapport.  
  
> [!NOTE]
>  Si vous êtes principalement intéressé consiste à valider une chaîne en déterminant s’il est conforme à un modèle particulier, vous pouvez utiliser la <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> classe.  
  
 Pour utiliser des expressions régulières, vous définissez le modèle que vous souhaitez identifier dans un flux de texte à l’aide de la syntaxe documentée dans [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Ensuite, vous pouvez éventuellement instancier un <xref:System.Text.RegularExpressions.Regex> objet. Enfin, vous appelez une méthode qui effectue une opération, telles que le remplacement de texte qui correspond au modèle d’expression régulière, ou identifier une correspondance de modèle.  
  
> [!NOTE]
>  Pour certains modèles courants d’expressions régulières, consultez [exemples d’expressions régulières](~/docs/standard/base-types/regular-expression-examples.md). Il existe également un nombre de bibliothèques en ligne des modèles d’expressions régulières, tel que celui à [Regular-Expressions.info](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a> Pour plus d’informations sur l’utilisation de la <xref:System.Text.RegularExpressions.Regex> de classe, consultez les sections suivantes dans cette rubrique :  
  
-   [Vs d’expression régulière. Méthodes String](#regex_vs_string)  
  
-   [Vs statiques. Méthodes d’instance](#static_vs_instance)  
  
-   [Exécution d’opérations d’Expression régulière](#regex_ops)  
  
-   [Définition d’une valeur de délai d’attente](#define_timeout)  
  
 Pour plus d'informations sur le langage d'expression régulière, consultez [Langage des expressions régulières - Aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md) ou téléchargez et imprimez l'une des brochures suivantes :  
  
 [Aide-mémoire au format Word (.docx)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [Aide-mémoire au format PDF (.pdf)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Vs d’expression régulière. Méthodes String  
 Le <xref:System.String?displayProperty=nameWithType> classe inclut plusieurs méthodes de comparaison et de recherche que vous pouvez utiliser pour effectuer des critères spéciaux avec le texte. Par exemple, le <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, et <xref:System.String.StartsWith%2A?displayProperty=nameWithType> méthodes déterminent si une instance de chaîne contient une sous-chaîne spécifiée ; et le <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, et <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> méthodes retournent le démarrage position d’une sous-chaîne spécifiée dans une chaîne. Utilisez les méthodes de la <xref:System.String?displayProperty=nameWithType> classe lorsque vous recherchez une chaîne spécifique. Utilisez la <xref:System.Text.RegularExpressions.Regex> classe lorsque vous recherchez un modèle spécifique dans une chaîne. Pour plus d’informations et des exemples, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
 [Retour sur Notes](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Vs statiques. Méthodes d’instance  
 Après avoir défini un modèle d’expression régulière, vous pouvez la fournir au moteur d’expression régulière de deux manières :  
  
-   En instanciant un <xref:System.Text.RegularExpressions.Regex> objet qui représente l’expression régulière. Pour ce faire, vous transmettez le modèle d’expression régulière à un <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> constructeur. Un <xref:System.Text.RegularExpressions.Regex> objet est immuable ; lorsque vous instanciez un <xref:System.Text.RegularExpressions.Regex> de l’objet avec une expression régulière, que l’expression régulière de l’objet ne peut pas être modifiée.  
  
-   En fournissant l’expression régulière et le texte à rechercher dans un `static` (`Shared` en Visual Basic) <xref:System.Text.RegularExpressions.Regex> (méthode). Cela vous permet d’utiliser une expression régulière sans créer explicitement un <xref:System.Text.RegularExpressions.Regex> objet.  
  
 Tous les <xref:System.Text.RegularExpressions.Regex> méthodes du modèle d’identification incluent à la fois statique et instance surcharges.  
  
 Le moteur d’expression régulière doit compiler un modèle particulier avant de pouvoir utiliser le modèle. Étant donné que <xref:System.Text.RegularExpressions.Regex> objets sont immuables, il s’agit d’une procédure unique qui se produit lorsqu’un <xref:System.Text.RegularExpressions.Regex> constructeur de classe ou une méthode statique est appelée. Pour éliminer la nécessité de compiler à plusieurs reprises une expression régulière unique, le moteur d’expression régulière met en cache les expressions régulières compilées utilisées dans les appels de méthode statique. Par conséquent, les méthodes de correspondance d’expression régulière offrent des performances comparables pour statique et les méthodes d’instance.  
  
> [!IMPORTANT]
>  Dans les .NET Framework versions 1.0 et 1.1, tout compilé les expressions régulières, s’ils ont été utilisés dans l’instance ou une méthode statique appelle, ont été mis en cache. À compter de .NET Framework 2.0, seules les expressions régulières utilisées dans les appels de méthode statique sont mises en cache.  
  
 Toutefois, la mise en cache peut nuire aux performances dans les deux cas suivants :  
  
-   Lorsque vous utilisez des appels de méthode statique avec un grand nombre d’expressions régulières. Par défaut, le moteur d’expression régulière met en cache des fichiers récents expressions régulières statiques 15. Si votre application utilise plus de 15 expressions régulières statiques, certaines expressions régulières doivent être recompilées. Pour empêcher cette recompilation, vous pouvez augmenter la <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> propriété.  
  
-   Lorsque vous instanciez un nouveau <xref:System.Text.RegularExpressions.Regex> objets avec des expressions régulières compilées précédemment. Par exemple, le code suivant définit une expression régulière pour rechercher des mots en double dans un flux de texte. Bien que l’exemple utilise une expression régulière unique, il instancie un nouveau <xref:System.Text.RegularExpressions.Regex> objet à traiter chaque ligne de texte. Cela entraîne la recompilation de l’expression régulière avec chaque itération de la boucle.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Pour empêcher la recompilation, vous devez instancier un seul <xref:System.Text.RegularExpressions.Regex> objet qui est accessible à tout le code qui le requiert, comme indiqué dans l’exemple réécrit suivant.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [Retour sur Notes](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Exécution d’opérations d’Expression régulière  
 Si vous décidez d’instancier un <xref:System.Text.RegularExpressions.Regex> de l’objet et appeler ses méthodes ou appeler des méthodes statiques, le <xref:System.Text.RegularExpressions.Regex> classe offre les fonctionnalités de mise en correspondance de modèle suivantes :  
  
-   Validation d’une correspondance. Vous appelez le <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> méthode pour déterminer si une correspondance est présente.  
  
-   Récupération d’une correspondance unique. Vous appelez le <xref:System.Text.RegularExpressions.Regex.Match%2A> méthode pour récupérer un <xref:System.Text.RegularExpressions.Match> objet qui représente la première correspondance dans une chaîne ou en partie d’une chaîne. Les correspondances suivantes peuvent être récupérées en appelant le <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> (méthode).  
  
-   Récupération de toutes les correspondances. Vous appelez le <xref:System.Text.RegularExpressions.Regex.Matches%2A> méthode pour récupérer un <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> objet qui représente toutes les correspondances trouvées dans une chaîne ou en partie d’une chaîne.  
  
-   Remplacement de texte correspondant. Vous appelez le <xref:System.Text.RegularExpressions.Regex.Replace%2A> méthode pour remplacer le texte correspondant. Le texte de remplacement peut également être défini par une expression régulière. En outre, certaines de la <xref:System.Text.RegularExpressions.Regex.Replace%2A> méthodes incluent un <xref:System.Text.RegularExpressions.MatchEvaluator> paramètre qui vous permet de définir par programmation le texte de remplacement.  
  
-   Création d’un tableau de chaînes qui est formée à partir de parties d’une chaîne d’entrée. Vous appelez le <xref:System.Text.RegularExpressions.Regex.Split%2A> méthode pour fractionner une chaîne d’entrée aux positions définies par l’expression régulière.  
  
 En plus de ses méthodes de critères spéciaux, les <xref:System.Text.RegularExpressions.Regex> classe inclut plusieurs méthodes spéciales :  
  
-   Le <xref:System.Text.RegularExpressions.Regex.Escape%2A> méthode échappe tous les caractères qui peuvent être interprétés comme opérateurs d’expression régulière dans une expression régulière ou une chaîne d’entrée.  
  
-   Le <xref:System.Text.RegularExpressions.Regex.Unescape%2A> méthode supprime ces caractères d’échappement.  
  
-   Le <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> méthode crée un assembly qui contient des expressions régulières prédéfinies. Le .NET Framework contient des exemples de ces assemblys à usage spécial dans le <xref:System.Web.RegularExpressions?displayProperty=nameWithType> espace de noms.  
  
 [Retour sur Notes](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Définition d’une valeur de délai d’attente  
 Le .NET Framework prend en charge un langage complet d’expression régulière qui fournit la puissance substantielle et la flexibilité dans les critères spéciaux. Toutefois, la puissance et la flexibilité ont un coût : le risque de faibles performances. Les expressions régulières médiocres sont étonnamment faciles à créer. Dans certains cas, les opérations d’expression régulière qui reposent sur une rétroaction excessive peuvent apparaître à cesser de répondre quand ils traitent le texte correspondant presque au modèle d’expression régulière. Pour plus d’informations sur le moteur d’expression régulière de .NET Framework, consultez [détails comportement des expressions régulières](~/docs/standard/base-types/details-of-regular-expression-behavior.md). Pour plus d’informations sur la rétroaction excessive, consultez [rétroaction](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], vous pouvez définir un intervalle de délai d’attente pour les correspondances d’expression régulière. Si le moteur d’expression régulière ne peut pas identifier une correspondance au sein de cet intervalle de temps, l’opération de correspondance lève un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception. Dans la plupart des cas, cela empêche le moteur d’expression régulière ne consomme une puissance de traitement en essayant de faire correspondre le texte correspondant presque au modèle d’expression régulière. Elle également peut indiquer, toutefois, que l’intervalle de délai d’attente a été défini trop faible ou que la charge actuelle de la machine a entraîné une dégradation globale des performances.  
  
 Façon dont vous gérez l’exception dépend de la cause de l’exception. Si l’exception se produit parce que l’intervalle de délai d’attente a une valeur trop faible ou en raison de la charge de la machine excessive, vous pouvez augmenter l’intervalle de délai d’attente et recommencez l’opération de correspondance. Si l’exception se produit parce que l’expression régulière utilise la rétroaction excessive, vous pouvez supposer qu’une correspondance n’existe pas, et, si vous le souhaitez, vous pouvez enregistrer des informations qui vous permettent de modifier le modèle d’expression régulière.  
  
 Vous pouvez définir un intervalle de délai d’attente en appelant le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructeur lorsque vous instanciez un objet d’expression régulière. Pour les méthodes statiques, vous pouvez définir un intervalle de délai d’attente en appelant une surcharge d’une méthode correspondante qui a un `matchTimeout` paramètre. Si vous ne définissez pas explicitement une valeur de délai d’attente, la valeur de délai d’attente par défaut est déterminée comme suit :  
  
-   En utilisant le délai d’expiration de l’application la valeur, s’il existe. Cela peut être toute valeur de délai d’attente qui s’applique au domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est instancié ou l’appel de méthode statique est effectué. Vous pouvez définir la valeur de délai d’attente de l’application en appelant le <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> méthode pour attribuer la représentation sous forme de chaîne d’un <xref:System.TimeSpan> valeur à la propriété « REGEX_DEFAULT_MATCH_TIMEOUT ».  
  
-   À l’aide de la valeur <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, si aucune valeur de délai d’attente de l’application a été définie.  
  
> [!IMPORTANT]
>  Nous vous recommandons de définir une valeur de délai d’attente dans toutes les opérations de mise en correspondance de modèle d’expression régulière. Pour plus d’informations, consultez [meilleures pratiques pour les Expressions régulières](~/docs/standard/base-types/best-practices.md).  
  
 [Retour sur Notes](#remarks)  
  
   
  
## Examples  
 L’exemple suivant utilise une expression régulière pour rechercher les occurrences répétées de mots dans une chaîne. L'expression régulière `\b(?<word>\w+)\s+(\k<word>)\b` peut être interprétée comme indiqué dans le tableau suivant.  
  
|Motif|Description |  
|-------------|-----------------|  
|`\b`|Démarrer la correspondance à une limite de mot.|  
|`(?<word>\w+)`|Correspond à un ou plusieurs caractères alphabétiques jusqu'à une limite de mot. Nommer ce groupe capturé `word`.|  
|`\s+`|Correspond à un ou plusieurs caractères d’espace blanc.|  
|`(\k<word>)`|Correspond au groupe capturé nommé `word`.|  
|`\b`|Mettre en correspondance la limite d'un mot.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 L’exemple suivant illustre l’utilisation d’une expression régulière pour vérifier si une chaîne représente une valeur monétaire ou a le format correct pour représenter une valeur monétaire. Dans ce cas, l’expression régulière est construite dynamiquement à partir de la <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, et <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> propriétés pour la culture actuelle de l’utilisateur. Si le système actuel du culture est en-US, l’expression régulière qui en résulte est `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`. Cette expression régulière peut être interprétée comme indiqué dans le tableau suivant.  
  
|Motif|Description |  
|-------------|-----------------|  
|`^`|Commencer au début de la chaîne.|  
|`\s*`|Correspond à zéro, un ou plusieurs espaces blancs.|  
|`[\+-]?`|Correspond à zéro ou une occurrence du signe positif ou le signe négatif.|  
|`\s?`|Mettre en correspondance zéro ou un espace blanc.|  
|`\$?`|Correspond à zéro ou une occurrence du signe dollar.|  
|`\s?`|Mettre en correspondance zéro ou un espace blanc.|  
|`\d*`|Met en correspondance zéro ou plusieurs chiffres décimaux.|  
|`\.?`|Mettre en correspondance zéro ou un symbole de virgule décimale.|  
|`\d{2}?`|Correspond zéro ou une fois à deux chiffres décimaux.|  
|`(\d*\.?\d{2}?){1}`|Mettre en correspondance de chiffres intégraux et fractionnaires séparés par un symbole de virgule décimale au moins une fois.|  
|`$`|Correspond à la fin de la chaîne.|  
  
 Dans ce cas, l’expression régulière suppose qu’une chaîne monétaire valide ne contient pas de symboles de séparateur de groupe, et qu’il dispose d’aucun chiffre fractionnaire ou le nombre de chiffres fractionnaires défini par la culture actuelle <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> propriété.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 Étant donné que l’expression régulière dans cet exemple est construite dynamiquement, nous ne savons pas au moment du design si le symbole monétaire de la culture actuelle, le signe décimal ou signes positifs et négatifs peuvent être mal interprétées par le moteur d’expression régulière comme régulière opérateurs de langage d’expression. Pour empêcher toute mauvaise interprétation, l’exemple passe chaque chaîne générée dynamiquement à la <xref:System.Text.RegularExpressions.Regex.Escape%2A> (méthode).  
  
 ]]></format>
    </remarks>
    <threadsafe>Le <see cref="T:System.Text.RegularExpressions.Regex" /> classe est immuable (en lecture seule) et thread-safe. <see cref="T:System.Text.RegularExpressions.Regex" /> objets peuvent être créées sur n’importe quel thread et partagés par plusieurs threads. Pour plus d’informations, consultez [sécurité des threads](~/docs/standard/base-types/thread-safety-in-regular-expressions.md).</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
    <related type="Article" href="~/docs/standard/base-types/regular-expressions.md">Expressions régulières du .NET Framework</related>
    <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.docx">Expressions régulières - Aide-mémoire (téléchargement au format Word)</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.pdf">Expressions régulières - Aide-mémoire (téléchargement au format PDF)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que ce constructeur est protégé ; elle peut uniquement être appelée par les classes dérivées de la <xref:System.Text.RegularExpressions.Regex> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.RegularExpressions.Regex" /> pour l'expression régulière spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez le [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md) rubriques.  
  
 Appel de la <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> constructeur équivaut à appeler le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> constructeur avec une valeur de <xref:System.Text.RegularExpressions.RegexOptions.None> pour le `options` argument.  
  
 Un <xref:System.Text.RegularExpressions.Regex> objet est immuable, ce qui signifie qu’il peut être utilisé uniquement pour le modèle de correspondance que vous définissez lors de sa création. Toutefois, il peut être utilisée n’importe quel nombre de fois sans être recompilé.  
  
 Ce constructeur instancie un objet d’expression régulière qui tente une correspondance respectant la casse des caractères alphabétiques définis dans `pattern`. Pour une correspondance de non-respect de la casse, utilisez le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> constructeur.  
  
   
  
## Examples  
 L’exemple suivant illustre comment utiliser ce constructeur pour instancier une expression régulière qui correspond à n’importe quel mot qui commence par les lettres « a » ou « t ».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 Notez que le modèle d’expression régulière ne peut pas correspondre le mot « The » au début du texte, étant donné que les comparaisons respectent la casse par défaut. Pour obtenir un exemple de comparaison respectant la casse, consultez le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> a la valeur <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Ce constructeur crée un <see cref="T:System.Text.RegularExpressions.Regex" /> objet qui utilise la valeur de délai d’attente par défaut du domaine d’application dans lequel il est créé. Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, le <see cref="T:System.Text.RegularExpressions.Regex" /> objet utilise la valeur <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, ce qui empêche l’expiration du délai de l’opération. Le constructeur recommandé pour la création d’un <see cref="T:System.Text.RegularExpressions.Regex" /> objet est <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, qui vous permet de définir l’intervalle de délai d’attente.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Objet qui contient un modèle sérialisé et des informations <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</param>
        <param name="context">Destination de cette sérialisation. (Ce paramètre n'est pas utilisé ; spécifiez <see langword="null" />).</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.RegularExpressions.Regex" /> à l'aide de données sérialisées.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException">Le modèle contenu par <paramref name="info" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="info" /> contient un indicateur <see cref="T:System.Text.RegularExpressions.RegexOptions" /> non valide.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <param name="options">Combinaison de bits de valeurs d'énumération qui modifient l'expression régulière.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.RegularExpressions.Regex" /> pour l'expression régulière spécifiée, avec des options qui modifient le modèle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez le [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md) rubriques.  
  
 Un <xref:System.Text.RegularExpressions.Regex> objet est immuable, ce qui signifie qu’il peut être utilisé uniquement pour les paramètres de correspondance que vous définissez lors de sa création. Toutefois, il peut être utilisée n’importe quel nombre de fois sans être recompilé.  
  
   
  
## Examples  
 L’exemple suivant illustre comment utiliser ce constructeur pour instancier une expression régulière qui correspond à n’importe quel mot qui commence par les lettres « a » ou « t ».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Notez que la collection de correspondances inclut le mot « The » qui commence le texte, car le `options` paramètre a défini des comparaisons sans respecter la casse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> contient un indicateur non valide.</exception>
        <block subset="none" type="usage"><para>Ce constructeur crée un <see cref="T:System.Text.RegularExpressions.Regex" /> objet qui utilise la valeur de délai d’attente par défaut du domaine d’application dans lequel il est créé. Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, le <see cref="T:System.Text.RegularExpressions.Regex" /> objet utilise la valeur <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, ce qui empêche l’expiration du délai de l’opération. Le constructeur recommandé pour la création d’un <see cref="T:System.Text.RegularExpressions.Regex" /> objet est <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, qui vous permet de définir l’intervalle de délai d’attente.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <param name="options">Combinaison de bits de valeurs d'énumération qui modifient l'expression régulière.</param>
        <param name="matchTimeout">Intervalle de délai d’attente ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> pour indiquer que la méthode ne doit pas expirer.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.RegularExpressions.Regex" /> pour l'expression régulière spécifiée, avec les options qui modifient le modèle et une valeur qui spécifie la durée pendant laquelle une méthode de modèle doit tenter une correspondance avant son expiration.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez le [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md) rubriques.  
  
 Un <xref:System.Text.RegularExpressions.Regex> objet est immuable, ce qui signifie qu’il peut être utilisé uniquement pour le modèle de correspondance que vous définissez lors de sa création. Toutefois, il peut être utilisée n’importe quel nombre de fois sans être recompilé.  
  
 Le `matchTimeout` paramètre spécifie la durée pendant laquelle une correspondance méthode doit essayer de trouver une correspondance avant son expiration. Si aucune correspondance n’est trouvée dans cet intervalle de temps, la méthode de critères spéciaux lève un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception. `matchTimeout` remplace la valeur de délai d’attente par défaut défini pour le domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est créé. Les méthodes de critères spéciaux d’instance observent le `matchTimeout` délai d’attente sont les suivantes :  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 Définition d’un intervalle de délai d’attente empêche des expressions régulières qui s’appuient sur une rétroaction excessive d’apparaître à cesser de répondre lorsqu’elles traitent une entrée qui contient près de correspondances. Pour plus d’informations, consultez [meilleures pratiques pour les Expressions régulières](~/docs/standard/base-types/best-practices.md) et [rétroaction](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Pour définir un délai raisonnable, tenez compte des facteurs suivants :  
  
-   La longueur et la complexité du modèle d’expression régulière. Les expressions régulières plus longs et plus complexes nécessitent un temps de celles qui sont plus court et plus simple.  
  
-   La charge prévue de la machine. Traitement prend plus de temps sur les systèmes qui ont une utilisation élevée du processeur et de la mémoire.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructeur pour instancier un <xref:System.Text.RegularExpressions.Regex> objet avec une valeur de délai d’attente d’une seconde. Le modèle d'expression régulière `(a+)+$`, qui correspond à une ou plusieurs séquences d'un ou plusieurs caractères « a » à la fin d'une ligne, est soumis à une rétroaction excessive. Si un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> est levée, l’exemple augmente la valeur de délai d’attente jusqu'à la valeur maximale de trois secondes. Sinon, il abandonne la tentative de mettre en correspondance.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> n’est pas une valeur de <see cref="T:System.Text.RegularExpressions.RegexOptions" /> valide.  
  
ou 
 <paramref name="matchTimeout" /> a une valeur négative, nulle ou supérieure à environ 24 jours.</exception>
        <block subset="none" type="usage"><para>Nous vous recommandons de définir le <paramref name="matchTimeout" /> paramètre à une valeur appropriée, comme les deux secondes. Si vous désactivez des délais d’attente en spécifiant <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, le moteur d’expression régulière offre des performances légèrement meilleures. Toutefois, vous devez désactiver les délais d’attente uniquement dans les conditions suivantes : 
-Lorsque l’entrée traitée par une expression régulière est dérivée d’une source connue et approuvée ou se compose de texte statique. Cela exclut le texte qui a été dynamiquement par les utilisateurs.  
  
-Lorsque le modèle d’expression régulière a été testé pour s’assurer qu’elle gère efficacement corresponde au, non-correspondances et proche.  
  
-Lorsque le modèle d’expression régulière ne contient aucun élément de langage qui est connus pour provoquer une rétroaction excessive lors du traitement d’une correspondance proche.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Rétroaction</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre maximal d'entrées dans le cache statique actuel des expressions régulières compilées.</summary>
        <value>Nombre maximal d'entrées dans le cache statique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex> classe conserve un cache interne des expressions régulières compilées utilisées dans les appels de méthode statique. Si la valeur spécifiée dans une opération ensembliste est inférieure à la taille de cache actuelle, les entrées du cache sont ignorées jusqu'à ce que la taille du cache est égale à la valeur spécifiée.  
  
 Par défaut, le cache conserve 15 expressions régulières statiques compilées. Votre application sera ont généralement pas modifier la taille du cache. Utilisez le <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> propriété uniquement lorsque vous souhaitez désactiver la mise en cache ou lorsque vous avez un cache exceptionnellement élevé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur d’une opération ensembliste est inférieure à zéro.</exception>
        <block subset="none" type="usage"><para>Dans le .NET Framework antérieures à la [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], les expressions régulières utilisées dans les deux statiques et les appels de méthode d’instance ont été mis en cache. Compter les [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], uniquement regular expressions utilisées dans les appels de méthode statique sont mises en cache.</para></block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" />Utilisé par un objet généré par la méthode <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un dictionnaire qui mappe des groupes de capture nommés à leurs valeurs d’index.</summary>
        <value>Dictionnaire qui mappe des groupes de capture nommés à leurs valeurs d’index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que cette propriété est protégée ; Il est uniquement accessible à partir d’une classe dérivée de la <xref:System.Text.RegularExpressions.Regex> classe.  
  
 Une opération ensembliste essaie de convertir la valeur assignée à la propriété à un <xref:System.Collections.Hashtable> l’objet ; si cette conversion échoue, il appelle le <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur affectée à la propriété <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> dans une opération ensembliste est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" />Utilisé par un objet généré par la méthode <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un dictionnaire qui mappe des groupes de capture numérotés à leurs valeurs d’index.</summary>
        <value>Dictionnaire qui mappe des groupes de capture numérotés à leurs valeurs d’index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que cette propriété est protégée ; Il est uniquement accessible à partir d’une classe dérivée de la <xref:System.Text.RegularExpressions.Regex> classe.  
  
 Une opération ensembliste essaie de convertir la valeur assignée à la propriété à un <xref:System.Collections.Hashtable> l’objet ; si cette conversion échoue, il appelle le <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur affectée à la propriété <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> dans une opération ensembliste est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" />Utilisé par un objet généré par la méthode <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" />Utilisé par un objet généré par la méthode <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compile les expressions régulières et les enregistre sur le disque dans un assembly unique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Sur .NET Core, les appels à la `Regex.CompileToAssembly` méthode throw un <xref:System.PlatformNotSupportedException>; écriture d’un assembly n’est pas pris en charge.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Tableau qui décrit les expressions régulières à compiler.</param>
        <param name="assemblyname">Nom de fichier de l’assembly.</param>
        <summary>Compile un ou plusieurs objets <see cref="T:System.Text.RegularExpressions.Regex" /> spécifiés dans un assembly nommé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> méthode génère un assembly .NET Framework dans la chaque expression régulière définie dans le `regexinfos` tableau est représenté par une classe. En règle générale, le <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> méthode est appelée à partir d’une application distincte qui génère un assembly d’expressions régulières compilées. Chaque expression régulière incluse dans l’assembly a les caractéristiques suivantes :  
  
-   Il est dérivé le <xref:System.Text.RegularExpressions.Regex> classe.  
  
-   Il est attribué le nom qualifié complet qui est défini par le `fullnamespace` et `name` paramètres de son <xref:System.Text.RegularExpressions.RegexCompilationInfo> objet.  
  
-   Il a une valeur par défaut (ou sans paramètre) constructeur.  
  
 En règle générale, le code qui instancie et utilise l’expression régulière compilée se trouve dans un assembly ou une application qui est distincte du code qui crée l’assembly.  
  
   
  
## Examples  
 L’exemple suivant crée un assembly nommé RegexLib.dll. L’assembly inclut deux expressions régulières compilées. La première, `Utilities.RegularExpressions.DuplicatedString`, correspond à deux mots contigus identiques. La seconde, `Utilities.RegularExpressions.EmailAddress`, vérifie si une chaîne a le format correct pour être une adresse de messagerie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 L’expression régulière qui vérifie si une chaîne de mots en double est ensuite instanciée et utilisée par l’exemple suivant.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Compilation réussie de ce deuxième exemple requiert une référence à RegexLib.dll (l’assembly créé par le premier exemple) à ajouter au projet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur de la propriété <see cref="P:System.Reflection.AssemblyName.Name" /> du paramètre <paramref name="assemblyname" /> est une chaîne vide ou null.  
  
ou 
Le modèle d'expression régulière d'un ou plusieurs objets de <paramref name="regexinfos" /> contient une syntaxe non valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> ou <paramref name="regexinfos" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core uniquement : La création d’un assembly d’expressions régulières compilées n’est pas prise en charge.</exception>
        <block subset="none" type="usage"><para>Si vous développez sur un système qui a [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ou ses versions intermédiaires est installées, vous ciblez [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], et que vous utilisez le <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> méthode pour créer un assembly qui contient des expressions régulières compilées. Essayez d’utiliser une des expressions régulières dans la mesure où l’assembly sur un système qui a [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] lève une exception. Pour contourner ce problème, vous pouvez procéder de l'une des manières suivantes : 
-Générer l’assembly qui contient les expressions régulières compilées sur un système qui a [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] au lieu de la version ultérieure est installé.  
  
-Au lieu de l’appel <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> et récupération de l’expression régulière compilée à partir d’un assembly, utilisez soit statique ou d’instance <see cref="T:System.Text.RegularExpressions.Regex" /> méthodes avec la <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> option lorsque vous instanciez un <see cref="T:System.Text.RegularExpressions.Regex" /> de l’objet ou appeler une expression régulière méthode de correspondance de modèle.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Compilation et réutilisation</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Tableau qui décrit les expressions régulières à compiler.</param>
        <param name="assemblyname">Nom de fichier de l’assembly.</param>
        <param name="attributes">Tableau qui définit les attributs à appliquer à l'assembly.</param>
        <summary>Compile un ou plusieurs objets <see cref="T:System.Text.RegularExpressions.Regex" /> spécifiés dans un assembly nommé avec les attributs spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> méthode génère un assembly .NET Framework dans la chaque expression régulière définie dans le `regexinfos` tableau est représenté par une classe. En règle générale, le <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> méthode est appelée à partir d’une application distincte qui génère un assembly d’expressions régulières compilées. Chaque expression régulière incluse dans l’assembly a les caractéristiques suivantes :  
  
-   Il est dérivé le <xref:System.Text.RegularExpressions.Regex> classe.  
  
-   Il est attribué le nom qualifié complet qui est défini par le `fullnamespace` et `name` paramètres de son <xref:System.Text.RegularExpressions.RegexCompilationInfo> objet.  
  
-   Il a une valeur par défaut (ou sans paramètre) constructeur.  
  
 En règle générale, le code qui instancie et utilise l’expression régulière compilée se trouve dans un assembly ou une application qui est distincte du code qui crée l’assembly.  
  
 Étant donné que le <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> méthode génère un assembly .NET Framework à partir d’un appel de méthode au lieu d’utiliser le mot-clé de définition de classe d’un langage particulier (tel que `class` en c# ou `Class`...`End Class` en Visual Basic), il n’autorise pas les attributs .NET Framework à assigner à l’assembly en utilisant la syntaxe d’attribut standard du langage de développement. Le `attributes` paramètre fournit une autre méthode permettant de définir les attributs qui s’appliquent à l’assembly. Pour chaque attribut que vous souhaitez appliquer à l’assembly, procédez comme suit :  
  
1.  Créer un tableau de <xref:System.Type> objets représentant les types de paramètre du constructeur d’attribut que vous souhaitez appeler.  
  
2.  Récupérer un <xref:System.Type> objet représentant la classe d’attributs que vous souhaitez appliquer au nouvel assembly.  
  
3.  Appelez le <xref:System.Type.GetConstructor%2A> (méthode) de l’attribut <xref:System.Type> objet à récupérer un <xref:System.Reflection.ConstructorInfo> objet représentant le constructeur d’attribut que vous souhaitez appeler. Passer le <xref:System.Type.GetConstructor%2A> méthode du tableau de <xref:System.Type> objets qui représentent des types de paramètres du constructeur.  
  
4.  Créer un <xref:System.Object> tableau qui définit les paramètres à passer au constructeur de l’attribut.  
  
5.  Instancier un <xref:System.Reflection.Emit.CustomAttributeBuilder> objet en passant à son constructeur la <xref:System.Reflection.ConstructorInfo> objet récupéré à l’étape 3 et le <xref:System.Object> tableau créé à l’étape 4.  
  
 Vous pouvez ensuite passer un tableau de ces <xref:System.Reflection.Emit.CustomAttributeBuilder> objets au lieu du `attributes` paramètre à la <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant crée un assembly nommé RegexLib.dll et applique le <xref:System.Reflection.AssemblyTitleAttribute> attribut. L’assembly inclut deux expressions régulières compilées. La première, `Utilities.RegularExpressions.DuplicatedString`, correspond à deux mots contigus identiques. La seconde, `Utilities.RegularExpressions.EmailAddress`, vérifie si une chaîne a le format correct pour être une adresse de messagerie.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 Vous pouvez vérifier que le <xref:System.Reflection.AssemblyTitleAttribute> attribut a été appliqué à l’assembly en examinant son manifeste avec un utilitaire de réflexion comme ILDasm.  
  
 L’expression régulière qui vérifie si une chaîne de mots en double est ensuite instanciée et utilisée par l’exemple suivant.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Compilation réussie de ce deuxième exemple requiert une référence à RegexLib.dll (l’assembly créé par le premier exemple) à ajouter au projet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur de la propriété <see cref="P:System.Reflection.AssemblyName.Name" /> du paramètre <paramref name="assemblyname" /> est une chaîne vide ou null.  
  
ou 
Le modèle d'expression régulière d'un ou plusieurs objets de <paramref name="regexinfos" /> contient une syntaxe non valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> ou <paramref name="regexinfos" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core uniquement : La création d’un assembly d’expressions régulières compilées n’est pas prise en charge.</exception>
        <block subset="none" type="usage"><para>Si vous développez sur un système qui a [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ou ses versions intermédiaires est installées, vous ciblez [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], et que vous utilisez le <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> méthode pour créer un assembly qui contient des expressions régulières compilées. Essayez d’utiliser une des expressions régulières dans la mesure où l’assembly sur un système qui a [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] lève une exception. Pour contourner ce problème, vous pouvez procéder de l'une des manières suivantes : 
-Générer l’assembly qui contient les expressions régulières compilées sur un système qui a [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] au lieu de la version ultérieure est installé.  
  
-Au lieu de l’appel <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> et récupération de l’expression régulière compilée à partir d’un assembly, utilisez soit statique ou d’instance <see cref="T:System.Text.RegularExpressions.Regex" /> méthodes avec la <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> option lorsque vous instanciez un <see cref="T:System.Text.RegularExpressions.Regex" /> de l’objet ou appeler une expression régulière méthode de correspondance de modèle.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Compilation et réutilisation</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
        <Parameter Name="resourceFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Tableau qui décrit les expressions régulières à compiler.</param>
        <param name="assemblyname">Nom de fichier de l’assembly.</param>
        <param name="attributes">Tableau qui définit les attributs à appliquer à l'assembly.</param>
        <param name="resourceFile">Nom du fichier de ressources Win32 à inclure dans l'assembly.</param>
        <summary>Compile un ou plusieurs objets <see cref="T:System.Text.RegularExpressions.Regex" /> spécifiés et un fichier de ressources spécifié dans un assembly nommé avec les attributs spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName% 2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 > méthode génère un assembly .NET Framework dans la chaque expression régulière définie dans le `regexinfos` tableau est représenté par une classe. En règle générale, le [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D% 2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 > méthode est appelée à partir d’une application distincte qui génère un assembly d’expressions régulières compilées. Chaque expression régulière incluse dans l’assembly a les caractéristiques suivantes :  
  
-   Il est dérivé le <xref:System.Text.RegularExpressions.Regex> classe.  
  
-   Il est attribué le nom qualifié complet qui est défini par le `fullnamespace` et `name` paramètres de son <xref:System.Text.RegularExpressions.RegexCompilationInfo> objet.  
  
-   Il a une valeur par défaut (ou sans paramètre) constructeur.  
  
 En règle générale, le code qui instancie et utilise l’expression régulière compilée se trouve dans un assembly ou une application qui est distincte du code qui crée l’assembly.  
  
 Étant donné que le <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> méthode génère un assembly .NET Framework à partir d’un appel de méthode au lieu d’utiliser le mot-clé de définition de classe d’un langage particulier (tel que `class` en c# ou `Class`...`End Class` en Visual Basic), il n’autorise pas les attributs .NET Framework à assigner à l’assembly en utilisant la syntaxe d’attribut standard du langage de développement. Le `attributes` paramètre fournit une autre méthode permettant de définir les attributs qui s’appliquent à l’assembly. Pour chaque attribut que vous souhaitez appliquer à l’assembly, procédez comme suit :  
  
1.  Créer un tableau de <xref:System.Type> objets représentant les types de paramètre du constructeur d’attribut que vous souhaitez appeler.  
  
2.  Récupérer un <xref:System.Type> objet représentant la classe d’attributs que vous souhaitez appliquer au nouvel assembly.  
  
3.  Appelez le <xref:System.Type.GetConstructor%2A> (méthode) de l’attribut <xref:System.Type> objet à récupérer un <xref:System.Reflection.ConstructorInfo> objet représentant le constructeur d’attribut que vous souhaitez appeler. Passer le <xref:System.Type.GetConstructor%2A> méthode du tableau de <xref:System.Type> objets qui représentent des types de paramètres du constructeur  
  
4.  Créer un <xref:System.Object> tableau qui définit les paramètres à passer au constructeur de l’attribut.  
  
5.  Instancier un <xref:System.Reflection.Emit.CustomAttributeBuilder> objet en passant à son constructeur la <xref:System.Reflection.ConstructorInfo> objet récupéré à l’étape 3 et le <xref:System.Object> tableau créé à l’étape 4.  
  
 Vous pouvez ensuite passer un tableau de ces <xref:System.Reflection.Emit.CustomAttributeBuilder> objets au lieu du `attributes` paramètre à la [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly% 28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 > méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur de la propriété <see cref="P:System.Reflection.AssemblyName.Name" /> du paramètre <paramref name="assemblyname" /> est une chaîne vide ou null.  
  
ou 
Le modèle d'expression régulière d'un ou plusieurs objets de <paramref name="regexinfos" /> contient une syntaxe non valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> ou <paramref name="regexinfos" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Le paramètre <paramref name="resourceFile" /> désigne un fichier ressource Win32 non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier désigné par le paramètre <paramref name="resourceFile" /> est introuvable.</exception>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core uniquement : La création d’un assembly d’expressions régulières compilées n’est pas prise en charge.</exception>
        <block subset="none" type="usage"><para>Si vous développez sur un système qui a [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ou ses versions intermédiaires est installées, vous ciblez [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], et que vous utilisez le <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> méthode pour créer un assembly qui contient des expressions régulières compilées. Essayez d’utiliser une des expressions régulières dans la mesure où l’assembly sur un système qui a [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] lève une exception. Pour contourner ce problème, vous pouvez procéder de l'une des manières suivantes : 
-Générer l’assembly qui contient les expressions régulières compilées sur un système qui a [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] au lieu de la version ultérieure est installé.  
  
-Au lieu de l’appel <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> et récupération de l’expression régulière compilée à partir d’un assembly, utilisez soit statique ou d’instance <see cref="T:System.Text.RegularExpressions.Regex" /> méthodes avec la <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> option lorsque vous instanciez un <see cref="T:System.Text.RegularExpressions.Regex" /> de l’objet ou appeler une expression régulière méthode de correspondance de modèle.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Compilation et réutilisation</related>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Chaîne d'entrée qui contient le texte à convertir.</param>
        <summary>Échappe un ensemble minimal de caractères (\\, *, +, ?, |, {, [, (,), ^, $, ., # et espace blanc) en les remplaçant par leur code d’échappement. Cela indique au moteur d'expressions régulières qu'il doit interpréter ces caractères littéralement, et non comme des métacaractères.</summary>
        <returns>Chaîne de caractères dont les métacaractères sont remplacés par leurs codes d'échappement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> Convertit une chaîne afin que le moteur des expressions régulières interprète tous les métacaractères qu’elle peut contenir en tant que littéraux de caractère. Par exemple, considérez une expression régulière qui est conçue pour extraire des commentaires qui sont délimitées par des crochets ouvrants et fermants ([et]) à partir du texte. Dans l’exemple suivant, l’expression régulière « [(.*?)] » est interprétée comme une classe de caractères. Au lieu de la mise en correspondance commentaires incorporés dans le texte d’entrée, l’expression régulière correspond à chaque ouverture ou une parenthèse fermante, un période, un astérisque ou un point d’interrogation.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 Toutefois, si le crochet ouvrant est ignoré en le passant à la <xref:System.Text.RegularExpressions.Regex.Escape%2A> (méthode), l’expression régulière parvienne à faire correspondre les commentaires incorporés dans la chaîne d’entrée. L'exemple suivant illustre ce comportement.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 Dans une expression régulière qui est définie à l’aide de texte statique, les caractères qui doivent être interprété littéralement et non comme des métacaractères peuvent être évitées en le faisant précéder par un symbole de barre oblique inverse (\\) ainsi que par l’appelant le <xref:System.Text.RegularExpressions.Regex.Escape%2A> (méthode). Dans une expression régulière qui est définie dynamiquement à l’aide de caractères qui ne sont pas connus au moment du design, appelant le <xref:System.Text.RegularExpressions.Regex.Escape%2A> méthode est particulièrement importante de s’assurer que le moteur des expressions régulières interprète les caractères individuels en tant que littéraux plutôt que comme des métacaractères.  
  
> [!NOTE]
>  Si un modèle d’expression régulière inclut le signe dièse (#) ou des caractères d’espace blanc littéraux, ils doivent être échappés si le texte d’entrée est analysé avec la <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option est activée.  
  
 Alors que le <xref:System.Text.RegularExpressions.Regex.Escape%2A> méthode s’échappe du crochet gauche ([) et l’accolade ouvrante ({}), il n’échappe pas leurs caractères de fermeture correspondants (] et}). Dans la plupart des cas, l’échappement n’est pas nécessaire. Si un crochet fermant ou une accolade n’est pas précédée par son caractère ouvrant correspondant, le moteur des expressions régulières l’interprète littéralement. Si une accolade ou un crochet ouvrant est interprétée comme un caractère de remplacement, le moteur des expressions régulières interprète le premier caractère comme un caractère de remplacement de fermeture du correspondante. Si ce n’est pas le comportement souhaité, le crochet fermant ou une accolade doit être échappée en ajoutant explicitement la barre oblique inverse (\\) caractères. Pour obtenir une illustration, consultez la section exemple.  
  
   
  
## Examples  
 L’exemple suivant extrait le texte des commentaires. Il suppose que les commentaires sont délimités par un symbole de commentaire begin et un symbole de commentaire de fin est sélectionné par l’utilisateur. Les symboles de commentaire doit être interprété littéralement, ils sont passés à la <xref:System.Text.RegularExpressions.Regex.Escape%2A> méthode pour vous assurer qu’ils ne peuvent pas être interprété à tort comme des métacaractères. En outre, l’exemple vérifie explicitement si le symbole de fin de commentaire entré par l’utilisateur est un crochet fermant (]) ou une accolade (}). Le cas, une barre oblique inverse (\\) est ajouté devant l’accolade ou afin qu’il est interprété littéralement. Notez que l’exemple utilise également le <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> collection pour afficher le commentaire uniquement, plutôt que le commentaire et ses symboles ouvrantes et fermantes.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f49cc9cc-db7d-4058-8b8a-422bc08b29b0">Caractères d'échappement dans les expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" />Utilisé par un objet généré par la méthode <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ce membre substitue <see cref="M:System.Object.Finalize" />. Une documentation plus complète est peut-être disponible dans cette rubrique.

Autorise <see cref="T:System.Object" /> à tenter de libérer des ressources et d'exécuter d'autres opérations de nettoyage avant que <see cref="T:System.Object" /> soit récupéré par l'opération garbage collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un tableau de noms de groupes de captures pour l'expression régulière.</summary>
        <returns>Tableau de chaînes des noms de groupes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La collection de noms de groupe contient l’ensemble des chaînes utilisées pour nommer les groupes de capture dans l’expression. Même si les groupes de capture ne sont pas nommées explicitement, ils sont automatiquement affectés des noms numériques (« 0 », « 1 », « 2 », « 3 » et ainsi de suite). Le « 0 » nommés groupe représente tout le texte mis en correspondance par le modèle d’expression régulière. Les groupes numérotés précèdent les groupes explicitement nommés dans la collection, et les groupes nommés apparaissent dans l’ordre dans lequel ils sont définis dans le modèle d’expression régulière.  
  
 Vous pouvez utiliser le <xref:System.Array.Length%2A> propriété sur le tableau retourné par cette méthode pour déterminer le nombre de groupes dans une expression régulière.  
  
   
  
## Examples  
 L’exemple suivant définit un à usage général `ShowMatches` méthode qui affiche les noms des groupes de l’expression régulière et leur texte correspondant.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 Dans ce cas, le modèle d’expression régulière `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` est destinée à analyser une phrase simple et pour identifier son premier mot, dernier mot et marque de fin de ponctuation. Le tableau suivant montre comment le modèle d’expression régulière est interprété :  
  
|Motif|Description |  
|-------------|-----------------|  
|`\b`|Commencer la correspondance à la limite d'un mot.|  
|`(?<FirstWord>\w+)`|Mettre en correspondance un ou plusieurs caractères alphabétiques. Il s’agit du `FirstWord` groupe nommé.|  
|\s ?|Mettre en correspondance zéro ou des espaces blancs.|  
|(\w+)|Mettre en correspondance un ou plusieurs caractères alphabétiques. Il s'agit du deuxième groupe de capture.|  
|\s|Mettre en correspondance un espace blanc.|  
|((\w+)\s)*|Correspond à zéro ou plusieurs occurrences d’un ou plusieurs caractères alphabétiques suivis d’un espace blanc. Il s'agit du premier groupe de capture.|  
|(? \<LastWord > \w+) ?|Correspond à zéro ou une occurrence d’un ou plusieurs caractères alphabétiques. Il s’agit du `LastWord` groupe nommé.|  
|(? \<Ponctuation > \p{Po})|Mettre en correspondance un caractère dont la catégorie Unicode est Punctuation, autres. Il s’agit du `Punctuation` groupe nommé.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Constructions de regroupement dans les expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un tableau des numéros de groupes de captures qui correspondent aux noms de groupes d'un tableau.</summary>
        <returns>Tableau d'entiers de numéros de groupes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les groupes de capture nommés et sans nommés sont accessibles par un nombre. Groupes sans nom sont numérotés de gauche à droite en commençant par 1. (Le groupe de capture dans l’index 0 (zéro) représente la correspondance dans sa globalité).  Les groupes nommés sont ensuite numérotés de gauche à droite en commençant avec un nombre qui est supérieur au nombre de sans nom des groupes de capture.  
  
 Faisant référence à un groupe par son numéro et non par nom de chaîne peut fournir un accès plus rapide.  
  
   
  
## Examples  
 L’exemple suivant définit une expression régulière, `\b((?<word>\w+)\s*)+(?<end>[.?!])`, qui correspond à une phrase. L’expression régulière comprend trois groupes de capture : un groupe sans nom qui capture un mot individuel, ainsi que d’un caractère d’espace qui peut-être suivre ; un groupe nommé `word` qui capture les mots individuels dans la phrase ; et un groupe nommé `end` qui capture les signes de ponctuation qui se termine la phrase. L’exemple appelle la <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> méthode pour obtenir les numéros de capture de tous les groupes et affiche ensuite leur chaîne capturée. En outre, le <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> méthode est utilisée pour indiquer si un groupe numéroté spécifique correspond à un groupe nommé.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 Le modèle d'expression régulière est interprété comme indiqué dans le tableau suivant.  
  
|Motif|Description |  
|-------------|-----------------|  
|`\b`|Commencer la correspondance à la limite d'un mot.|  
|`(?<word>\w+)`|Correspond à un ou plusieurs caractères alphabétiques et affecter les chaînes de mise en correspondance à un groupe nommé `word`.|  
|`\s*`|Correspond à zéro, un ou plusieurs espaces blancs.|  
|`((?<word>\w+)\s*)`|Affecter le `word` groupe capturé, suivi par aucun capturées espaces pour le premier groupe capturé.|  
|`((?<word>\w+)\s*)+`|Mettre en correspondance d’un ou plusieurs caractères alphabétiques suivis par les caractères d’espace blanc une ou plusieurs fois.|  
|`(?<end>[.?!])`|Mettre en correspondance un point, un point d'interrogation ou un point d'exclamation. Affectez le caractère correspondant à la `end` groupe de capture.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Constructions de regroupement dans les expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Numéro de groupe à convertir en nom de groupe correspondant.</param>
        <summary>Obtient le nom de groupe qui correspond au numéro de groupe spécifié.</summary>
        <returns>Chaîne qui contient le nom de groupe associé au numéro de groupe spécifié. Si aucun nom de groupe ne correspond à <paramref name="i" />, la méthode retourne <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un modèle d’expression régulière peut contenir nommés ou numérotés groupes de capture, qui délimitent les sous-expressions dans une correspondance de modèle. Les groupes numérotés sont délimités par la syntaxe (*sous-expression*) et numérotés selon leur ordre dans l’expression régulière. Les groupes nommés sont délimités par la syntaxe ( ?`<` *nom*`>`*sous-expression*) ou ( ? » *nom*'*sous-expression*), où *nom* est le nom par lequel la sous-expression. (Pour plus d'informations, consultez [Constructions de regroupement](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) La <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> méthode identifie les groupes nommés et les groupes numérotés par leur position ordinale dans l’expression régulière. Position ordinale zéro représente toujours l’expression régulière entière. Numérotée tous les groupes sont ensuite comptés avant les groupes nommés, quelle que soit leur position réelle dans le modèle d’expression régulière.  
  
 Si `i` est le nombre d’un groupe nommé, la méthode retourne le nom du groupe. Si `i` est le nombre d’un groupe sans nom, la méthode retourne la représentation sous forme de chaîne du nombre. Par exemple, si `i` est 1, la méthode retourne « 1 ». Si `i` n’est pas le nombre d’un groupe de capture, la méthode retourne <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Si une correspondance est trouvée, la valeur retournée par cette méthode peut ensuite être utilisée pour récupérer le <xref:System.Text.RegularExpressions.Group> objet qui représente le groupe capturé à partir de la <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> propriété. Le <xref:System.Text.RegularExpressions.GroupCollection> est retourné par la <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> propriété.  
  
   
  
## Examples  
 L’exemple suivant définit un modèle d’expression régulière qui correspond à une ligne d’adresse contenant un nom de ville des États-Unis, le nom de l’état et le code postal. L’exemple utilise le <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> méthode pour récupérer les noms de groupes de capture. Il utilise ensuite ces noms pour récupérer les groupes capturés correspondants pour les correspondances.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 Le modèle d’expression régulière est défini par l’expression suivante :  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 Le tableau suivant montre comment le modèle d'expression régulière est interprété.  
  
|Motif|Description |  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Correspond à un ou plusieurs caractères alphabétiques ou un espace blanc. Affecter à ce groupe capturé le nom `city`.|  
|`,`|Correspond à une virgule (,) suivie d’un caractère d’espace blanc.|  
|`(?<state>[A-Za-z]{2})`|Correspond à deux caractères alphabétiques. Affecter à ce groupe capturé le nom `state`. Ce groupe doit être suivi d’un caractère d’espace blanc.|  
|`(?<zip>\d{5}(-\d{4})?)`|Correspond à cinq chiffres suivies de zéro ou une occurrence d’un trait d’union suivie de quatre chiffres. Affecter à ce groupe capturé le nom `zip`.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Constructions de regroupement</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de groupe à convertir en numéro de groupe correspondant.</param>
        <summary>Retourne le numéro de groupe qui correspond au nom de groupe spécifié.</summary>
        <returns>Numéro de groupe correspondant au nom de groupe spécifié, ou -1 si <paramref name="name" /> n'est pas un nom de groupe valide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un modèle d’expression régulière peut contenir nommés ou numérotés groupes de capture, qui délimitent les sous-expressions dans une correspondance de modèle. Les groupes numérotés sont délimités par la syntaxe (*sous-expression*) et numérotés selon leur ordre dans l’expression régulière. Les groupes nommés sont délimités par la syntaxe ( ?`<` *nom*`>`*sous-expression*) ou ( ? » *nom*'*sous-expression*), où *nom* est le nom par lequel la sous-expression. (Pour plus d'informations, consultez [Constructions de regroupement](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) La <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> méthode identifie les groupes nommés et les groupes numérotés par leur position ordinale dans l’expression régulière. Position ordinale zéro représente toujours l’expression régulière entière. Numérotée tous les groupes sont ensuite comptés avant les groupes nommés, quelle que soit leur position réelle dans le modèle d’expression régulière.  
  
 Si `name` est la représentation sous forme de chaîne d’un numéro de groupe qui est présent dans le modèle d’expression régulière, la méthode retourne ce nombre. Si `name` correspond à un élément nommé groupe qui n’est présent dans le modèle d’expression régulière de capture, la méthode retourne le numéro correspondant. La comparaison de `name` avec le groupe nom respecte la casse. Si `name` ne correspond pas au nom d’un groupe de capture ou à la représentation sous forme de chaîne du nombre d’un groupe de capture, la méthode retourne -1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Constructions de regroupement</related>
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie qu’une opération de critères spéciaux ne doit pas expirer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> classe constructeur et un numéro d’utilisation de méthodes de correspondance statique le <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> constante afin d’indiquer que la tentative de trouver une correspondance de modèle ne doit pas expirer.  
  
> [!WARNING]
>  Affectation de valeur de délai d’attente du moteur d’expression régulière <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> peut provoquer des expressions régulières qui s’appuient sur une rétroaction excessive pour ne plus répondre lors du traitement de texte correspondant presque au modèle d’expression régulière. Si vous désactivez des délais d’expiration, vous devez vous assurer que votre expression régulière ne repose pas sur une rétroaction excessive et qu’il gère le texte correspondant presque au modèle d’expression régulière.  
>   
>  Pour plus d’informations sur la gestion de la rétroaction, consultez [rétroaction](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Le <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> constante peut être fournie comme valeur de la `matchTimeout` argument des membres suivants :  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" />Utilisé par un objet généré par la méthode <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Les références ont déjà été initialisées.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Durée maximale pouvant s’écouler lors d’une opération de correspondance de modèle avant que l’opération expire.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indique si l'expression régulière trouve une correspondance dans la chaîne d'entrée.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <summary>Indique si l'expression régulière spécifiée dans le constructeur <see cref="T:System.Text.RegularExpressions.Regex" /> cherche une correspondance dans une chaîne d'entrée spécifique.</summary>
        <returns><see langword="true" /> si l'expression régulière trouve une correspondance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> méthode est généralement utilisée pour valider une chaîne ou pour vous assurer qu’une chaîne est conforme à un modèle particulier sans récupérer cette chaîne pour une manipulation ultérieure. Si vous souhaitez déterminer si une ou plusieurs chaînes correspondent à un modèle d’expression régulière et ensuite de les récupérer pour une manipulation ultérieure, appel le <xref:System.Text.RegularExpressions.Regex.Match%2A> ou <xref:System.Text.RegularExpressions.Regex.Matches%2A> (méthode).  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié par le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructeur. Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est créé. Si aucun délai d’attente n’est défini dans le <xref:System.Text.RegularExpressions.Regex> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> méthode pour déterminer si une chaîne est un numéro de référence valide. L’expression régulière suppose que le numéro de référence a un format spécifique qui se compose de trois jeux de caractères séparés par des traits d’union. Le premier jeu qui contient quatre caractères, doit se composer d’un caractère alphanumérique suivi de deux caractères numériques suivies d’un caractère alphanumérique. Le deuxième jeu, qui se compose de trois caractères, doit être numérique. Le troisième ensemble, ce qui se compose de quatre caractères, doit avoir trois caractères numériques suivis d’un caractère alphanumérique.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 Le modèle d'expression régulière est le suivant :  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 Le tableau suivant montre comment le modèle d'expression régulière est interprété.  
  
|Motif|Description |  
|-------------|-----------------|  
|`^`|Commencer la correspondance au début de la ligne.|  
|`[a-zA-Z0-9]`|Mettre en correspondance un caractère alphabétique unique (`a` via `z` ou `A` via `Z`) ou caractère numérique.|  
|`\d{2}`|Correspond à deux caractères numériques.|  
|`[a-zA-Z0-9]`|Mettre en correspondance un caractère alphabétique unique (`a` via `z` ou `A` via `Z`) ou caractère numérique.|  
|`-`|Mettre en correspondance un trait d'union.|  
|`\d{3}`|Correspond à exactement trois caractères numériques.|  
|`(-\d{3}){2}`|Rechercher un trait d’union suivie de trois caractères numériques et mettre en correspondance deux occurrences de ce modèle.|  
|`[a-zA-Z0-9]`|Mettre en correspondance un caractère alphabétique unique (`a` via `z` ou `A` via `Z`) ou caractère numérique.|  
|`$`|Terminer la correspondance à la fin de la ligne.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="startat">Position du caractère où la recherche doit commencer.</param>
        <summary>Indique si l'expression régulière spécifiée dans le constructeur <see cref="T:System.Text.RegularExpressions.Regex" /> cherche une correspondance dans la chaîne d'entrée spécifiée, en commençant à la position de départ définie dans la chaîne.</summary>
        <returns><see langword="true" /> si l'expression régulière trouve une correspondance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> méthode est généralement utilisée pour valider une chaîne ou pour vous assurer qu’une chaîne est conforme à un modèle particulier sans récupérer cette chaîne pour une manipulation ultérieure. Si vous souhaitez déterminer si une ou plusieurs chaînes correspondent à un modèle d’expression régulière et ensuite de les récupérer pour une manipulation ultérieure, appel le <xref:System.Text.RegularExpressions.Regex.Match%2A> ou <xref:System.Text.RegularExpressions.Regex.Matches%2A> (méthode).  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié par le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructeur. Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est créé. Si aucun délai d’attente n’est défini dans le <xref:System.Text.RegularExpressions.Regex> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> méthode pour déterminer si une chaîne est un numéro de référence valide. Il recherche un numéro de référence qui suit un signe deux-points ( :)) dans une chaîne. Le <xref:System.String.IndexOf%28System.Char%29> méthode est utilisée pour déterminer la position du caractère deux-points, qui est ensuite transmise à la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> (méthode). L’expression régulière suppose que le numéro de référence a un format spécifique qui se compose de trois jeux de caractères séparés par des traits d’union. Le premier jeu qui contient quatre caractères, doit se composer d’un caractère alphanumérique suivi de deux caractères numériques suivies d’un caractère alphanumérique. Le deuxième jeu, qui se compose de trois caractères, doit être numérique. Le troisième ensemble, ce qui se compose de quatre caractères, doit avoir trois caractères numériques suivis d’un caractère alphanumérique.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 Le modèle d'expression régulière est le suivant :  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 Le tableau suivant montre comment le modèle d'expression régulière est interprété.  
  
|Motif|Description |  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Mettre en correspondance un caractère alphabétique unique (`a` via `z` ou `A` via `Z`) ou caractère numérique.|  
|`\d{2}`|Correspond à deux caractères numériques.|  
|`[a-zA-Z0-9]`|Mettre en correspondance un caractère alphabétique unique (`a` via `z` ou `A` via `Z`) ou caractère numérique.|  
|`-`|Mettre en correspondance un trait d'union.|  
|`\d{3}`|Correspond à exactement trois caractères numériques.|  
|`(-\d{3}){2}`|Rechercher un trait d’union suivie de trois caractères numériques et mettre en correspondance deux occurrences de ce modèle.|  
|`[a-zA-Z0-9]`|Mettre en correspondance un caractère alphabétique unique (`a` via `z` ou `A` via `Z`) ou caractère numérique.|  
|`$`|Terminer la correspondance à la fin de la ligne.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> est inférieur à zéro ou supérieur à la longueur de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <summary>Indique si l'expression régulière spécifiée cherche une correspondance dans la chaîne d'entrée spécifiée.</summary>
        <returns><see langword="true" /> si l'expression régulière trouve une correspondance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> méthode est généralement utilisée pour valider une chaîne ou pour vous assurer qu’une chaîne est conforme à un modèle particulier sans récupérer cette chaîne pour une manipulation ultérieure. Si vous souhaitez déterminer si une ou plusieurs chaînes correspondent à un modèle d’expression régulière et ensuite de les récupérer pour une manipulation ultérieure, appel le <xref:System.Text.RegularExpressions.Regex.Match%2A> ou <xref:System.Text.RegularExpressions.Regex.Matches%2A> (méthode).  
  
 Statiques <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> méthode équivaut à construire un <xref:System.Text.RegularExpressions.Regex> objet avec le modèle d’expression régulière spécifié par `pattern` et en appelant le <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> méthode d’instance. Ce modèle d’expression régulière est mis en cache pour la récupération rapide par le moteur d’expression régulière.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée. Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> méthode pour déterminer si une chaîne est un numéro de référence valide. L’expression régulière suppose que le numéro de référence a un format spécifique qui se compose de trois jeux de caractères séparés par des traits d’union. Le premier jeu qui contient quatre caractères, doit se composer d’un caractère alphanumérique suivi de deux caractères numériques suivies d’un caractère alphanumérique. Le deuxième jeu, qui se compose de trois caractères, doit être numérique. Le troisième ensemble, ce qui se compose de quatre caractères, doit avoir trois caractères numériques suivis d’un caractère alphanumérique.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 Le modèle d'expression régulière est le suivant :  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 Le tableau suivant montre comment le modèle d'expression régulière est interprété.  
  
|Motif|Description |  
|-------------|-----------------|  
|`^`|Commencer la correspondance au début de la ligne.|  
|`[a-zA-Z0-9]`|Mettre en correspondance un caractère alphabétique unique (`a` via `z` ou `A` via `Z`) ou caractère numérique.|  
|`\d{2}`|Correspond à deux caractères numériques.|  
|`[a-zA-Z0-9]`|Mettre en correspondance un caractère alphabétique unique (`a` via `z` ou `A` via `Z`) ou caractère numérique.|  
|`-`|Mettre en correspondance un trait d'union.|  
|`\d{3}`|Correspond à exactement trois caractères numériques.|  
|`(-\d{3}){2}`|Rechercher un trait d’union suivie de trois caractères numériques et mettre en correspondance deux occurrences de ce modèle.|  
|`[a-zA-Z0-9]`|Mettre en correspondance un caractère alphabétique unique (`a` via `z` ou `A` via `Z`) ou caractère numérique.|  
|`$`|Terminer la correspondance à la fin de la ligne.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="pattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <block subset="none" type="usage"><para>Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans lequel la méthode est appelée. Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, ce qui empêche la méthode de délai d’expiration, est utilisé. La méthode statique recommandée pour la vérification d’une correspondance de modèle est <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, qui vous permet de définir l’intervalle de délai d’attente.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="pattern">Modèle d'expression régulière à mettre en correspondance.</param>
        <param name="options">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</param>
        <summary>Indique si l'expression régulière spécifiée cherche une correspondance dans la chaîne d'entrée spécifiée, en utilisant les options de correspondance spécifiées.</summary>
        <returns><see langword="true" /> si l'expression régulière trouve une correspondance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> méthode est généralement utilisée pour valider une chaîne ou pour vous assurer qu’une chaîne est conforme à un modèle particulier sans récupérer cette chaîne pour une manipulation ultérieure. Si vous souhaitez déterminer si une ou plusieurs chaînes correspondent à un modèle d’expression régulière et ensuite de les récupérer pour une manipulation ultérieure, appel le <xref:System.Text.RegularExpressions.Regex.Match%2A> ou <xref:System.Text.RegularExpressions.Regex.Matches%2A> (méthode).  
  
 Statiques <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> méthode équivaut à construire un <xref:System.Text.RegularExpressions.Regex> objet avec le modèle d’expression régulière spécifié par `pattern` et les options d’expression régulière spécifiées par `options` et en appelant le <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> instance méthode. Ce modèle d’expression régulière est mis en cache pour la récupération rapide par le moteur d’expression régulière.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée. Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> méthode pour déterminer si une chaîne est un numéro de référence valide. L’expression régulière suppose que le numéro de référence a un format spécifique qui se compose de trois jeux de caractères séparés par des traits d’union. Le premier jeu qui contient quatre caractères, doit se composer d’un caractère alphanumérique suivi de deux caractères numériques suivies d’un caractère alphanumérique. Le deuxième jeu, qui se compose de trois caractères, doit être numérique. Le troisième ensemble, ce qui se compose de quatre caractères, doit avoir trois caractères numériques suivis d’un caractère alphanumérique.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 Le modèle d'expression régulière est le suivant :  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 Le tableau suivant montre comment le modèle d'expression régulière est interprété.  
  
|Motif|Description |  
|-------------|-----------------|  
|`^`|Commencer la correspondance au début de la chaîne.|  
|`[A-Z0-9]`|Correspond à n’importe quel caractère alphabétique unique de `A` via `Z`, ou n’importe quel caractère numérique.|  
|`\d{2}`|Correspond à deux caractères numériques.|  
|`[A-Z0-9]`|Correspond à n’importe quel caractère alphabétique unique de `A` via `Z`, ou n’importe quel caractère numérique.|  
|`-`|Mettre en correspondance un trait d'union.|  
|`\d{3}`|Correspond à exactement trois caractères numériques.|  
|`(-\d{3}){2}`|Rechercher un trait d’union suivie de trois caractères numériques et mettre en correspondance deux occurrences de ce modèle...|  
|`[A-Z0-9]`|Correspond à n’importe quel caractère alphabétique unique de `A` via `Z`, ou n’importe quel caractère numérique.|  
|`$`|Termine la correspondance à la fin de la chaîne.|  
  
 Appel de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> méthode avec le `options` paramètre la valeur <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> est équivalente à la définition de l’expression régulière suivante :  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Pour la comparaison, consultez l’exemple de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="pattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> n’est pas une valeur de <see cref="T:System.Text.RegularExpressions.RegexOptions" /> valide.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <block subset="none" type="usage"><para>Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans lequel elle est appelée. Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, ce qui empêche la méthode de délai d’expiration, est utilisé. La méthode statique recommandée pour la vérification d’une correspondance de modèle est <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, qui vous permet de définir l’intervalle de délai d’attente.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="pattern">Modèle d'expression régulière à mettre en correspondance.</param>
        <param name="options">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</param>
        <param name="matchTimeout">Intervalle de délai d’attente ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> pour indiquer que la méthode ne doit pas expirer.</param>
        <summary>Indique si l'expression régulière spécifiée trouve une correspondance dans la chaîne d'entrée spécifiée, en utilisant les options de correspondance et un intervalle de délai d'attente spécifiés.</summary>
        <returns><see langword="true" /> si l'expression régulière trouve une correspondance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> méthode est généralement utilisée pour valider une chaîne ou pour vous assurer qu’une chaîne est conforme à un modèle particulier sans récupérer cette chaîne pour une manipulation ultérieure. Si vous souhaitez déterminer si une ou plusieurs chaînes correspondent à un modèle d’expression régulière et ensuite de les récupérer pour une manipulation ultérieure, appel le <xref:System.Text.RegularExpressions.Regex.Match%2A> ou <xref:System.Text.RegularExpressions.Regex.Matches%2A> (méthode).  
  
 Statiques <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> méthode équivaut à construire un <xref:System.Text.RegularExpressions.Regex> objet avec le modèle d’expression régulière spécifié par `pattern` et les options d’expression régulière spécifiées par `options` et en appelant le <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> instance méthode. Ce modèle d’expression régulière est mis en cache pour la récupération rapide par le moteur d’expression régulière.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Le `matchTimeout` paramètre spécifie la manière dont la durée pendant laquelle un modèle de correspondance méthode doit essayer de trouver une correspondance avant son expiration. Définition d’un intervalle de délai d’attente empêche des expressions régulières qui s’appuient sur une rétroaction excessive d’apparaître à cesser de répondre lorsqu’elles traitent une entrée qui contient près de correspondances. Pour plus d’informations, consultez [meilleures pratiques pour les Expressions régulières](~/docs/standard/base-types/best-practices.md) et [rétroaction](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Si aucune correspondance n’est trouvée dans cet intervalle de temps, la méthode lève un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception. `matchTimeout` remplace toute valeur de délai d’attente par défaut défini pour le domaine d’application dans laquelle la méthode s’exécute.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> méthode pour déterminer si une chaîne est un numéro de référence valide. L’expression régulière suppose que le numéro de référence a un format spécifique qui se compose de trois jeux de caractères séparés par des traits d’union. Le premier jeu qui contient quatre caractères, doit se composer d’un caractère alphanumérique suivi de deux caractères numériques suivies d’un caractère alphanumérique. Le deuxième jeu, qui se compose de trois caractères, doit être numérique. Le troisième ensemble, ce qui se compose de quatre caractères, doit avoir trois caractères numériques suivis d’un caractère alphanumérique. Mise en correspondance le modèle d’expression régulière doit impliquer minimal effectuer une recherche dans la chaîne d’entrée, donc la méthode définit un intervalle de délai d’attente de 500 millisecondes.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 Le modèle d'expression régulière est le suivant :  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 Le tableau suivant montre comment le modèle d'expression régulière est interprété.  
  
|Motif|Description |  
|-------------|-----------------|  
|`^`|Commencer la correspondance au début de la chaîne.|  
|`[A-Z0-9]`|Correspond à n’importe quel caractère alphabétique unique de `A` via `Z`, ou n’importe quel caractère numérique.|  
|`\d{2}`|Correspond à deux caractères numériques.|  
|`[A-Z0-9]`|Correspond à n’importe quel caractère alphabétique unique de `A` via `Z`, ou n’importe quel caractère numérique.|  
|`-`|Mettre en correspondance un trait d'union.|  
|`\d{3}`|Correspond à exactement trois caractères numériques.|  
|`(-\d{3}){2}`|Rechercher un trait d’union suivie de trois caractères numériques et mettre en correspondance deux occurrences de ce modèle.|  
|`[A-Z0-9]`|Correspond à n’importe quel caractère alphabétique unique de `A` via `Z`, ou n’importe quel caractère numérique.|  
|`$`|Termine la correspondance à la fin de la chaîne.|  
  
 Appel de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> méthode avec le `options` paramètre la valeur <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> est équivalente à la définition de l’expression régulière suivante :  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Pour la comparaison, consultez l’exemple de la <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="pattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> n’est pas une valeur de <see cref="T:System.Text.RegularExpressions.RegexOptions" /> valide.  
  
ou 
 <paramref name="matchTimeout" /> a une valeur négative, nulle ou supérieure à environ 24 jours.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré.</exception>
        <block subset="none" type="usage"><para>Nous vous recommandons de définir le <paramref name="matchTimeout" /> paramètre à une valeur appropriée, comme les deux secondes. Si vous désactivez des délais d’attente en spécifiant <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, le moteur d’expression régulière offre des performances légèrement meilleures. Toutefois, vous devez désactiver les délais d’attente uniquement dans les conditions suivantes : 
-Lorsque l’entrée traitée par une expression régulière est dérivée d’une source connue et approuvée ou se compose de texte statique. Cela exclut le texte qui a été dynamiquement par les utilisateurs.  
  
-Lorsque le modèle d’expression régulière a été testé pour s’assurer qu’elle gère efficacement corresponde au, non-correspondances et proche.  
  
-Lorsque le modèle d’expression régulière ne contient aucun élément de langage qui est connus pour provoquer une rétroaction excessive lors du traitement d’une correspondance proche.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche dans une chaîne d'entrée une sous-chaîne qui correspond à un modèle d'expression régulière et retourne la première occurrence sous forme d'objet <see cref="T:System.Text.RegularExpressions.Match" /> unique.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <summary>Recherche dans la chaîne d'entrée spécifiée la première occurrence de l'expression régulière spécifiée dans le constructeur <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Objet qui contient des informations sur la correspondance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> méthode retourne la première sous-chaîne qui correspond à un modèle d’expression régulière dans une chaîne d’entrée. Pour plus d’informations sur les éléments de langage utilisés pour générer un modèle d’expression régulière, consultez [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Vous pouvez déterminer si le modèle d’expression régulière a été trouvé dans la chaîne d’entrée en vérifiant la valeur de retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Group.Success%2A> propriété. Si une correspondance est trouvée, retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Capture.Value%2A> propriété contient la sous-chaîne à partir de `input` qui correspond au modèle d’expression régulière. Si aucune correspondance n’est trouvée, sa valeur est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Cette méthode retourne la première sous-chaîne dans `input` qui correspond au modèle d’expression régulière. Vous pouvez récupérer les correspondances suivantes en appelant à plusieurs reprises retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> (méthode). Vous pouvez également récupérer toutes les correspondances dans un seul appel de méthode en appelant le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> (méthode).  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié par le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructeur. Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est créé. Si aucun délai d’attente n’est défini dans le <xref:System.Text.RegularExpressions.Regex> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
   
  
## Examples  
 L’exemple suivant recherche le modèle d’expression régulière correspond à une chaîne, puis répertorie la mise en correspondance les groupes, captures et positions de capture.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 Le modèle d’expression régulière `(\w+)\s+(car)` correspond aux occurrences du mot « car » avec le mot qui la précède. Il est interprété comme indiqué dans le tableau suivant.  
  
|Motif|Description |  
|-------------|-----------------|  
|`(\w+)`|Mettre en correspondance un ou plusieurs caractères alphabétiques. Il s'agit du premier groupe de capture.|  
|`\s+`|Correspond à un ou plusieurs caractères d’espace blanc.|  
|(ARC)|Correspond à la chaîne littérale « car ». Il s'agit du deuxième groupe de capture.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="startat">Position du caractère de base zéro à partir duquel commencer la recherche.</param>
        <summary>Recherche dans la chaîne d'entrée la première occurrence d'une expression régulière, en commençant à la position de départ spécifiée dans la chaîne.</summary>
        <returns>Objet qui contient des informations sur la correspondance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> méthode retourne la première sous-chaîne qui correspond à un modèle d’expression régulière, en commençant l’ou après le `startat` position de caractère, dans une chaîne d’entrée. Pour plus d’informations sur les éléments de langage utilisés pour générer un modèle d’expression régulière, consultez [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Le modèle d’expression régulière pour lequel le <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> recherches de méthode est définie par l’appel à un de la <xref:System.Text.RegularExpressions.Regex> constructeurs de classe. Pour plus d’informations sur les éléments qui peuvent former un modèle d’expression régulière, consultez [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Vous pouvez éventuellement spécifier une position de départ dans la chaîne à l’aide de le `startat` paramètre. Lorsque le moteur d’expression régulière analyse de gauche à droite (la valeur par défaut), la correspondance et l’analyse de la déplacent vers la droite, en commençant au niveau du caractère spécifié dans `startat`. Quand le moteur des expressions régulières analyse de droite à gauche (lorsque le modèle d’expression régulière est construit avec la <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option), la correspondance et l’analyse dans la direction opposée et commencent par le caractère situé à `startat` -1. Si vous ne spécifiez pas une position de départ, la recherche commence à la valeur par défaut `startat` position. Si l’expression régulière cherche de gauche à droite, la valeur par défaut `startat` position est à l’extrémité gauche du `input`; si elle cherche de droite à gauche, la valeur par défaut `startat` position est à l’extrémité droite de `input`.  
  
 Si vous souhaitez restreindre une correspondance afin qu’elle commence à une position de caractère particulier dans la chaîne et le moteur des expressions régulières n’analyse pas le reste de la chaîne pour une correspondance, ancrez l’expression régulière avec un `\G` (à gauche de gauche à droite modèle, ou à droite pour un modèle de droite à gauche). Cela limite la correspondance de sorte qu’elle commence exactement à `startat`.  
  
 Vous pouvez déterminer si le modèle d’expression régulière a été trouvé dans la chaîne d’entrée en vérifiant la valeur de retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Group.Success%2A> propriété. Si une correspondance est trouvée, retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Capture.Value%2A> propriété contient la sous-chaîne à partir de `input` qui correspond au modèle d’expression régulière. Si aucune correspondance n’est trouvée, sa valeur est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Cette méthode retourne la première sous-chaîne trouvée pendant ou après le `startat` position de caractère dans `input` qui correspond au modèle d’expression régulière. Vous pouvez récupérer les correspondances suivantes en appelant à plusieurs reprises retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> (méthode). Vous pouvez également récupérer toutes les correspondances dans un seul appel de méthode en appelant le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> (méthode).  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié par le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructeur. Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse n’importe quelle valeur de délai d’expiration établi pour le domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est créé. Si aucun délai d’attente n’est défini dans le <xref:System.Text.RegularExpressions.Regex> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> est inférieur à zéro ou supérieur à la longueur de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <summary>Recherche dans la chaîne d'entrée spécifiée la première occurrence de l'expression régulière spécifiée.</summary>
        <returns>Objet qui contient des informations sur la correspondance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> méthode retourne la première sous-chaîne qui correspond à un modèle d’expression régulière dans une chaîne d’entrée. Pour plus d’informations sur les éléments de langage utilisés pour générer un modèle d’expression régulière, consultez [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Statiques <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> méthode équivaut à construire un <xref:System.Text.RegularExpressions.Regex> de l’objet avec le modèle d’expression régulière spécifiée et l’appel de l’instance <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> (méthode). Dans ce cas, le moteur d’expression régulière met en cache le modèle d’expression régulière.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Vous pouvez déterminer si le modèle d’expression régulière a été trouvé dans la chaîne d’entrée en vérifiant la valeur de retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Group.Success%2A> propriété. Si une correspondance est trouvée, retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Capture.Value%2A> propriété contient la sous-chaîne à partir de `input` qui correspond au modèle d’expression régulière. Si aucune correspondance n’est trouvée, sa valeur est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Cette méthode retourne la première sous-chaîne dans `input` qui correspond au modèle d’expression régulière. Vous pouvez récupérer les correspondances suivantes en appelant à plusieurs reprises retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> (méthode). Vous pouvez également récupérer toutes les correspondances dans un seul appel de méthode en appelant le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> (méthode).  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée. Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> méthode pour rechercher le premier mot qui contient au moins un `z` caractère, puis appelle le <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> procédé à aucune autre correspondance trouvée.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 Le modèle d'expression régulière `\b\w*z+\w*\b` est interprété comme indiqué dans le tableau suivant.  
  
|Motif|Description |  
|-------------|-----------------|  
|`\b`|Commencer la correspondance à la limite d'un mot.|  
|`\w*`|Correspond à zéro, une ou plusieurs caractères alphabétiques.|  
|`z+`|Mettre en correspondance un ou plusieurs occurrences de la `z` caractère.|  
|`\w*`|Correspond à zéro, une ou plusieurs caractères alphabétiques.|  
|`\b`|Terminer la correspondance à la limite d'un mot.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="pattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <block subset="none" type="usage"><para>Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans lequel elle est appelée. Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, ce qui empêche la méthode de délai d’expiration, est utilisé. La méthode statique recommandée pour la récupération d’une correspondance de modèle est <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, qui vous permet de définir l’intervalle de délai d’attente.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="beginning">Position du caractère de base zéro dans la chaîne d'entrée qui définit la position la plus à gauche à parcourir.</param>
        <param name="length">Nombre de caractères dans la sous-chaîne à inclure dans la recherche.</param>
        <summary>Recherche dans la chaîne d'entrée la première occurrence d'une expression régulière, en commençant à la position de départ spécifiée et en recherchant uniquement le nombre spécifié de caractères.</summary>
        <returns>Objet qui contient des informations sur la correspondance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> méthode retourne la première sous-chaîne qui correspond à un modèle d’expression régulière dans une partie d’une chaîne d’entrée. Pour plus d’informations sur les éléments de langage utilisés pour générer un modèle d’expression régulière, consultez [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Le modèle d’expression régulière pour lequel le <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> recherches de méthode est définie par l’appel à un de la <xref:System.Text.RegularExpressions.Regex> constructeurs de classe. Pour plus d’informations sur les éléments qui peuvent former un modèle d’expression régulière, consultez [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Le <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> méthode recherche la partie de `input` défini par le `beginning` et `length` paramètres du modèle d’expression régulière. `beginning` toujours définit l’index du caractère à l’extrême gauche à inclure dans la recherche, et `length` définit le nombre maximal de caractères à rechercher. Ensemble, ils définissent la plage de la recherche. Si la recherche se poursuit à partir de la gauche vers la droite (la valeur par défaut), le moteur d’expression régulière cherche de caractère à l’index `beginning` au caractère à l’index `beginning`  +  `length` - 1. Si le moteur d’expression régulière a été instancié à l’aide de la <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option pour que la recherche se poursuit de droite à gauche, le moteur d’expression régulière recherche à partir du caractère à l’index `beginning`  +  `length` - 1 pour le caractère à l’index `beginning`. Cette méthode retourne la première correspondance qu’il trouve dans cette plage. Vous pouvez récupérer les correspondances suivantes en appelant à plusieurs reprises retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> (méthode).  
  
 Vous pouvez déterminer si le modèle d’expression régulière a été trouvé dans la chaîne d’entrée en vérifiant la valeur de retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Group.Success%2A> propriété. Si une correspondance est trouvée, retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Capture.Value%2A> propriété contient la sous-chaîne à partir de `input` qui correspond au modèle d’expression régulière. Si aucune correspondance n’est trouvée, sa valeur est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié par le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructeur. Si vous ne définissez pas une valeur de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est créé. Si aucun délai d’attente n’est défini dans le <xref:System.Text.RegularExpressions.Regex> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="beginning" /> est inférieur à zéro ou supérieur à la longueur de <paramref name="input" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro ou supérieur à la longueur de <paramref name="input" />.  
  
ou 
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="-1" /> identifie un emplacement situé en dehors de la plage de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="pattern">Modèle d'expression régulière à mettre en correspondance.</param>
        <param name="options">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</param>
        <summary>Recherche dans la chaîne d'entrée la première occurrence de l'expression régulière spécifiée, en utilisant les options de correspondance spécifiées.</summary>
        <returns>Objet qui contient des informations sur la correspondance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> méthode retourne la première sous-chaîne qui correspond à un modèle d’expression régulière dans une chaîne d’entrée. Pour plus d’informations sur les éléments de langage utilisés pour générer un modèle d’expression régulière, consultez [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Statiques <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> méthode équivaut à construire un <xref:System.Text.RegularExpressions.Regex> de l’objet avec le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> constructeur et l’appel de l’instance <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> (méthode).  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Vous pouvez déterminer si le modèle d’expression régulière a été trouvé dans la chaîne d’entrée en vérifiant la valeur de retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Group.Success%2A> propriété. Si une correspondance est trouvée, retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Capture.Value%2A> propriété contient la sous-chaîne à partir de `input` qui correspond au modèle d’expression régulière. Si aucune correspondance n’est trouvée, sa valeur est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Cette méthode retourne la première sous-chaîne trouvée dans `input` qui correspond au modèle d’expression régulière. Vous pouvez récupérer les correspondances suivantes en appelant à plusieurs reprises retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Match.NextMatch%2A> (méthode). Vous pouvez également récupérer toutes les correspondances dans un seul appel de méthode en appelant le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> (méthode).  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de correspondance dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée. Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
   
  
## Examples  
 L’exemple suivant définit une expression régulière qui correspond aux mots commençant par la lettre « a ». Il utilise le <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option pour vous assurer que l’expression régulière recherche les mots commençant par les deux en majuscules des minuscules « a » et un « a ».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 Le modèle d'expression régulière `\ba\w*\b` est interprété comme indiqué dans le tableau suivant.  
  
|Motif|Description |  
|-------------|-----------------|  
|`\b`|Commencer la correspondance à la limite d'un mot.|  
|`a`|Mettre en correspondance le caractère « a ».|  
|`\w*`|Correspond à zéro, une ou plusieurs caractères alphabétiques.|  
|`\b`|Terminer la correspondance à la limite d'un mot.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="pattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> n’est pas une combinaison valide au niveau du bit de valeurs <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <block subset="none" type="usage"><para>Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans lequel elle est appelée. Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, ce qui empêche la méthode de délai d’expiration, est utilisé. La méthode statique recommandée pour la récupération d’une correspondance de modèle est <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, qui vous permet de définir l’intervalle de délai d’attente.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="pattern">Modèle d'expression régulière à mettre en correspondance.</param>
        <param name="options">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</param>
        <param name="matchTimeout">Intervalle de délai d’attente ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> pour indiquer que la méthode ne doit pas expirer.</param>
        <summary>Recherche dans la chaîne d'entrée la première occurrence de l'expression régulière spécifiée, en utilisant les options de correspondance et l'intervalle de délai d'attente spécifiés.</summary>
        <returns>Objet qui contient des informations sur la correspondance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> méthode retourne la première sous-chaîne qui correspond à un modèle d’expression régulière dans une chaîne d’entrée. Pour plus d’informations sur les éléments de langage utilisés pour générer un modèle d’expression régulière, consultez [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Statiques <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> méthode équivaut à construire un <xref:System.Text.RegularExpressions.Regex> de l’objet avec le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> constructeur et l’appel de l’instance <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> (méthode).  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Vous pouvez déterminer si le modèle d’expression régulière a été trouvé dans la chaîne d’entrée en vérifiant la valeur de retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Group.Success%2A> propriété. Si une correspondance est trouvée, retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Capture.Value%2A> propriété contient la sous-chaîne à partir de `input` qui correspond au modèle d’expression régulière. Si aucune correspondance n’est trouvée, sa valeur est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Cette méthode retourne la première sous-chaîne trouvée dans `input` qui correspond au modèle d’expression régulière. Vous pouvez récupérer les correspondances suivantes en appelant à plusieurs reprises retourné <xref:System.Text.RegularExpressions.Match> l’objet <xref:System.Text.RegularExpressions.Match.NextMatch%2A> (méthode). Vous pouvez également récupérer toutes les correspondances dans un seul appel de méthode en appelant le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> (méthode).  
  
 Le `matchTimeout` paramètre spécifie la manière dont la durée pendant laquelle un modèle de correspondance méthode doit essayer de trouver une correspondance avant son expiration. Définition d’un intervalle de délai d’attente empêche des expressions régulières qui s’appuient sur une rétroaction excessive d’apparaître à cesser de répondre lorsqu’elles traitent une entrée qui contient près de correspondances. Pour plus d’informations, consultez [meilleures pratiques pour les Expressions régulières](~/docs/standard/base-types/best-practices.md) et [rétroaction](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Si aucune correspondance n’est trouvée dans cet intervalle de temps, la méthode lève un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception. `matchTimeout` remplace toute valeur de délai d’attente par défaut défini pour le domaine d’application dans laquelle la méthode s’exécute.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="pattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> n’est pas une combinaison valide au niveau du bit de valeurs <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
ou 
 <paramref name="matchTimeout" /> a une valeur négative, nulle ou supérieure à environ 24 jours.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un dépassement du délai d’attente s’est produit. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <block subset="none" type="usage"><para>Nous vous recommandons de définir le <paramref name="matchTimeout" /> paramètre à une valeur appropriée, comme les deux secondes. Si vous désactivez des délais d’attente en spécifiant <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, le moteur d’expression régulière offre des performances légèrement meilleures. Toutefois, vous devez désactiver les délais d’attente uniquement dans les conditions suivantes : 
-Lorsque l’entrée traitée par une expression régulière est dérivée d’une source connue et approuvée ou se compose de texte statique. Cela exclut le texte qui a été dynamiquement par les utilisateurs.  
  
-Lorsque le modèle d’expression régulière a été testé pour s’assurer qu’elle gère efficacement corresponde au, non-correspondances et proche.  
  
-Lorsque le modèle d’expression régulière ne contient aucun élément de langage qui est connus pour provoquer une rétroaction excessive lors du traitement d’une correspondance proche.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche dans une chaîne d'entrée toutes les occurrences d'une expression régulière et retourne toutes les correspondances.</summary>
        <block subset="none" type="usage"><para>Lorsqu’une tentative de correspondance est répétée en appelant le <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> méthode, le moteur d’expression régulière donne les correspondances vides un traitement spécial. En règle générale, le moteur d’expression régulière commence la recherche de la correspondance suivante exactement là où la correspondance précédente était arrêtée. Toutefois, après une correspondance vide, le moteur des expressions régulières avance d’un caractère avant d’essayer la correspondance suivante. Ce comportement garantit que le moteur d’expression régulière doit suivre la chaîne. Sinon, car aucun déplacement vers l’avant n’entraîne pas une correspondance vide, la correspondance suivante commencerait exactement au même endroit que la correspondance précédente, et elle doit correspondre à plusieurs reprises à la même chaîne vide.  
  
Dans l’exemple suivant, le modèle d’expression régulière <c>un *</c> recherche zéro ou plusieurs occurrences de la lettre « a » dans la chaîne « abaabb ». Comme la sortie de l’exemple, résultant <see cref="T:System.Text.RegularExpressions.MatchCollection" /> objet contient six <see cref="T:System.Text.RegularExpressions.Match" /> objets. La première tentative de correspondance recherche le premier « a ». La deuxième correspondance démarre exactement où la première correspondance se termine, avant le premier b ; il trouve aucune occurrence de « a » et retourne une chaîne vide. La troisième correspondance ne commence pas exactement où la deuxième correspondance s’est terminée, car la deuxième correspondance a retourné une chaîne vide. Au lieu de cela, il commence un caractère plus tard, après le premier « b ». La troisième correspondance trouve deux occurrences de « a » et retourne « aa ». La quatrième correspondance commence là où s’est terminée la troisième, avant le deuxième « b » et retourne une chaîne vide. La cinquième tentative de correspondance avance un caractère afin qu’il commence avant le troisième « b » et retourne une chaîne vide. La sixième correspondance commence après le dernier « b » et retourne une chaîne vide à nouveau.  
  
[ ! code-csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [ ! code-vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <summary>Recherche dans la chaîne d'entrée spécifiée toutes les occurrences d'une expression régulière.</summary>
        <returns>Collection des objets <see cref="T:System.Text.RegularExpressions.Match" /> trouvés par la recherche. Si aucune correspondance n’est trouvée, la méthode retourne un objet de collection vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> méthode est similaire à la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> (méthode), à ceci près qu’elle retourne des informations sur toutes les correspondances trouvées dans la chaîne d’entrée, au lieu d’une correspondance unique. Il est équivalent au code suivant :  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 La collection inclut uniquement les correspondances et se termine à la première non-correspondance.  
  
 Le modèle d’expression régulière pour lequel le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> recherches de méthode est définie par l’appel à un de la <xref:System.Text.RegularExpressions.Regex> constructeurs de classe. Pour plus d’informations sur les éléments qui peuvent former un modèle d’expression régulière, consultez [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Le <xref:System.Text.RegularExpressions.Regex.Matches%2A> méthode utilise l’évaluation tardive pour remplir retourné <xref:System.Text.RegularExpressions.MatchCollection> objet. Accès aux membres de cette collection comme <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> et <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> provoque la collection à remplir immédiatement. Pour tirer parti de l’évaluation tardive, vous devez itérer la collection en utilisant une construction telle que `foreach` en c# et `For Each`...`Next` en Visual Basic.  
  
 En raison de son évaluation paresseuse, appelant le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> méthode ne lève pas une <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception. Toutefois, l’exception est levée lorsqu’une opération est effectuée sur le <xref:System.Text.RegularExpressions.MatchCollection> objet retourné par cette méthode, si le <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> propriété n’est pas <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> et une opération de correspondance dépasse le délai d’attente.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> méthode pour identifier des mots dans une phrase qui se terminent par « es ».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 Le modèle d'expression régulière `\b\w+es\b` est défini comme indiqué dans le tableau suivant.  
  
|Motif|Description |  
|-------------|-----------------|  
|`\b`|Commencer la correspondance à la limite d'un mot.|  
|`\w+`|Mettre en correspondance un ou plusieurs caractères alphabétiques.|  
|`es`|Correspond à la chaîne littérale « es ».|  
|`\b`|Terminer la correspondance à la limite d'un mot.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="startat">Position du caractère dans la chaîne d'entrée à partir duquel commencer la recherche.</param>
        <summary>Recherche dans la chaîne d'entrée spécifiée toutes les occurrences d'une expression régulière, en commençant à la position de démarrage spécifiée dans la chaîne.</summary>
        <returns>Collection des objets <see cref="T:System.Text.RegularExpressions.Match" /> trouvés par la recherche. Si aucune correspondance n’est trouvée, la méthode retourne un objet de collection vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> méthode est similaire à la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> (méthode), à ceci près qu’elle retourne des informations sur toutes les correspondances trouvées dans la chaîne d’entrée, au lieu d’une correspondance unique. Il est équivalent au code suivant :  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 Le modèle d’expression régulière pour lequel le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> recherches de méthode est définie par l’appel à un de la <xref:System.Text.RegularExpressions.Regex> constructeurs de classe. Pour plus d’informations sur les éléments qui peuvent former un modèle d’expression régulière, consultez [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Le <xref:System.Text.RegularExpressions.Regex.Matches%2A> méthode utilise l’évaluation tardive pour remplir retourné <xref:System.Text.RegularExpressions.MatchCollection> objet. Accès aux membres de cette collection comme <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> et <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> provoque la collection à remplir immédiatement. Pour tirer parti de l’évaluation tardive, vous devez itérer la collection en utilisant une construction telle que `foreach` en c# et `For Each`...`Next` en Visual Basic.  
  
 En raison de son évaluation paresseuse, appelant le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> méthode ne lève pas une <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception. Toutefois, l’exception est levée lorsqu’une opération est effectuée sur le <xref:System.Text.RegularExpressions.MatchCollection> objet retourné par cette méthode, si le <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> propriété n’est pas <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> et une opération de correspondance dépasse le délai d’attente. 
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> méthode pour rechercher le premier mot dans une phrase qui se termine par « es », puis appelle la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> méthode pour identifier des mots supplémentaires qui se terminent par « es ».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 Le modèle d'expression régulière `\b\w+es\b` est défini comme indiqué dans le tableau suivant.  
  
|Motif|Description |  
|-------------|-----------------|  
|`\b`|Commencer la correspondance à la limite d'un mot.|  
|`\w+`|Mettre en correspondance un ou plusieurs caractères alphabétiques.|  
|`es`|Correspond à la chaîne littérale « es ».|  
|`\b`|Terminer la correspondance à la limite d'un mot.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> est inférieur à zéro ou supérieur à la longueur de <paramref name="input" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <summary>Recherche dans la chaîne d'entrée spécifiée toutes les occurrences d'une expression régulière spécifiée.</summary>
        <returns>Collection des objets <see cref="T:System.Text.RegularExpressions.Match" /> trouvés par la recherche. Si aucune correspondance n’est trouvée, la méthode retourne un objet de collection vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> méthode est similaire à la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> (méthode), à ceci près qu’elle retourne des informations sur toutes les correspondances trouvées dans la chaîne d’entrée, au lieu d’une correspondance unique. Il est équivalent au code suivant :  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 La méthode statique `Matches` méthodes sont équivalentes à construire un <xref:System.Text.RegularExpressions.Regex> de l’objet avec le modèle d’expression régulière spécifiée et en appelant la méthode d’instance `Matches`.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Le <xref:System.Text.RegularExpressions.Regex.Matches%2A> méthode utilise l’évaluation tardive pour remplir retourné <xref:System.Text.RegularExpressions.MatchCollection> objet. Accès aux membres de cette collection comme <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> et <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> provoque la collection à remplir immédiatement. Pour tirer parti de l’évaluation tardive, vous devez itérer la collection en utilisant une construction telle que `foreach` en c# et `For Each`...`Next` en Visual Basic.  
  
 En raison de son évaluation paresseuse, appelant le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> méthode ne lève pas une <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception. Toutefois, l’exception est levée lorsqu’une opération est effectuée sur le <xref:System.Text.RegularExpressions.MatchCollection> objet retourné par cette méthode, si un intervalle de délai d’expiration est défini par la propriété « REGEX_DEFAULT_MATCH_TIMEOUT » du domaine d’application actuel et une opération de correspondance dépasse ce délai d’attente.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> méthode pour identifier tout mot dans une phrase qui se termine par « es ».  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 Le modèle d'expression régulière `\b\w+es\b` est défini comme indiqué dans le tableau suivant.  
  
|Motif|Description |  
|-------------|-----------------|  
|`\b`|Commencer la correspondance à la limite d'un mot.|  
|`\w+`|Mettre en correspondance un ou plusieurs caractères alphabétiques.|  
|`es`|Correspond à la chaîne littérale « es ».|  
|`\b`|Terminer la correspondance à la limite d'un mot.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="pattern" /> a la valeur <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans lequel elle est appelée. Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, ce qui empêche la méthode de délai d’expiration, est utilisé. La méthode statique recommandée pour récupérer plusieurs modèle correspond est <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, ce qui vous permet de spécifier l’intervalle de délai d’attente.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <param name="options">Combinaison de bits de valeurs d'énumération qui spécifient des options pour la correspondance.</param>
        <summary>Recherche dans la chaîne d'entrée spécifiée toutes les occurrences d'une expression régulière spécifique, en utilisant les options de correspondance spécifiées.</summary>
        <returns>Collection des objets <see cref="T:System.Text.RegularExpressions.Match" /> trouvés par la recherche. Si aucune correspondance n’est trouvée, la méthode retourne un objet de collection vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> méthode est similaire à la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> (méthode), à ceci près qu’elle retourne des informations sur toutes les correspondances trouvées dans la chaîne d’entrée, au lieu d’une correspondance unique. Il est équivalent au code suivant :  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 La méthode statique `Matches` méthodes sont équivalentes à construire un <xref:System.Text.RegularExpressions.Regex> de l’objet avec le modèle d’expression régulière spécifiée et en appelant la méthode d’instance `Matches`.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Le <xref:System.Text.RegularExpressions.Regex.Matches%2A> méthode utilise l’évaluation tardive pour remplir retourné <xref:System.Text.RegularExpressions.MatchCollection> objet. Accès aux membres de cette collection comme <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> et <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> provoque la collection à remplir immédiatement. Pour tirer parti de l’évaluation tardive, vous devez itérer la collection en utilisant une construction telle que `foreach` en c# et `For Each`...`Next` en Visual Basic.  
  
 En raison de son évaluation paresseuse, appelant le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> méthode ne lève pas une <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception. Toutefois, l’exception est levée lorsqu’une opération est effectuée sur le <xref:System.Text.RegularExpressions.MatchCollection> objet retourné par cette méthode, si un intervalle de délai d’expiration est défini par la propriété « REGEX_DEFAULT_MATCH_TIMEOUT » du domaine d’application actuel et une opération de correspondance dépasse ce délai d’attente.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> méthode pour identifier tout mot dans une phrase qui se termine par « es », puis appelle la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> méthode pour effectuer une comparaison respectant la casse du modèle avec la chaîne d’entrée. Comme le montre la sortie, les deux méthodes retournent des résultats différents.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 Le modèle d'expression régulière `\b\w+es\b` est défini comme indiqué dans le tableau suivant.  
  
|Motif|Description |  
|-------------|-----------------|  
|`\b`|Commencer la correspondance à la limite d'un mot.|  
|`\w+`|Mettre en correspondance un ou plusieurs caractères alphabétiques.|  
|`es`|Correspond à la chaîne littérale « es ».|  
|`\b`|Terminer la correspondance à la limite d'un mot.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="pattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> n’est pas une combinaison valide au niveau du bit de valeurs <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <block subset="none" type="usage"><para>Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans lequel elle est appelée. Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, ce qui empêche la méthode de délai d’expiration, est utilisé. La méthode statique recommandée pour récupérer plusieurs modèle correspond est <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, qui vous permet de définir l’intervalle de délai d’attente.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <param name="options">Combinaison de bits de valeurs d'énumération qui spécifient des options pour la correspondance.</param>
        <param name="matchTimeout">Intervalle de délai d’attente ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> pour indiquer que la méthode ne doit pas expirer.</param>
        <summary>Recherche dans la chaîne d'entrée spécifiée toutes les occurrences d'une expression régulière spécifiée, en utilisant les options de correspondance et l'intervalle de délai d'attente spécifiés.</summary>
        <returns>Collection des objets <see cref="T:System.Text.RegularExpressions.Match" /> trouvés par la recherche. Si aucune correspondance n’est trouvée, la méthode retourne un objet de collection vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> méthode est similaire à la <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> (méthode), à ceci près qu’elle retourne des informations sur toutes les correspondances trouvées dans la chaîne d’entrée, au lieu d’une correspondance unique. Il est équivalent au code suivant :  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 La méthode statique `Matches` méthodes sont équivalentes à construire un <xref:System.Text.RegularExpressions.Regex> de l’objet avec le modèle d’expression régulière spécifiée et en appelant la méthode d’instance `Matches`.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Le <xref:System.Text.RegularExpressions.Regex.Matches%2A> méthode utilise l’évaluation tardive pour remplir retourné <xref:System.Text.RegularExpressions.MatchCollection> objet. Accès aux membres de cette collection comme <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> et <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> provoque la collection à remplir immédiatement. Pour tirer parti de l’évaluation tardive, vous devez itérer la collection en utilisant une construction telle que `foreach` en c# et `For Each`...`Next` en Visual Basic.  
  
 En raison de son évaluation paresseuse, appelant le <xref:System.Text.RegularExpressions.Regex.Matches%2A> méthode ne lève pas une <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception. Toutefois, une exception est levée lorsqu’une opération est effectuée sur le <xref:System.Text.RegularExpressions.MatchCollection> objet retourné par cette méthode, si une opération de correspondance dépasse ce délai d’attente spécifié par le`matchTimeout` paramètre.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> méthode pour effectuer une comparaison respectant la casse qui correspond à n’importe quel mot dans une phrase qui se termine par « es ». Il appelle ensuite la <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> méthode pour effectuer une comparaison respectant la casse du modèle avec la chaîne d’entrée. Dans les deux cas, l’intervalle de délai d’attente est défini sur une seconde. Comme le montre la sortie, les deux méthodes retournent des résultats différents.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 Le modèle d'expression régulière `\b\w+es\b` est défini comme indiqué dans le tableau suivant.  
  
|Motif|Description |  
|-------------|-----------------|  
|`\b`|Commencer la correspondance à la limite d'un mot.|  
|`\w+`|Mettre en correspondance un ou plusieurs caractères alphabétiques.|  
|`es`|Correspond à la chaîne littérale « es ».|  
|`\b`|Terminer la correspondance à la limite d'un mot.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="pattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> n’est pas une combinaison valide au niveau du bit de valeurs <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
ou 
 <paramref name="matchTimeout" /> a une valeur négative, nulle ou supérieure à environ 24 jours.</exception>
        <block subset="none" type="usage"><para>Nous vous recommandons de définir le <paramref name="matchTimeout" /> paramètre à une valeur appropriée, comme les deux secondes. Si vous désactivez des délais d’attente en spécifiant <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, le moteur d’expression régulière offre des performances légèrement meilleures. Toutefois, vous devez désactiver les délais d’attente uniquement dans les conditions suivantes : 
-Lorsque l’entrée traitée par une expression régulière est dérivée d’une source connue et approuvée ou se compose de texte statique. Cela exclut le texte qui a été dynamiquement par les utilisateurs.  
  
-Lorsque le modèle d’expression régulière a été testé pour s’assurer qu’elle gère efficacement corresponde au, non-correspondances et proche.  
  
-Lorsque le modèle d’expression régulière ne contient aucun élément de langage qui est connus pour provoquer une rétroaction excessive lors du traitement d’une correspondance proche.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'intervalle du délai d'attente de l'instance actuelle.</summary>
        <value>Intervalle de temps maximum par défaut qui peut s'écouler lors d'une opération de correspondance de modèles avant qu'une <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> soit levée, ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> si les délais d'attente sont désactivés.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> propriété définit l’intervalle de temps maximale approximative un <xref:System.Text.RegularExpressions.Regex> instance pour exécuter une seule opération de correspondance avant l’expiration de l’opération. Le moteur d’expression régulière lève un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception lors de sa prochaine vérification de minutage après l’intervalle de délai d’expiration est écoulé. Cela empêche le moteur d’expression régulière de traiter des chaînes d’entrée qui nécessitent une rétroaction excessive. Pour plus d’informations, consultez [rétroaction](~/docs/standard/base-types/backtracking-in-regular-expressions.md) et [meilleures pratiques pour les Expressions régulières](~/docs/standard/base-types/best-practices.md).  
  
 Cette propriété est en lecture seule. Vous pouvez définir explicitement sa valeur pour une personne <xref:System.Text.RegularExpressions.Regex> objet en appelant le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructeur ; et vous pouvez définir sa valeur pour tous les <xref:System.Text.RegularExpressions.Regex> correspondance des opérations dans un domaine d’application en appelant le <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> (méthode) et en fournissant un <xref:System.TimeSpan> valeur pour la propriété « REGEX_DEFAULT_MATCH_TIMEOUT », comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 Si vous ne définissez pas explicitement un intervalle de délai d’attente, la valeur par défaut <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> est utilisées et de correspondance des opérations n’expirent pas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les options passées dans le constructeur <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <value>Un ou plusieurs membres de l'énumération <see cref="T:System.Text.RegularExpressions.RegexOptions" /> qui représente les options qui ont été passées au constructeur <see cref="T:System.Text.RegularExpressions.Regex" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de la <xref:System.Text.RegularExpressions.Regex.Options%2A> propriété se compose d’un ou plusieurs membres de la <xref:System.Text.RegularExpressions.RegexOptions> énumération. Si aucune option ont été définies dans le <xref:System.Text.RegularExpressions.Regex> constructeur de classe, sa valeur est <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>. Les options disponibles sont décrites en détail dans le [Options des expressions régulières](~/docs/standard/base-types/regular-expression-options.md) rubrique.  
  
 Notez que le <xref:System.Text.RegularExpressions.Regex.Options%2A> propriété ne reflète pas les options inline définies dans l’expression régulière de modèle lui-même.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> est la classe de base des expressions régulières créée par le <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> (méthode). Ces expressions régulières compilées utilisent l’implémentation de classe de base de la <see cref="P:System.Text.RegularExpressions.Regex.Options" /> propriété. Si elle est appelée à partir d’une classe dérivée, la <see cref="P:System.Text.RegularExpressions.Regex.Options" /> propriété retourne les options qui ont été passées à la <paramref name="options" /> paramètre de la <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> constructeur de classe qui a été utilisé pour définir l’expression régulière.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/c82dc689-7e82-4767-a18d-cd24ce5f05e9">Options des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" />Utilisé par un objet généré par la méthode <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dans la chaîne d'entrée spécifiée, remplace les chaînes qui correspondent à un modèle d'expression régulière par une chaîne de remplacement spécifique.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substitutions</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="replacement">Chaîne de remplacement.</param>
        <summary>Dans une chaîne d’entrée spécifiée, remplace toutes les chaînes qui correspondent à un modèle d’expression régulière par une chaîne de remplacement spécifiée.</summary>
        <returns>Nouvelle chaîne identique à la chaîne d'entrée, sauf que la chaîne de remplacement remplace chaque chaîne correspondante. Si le modèle d’expression régulière n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de correspondances commence au début de la `input` chaîne. L’expression régulière est le modèle défini par le constructeur pour actuel <xref:System.Text.RegularExpressions.Regex> objet.  
  
 Le `replacement` paramètre spécifie la chaîne qui doit remplacer chaque correspondance dans `input`. `replacement` peut être constitué de n’importe quelle combinaison de texte littéral et [substitutions](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Par exemple, le modèle de remplacement `a*${test}b` insère la chaîne « un * » suivie de la sous-chaîne qui est mis en correspondance par le `test` groupe de capture, le cas échéant, suivie de la chaîne « b ». Le * caractère n’est pas reconnu comme un caractère de remplacement dans un modèle de remplacement.  
  
> [!NOTE]
>  Les substitutions sont les éléments de langage d’expression régulière seulement sont reconnus dans un modèle de remplacement. Tous les autres éléments de langage d’expression régulière, notamment [caractère d’échappement](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sont autorisées dans les modèles d’expressions régulières uniquement et ne sont pas reconnues dans les modèles de remplacement.  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié par le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructeur. Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est créé. Si aucun délai d’attente n’est défini dans le <xref:System.Text.RegularExpressions.Regex> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 Étant donné que la méthode retourne `input` inchangé s’il n’existe aucune correspondance, vous pouvez utiliser la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.  
  
   
  
## Examples  
 L’exemple suivant définit une expression régulière, `\s+`, qui correspond à un ou plusieurs caractères d’espace blanc. La chaîne de remplacement, « », les remplace par un espace unique.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 L’exemple suivant définit une expression régulière, `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`et un modèle de remplacement, `$2`, qui supprime un préfixe ou un symbole de devise à droite d’une valeur numérique.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 L'expression régulière est interprétée comme indiqué dans le tableau suivant.  
  
|Motif|Description |  
|-------------|-----------------|  
|`\p{Sc}`|Mettre en correspondance un symbole monétaire. `{Sc}` désigne n’importe quel caractère qui est membre du symbole Unicode, catégorie de devise.|  
|`\s?`|Mettre en correspondance zéro ou un espace blanc.|  
|`(\p{Sc}\s?)?`|Correspond à zéro ou une occurrence de la combinaison d’un symbole monétaire suivi par zéro ou un caractère d’espace blanc. Il s'agit du premier groupe de capture.|  
|`\d+`|Mettre en correspondance un ou plusieurs chiffres décimaux.|  
|`\.?`|Correspond à zéro ou une occurrence d’une période (utilisée comme un caractère de séparateur décimal).|  
|`((?<=\.)\d+)?`|Si une période est le caractère précédent, correspond à un ou plusieurs chiffres décimaux. Ce modèle peut être mis en correspondance zéro ou une fois.|  
|`(\d+\.?((?<=\.)\d+)?)`|Mettre en correspondance d’un ou plusieurs chiffres décimaux, suivi d’un point facultatif et de chiffres décimaux supplémentaires. Il s'agit du deuxième groupe de capture. L’appel à la <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> méthode remplace la correspondance entière par la valeur de ce groupe capturé.|  
|<code>(?(1)&#124;\s?\p{Sc})?</code>|Si le premier groupe capturé existe, correspond à une chaîne vide. Sinon, mettre en correspondance zéro ou un espace blanc suivi par un symbole monétaire.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="replacement" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substitutions</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="evaluator">Méthode personnalisée qui examine chaque correspondance et retourne la chaîne correspondante d'origine ou une chaîne de remplacement.</param>
        <summary>Dans une chaîne d’entrée spécifiée, remplace toutes les chaînes qui correspondent à une expression régulière spécifiée par une chaîne retournée par un délégué <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Nouvelle chaîne identique à la chaîne d'entrée, sauf qu'une chaîne de remplacement remplace chaque chaîne correspondante. Si le modèle d’expression régulière n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> méthode est utile pour remplacer une correspondance d’expression régulière si une des conditions suivantes est vraie :  
  
-   Impossible de spécifier facilement la chaîne de remplacement par un modèle de remplacement d’expression régulière.  
  
-   Résultats de la chaîne de remplacement d’un traitement effectué sur la chaîne correspondante.  
  
-   Résultats de la chaîne de remplacement d’un traitement conditionnel.  
  
 La méthode revient à appeler le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> méthode et passer chaque <xref:System.Text.RegularExpressions.Match> objet retourné <xref:System.Text.RegularExpressions.MatchCollection> collection à la `evaluator` déléguer.  
  
 L’expression régulière est le modèle défini par le constructeur pour actuel <xref:System.Text.RegularExpressions.Regex> objet.  
  
 Le `evaluator` paramètre est le délégué d’une méthode personnalisée que vous définissez et qui examine chaque correspondance. La méthode personnalisée doit avoir la signature suivante pour faire correspondre le <xref:System.Text.RegularExpressions.MatchEvaluator> déléguer.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Votre méthode personnalisée retourne une chaîne qui remplace l’entrée correspondante.  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié par le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructeur. Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est créé. Si aucun délai d’attente n’est défini dans le <xref:System.Text.RegularExpressions.Regex> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 Étant donné que la méthode retourne `input` inchangé s’il n’existe aucune correspondance, vous pouvez utiliser la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.  
  
   
  
## Examples  
 L’exemple de code suivant affiche une chaîne d’origine, met en correspondance chaque mot dans la chaîne d’origine, convertit le premier caractère de chaque correspondance en majuscules, puis affiche la chaîne convertie.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="evaluator" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substitutions</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="replacement">Chaîne de remplacement.</param>
        <param name="count">Nombre maximal d’occurrences du remplacement.</param>
        <summary>Dans une chaîne d’entrée spécifiée, remplace le nombre maximal spécifié de chaînes qui correspondent à un modèle d’expression régulière par une chaîne de remplacement spécifiée.</summary>
        <returns>Nouvelle chaîne identique à la chaîne d'entrée, sauf que la chaîne de remplacement remplace chaque chaîne correspondante. Si le modèle d’expression régulière n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de correspondances commence au début de la `input` chaîne. L’expression régulière est le modèle qui est défini par le constructeur pour actuel <xref:System.Text.RegularExpressions.Regex> objet. Si `count` est négatif, les remplacements continuent jusqu'à la fin de la chaîne. Si `count` dépasse le nombre de correspondances, toutes les correspondances sont remplacées.  
  
 Le `replacement` paramètre spécifie la chaîne qui doit remplacer la première `count` correspond à dans `input`. `replacement` peut être constitué de n’importe quelle combinaison de texte littéral et [substitutions](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Par exemple, le modèle de remplacement `a*${test}b` insère la chaîne « un * » suivie de la sous-chaîne qui est mis en correspondance par le `test` groupe de capture, le cas échéant, suivie de la chaîne « b ». Le * caractère n’est pas reconnu comme un caractère de remplacement dans un modèle de remplacement.  
  
> [!NOTE]
>  Les substitutions sont les éléments de langage d’expression régulière seulement sont reconnus dans un modèle de remplacement. Tous les autres éléments de langage d’expression régulière, notamment [caractère d’échappement](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sont autorisées dans les modèles d’expressions régulières uniquement et ne sont pas reconnues dans les modèles de remplacement.  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié par le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructeur. Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est créé. Si aucun délai d’attente n’est défini dans le <xref:System.Text.RegularExpressions.Regex> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 Étant donné que la méthode retourne `input` inchangé s’il n’existe aucune correspondance, vous pouvez utiliser la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.  
  
   
  
## Examples  
 L’exemple suivant remplace les cinq premières occurrences de caractères en double avec un caractère unique. Le modèle d’expression régulière `(\w)\1` correspond à des occurrences consécutives d’un caractère unique et affecte la première occurrence au premier groupe de capture. Le modèle de remplacement `$1` remplace la correspondance entière par le premier groupe capturé.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="replacement" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substitutions</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <param name="replacement">Chaîne de remplacement.</param>
        <summary>Dans la chaîne d'entrée spécifiée, remplace toutes les chaînes qui correspondent à l'expression régulière spécifiée par une chaîne de remplacement spécifiée.</summary>
        <returns>Nouvelle chaîne identique à la chaîne d'entrée, sauf que la chaîne de remplacement remplace chaque chaîne correspondante. Si <paramref name="pattern" /> n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode statique `Replace` méthodes sont équivalentes à construire un <xref:System.Text.RegularExpressions.Regex> de l’objet avec le modèle d’expression régulière spécifiée et en appelant la méthode d’instance `Replace`.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md). La recherche de correspondances commence au début de la `input` chaîne.  
  
 Le `replacement` paramètre spécifie la chaîne qui doit remplacer chaque correspondance dans `input`. `replacement` peut être constitué de n’importe quelle combinaison de texte littéral et [substitutions](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Par exemple, le modèle de remplacement `a*${test}b` insère la chaîne « un * » suivie de la sous-chaîne qui est mis en correspondance par le `test` groupe de capture, le cas échéant, suivie de la chaîne « b ». Le * caractère n’est pas reconnu comme un caractère de remplacement dans un modèle de remplacement.  
  
> [!NOTE]
>  Les substitutions sont les éléments de langage d’expression régulière seulement sont reconnus dans un modèle de remplacement. Tous les autres éléments de langage d’expression régulière, notamment [caractère d’échappement](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sont autorisées dans les modèles d’expressions régulières uniquement et ne sont pas reconnues dans les modèles de remplacement.  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée. Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 Étant donné que la méthode retourne `input` inchangé s’il n’existe aucune correspondance, vous pouvez utiliser la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.  
  
   
  
## Examples  
 L’exemple suivant définit une expression régulière, `\s+`, qui correspond à un ou plusieurs caractères d’espace blanc. La chaîne de remplacement, « », les remplace par un espace unique.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 L’exemple suivant utilise la <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> méthode pour remplacer les noms d’ordinateur et le lecteur locales dans un chemin d’accès UNC avec un chemin d’accès de fichier local. L’expression régulière utilise la <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriété à inclure le nom de l’ordinateur local et le <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> méthode pour inclure les noms des lecteurs logiques. Pour exécuter l’exemple, vous devez remplacer la chaîne littérale « Monordinateur » par le nom de votre ordinateur local.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 Le modèle d’expression régulière est défini par l’expression suivante :  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 Le tableau suivant montre comment le modèle d'expression régulière est interprété.  
  
|Motif|Description |  
|-------------|-----------------|  
|`\\\\`|Barre oblique inverse consécutif de correspondance deux (`\`) caractères. Étant donné que le caractère barre oblique inverse est interprété comme caractère d’échappement, chaque barre oblique inverse doit être précédé d’une autre barre oblique inverse.|  
|`(?i:" + Environment.MachineName + ")`|Procédez à la casse de la chaîne retournée par la <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriété.|  
|`(?:\.\w+)*`|Correspond à la période (`.`) caractères suivi d’un ou plusieurs caractères alphabétiques. Cette correspondance peut se produire zéro ou plusieurs fois. La sous-expression mise en correspondance n’est pas capturée.|  
|`\\`|Correspond à une barre oblique inverse (`\`) caractères.|  
|`((?i:[" + driveNames + "]))`|Procédez à la casse de la classe de caractères est constitué par les lettres de lecteur individuelles. Cette correspondance est la première sous-expression capturée.|  
|`\$`|Correspond au signe dollar littéral (`$`) caractères.|  
  
 Le modèle de remplacement `$1` remplace la correspondance entière par la première sous-expression capturée. Autrement dit, il remplace le nom d’ordinateur et le lecteur UNC par la lettre de lecteur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> ou <paramref name="replacement" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <block subset="none" type="usage"><para>Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans lequel elle est appelée. Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, ce qui empêche la méthode de délai d’expiration, est utilisé. La méthode statique recommandée pour remplacer une correspondance de modèle est <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, qui vous permet de définir l’intervalle de délai d’attente.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substitutions</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <param name="evaluator">Méthode personnalisée qui examine chaque correspondance et retourne la chaîne correspondante d'origine ou une chaîne de remplacement.</param>
        <summary>Dans une chaîne d’entrée spécifiée, remplace toutes les chaînes qui correspondent à une expression régulière spécifiée par une chaîne retournée par un délégué <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Nouvelle chaîne identique à la chaîne d'entrée, sauf qu'une chaîne de remplacement remplace chaque chaîne correspondante. Si <paramref name="pattern" /> n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> méthode est utile pour remplacer une correspondance d’expression régulière si une des conditions suivantes est vraie :  
  
-   Impossible de spécifier facilement la chaîne de remplacement par un modèle de remplacement d’expression régulière.  
  
-   Résultats de la chaîne de remplacement d’un traitement effectué sur la chaîne correspondante.  
  
-   Résultats de la chaîne de remplacement d’un traitement conditionnel.  
  
 La méthode revient à appeler le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> méthode et passer chaque <xref:System.Text.RegularExpressions.Match> objet retourné <xref:System.Text.RegularExpressions.MatchCollection> collection à la `evaluator` déléguer.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Le `evaluator` paramètre est le délégué d’une méthode personnalisée que vous définissez et qui examine chaque correspondance. La méthode personnalisée doit avoir la signature suivante pour faire correspondre le <xref:System.Text.RegularExpressions.MatchEvaluator> déléguer.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Votre méthode personnalisée retourne une chaîne qui remplace l’entrée correspondante.  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée. Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 Étant donné que la méthode retourne `input` inchangé s’il n’existe aucune correspondance, vous pouvez utiliser la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.  
  
   
  
## Examples  
 L’exemple suivant utilise une expression régulière pour extraire les mots individuels d’une chaîne, puis utilise un <xref:System.Text.RegularExpressions.MatchEvaluator> délégué à appeler une méthode nommée `WordScramble` qui brouille les lettres individuelles dans le mot. Pour ce faire, le `WordScramble` méthode crée un tableau qui contient les caractères dans la correspondance. Il crée également un tableau parallèle qu’il remplit avec des nombres à virgule flottante aléatoire. Les tableaux sont triés en appelant le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> (méthode) et le tableau trié est fourni en tant qu’argument à un <xref:System.String> constructeur de classe. Cette chaîne nouvellement créée est ensuite retournée par la `WordScramble` (méthode). Le modèle d’expression régulière `\w+` correspond à un ou plusieurs caractères alphabétiques ; le moteur d’expression régulière continue à ajouter des caractères à la correspondance jusqu'à ce qu’il rencontre un caractère non alphabétique, par exemple un caractère d’espace blanc.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> ou <paramref name="evaluator" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <block subset="none" type="usage"><para>Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans lequel elle est appelée. Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, ce qui empêche la méthode de délai d’expiration, est utilisé. La méthode statique recommandée pour l’évaluation et le remplacement d’une correspondance de modèle est <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, qui vous permet de définir l’intervalle de délai d’attente.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substitutions</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="evaluator">Méthode personnalisée qui examine chaque correspondance et retourne la chaîne correspondante d'origine ou une chaîne de remplacement.</param>
        <param name="count">Nombre maximal de fois où le remplacement aura lieu.</param>
        <summary>Dans la chaîne d'entrée spécifiée, remplace le nombre maximal spécifié de chaînes qui correspondent à un modèle d'expression régulière par une chaîne retournée par un délégué <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Nouvelle chaîne identique à la chaîne d'entrée, sauf qu'une chaîne de remplacement remplace chaque chaîne correspondante. Si le modèle d’expression régulière n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> méthode est utile pour remplacer une correspondance d’expression régulière si une des conditions suivantes est vraie :  
  
-   Impossible de spécifier facilement la chaîne de remplacement par un modèle de remplacement d’expression régulière.  
  
-   Résultats de la chaîne de remplacement d’un traitement effectué sur la chaîne correspondante.  
  
-   Résultats de la chaîne de remplacement d’un traitement conditionnel.  
  
 La méthode revient à appeler le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> (méthode) et en passant la première `count` <xref:System.Text.RegularExpressions.Match> objets retourné <xref:System.Text.RegularExpressions.MatchCollection> collection à la `evaluator` déléguer.  
  
 L’expression régulière est le modèle défini par le constructeur pour actuel <xref:System.Text.RegularExpressions.Regex> objet.  
  
 Le `evaluator` paramètre est le délégué d’une méthode personnalisée que vous définissez et qui examine chaque correspondance. La méthode personnalisée doit avoir la signature suivante pour faire correspondre le <xref:System.Text.RegularExpressions.MatchEvaluator> déléguer.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Votre méthode personnalisée retourne une chaîne qui remplace l’entrée correspondante.  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié par le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructeur. Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est créé. Si aucun délai d’attente n’est défini dans le <xref:System.Text.RegularExpressions.Regex> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 Étant donné que la méthode retourne `input` inchangé s’il n’existe aucune correspondance, vous pouvez utiliser la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.  
  
   
  
## Examples  
 L’exemple suivant utilise une expression régulière pour délibérément mal orthographier la moitié des mots contenus dans une liste. Elle utilise l’expression régulière `\w*(ie|ei)\w*` pour faire correspondre les mots qui incluent les caractères « ie » ou « AE ». Il passe la première moitié de mots correspondants à la `ReverseLetter` (méthode), qui, à son tour, utilise le <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> méthode à inverser « i » et « e » dans la chaîne correspondante. Les mots restants restent inchangés.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 L'expression régulière `\w*(ie|ei)\w*` est définie comme indiqué dans le tableau suivant.  
  
|Motif|Description |  
|-------------|-----------------|  
|`\w*`|Mettre en correspondance zéro, un ou plusieurs caractères alphabétiques.|  
|<code>(ie&#124;ei)</code>|Mettre en correspondance « ie » ou « AE ».|  
|`\w*`|Mettre en correspondance zéro, un ou plusieurs caractères alphabétiques.|  
  
 Le modèle d’expression régulière `([ie])([ie])` dans le `ReverseLetter` méthode correspond à la première « i » ou « e » dans la diphtongue « ie » ou « AE » et lui attribue la lettre au premier groupe de capture. Il correspond à la deuxième « i » ou « e » et lui attribue la lettre au deuxième groupe de capture. Les deux caractères sont alors annulées en appelant le <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> méthode avec le modèle de remplacement `$2$1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="evaluator" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substitutions</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="replacement">Chaîne de remplacement.</param>
        <param name="count">Nombre maximal d’occurrences du remplacement.</param>
        <param name="startat">Position du caractère dans la chaîne d’entrée où la recherche commence.</param>
        <summary>Dans une sous-chaîne d’entrée spécifiée, remplace un nombre maximal spécifié de chaînes qui correspondent à un modèle d’expression régulière par une chaîne de remplacement spécifiée.</summary>
        <returns>Nouvelle chaîne identique à la chaîne d'entrée, sauf que la chaîne de remplacement remplace chaque chaîne correspondante. Si le modèle d’expression régulière n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de correspondances démarre dans le `input` chaîne à la position spécifiée par le `startat` paramètre. L’expression régulière est le modèle défini par le constructeur pour actuel <xref:System.Text.RegularExpressions.Regex> objet. Si `count` est négatif, les remplacements continuent jusqu'à la fin de la chaîne. Si `count` dépasse le nombre de correspondances, toutes les correspondances sont remplacées.  
  
 Le `replacement` paramètre spécifie la chaîne qui doit remplacer chaque correspondance dans `input`. `replacement` peut être constitué de n’importe quelle combinaison de texte littéral et [substitutions](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Par exemple, le modèle de remplacement `a*${test}b` insère la chaîne « un * » suivie de la sous-chaîne qui est mis en correspondance par le `test` groupe de capture, le cas échéant, suivie de la chaîne « b ». Le * caractère n’est pas reconnu comme un caractère de remplacement dans un modèle de remplacement.  
  
> [!NOTE]
>  Les substitutions sont les éléments de langage d’expression régulière seulement sont reconnus dans un modèle de remplacement. Tous les autres éléments de langage d’expression régulière, notamment [caractère d’échappement](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sont autorisées dans les modèles d’expressions régulières uniquement et ne sont pas reconnues dans les modèles de remplacement.  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié par le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructeur. Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est créé. Si aucun délai d’attente n’est défini dans le <xref:System.Text.RegularExpressions.Regex> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 Étant donné que la méthode retourne `input` inchangé s’il n’existe aucune correspondance, vous pouvez utiliser la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.  
  
   
  
## Examples  
 L’exemple suivant applique un interligne double toutes les valeurs sauf la première ligne d’une chaîne. Il définit un modèle d’expression régulière, `^.*$`, qui correspond à une ligne de texte, appelle le <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> méthode pour faire correspondre la première ligne de la chaîne et utilise le `Match.Index` et `Match.Count` propriétés pour déterminer la position de départ de la seconde ligne.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 Le modèle d'expression régulière `^.*$` est défini comme indiqué dans le tableau suivant.  
  
|Motif|Description |  
|-------------|-----------------|  
|`^`|Correspond au début d’une ligne. (Notez que le <xref:System.Text.RegularExpressions.Regex> objet a été instancié à l’aide de la <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option ; sinon, cette classe de caractères correspondrait à uniquement le début de la chaîne d’entrée.)|  
|`.*`|Correspond à n’importe quel caractère zéro ou plusieurs fois.|  
|`$`|Correspond à la fin d’une ligne. (Notez que le <xref:System.Text.RegularExpressions.Regex> objet a été instancié à l’aide de la <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option ; sinon, cette classe de caractères correspondrait à uniquement le début de la chaîne d’entrée.)|  
  
 La chaîne de remplacement (`vbCrLf + "$&"` en Visual Basic, `"\n$&"` en c#) ajoute une nouvelle ligne avant la chaîne correspondante. Notez que `\n` en C# exemple est interprété comme le caractère de saut de ligne par le compilateur c# ; il ne représente pas un échappement de caractères d’expression régulière.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="replacement" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> est inférieur à zéro ou supérieur à la longueur de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substitutions</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <param name="replacement">Chaîne de remplacement.</param>
        <param name="options">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</param>
        <summary>Dans la chaîne d'entrée spécifiée, remplace toutes les chaînes qui correspondent à l'expression régulière spécifiée par une chaîne de remplacement spécifiée. Les options spécifiées modifient l'opération correspondante.</summary>
        <returns>Nouvelle chaîne identique à la chaîne d'entrée, sauf que la chaîne de remplacement remplace chaque chaîne correspondante. Si <paramref name="pattern" /> n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode statique `Replace` méthodes sont équivalentes à construire un <xref:System.Text.RegularExpressions.Regex> de l’objet avec le modèle d’expression régulière spécifiée et en appelant la méthode d’instance `Replace`.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Si vous spécifiez <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> pour le `options` de paramètre, la recherche de correspondances commence à la fin de la chaîne d’entrée et les déplace vers la gauche ; sinon, la recherche commence au début de la chaîne d’entrée et déplacé vers la droite.  
  
 Le `replacement` paramètre spécifie la chaîne qui doit remplacer chaque correspondance dans `input`. `replacement` peut être constitué de n’importe quelle combinaison de texte littéral et [substitutions](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Par exemple, le modèle de remplacement `a*${test}b` insère la chaîne « un * » suivie de la sous-chaîne qui est mis en correspondance par le `test` groupe de capture, le cas échéant, suivie de la chaîne « b ». Le * caractère n’est pas reconnu comme un caractère de remplacement dans un modèle de remplacement.  
  
> [!NOTE]
>  Les substitutions sont les éléments de langage d’expression régulière seulement sont reconnus dans un modèle de remplacement. Tous les autres éléments de langage d’expression régulière, notamment [caractère d’échappement](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sont autorisées dans les modèles d’expressions régulières uniquement et ne sont pas reconnues dans les modèles de remplacement.  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée. Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 Étant donné que la méthode retourne `input` inchangé s’il n’existe aucune correspondance, vous pouvez utiliser la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> méthode pour remplacer les noms d’ordinateur et le lecteur locales dans un chemin d’accès UNC avec un chemin d’accès de fichier local. L’expression régulière utilise la <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriété à inclure le nom de l’ordinateur local et le <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> méthode pour inclure les noms des lecteurs logiques. Toutes les comparaisons de chaîne d’expression régulière respectent la casse. Pour exécuter l’exemple, vous devez remplacer la chaîne littérale « Monordinateur » par le nom de votre ordinateur local.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 Le modèle d’expression régulière est défini par l’expression suivante :  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 Le tableau suivant montre comment le modèle d'expression régulière est interprété.  
  
|Motif|Description |  
|-------------|-----------------|  
|`\\\\`|Barre oblique inverse consécutif de correspondance deux (`\`) caractères. Étant donné que le caractère barre oblique inverse est interprété comme caractère d’échappement, chaque barre oblique inverse doit être précédé d’une autre barre oblique inverse.|  
|`+ Environment.MachineName +`|Correspond à la chaîne retournée par la <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriété.|  
|`(?:\.\w+)*`|Correspond à la période (`.`) caractères suivi d’un ou plusieurs caractères alphabétiques. Cette correspondance peut se produire zéro ou plusieurs fois. La sous-expression mise en correspondance n’est pas capturée.|  
|`\\`|Correspond à une barre oblique inverse (`\`) caractères.|  
|`([" + driveNames + "])`|Correspond à la classe de caractères qui se compose de lettres de lecteur individuelles. Cette correspondance est la première sous-expression capturée.|  
|`\$`|Correspond au signe dollar littéral (`$`) caractères.|  
  
 Le modèle de remplacement `$1` remplace la correspondance entière par la première sous-expression capturée. Autrement dit, il remplace le nom d’ordinateur et le lecteur UNC par la lettre de lecteur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> ou <paramref name="replacement" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> n’est pas une combinaison valide au niveau du bit de valeurs <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <block subset="none" type="usage"><para>Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans lequel elle est appelée. Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, ce qui empêche la méthode de délai d’expiration, est utilisé. La méthode statique recommandée pour remplacer une correspondance de modèle est <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, qui vous permet de définir l’intervalle de délai d’attente.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substitutions</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <param name="evaluator">Méthode personnalisée qui examine chaque correspondance et retourne la chaîne correspondante d'origine ou une chaîne de remplacement.</param>
        <param name="options">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</param>
        <summary>Dans une chaîne d’entrée spécifiée, remplace toutes les chaînes qui correspondent à une expression régulière spécifiée par une chaîne retournée par un délégué <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Les options spécifiées modifient l'opération correspondante.</summary>
        <returns>Nouvelle chaîne identique à la chaîne d'entrée, sauf qu'une chaîne de remplacement remplace chaque chaîne correspondante. Si <paramref name="pattern" /> n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> méthode est utile pour remplacer une correspondance d’expression régulière si une des conditions suivantes est vraie :  
  
-   Impossible de spécifier facilement la chaîne de remplacement par un modèle de remplacement d’expression régulière.  
  
-   Résultats de la chaîne de remplacement d’un traitement effectué sur la chaîne correspondante.  
  
-   Résultats de la chaîne de remplacement d’un traitement conditionnel.  
  
 La méthode revient à appeler le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> méthode et passer chaque <xref:System.Text.RegularExpressions.Match> objet retourné <xref:System.Text.RegularExpressions.MatchCollection> collection à la `evaluator` déléguer.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Le `evaluator` paramètre est le délégué d’une méthode personnalisée que vous définissez et qui examine chaque correspondance. La méthode personnalisée doit avoir la signature suivante pour faire correspondre le <xref:System.Text.RegularExpressions.MatchEvaluator> déléguer.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Votre méthode personnalisée retourne une chaîne qui remplace l’entrée correspondante.  
  
 Si vous spécifiez <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> pour le `options` de paramètre, la recherche de correspondances commence à la fin de la chaîne d’entrée et les déplace vers la gauche ; sinon, la recherche commence au début de la chaîne d’entrée et déplacé vers la droite.  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée. Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 Étant donné que la méthode retourne `input` inchangé s’il n’existe aucune correspondance, vous pouvez utiliser la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.  
  
   
  
## Examples  
 L’exemple suivant utilise une expression régulière pour extraire les mots individuels d’une chaîne, puis utilise un <xref:System.Text.RegularExpressions.MatchEvaluator> délégué à appeler une méthode nommée `WordScramble` qui brouille les lettres individuelles dans le mot. Pour ce faire, le `WordScramble` méthode crée un tableau qui contient les caractères dans la correspondance. Il crée également un tableau parallèle qu’il remplit avec des nombres à virgule flottante aléatoire. Les tableaux sont triés en appelant le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> (méthode) et le tableau trié est fourni en tant qu’argument à un <xref:System.String> constructeur de classe. Cette chaîne nouvellement créée est ensuite retournée par la `WordScramble` (méthode). Le modèle d’expression régulière `\w+` correspond à un ou plusieurs caractères alphabétiques ; le moteur d’expression régulière continue à ajouter des caractères à la correspondance jusqu'à ce qu’il rencontre un caractère non alphabétique, par exemple un caractère d’espace blanc. L’appel à la <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> méthode inclut la <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option afin que le commentaire dans le modèle d’expression régulière `\w+  # Matches all the characters in a word.` est ignoré par le moteur d’expression régulière.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> ou <paramref name="evaluator" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> n’est pas une combinaison valide au niveau du bit de valeurs <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substitutions</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="evaluator">Méthode personnalisée qui examine chaque correspondance et retourne la chaîne correspondante d'origine ou une chaîne de remplacement.</param>
        <param name="count">Nombre maximal de fois où le remplacement aura lieu.</param>
        <param name="startat">Position du caractère dans la chaîne d’entrée où la recherche commence.</param>
        <summary>Dans la sous-chaîne d'entrée spécifiée, remplace le nombre maximal spécifié de chaînes qui correspondent à un modèle d'expression régulière par une chaîne retournée par un délégué <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Nouvelle chaîne identique à la chaîne d'entrée, sauf qu'une chaîne de remplacement remplace chaque chaîne correspondante. Si le modèle d’expression régulière n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> méthode est utile pour remplacer une correspondance d’expression régulière si une des conditions suivantes est vraie :  
  
-   Impossible de spécifier facilement la chaîne de remplacement par un modèle de remplacement d’expression régulière.  
  
-   Résultats de la chaîne de remplacement d’un traitement effectué sur la chaîne correspondante.  
  
-   Résultats de la chaîne de remplacement d’un traitement conditionnel.  
  
 La méthode revient à appeler le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> (méthode) et en passant la première `count` <xref:System.Text.RegularExpressions.Match> objets retourné <xref:System.Text.RegularExpressions.MatchCollection> collection à la `evaluator` déléguer.  
  
 L’expression régulière est le modèle défini par le constructeur pour actuel <xref:System.Text.RegularExpressions.Regex> objet.  
  
 Le `evaluator` paramètre est le délégué d’une méthode personnalisée que vous définissez et qui examine chaque correspondance. La méthode personnalisée doit avoir la signature suivante pour faire correspondre le <xref:System.Text.RegularExpressions.MatchEvaluator> déléguer.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Votre méthode personnalisée retourne une chaîne qui remplace l’entrée correspondante.  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de remplacement dépasse l’intervalle de délai d’attente spécifié par le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructeur. Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est créé. Si aucun délai d’attente n’est défini dans le <xref:System.Text.RegularExpressions.Regex> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 Étant donné que la méthode retourne `input` inchangé s’il n’existe aucune correspondance, vous pouvez utiliser la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="evaluator" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> est inférieur à zéro ou supérieur à la longueur de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substitutions</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <param name="replacement">Chaîne de remplacement.</param>
        <param name="options">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</param>
        <param name="matchTimeout">Intervalle de délai d’attente ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> pour indiquer que la méthode ne doit pas expirer.</param>
        <summary>Dans la chaîne d'entrée spécifiée, remplace toutes les chaînes qui correspondent à l'expression régulière spécifiée par une chaîne de remplacement spécifiée. Les paramètres supplémentaires spécifient les options qui modifient l'opération et l'intervalle de délai d'attente correspondants si aucune correspondance n'est trouvée.</summary>
        <returns>Nouvelle chaîne identique à la chaîne d'entrée, sauf que la chaîne de remplacement remplace chaque chaîne correspondante. Si <paramref name="pattern" /> n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode statique `Replace` méthodes sont équivalentes à construire un <xref:System.Text.RegularExpressions.Regex> de l’objet avec le modèle d’expression régulière spécifiée et en appelant la méthode d’instance `Replace`.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Si vous spécifiez <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> pour le `options` de paramètre, la recherche de correspondances commence à la fin de la chaîne d’entrée et les déplace vers la gauche ; sinon, la recherche commence au début de la chaîne d’entrée et déplacé vers la droite.  
  
 Le `replacement` paramètre spécifie la chaîne qui doit remplacer chaque correspondance dans `input`. `replacement` peut être constitué de n’importe quelle combinaison de texte littéral et [substitutions](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Par exemple, le modèle de remplacement `a*${test}b` insère la chaîne « un * » suivie de la sous-chaîne qui est mis en correspondance par le `test` groupe de capture, le cas échéant, suivie de la chaîne « b ». Le * caractère n’est pas reconnu comme un caractère de remplacement dans un modèle de remplacement.  
  
> [!NOTE]
>  Les substitutions sont les éléments de langage d’expression régulière seulement sont reconnus dans un modèle de remplacement. Tous les autres éléments de langage d’expression régulière, notamment [caractère d’échappement](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sont autorisées dans les modèles d’expressions régulières uniquement et ne sont pas reconnues dans les modèles de remplacement.  
  
 Le `matchTimeout` paramètre spécifie la manière dont la durée pendant laquelle un modèle de correspondance méthode doit essayer de trouver une correspondance avant son expiration. Définition d’un intervalle de délai d’attente empêche des expressions régulières qui s’appuient sur une rétroaction excessive d’apparaître à cesser de répondre lorsqu’elles traitent une entrée qui contient près de correspondances. Pour plus d’informations, consultez [meilleures pratiques pour les Expressions régulières](~/docs/standard/base-types/best-practices.md) et [rétroaction](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Si aucune correspondance n’est trouvée dans cet intervalle de temps, la méthode lève un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception. `matchTimeout` remplace toute valeur de délai d’attente par défaut défini pour le domaine d’application dans laquelle la méthode s’exécute.  
  
 Étant donné que la méthode retourne `input` inchangé s’il n’existe aucune correspondance, vous pouvez utiliser la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> méthode pour remplacer les noms d’ordinateur et le lecteur locales dans un chemin d’accès UNC avec un chemin d’accès de fichier local. L’expression régulière utilise la <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriété à inclure le nom de l’ordinateur local et le <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> méthode pour inclure les noms des lecteurs logiques. Toutes les comparaisons de chaîne d’expression régulière respectent la casse, et toute opération de remplacement unique expire si une correspondance est introuvable dans 0,5 seconde. Pour exécuter l’exemple, vous devez remplacer la chaîne littérale « Monordinateur » par le nom de votre ordinateur local.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 Le modèle d’expression régulière est défini par l’expression suivante :  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 Le tableau suivant montre comment le modèle d'expression régulière est interprété.  
  
|Motif|Description |  
|-------------|-----------------|  
|`\\\\`|Barre oblique inverse consécutif de correspondance deux (`\`) caractères. Étant donné que le caractère barre oblique inverse est interprété comme caractère d’échappement, chaque barre oblique inverse doit être précédé d’une autre barre oblique inverse.|  
|`+ Environment.MachineName +`|Correspond à la chaîne retournée par la <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriété.|  
|`(?:\.\w+)*`|Correspond à la période (`.`) caractères suivi d’un ou plusieurs caractères alphabétiques. Cette correspondance peut se produire zéro ou plusieurs fois. La sous-expression mise en correspondance n’est pas capturée.|  
|`\\`|Correspond à une barre oblique inverse (`\`) caractères.|  
|`([" + driveNames + "])`|Correspond à la classe de caractères qui se compose de lettres de lecteur individuelles. Cette correspondance est la première sous-expression capturée.|  
|`\$`|Correspond au signe dollar littéral (`$`) caractères.|  
  
 Le modèle de remplacement `$1` remplace la correspondance entière par la première sous-expression capturée. Autrement dit, il remplace le nom d’ordinateur et le lecteur UNC par la lettre de lecteur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> ou <paramref name="replacement" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> n’est pas une combinaison d’opérations au niveau du bit de valeurs <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
ou 
 <paramref name="matchTimeout" /> a une valeur négative, nulle ou supérieure à environ 24 jours.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un dépassement du délai d’attente s’est produit. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <block subset="none" type="usage"><para>Nous vous recommandons de définir le <paramref name="matchTimeout" /> paramètre à une valeur appropriée, comme les deux secondes. Si vous désactivez des délais d’attente en spécifiant <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, le moteur d’expression régulière offre des performances légèrement meilleures. Toutefois, vous devez désactiver les délais d’attente uniquement dans les conditions suivantes : 
-Lorsque l’entrée traitée par une expression régulière est dérivée d’une source connue et approuvée ou se compose de texte statique. Cela exclut le texte qui a été dynamiquement par les utilisateurs.  
  
-Lorsque le modèle d’expression régulière a été testé pour s’assurer qu’elle gère efficacement corresponde au, non-correspondances et proche.  
  
-Lorsque le modèle d’expression régulière ne contient aucun élément de langage qui est connus pour provoquer une rétroaction excessive lors du traitement d’une correspondance proche.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substitutions</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Rétroaction</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Meilleures pratiques des expressions régulières dans le .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne dans laquelle une correspondance doit être recherchée.</param>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <param name="evaluator">Méthode personnalisée qui examine chaque correspondance et retourne la chaîne correspondante d'origine ou une chaîne de remplacement.</param>
        <param name="options">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</param>
        <param name="matchTimeout">Intervalle de délai d’attente ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> pour indiquer que la méthode ne doit pas expirer.</param>
        <summary>Dans la chaîne d’entrée spécifiée, remplace toutes les sous-chaînes qui correspondent à une expression régulière spécifiée par une chaîne retournée par un délégué <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Les paramètres supplémentaires spécifient les options qui modifient l'opération et l'intervalle de délai d'attente correspondants si aucune correspondance n'est trouvée.</summary>
        <returns>Nouvelle chaîne identique à la chaîne d'entrée, sauf que la chaîne de remplacement remplace chaque chaîne correspondante. Si <paramref name="pattern" /> n’a pas de correspondance dans l’instance actuelle, la méthode retourne l’instance actuelle inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> méthode est utile pour remplacer une correspondance d’expression régulière si une des conditions suivantes est vraie :  
  
-   Si la chaîne de remplacement ne peut pas être facilement spécifiée par un modèle de remplacement d’expression régulière.  
  
-   Si la chaîne de remplacement résulte d’un traitement est effectuée sur la chaîne correspondante.  
  
-   Si la chaîne de remplacement résulte de traitement conditionnel.  
  
 La méthode revient à appeler le <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> méthode et passer chaque <xref:System.Text.RegularExpressions.Match> objet retourné <xref:System.Text.RegularExpressions.MatchCollection> collection à la `evaluator` déléguer.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Le `evaluator` paramètre est le délégué d’une méthode personnalisée que vous définissez et qui examine chaque correspondance. La méthode personnalisée doit avoir la signature suivante pour faire correspondre le <xref:System.Text.RegularExpressions.MatchEvaluator> déléguer.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Votre méthode personnalisée retourne une chaîne qui remplace l’entrée correspondante.  
  
 Si vous spécifiez <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> pour le `options` de paramètre, la recherche de correspondances commence à la fin de la chaîne d’entrée et les déplace vers la gauche ; sinon, la recherche commence au début de la chaîne d’entrée et déplacé vers la droite.  
  
 Le `matchTimeout` paramètre spécifie la manière dont la durée pendant laquelle un modèle de correspondance méthode doit essayer de trouver une correspondance avant son expiration. Définition d’un intervalle de délai d’attente empêche des expressions régulières qui s’appuient sur une rétroaction excessive d’apparaître à « cesser de répondre lorsqu’elles traitent une entrée qui contient près de correspondances. Pour plus d’informations, consultez [meilleures pratiques pour les Expressions régulières](~/docs/standard/base-types/best-practices.md) et [rétroaction](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Si aucune correspondance n’est trouvée dans cet intervalle de temps, la méthode lève un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception. `matchTimeout` remplace toute valeur de délai d’attente par défaut défini pour le domaine d’application dans laquelle la méthode s’exécute.  
  
 Étant donné que la méthode retourne `input` inchangé s’il n’existe aucune correspondance, vous pouvez utiliser la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> méthode pour déterminer si la méthode a apporté des remplacements pour la chaîne d’entrée.  
  
   
  
## Examples  
 L’exemple suivant utilise une expression régulière pour extraire les mots individuels d’une chaîne, puis utilise un <xref:System.Text.RegularExpressions.MatchEvaluator> délégué à appeler une méthode nommée `WordScramble` qui brouille les lettres individuelles dans le mot. Pour ce faire, le `WordScramble` méthode crée un tableau qui contient les caractères dans la correspondance. Il crée également un tableau parallèle qu’il remplit avec des nombres à virgule flottante aléatoire. Les tableaux sont triés en appelant le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> (méthode) et le tableau trié est fourni en tant qu’argument à un <xref:System.String> constructeur de classe. Cette chaîne nouvellement créée est ensuite retournée par la `WordScramble` (méthode). Le modèle d’expression régulière `\w+` correspond à un ou plusieurs caractères alphabétiques ; le moteur d’expression régulière continue à ajouter des caractères à la correspondance jusqu'à ce qu’il rencontre un caractère non alphabétique, par exemple un caractère d’espace blanc. L’appel à la <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> méthode inclut la <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option afin que le commentaire dans le modèle d’expression régulière `\w+  # Matches all the characters in a word.` est ignoré par le moteur d’expression régulière.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> ou <paramref name="evaluator" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> n’est pas une combinaison d’opérations au niveau du bit de valeurs <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
- ou - 
 <paramref name="matchTimeout" /> a une valeur négative, nulle ou supérieure à environ 24 jours.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un dépassement du délai d’attente s’est produit. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <block subset="none" type="usage"><para>Nous vous recommandons de définir le <paramref name="matchTimeout" /> paramètre à une valeur appropriée, comme les deux secondes. Si vous désactivez des délais d’attente en spécifiant <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, le moteur d’expression régulière offre des performances légèrement meilleures. Toutefois, vous devez désactiver les délais d’attente uniquement dans les conditions suivantes : 
-Lorsque l’entrée traitée par une expression régulière est dérivée d’une source connue et approuvée ou se compose de texte statique. Cela exclut le texte qui a été dynamiquement par les utilisateurs.  
  
-Lorsque le modèle d’expression régulière a été testé pour s’assurer qu’elle gère efficacement corresponde au, non-correspondances et proche.  
  
-Lorsque le modèle d’expression régulière ne contient aucun élément de langage qui est connus pour provoquer une rétroaction excessive lors du traitement d’une correspondance proche.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Substitutions</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Rétroaction</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Meilleures pratiques des expressions régulières dans le .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l'expression régulière cherche de droite à gauche.</summary>
        <value><see langword="true" /> si l'expression régulière cherche de droite à gauche ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> est `true` si le <xref:System.Text.RegularExpressions.Regex> instance a été créée avec le <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> option.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" />Utilisé par un objet généré par la méthode <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fractionne une chaîne d'entrée en tableau de sous-chaînes aux positions définies par une correspondance d'expression régulière.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne à fractionner.</param>
        <summary>Fractionne une chaîne d'entrée en un tableau de sous-chaînes, aux positions définies par un modèle d'expression régulière spécifié dans le constructeur <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Tableau de chaînes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> méthodes sont similaires à la <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> (méthode), à ceci près que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> fractionne la chaîne à un délimiteur déterminé par une expression régulière au lieu d’un jeu de caractères. La chaîne est fractionnée autant de fois que possible. Si aucun délimiteur n’est trouvé, la valeur de retour contient un élément dont la valeur est la chaîne d’entrée d’origine.  
  
 Si plusieurs correspondances sont adjacentes, une chaîne vide est insérée dans le tableau. Par exemple, le fractionnement d’une chaîne sur un seul trait d’union, le tableau retourné inclure une chaîne vide à la position où sont trouvent les deux traits d’union, comme le montre le code suivant.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 Si une correspondance est trouvée au début ou à la fin de la chaîne d’entrée, une chaîne vide est incluse au début ou à la fin du tableau retourné. L’exemple suivant utilise le modèle d’expression régulière `\d+` pour fractionner une chaîne d’entrée sur des caractères numériques. Étant donné que la chaîne commence et se termine avec la mise en correspondance des caractères numériques, la valeur de l’élément de premier et dernier du tableau retourné est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 Si les parenthèses de capture sont utilisées dans un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expression, tout texte capturée est inclus dans le tableau de chaînes qui en résulte. Par exemple, si vous fractionnez la chaîne « plum-pear » sur un trait d’union placé dans les parenthèses de capture, le tableau retourné inclut un élément de chaîne qui contient le trait d’union.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 Toutefois, lorsque le modèle d’expression régulière inclut plusieurs jeux de parenthèses de capture, le comportement de cette méthode dépend de la version du .NET Framework. Dans le .NET Framework 1.0 et 1.1, si une correspondance est introuvable dans le premier jeu de parenthèses, de texte capturé à partir des autres parenthèses de capture n’est pas inclus dans le tableau retourné. À compter de .NET Framework 2.0, tout le texte capturé est également ajouté au tableau retourné. Par exemple, le code suivant utilise deux jeux de parenthèses de capture pour extraire les éléments d’une date, y compris les séparateurs de date, d’une chaîne de date. Le premier jeu de parenthèses de capture capture le trait d’union, et la deuxième capture la barre oblique. Si l’exemple de code est compilé et exécuté sous le .NET Framework 1.0 ou 1.1, il exclut les barres obliques ; s’il est compilé et exécuté sous le .NET Framework 2.0 ou versions ultérieures, il les inclut.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 Si l’expression régulière peut correspondre à une chaîne vide, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> fractionne la chaîne en un tableau de chaînes à caractère unique, car le délimiteur de chaîne vide peut être trouvé à chaque emplacement. Par exemple :  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 Notez que le tableau retourné inclut également une chaîne vide au début et à la fin du tableau.  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de fractionnement dépasse l’intervalle de délai d’attente spécifié par le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructeur. Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est créé. Si aucun délai d’attente n’est défini dans le <xref:System.Text.RegularExpressions.Regex> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne à fractionner.</param>
        <param name="count">Nombre maximal de fois où le fractionnement peut avoir lieu.</param>
        <summary>Fractionne une chaîne d'entrée spécifiée un nombre de fois maximal spécifié en un tableau de sous-chaînes, aux positions définies par une expression régulière spécifiée dans le constructeur <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Tableau de chaînes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> méthodes sont similaires à la <xref:System.String.Split%2A?displayProperty=nameWithType> (méthode), à ceci près que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> fractionne la chaîne à un délimiteur déterminé par une expression régulière au lieu d’un jeu de caractères. Le `count` paramètre spécifie le nombre maximal de sous-chaînes dans lesquelles la `input` chaîne peut être fractionnée ; la dernière chaîne contient la fractionnée de la chaîne. Un `count` valeur zéro fournit le comportement par défaut de fractionnement autant de fois que possible.  
  
 Si plusieurs correspondances sont adjacentes ou si une correspondance est trouvée au début ou à la fin de `input`, et le nombre de correspondances trouvées est au moins deux inférieur à `count`, une chaîne vide est insérée dans le tableau. Autrement dit, les chaînes vides qui résultent de correspondances adjacentes ou de correspondances au début ou à la fin de la chaîne d’entrée sont comptés pour déterminer si le nombre de mises en correspondance de sous-chaînes equals `count`. Dans l’exemple suivant, l’expression régulière `/d+` est utilisé pour fractionner une chaîne d’entrée qui inclut un ou plusieurs chiffres décimaux en un maximum de trois des sous-chaînes. Étant donné que le début de la chaîne d’entrée correspond au modèle d’expression régulière, le premier élément du tableau contient <xref:System.String.Empty?displayProperty=nameWithType>, le deuxième contient le premier jeu de caractères alphabétiques dans la chaîne d’entrée et le troisième contient le reste de la chaîne qui suit la correspondance de tiers.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 Si les parenthèses de capture sont utilisées dans une expression régulière, n’importe quel texte capturé est inclus dans le tableau de chaînes fractionnées. Toutefois, tous les éléments de tableau qui contiennent le texte capturé ne sont pas comptés pour déterminer si le nombre de correspondances a atteint `count`. Par exemple, si la chaîne « apple-apricot-plum-pear-banana » en un maximum de quatre résultats sous-chaînes dans un tableau de sept éléments, comme le code suivant montre.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 Toutefois, lorsque le modèle d’expression régulière inclut plusieurs jeux de parenthèses de capture, le comportement de cette méthode dépend de la version du .NET Framework. Dans le .NET Framework 1.0 et 1.1, seul le texte capturé à partir du premier jeu de parenthèses de capture est inclus dans le tableau retourné. À compter de .NET Framework 2.0, tout le texte capturé est ajouté au tableau retourné. Toutefois, les éléments dans le tableau retourné qui contiennent le texte capturé ne sont pas comptés pour déterminer si le nombre de mises en correspondance de sous-chaînes equals `count`. Par exemple, dans le code suivant, une expression régulière utilise deux jeux de parenthèses de capture pour extraire les éléments d’une date à partir d’une chaîne de date. Le premier jeu de parenthèses de capture capture le trait d’union, et la deuxième capture la barre oblique. L’appel à la <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> méthode spécifie ensuite un maximum de deux éléments dans le tableau retourné. Si l’exemple de code est compilé et exécuté sous le .NET Framework 1.0 ou 1.1, la méthode retourne un tableau de chaînes de deux éléments. S’il est compilé et exécuté sous le .NET Framework 2.0 ou versions ultérieures, la méthode retourne un tableau de chaînes de trois éléments.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 Si l’expression régulière peut correspondre à une chaîne vide, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> fractionne la chaîne en un tableau de chaînes à caractère unique, car le délimiteur de chaîne vide peut être trouvé à chaque emplacement. L’exemple suivant fractionne la chaîne « characters » en comme de nombreux éléments qu’il y dans la chaîne d’entrée. Étant donné que la chaîne null correspond au début de la chaîne d’entrée, une chaîne null est insérée au début du tableau retourné. Cela entraîne le dixième élément se compose de deux caractères à la fin de la chaîne d’entrée.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de fractionnement dépasse l’intervalle de délai d’attente spécifié par le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructeur. Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est créé. Si aucun délai d’attente n’est défini dans le <xref:System.Text.RegularExpressions.Regex> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne à fractionner.</param>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <summary>Fractionne une chaîne d’entrée en tableau de sous-chaînes aux positions définies par un modèle d’expression régulière.</summary>
        <returns>Tableau de chaînes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> méthodes sont similaires à la <xref:System.String.Split%2A?displayProperty=nameWithType> (méthode), à ceci près que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> fractionne la chaîne à un délimiteur déterminé par une expression régulière au lieu d’un jeu de caractères. Le `input` chaîne est fractionnée autant de fois que possible. Si `pattern` est introuvable dans le `input` chaîne, la valeur de retour contient un élément dont la valeur est la version d’origine `input` chaîne.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Les expressions régulières utilisées dans les appels statiques compilées <xref:System.Text.RegularExpressions.Regex.Split%2A> méthodes sont mis en cache automatiquement. Pour gérer la durée de vie des expressions régulières compilées vous-même, utilisez l’instance <xref:System.Text.RegularExpressions.Regex.Split%2A> méthodes.  
  
 Si plusieurs correspondances sont adjacentes, une chaîne vide est insérée dans le tableau. Par exemple, le fractionnement d’une chaîne sur un seul trait d’union, le tableau retourné inclure une chaîne vide à la position où sont trouvent les deux traits d’union, comme le montre le code suivant.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 Si une correspondance est trouvée au début ou à la fin de la chaîne d’entrée, une chaîne vide est incluse au début ou à la fin du tableau retourné. L’exemple suivant utilise le modèle d’expression régulière `\d+` pour fractionner une chaîne d’entrée sur des caractères numériques. Étant donné que la chaîne commence et se termine avec la mise en correspondance des caractères numériques, la valeur de l’élément de premier et dernier du tableau retourné est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 Si les parenthèses de capture sont utilisées dans un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expression, tout texte capturée est inclus dans le tableau de chaînes qui en résulte. Par exemple, si vous fractionnez la chaîne « plum-pear » sur un trait d’union placé dans les parenthèses de capture, le tableau retourné inclut un élément de chaîne qui contient le trait d’union.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Toutefois, lorsque le modèle d’expression régulière inclut plusieurs jeux de parenthèses de capture, le comportement de cette méthode dépend de la version du .NET Framework. Dans le .NET Framework 1.0 et 1.1, si une correspondance est introuvable dans le premier jeu de parenthèses, de texte capturé à partir des autres parenthèses de capture n’est pas inclus dans le tableau retourné. À compter de .NET Framework 2.0, tout le texte capturé est également ajouté au tableau retourné. Par exemple, le code suivant utilise deux jeux de parenthèses de capture pour extraire les éléments d’une date, y compris les séparateurs de date, d’une chaîne de date. Le premier jeu de parenthèses de capture capture le trait d’union, et la deuxième capture la barre oblique. Si l’exemple de code est compilé et exécuté sous le .NET Framework 1.0 ou 1.1, il exclut les barres obliques ; s’il est compilé et exécuté sous le .NET Framework 2.0 ou versions ultérieures, il les inclut.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Si l’expression régulière peut correspondre à une chaîne vide, <xref:System.Text.RegularExpressions.Regex.Split%2A> fractionne la chaîne en un tableau de chaînes à caractère unique, car le délimiteur de chaîne vide peut être trouvé à chaque emplacement. Par exemple :  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 Notez que le tableau retourné inclut également une chaîne vide au début et à la fin du tableau.  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de fractionnement dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée. Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="pattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <block subset="none" type="usage"><para>Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans lequel la méthode est appelée. Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, ce qui empêche la méthode de délai d’expiration, est utilisé. La méthode statique recommandée pour fractionner le texte sur une correspondance de modèle est <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, qui vous permet de définir l’intervalle de délai d’attente.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne à fractionner.</param>
        <param name="count">Nombre maximal de fois où le fractionnement peut avoir lieu.</param>
        <param name="startat">Position du caractère dans la chaîne d'entrée où la recherche commencera.</param>
        <summary>Fractionne une chaîne d'entrée spécifiée un nombre de fois maximal spécifié en un tableau de sous-chaînes, aux positions définies par une expression régulière spécifiée dans le constructeur <see cref="T:System.Text.RegularExpressions.Regex" />. La recherche du modèle d’expression régulière débute à une position de caractère spécifiée dans la chaîne d’entrée.</summary>
        <returns>Tableau de chaînes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> méthodes sont similaires à la <xref:System.String.Split%2A?displayProperty=nameWithType> (méthode), à ceci près que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> fractionne la chaîne à un délimiteur déterminé par une expression régulière au lieu d’un jeu de caractères. Le `count` paramètre spécifie le nombre maximal de sous-chaînes dans lesquelles la `input` chaîne est fractionnée ; la dernière chaîne contient la fractionnée de la chaîne. Un `count` valeur zéro fournit le comportement par défaut de fractionnement autant de fois que possible. Le `startat` paramètre définit le point à partir duquel commence la recherche pour le premier délimiteur (Cela peut être utilisé pour ignorer l’espace blanc de début).  
  
 Si aucune correspondance n’est trouvée à partir de la `count`+ 1 positionner dans la chaîne, la méthode retourne un tableau d’un élément qui contient le `input` chaîne. Si un ou plusieurs correspondances sont trouvées, le premier élément du tableau retourné contient la première partie de la chaîne au premier caractère jusqu'à un caractère avant la correspondance.  
  
 Si plusieurs correspondances sont adjacentes et le nombre de correspondances trouvées est au moins deux inférieur à `count`, une chaîne vide est insérée dans le tableau. De même, si une correspondance est trouvée à `startat`, qui est le premier caractère dans la chaîne, le premier élément du tableau retourné est une chaîne vide. Autrement dit, les chaînes vides qui résultent des correspondances adjacentes sont comptés pour déterminer si le nombre de mises en correspondance de sous-chaînes equals `count`. Dans l’exemple suivant, l’expression régulière `\d+` est utilisé pour rechercher la position de départ de la première sous-chaîne de caractères numériques dans une chaîne, puis fractionne la chaîne pour un maximum de trois fois à partir de cette position. Étant donné que le modèle d’expression régulière correspond au début de la chaîne d’entrée, le tableau de chaînes retourné se compose d’une chaîne vide, une chaîne de caractères alphabétiques cinq caractères et le reste de la chaîne,  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 Si les parenthèses de capture sont utilisées dans une expression régulière, n’importe quel texte capturé est inclus dans le tableau de chaînes fractionnées. Toutefois, tous les éléments de tableau qui contiennent le texte capturé ne sont pas comptés pour déterminer si le nombre de correspondances a atteint `count`. Par exemple, si la chaîne « « apple-apricot-plum-pear-pomegranate-pineapple-peach » est fractionnée en un maximum de quatre sous-chaînes en commençant à caractère 15 dans les résultats de la chaîne dans un tableau de sept éléments, comme le montre le code suivant.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 Toutefois, lorsque le modèle d’expression régulière inclut plusieurs jeux de parenthèses de capture, le comportement de cette méthode dépend de la version du .NET Framework. Dans .NET Framework 1.0 et 1.1, si une correspondance est introuvable dans le premier jeu de parenthèses, de texte capturé à partir des autres parenthèses de capture n’est pas inclus dans le tableau retourné. À compter de .NET Framework 2.0, tout le texte capturé est également ajouté au tableau retourné. Par exemple, le code suivant utilise deux jeux de parenthèses de capture pour extraire les mots individuels dans une chaîne. Le premier jeu de parenthèses de capture capture le trait d’union, et la deuxième capture la barre verticale. Si l’exemple de code est compilé et exécuté sous le .NET Framework 1.0 ou 1.1, il exclut la verticale de la barre des caractères ; s’il est compilé et exécuté sous le .NET Framework 2.0 ou versions ultérieures, il les inclut.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 Si l’expression régulière peut correspondre à une chaîne vide, <xref:System.Text.RegularExpressions.Regex.Split%2A> fractionne la chaîne en un tableau de chaînes à caractère unique, car le délimiteur de chaîne vide peut être trouvé à chaque emplacement. L’exemple suivant fractionne les caractères « chaîne » en autant d’éléments que contient de la chaîne d’entrée, en commençant par le caractère « a ». Étant donné que la chaîne null correspond à la fin de la chaîne d’entrée, une chaîne null est insérée à la fin du tableau retourné.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de fractionnement dépasse l’intervalle de délai d’attente spécifié par le <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructeur. Si vous ne définissez pas un intervalle de délai d’attente lorsque vous appelez le constructeur, l’exception est levée si l’opération dépasse une valeur de délai d’attente établie pour le domaine d’application dans lequel le <xref:System.Text.RegularExpressions.Regex> objet est créé. Si aucun délai d’attente n’est défini dans le <xref:System.Text.RegularExpressions.Regex> appel de constructeur ou dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> est inférieur à zéro ou supérieur à la longueur de <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne à fractionner.</param>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <param name="options">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</param>
        <summary>Fractionne une chaîne d’entrée en tableau de sous-chaînes aux positions définies par un modèle d’expression régulière spécifié. Les options spécifiées modifient l'opération correspondante.</summary>
        <returns>Tableau de chaînes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> méthodes sont similaires à la <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> (méthode), à ceci près que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> fractionne la chaîne à un délimiteur déterminé par une expression régulière au lieu d’un jeu de caractères. La chaîne est fractionnée autant de fois que possible. Si aucun délimiteur n’est trouvé, la valeur de retour contient un élément dont la valeur est la version d’origine `input` chaîne.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Les expressions régulières utilisées dans les appels statiques compilées <xref:System.Text.RegularExpressions.Regex.Split%2A> méthodes sont mis en cache automatiquement. Pour gérer la durée de vie des expressions régulières compilées vous-même, utilisez l’instance <xref:System.Text.RegularExpressions.Regex.Split%2A> méthodes.  
  
 Si plusieurs correspondances sont adjacentes, une chaîne vide est insérée dans le tableau. Par exemple, le fractionnement d’une chaîne sur un seul trait d’union, le tableau retourné inclure une chaîne vide à la position où sont trouvent les deux traits d’union.  
  
 Si une correspondance est trouvée au début ou à la fin de la chaîne d’entrée, une chaîne vide est incluse au début ou à la fin du tableau retourné. L’exemple suivant utilise le modèle d’expression régulière `[a-z]+` pour fractionner une chaîne d’entrée sur n’importe quel caractère alphabétique majuscule ou minuscule. Étant donné que la chaîne commence et se termine avec la mise en correspondance des caractères alphabétiques, la valeur de l’élément de premier et dernier du tableau retourné est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 Si les parenthèses de capture sont utilisées dans un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expression, tout texte capturée est inclus dans le tableau de chaînes qui en résulte. Par exemple, si vous fractionnez la chaîne « plum-pear » sur un trait d’union placé dans les parenthèses de capture, le tableau retourné inclut un élément de chaîne qui contient le trait d’union.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Toutefois, lorsque le modèle d’expression régulière inclut plusieurs jeux de parenthèses de capture, le comportement de cette méthode dépend de la version du .NET Framework. Dans le .NET Framework 1.0 et 1.1, si une correspondance est introuvable dans le premier jeu de parenthèses, de texte capturé à partir des autres parenthèses de capture n’est pas inclus dans le tableau retourné. À compter de .NET Framework 2.0, tout le texte capturé est également ajouté au tableau retourné. Par exemple, le code suivant utilise deux jeux de parenthèses de capture pour extraire les éléments d’une date, y compris les séparateurs de date, d’une chaîne de date. Le premier jeu de parenthèses de capture capture le trait d’union, et la deuxième capture la barre oblique. Si l’exemple de code est compilé et exécuté sous le .NET Framework 1.0 ou 1.1, il exclut les barres obliques ; s’il est compilé et exécuté sous le .NET Framework 2.0 ou versions ultérieures, il les inclut.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Si l’expression régulière peut correspondre à une chaîne vide, <xref:System.Text.RegularExpressions.Regex.Split%2A> fractionne la chaîne en un tableau de chaînes à caractère unique, car le délimiteur de chaîne vide peut être trouvé à chaque emplacement.  
  
 Le <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception est levée si la durée d’exécution de l’opération de fractionnement dépasse l’intervalle de délai d’attente spécifié pour le domaine d’application dans lequel la méthode est appelée. Si aucun délai d’attente n’est défini dans les propriétés du domaine d’application, ou si la valeur de délai d’attente est <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, aucune exception n’est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="pattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> n’est pas une combinaison valide au niveau du bit de valeurs <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un délai d’attente a expiré. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <block subset="none" type="usage"><para>Cette méthode expire après un intervalle est égal à la valeur de délai d’attente par défaut du domaine d’application dans lequel la méthode est appelée. Si une valeur de délai d’attente n’a pas été définie pour le domaine d’application, la valeur <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, ce qui empêche la méthode de délai d’expiration, est utilisé. La méthode statique recommandée pour fractionner le texte sur une correspondance de modèle est <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, qui vous permet de définir l’intervalle de délai d’attente.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Chaîne à fractionner.</param>
        <param name="pattern">Modèle d’expression régulière à mettre en correspondance.</param>
        <param name="options">Combinaison d'opérations de bits des valeurs d'énumération qui fournissent des options pour la correspondance.</param>
        <param name="matchTimeout">Intervalle de délai d’attente ou <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> pour indiquer que la méthode ne doit pas expirer.</param>
        <summary>Fractionne une chaîne d’entrée en tableau de sous-chaînes aux positions définies par un modèle d’expression régulière spécifié. Les paramètres supplémentaires spécifient les options qui modifient l'opération et l'intervalle de délai d'attente correspondants si aucune correspondance n'est trouvée.</summary>
        <returns>Tableau de chaînes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> méthodes sont similaires à la <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> (méthode), à ceci près que <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> fractionne la chaîne à un délimiteur déterminé par une expression régulière au lieu d’un jeu de caractères. La chaîne est fractionnée autant de fois que possible. Si aucun délimiteur n’est trouvé, la valeur de retour contient un élément dont la valeur est la version d’origine `input` chaîne.  
  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Les expressions régulières utilisées dans les appels statiques compilées <xref:System.Text.RegularExpressions.Regex.Split%2A> méthodes sont mis en cache automatiquement. Pour gérer la durée de vie des expressions régulières compilées vous-même, utilisez l’instance <xref:System.Text.RegularExpressions.Regex.Split%2A> méthodes.  
  
 Si plusieurs correspondances sont adjacentes, une chaîne vide est insérée dans le tableau. Par exemple, le fractionnement d’une chaîne sur un seul trait d’union, le tableau retourné inclure une chaîne vide à la position où sont trouvent les deux traits d’union.  
  
 Si une correspondance est trouvée au début ou à la fin de la chaîne d’entrée, une chaîne vide est incluse au début ou à la fin du tableau retourné. L’exemple suivant utilise le modèle d’expression régulière `[a-z]+` pour fractionner une chaîne d’entrée sur n’importe quel caractère alphabétique majuscule ou minuscule. Étant donné que la chaîne commence et se termine avec la mise en correspondance des caractères alphabétiques, la valeur de l’élément de premier et dernier du tableau retourné est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 Si les parenthèses de capture sont utilisées dans un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> expression, tout texte capturée est inclus dans le tableau de chaînes qui en résulte. Par exemple, si vous fractionnez la chaîne « plum-pear » sur un trait d’union placé dans les parenthèses de capture, le tableau retourné inclut un élément de chaîne qui contient le trait d’union.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Toutefois, lorsque le modèle d’expression régulière inclut plusieurs jeux de parenthèses de capture, le comportement de cette méthode dépend de la version du .NET Framework. Dans le .NET Framework 1.0 et 1.1, si une correspondance est introuvable dans le premier jeu de parenthèses, de texte capturé à partir des autres parenthèses de capture n’est pas inclus dans le tableau retourné. À compter de .NET Framework 2.0, tout le texte capturé est également ajouté au tableau retourné. Par exemple, le code suivant utilise deux jeux de parenthèses de capture pour extraire les éléments d’une date, y compris les séparateurs de date, d’une chaîne de date. Le premier jeu de parenthèses de capture capture le trait d’union, et la deuxième capture la barre oblique. Si l’exemple de code est compilé et exécuté sous le .NET Framework 1.0 ou 1.1, il exclut les barres obliques ; s’il est compilé et exécuté sous le .NET Framework 2.0 ou versions ultérieures, il les inclut.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Si l’expression régulière peut correspondre à une chaîne vide, <xref:System.Text.RegularExpressions.Regex.Split%2A> fractionne la chaîne en un tableau de chaînes à caractère unique, car le délimiteur de chaîne vide peut être trouvé à chaque emplacement.  
  
 Le `matchTimeout` paramètre spécifie la manière dont la durée pendant laquelle un modèle de correspondance méthode doit essayer de trouver une correspondance avant son expiration. Définition d’un intervalle de délai d’attente empêche des expressions régulières qui s’appuient sur une rétroaction excessive d’apparaître à cesser de répondre lorsqu’elles traitent une entrée qui contient près de correspondances. Pour plus d’informations, consultez [meilleures pratiques pour les Expressions régulières](~/docs/standard/base-types/best-practices.md) et [rétroaction](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Si aucune correspondance n’est trouvée dans cet intervalle de temps, la méthode lève un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception. `matchTimeout` remplace toute valeur de délai d’attente par défaut défini pour le domaine d’application dans laquelle la méthode s’exécute.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une erreur d’analyse d’expression régulière s’est produite.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ou <paramref name="pattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> n’est pas une combinaison valide au niveau du bit de valeurs <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
ou 
 <paramref name="matchTimeout" /> a une valeur négative, nulle ou supérieure à environ 24 jours.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Un dépassement du délai d’attente s’est produit. Pour plus d’informations sur les dépassements de délai d’attente, consultez la section Notes.</exception>
        <block subset="none" type="usage"><para>Nous vous recommandons de définir le <paramref name="matchTimeout" /> paramètre à une valeur appropriée, comme les deux secondes. Si vous désactivez des délais d’attente en spécifiant <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, le moteur d’expression régulière offre des performances légèrement meilleures. Toutefois, vous devez désactiver les délais d’attente uniquement dans les conditions suivantes : 
-Lorsque l’entrée traitée par une expression régulière est dérivée d’une source connue et approuvée ou se compose de texte statique. Cela exclut le texte qui a été dynamiquement par les utilisateurs.  
  
-Lorsque le modèle d’expression régulière a été testé pour s’assurer qu’elle gère efficacement corresponde au, non-correspondances et proche.  
  
-Lorsque le modèle d’expression régulière ne contient aucun élément de langage qui est connus pour provoquer une rétroaction excessive lors du traitement d’une correspondance proche.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Éléments du langage des expressions régulières</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">Objet à remplir avec des informations de sérialisation.</param>
        <param name="context">Emplacement de stockage et de récupération des données sérialisées. Ce paramètre est réservé pour une future utilisation.</param>
        <summary>Remplit un objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> avec les données nécessaires pour désérialiser l'objet <see cref="T:System.Text.RegularExpressions.Regex" /> actuel.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le modèle d'expression régulière qui a été passé au constructeur <see langword="Regex" />.</summary>
        <returns>Paramètre <paramref name="pattern" /> qui a été passé au constructeur <see langword="Regex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `pattern` paramètre se compose des éléments de langage d’expression régulière qui décrivent symboliquement la chaîne à faire correspondre. Pour plus d’informations sur les expressions régulières, consultez [Expressions régulières .NET Framework](~/docs/standard/base-types/regular-expressions.md) et [langage des expressions régulières - aide-mémoire](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> est la classe de base des expressions régulières créée par le <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> (méthode). Ces expressions régulières compilées utilisent le <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> implémentation de la classe de base. Si elle est appelée à partir d’une classe dérivée, la <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> méthode retourne la chaîne qui a été passée à la <paramref name="pattern" /> paramètre de la <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> constructeur de classe qui a été utilisé pour définir l’expression régulière.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Chaîne d'entrée qui contient le texte à convertir.</param>
        <summary>Convertit les caractères d'échappement dans la chaîne d'entrée.</summary>
        <returns>Chaîne de caractères dont les caractères d'échappement remplacés sont remis dans leur forme initiale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.RegularExpressions.Regex.Unescape%2A> méthode effectue l’une des deux transformations suivantes :  
  
-   Il inverse la transformation exécutée par le <xref:System.Text.RegularExpressions.Regex.Escape%2A> méthode en supprimant le caractère d’échappement («\\») à partir de chaque caractère d’échappement par la méthode. Ceux-ci incluent le \\, *, +, ?, &#124;, {, [, (,), ^, $,., # et les caractères d’espace blanc. En outre, le <xref:System.Text.RegularExpressions.Regex.Unescape%2A> méthode annule le remplacement le crochet fermant (]) et les caractères d’accolade (}) de fermeture.  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> ne peut pas inverser une chaîne avec séquence d’échappement parfaitement de parce qu’il ne peut pas déduire précisément quels caractères se sont échappés,  
  
-   Il remplace les valeurs hexadécimales dans les littéraux de chaîne textuelle par les caractères imprimables réelles. Par exemple, il remplace @"\x07" avec « \a », ou @"\x0A" avec « \n ». Il convertit des caractères alphanumériques et des caractères d’échappement prises en charge telles que \a, \b, \e, \n, \r, \f, \t, \v.
  
 Si le <xref:System.Text.RegularExpressions.Regex.Unescape%2A> méthode rencontre d’autres séquences d’échappement qu’il ne peut pas convertir, telles que \w ou \s, elle lève une <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="str" /> inclut une séquence d'échappement non reconnue.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Langage des expressions régulières - Aide-mémoire</related>
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" />Utilisé par un objet généré par la méthode <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns><see langword="true" /> si la propriété <see cref="P:System.Text.RegularExpressions.Regex.Options" /> contient l'option <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" />Utilisé par un objet généré par la méthode <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns><see langword="true" /> si la propriété <see cref="P:System.Text.RegularExpressions.Regex.Options" /> contient l'option <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">Délai d'attente à vérifier.</param>
        <summary>Vérifie si un intervalle de délai d'attente est compris dans une plage acceptable.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>