<Type Name="DependsOnAttribute" FullName="System.Windows.Markup.DependsOnAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7a54265820b84732300967ef429bbd1b8b96d7b3" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30656253" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependsOnAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependsOnAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.DependsOnAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependsOnAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependsOnAttribute sealed : Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indique que la propriété avec attributs dépend de la valeur d’une autre propriété.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Markup.XamlWriter.Save%2A> méthode sur <xref:System.Windows.Markup.XamlWriter> traite avant le traitement de la propriété de cet attribut est défini sur la propriété spécifiée.  
  
 Le `name` valeur appliquée à cet attribut doit être le nom non qualifié simple d’une propriété qui existe dans le même type. Vous ne pouvez pas spécifier de propriétés jointes comme étant dépendants.  
  
 Lorsque vous appliquez cet attribut, doit veiller à éviter les dépendances circulaires.  Les dépendances circulaires sont uniquement détectés lorsque toutes les propriétés dans le cycle ont été écrits et même dans ce cas, le comportement est non déterministe.  
  
 Appliquer cet attribut à une définition de propriété garantit que les propriétés dépendantes sont traitées en premier dans l’écriture d’objet XAML. Il fait partie des règles générales du balisage XAML que les valeurs d’attribut appliqués à un objet créé doivent pouvoir être traitées dans n’importe quel ordre. Utilisations de <xref:System.Windows.Markup.DependsOnAttribute> spécifier les cas exceptionnels de propriétés sur les types où un ordre spécifique d’analyse doit être suivi de la création d’objet valide.  
  
 Dans les versions précédentes du .NET Framework, cette classe existait dans l’assembly WindowsBase spécifique de WPF. Dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Windows.Markup.DependsOnAttribute> est dans l’assembly System.Xaml. Pour plus d’informations, consultez [Types migrés de WPF vers System.Xaml](~/docs/framework/xaml-services/types-migrated-from-wpf-to-system-xaml.md).  
  
## <a name="wpf-usage-notes"></a>Remarques sur l'utilisation de WPF  
 Le <xref:System.Windows.Setter.Value%2A> propriété sur le <xref:System.Windows.Setter> classe est un exemple d’une propriété dans WPF où le <xref:System.Windows.Markup.DependsOnAttribute> attribut est appliqué.  <xref:System.Windows.Setter.Value%2A> dépend de <xref:System.Windows.Setter.Property%2A> et <xref:System.Windows.Setter.TargetName%2A> sont traités en premier, sinon il n’existe aucun moyen connaître le type est censé être créés pour les cas de convertisseur de valeur.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependsOnAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.DependsOnAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependsOnAttribute(System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Propriété de laquelle dépend la propriété associée à ce <see cref="T:System.Windows.Markup.DependsOnAttribute" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Markup.DependsOnAttribute" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.DependsOnAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de la propriété associée déclarée dans <see cref="T:System.Windows.Markup.DependsOnAttribute" />.</summary>
        <value>Nom de la propriété associée.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeId">
      <MemberSignature Language="C#" Value="public override object TypeId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object TypeId" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.DependsOnAttribute.TypeId" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeId As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ TypeId { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un identificateur unique pour ce <see cref="T:System.Windows.Markup.DependsOnAttribute" />.</summary>
        <value>Identificateur unique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une valeur générée qui utilise un comportement de remplacement afin de permettre à plusieurs attributs avec le même <xref:System.Windows.Markup.DependsOnAttribute.Name%2A> à appliquer. Tant que les dépendances ne sont pas circulaires ou ambigües, plusieurs <xref:System.Windows.Markup.DependsOnAttribute> références au même nom de propriété sont prises en charge.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>