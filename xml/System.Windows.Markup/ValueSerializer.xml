<Type Name="ValueSerializer" FullName="System.Windows.Markup.ValueSerializer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="65a7488a614c640ae3cdd3cf8bb8adf47c3ea15d" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="64994678" /></Metadata><TypeSignature Language="C#" Value="public abstract class ValueSerializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ValueSerializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.ValueSerializer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ValueSerializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class ValueSerializer abstract" />
  <TypeSignature Language="F#" Value="type ValueSerializer = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Classe abstraite qui définit le comportement de conversion pour la sérialisation à partir d’une représentation sous forme d’objet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chaîne retournée par un convertisseur pour la sérialisation doit être sans perte et le convertisseur doit toujours retourner la même chaîne pour une valeur particulière.  Si un convertisseur de type (dérivé <xref:System.ComponentModel.TypeConverter>) ne répond pas à ces exigences dans son `ConvertTo` implémentations pour la sortie de chaîne, un custom <xref:System.Windows.Markup.ValueSerializer> doit être déclarée. Soit le <xref:System.Windows.Markup.ValueSerializer> doit respecter la configuration requise, ou une valeur null <xref:System.Windows.Markup.ValueSerializer> doit être associé au type. Un <xref:System.Windows.Markup.ValueSerializer> est associé à un type en appliquant la <xref:System.Windows.Markup.ValueSerializerAttribute> attribut.  
  
 Une valeur null <xref:System.Windows.Markup.ValueSerializer> indique le convertisseur de type doit être ignoré pour les conversions de convert-string du graphique d’objet.  
  
> [!IMPORTANT]
>  Implémentation de <xref:System.Windows.Markup.ValueSerializer> doit éviter de lever des exceptions. Sérialisation peuvent mettre fin à toutes les exceptions levées.  
  
 <xref:System.Windows.Markup.IValueSerializerContext> pour un <xref:System.Windows.Markup.ValueSerializer> et ses API est analogue à <xref:System.ComponentModel.ITypeDescriptorContext> pour un <xref:System.ComponentModel.TypeConverter>. En fait, <xref:System.Windows.Markup.IValueSerializerContext> hérite <xref:System.ComponentModel.ITypeDescriptorContext>. Quand un <xref:System.Windows.Markup.ValueSerializer> API de classe dérivée est appelée, l’appelant (généralement un processus de sérialisation) passe un contexte qui peut fournir certains services. En raison de la recommandation générale qui un <xref:System.Windows.Markup.ValueSerializer> ne doit pas lever d’exceptions. Échec pour retourner un service particulier à partir du contexte ne doit pas également lever des exceptions.  
  
 Dans les versions précédentes du .NET Framework, cette classe existait dans l’assembly WindowsBase spécifique de WPF. Dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Windows.Markup.ValueSerializer> est dans l’assembly System.Xaml. Pour plus d'informations, consultez [Types Migrated from WPF to System.Xaml](~/docs/framework/xaml-services/types-migrated-from-wpf-to-system-xaml.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlXmlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ValueSerializer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le corps de ce constructeur est vide ; le <xref:System.Windows.Markup.ValueSerializer> classe ne contient-elle pas toutes les valeurs qui requièrent une initialisation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertFromString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertFromString (value As String, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à évaluer pour la conversion.</param>
        <param name="context">Informations de contexte utilisées pour la conversion.</param>
        <summary>En cas de substitution dans une classe dérivée, détermine si le <see cref="T:System.String" /> spécifié peut être converti en instance du type que l’implémentation de <see cref="T:System.Windows.Markup.ValueSerializer" /> prend en charge.</summary>
        <returns><see langword="true" /> si la valeur peut être convertie ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourne l’implémentation de base toujours `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertToString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertToString (value As Object, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Objet à évaluer pour la conversion.</param>
        <param name="context">Informations de contexte utilisées pour la conversion.</param>
        <summary>En cas de remplacement dans une classe dérivée, détermine si l’objet spécifié peut être converti en <see cref="T:System.String" />.</summary>
        <returns><see langword="true" /> si <paramref name="value" /> peut être converti en <see cref="T:System.String" /> ; sinon, <see langword="false." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourne l’implémentation de base toujours `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertFromString">
      <MemberSignature Language="C#" Value="public virtual object ConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertFromString (value As String, context As IValueSerializerContext) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj&#xA;override this.ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj" Usage="valueSerializer.ConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à convertir.</param>
        <param name="context">Informations de contexte utilisées pour la conversion.</param>
        <summary>En cas de substitution dans une classe dérivée, convertit un <see cref="T:System.String" /> en une instance du type que l’implémentation de <see cref="T:System.Windows.Markup.ValueSerializer" /> prend en charge.</summary>
        <returns>Nouvelle instance du type que l’implémentation de <see cref="T:System.Windows.Markup.ValueSerializer" /> prend en charge en fonction du <paramref name="value" /> fourni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation de base toujours lève une exception.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> ne peut pas être converti.</exception>
        <block subset="none" type="overrides"><para>Éviter de lever des exceptions à partir des implémentations. Consultez <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ConvertToString">
      <MemberSignature Language="C#" Value="public virtual string ConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertToString (value As Object, context As IValueSerializerContext) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string&#xA;override this.ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string" Usage="valueSerializer.ConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Objet à convertir en chaîne.</param>
        <param name="context">Informations de contexte utilisées pour la conversion.</param>
        <summary>En cas de substitution dans une classe dérivée, convertit l’objet spécifié en <see cref="T:System.String" />.</summary>
        <returns>Représentation sous forme de chaîne de l’objet spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation de base toujours lève une exception.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> ne peut pas être converti.</exception>
        <block subset="none" type="overrides"><para>Éviter de lever des exceptions à partir des implémentations. Consultez <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetConvertFromException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertFromException (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertFromException(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertFromException(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertFromException (value As Object) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertFromException(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetConvertFromException : obj -&gt; Exception" Usage="valueSerializer.GetConvertFromException value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Objet qui n’a pas pu être converti.</param>
        <summary>Retourne une exception à lever quand une conversion ne peut pas être effectuée.</summary>
        <returns>Objet <see cref="T:System.Exception" /> pour l’exception à lever quand une conversion <see langword="ConvertFrom" /> ne peut pas être effectuée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le texte réel `throw` mot clé n’est pas appelé par cette méthode, par conséquent, l’utilisation classique est `throw GetConvertFromException` (avec les paramètres fournis).  
  
 L’exception spécifique retournée est <xref:System.InvalidOperationException>, avec `value` passé dans le message d’exception. Le modèle d’utilisation est identique à celui des utilitaires d’exception dans <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConvertToException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertToException (object value, Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertToException(object value, class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertToException(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertToException (value As Object, destinationType As Type) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertToException(System::Object ^ value, Type ^ destinationType);" />
      <MemberSignature Language="F#" Value="member this.GetConvertToException : obj * Type -&gt; Exception" Usage="valueSerializer.GetConvertToException (value, destinationType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="destinationType" Type="System.Type" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Objet qui n’a pas pu être converti.</param>
        <param name="destinationType">Type qui représente le type cible de la tentative de conversion.</param>
        <summary>Retourne une exception à lever quand une conversion ne peut pas être effectuée.</summary>
        <returns>Objet <see cref="T:System.Exception" /> pour l’exception à lever quand une conversion <see langword="ConvertTo" /> ne peut pas être effectuée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le texte réel `throw` mot clé n’est pas appelé par cette méthode, par conséquent, l’utilisation classique est `throw GetConvertToException` (avec `value` paramètre fourni).  
  
 L’exception spécifique retournée est <xref:System.InvalidOperationException>, avec `value` passé dans le message d’exception. Le modèle d’utilisation est identique à celui des utilitaires d’exception dans <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSerializerFor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient le <see cref="T:System.Windows.Markup.ValueSerializer" /> pour un objet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor descriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" Index="0" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="descriptor">Descripteur de propriété CLR pour la propriété à sérialiser.</param>
        <summary>Obtient le <see cref="T:System.Windows.Markup.ValueSerializer" /> déclaré pour une propriété, en passant un descripteur de propriété CLR pour la propriété.</summary>
        <returns>Sérialiseur associé à la propriété spécifiée. Peut retourner la valeur <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Markup.ValueSerializer> pour une propriété, ou pour un type qui est utilisé comme valeur pour une propriété, est indiqué en appliquant la <xref:System.Windows.Markup.ValueSerializerAttribute> attribut sur la déclaration de propriété ou un type. Le <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> méthode est une méthode utilitaire qui lit les informations de système de type CLR et retourne un nouvel <xref:System.Windows.Markup.ValueSerializer> classe basée sur l’attribut si trouvé sur la propriété, ou ensuite si trouvé sur le type de propriété. `null` peut être retournée si aucun sérialiseur n’existe. `null` peut également être retourné si un type ou une propriété est attribuée délibérément avec une valeur null <xref:System.Windows.Markup.ValueSerializerAttribute>.  
  
 Un autre mode qui <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> prend en charge est de retour interne `TypeConverterValueSerializer` (classe), qui est un <xref:System.Windows.Markup.ValueSerializer> implémentation qui encapsule un <xref:System.ComponentModel.TypeConverter> et se traduit par la `Convert` méthodes à `Convert*String` méthodes (par exemple <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>est appelé avec l’entrée la <xref:System.String> tapez et se traduit par <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>. Cette opération est effectuée uniquement dans les cas où toutes les conditions suivantes sont remplies :  
  
-   Un <xref:System.ComponentModel.TypeConverterAttribute> se trouve sur la propriété pertinente ou type de la propriété pertinente.  
  
-   Le texte indiqué <xref:System.ComponentModel.TypeConverter> peut être construit correctement.  
  
-   Le <xref:System.ComponentModel.TypeConverter> retourne `true` pour <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>, appelé pour référencer le <xref:System.String> type.  
  
-   Le <xref:System.ComponentModel.TypeConverter> retourne `true` pour <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>, appelé pour référencer le <xref:System.String> type.  
  
-   Le <xref:System.ComponentModel.TypeConverter> retourne `true` pour <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>, appelé pour référencer le <xref:System.String> type.  
  
> [!NOTE]
>  Les éléments suivants sont des cas spéciaux : <xref:System.DateTime> types retournent un <xref:System.Windows.Markup.DateTimeValueSerializer>; <xref:System.String> types retournent un sérialiseur interne mais fonctionnel (`StringValueSerializer`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="descriptor" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="type">Type pour lequel obtenir <see cref="T:System.Windows.Markup.ValueSerializer" />.</param>
        <summary>Obtient le <see cref="T:System.Windows.Markup.ValueSerializer" /> déclaré pour le type spécifié.</summary>
        <returns>Sérialiseur associé au type spécifié. Peut retourner la valeur <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Markup.ValueSerializer> pour un type est indiqué en appliquant la <xref:System.Windows.Markup.ValueSerializerAttribute> attribut sur la déclaration de type. Le <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> méthode est une méthode utilitaire qui lit les informations de système de type CLR et retourne un nouvel <xref:System.Windows.Markup.ValueSerializer> classe basée sur l’attribut si trouvé sur spécifié `type`. `null` peut être retournée si aucun sérialiseur n’existe. `null` peut également être retourné si un type est délibérément attribué avec une valeur null <xref:System.Windows.Markup.ValueSerializerAttribute>.  
  
 Un autre mode qui <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> prend en charge est de retour interne `TypeConverterValueSerializer` (classe), qui est un <xref:System.Windows.Markup.ValueSerializer> implémentation qui encapsule un <xref:System.ComponentModel.TypeConverter> et se traduit par la `Convert` méthodes à `Convert*String` méthodes (par exemple <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>est appelé avec l’entrée la <xref:System.String> tapez et se traduit par <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>. Cette opération est effectuée uniquement dans les cas où toutes les conditions suivantes sont remplies :  
  
-   Un <xref:System.ComponentModel.TypeConverterAttribute> se trouve sur `type`.  
  
-   Le texte indiqué <xref:System.ComponentModel.TypeConverter> peut être construit correctement.  
  
-   Le <xref:System.ComponentModel.TypeConverter> retourne `true` pour <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>, appelé pour référencer le <xref:System.String> type.  
  
-   Le <xref:System.ComponentModel.TypeConverter> retourne `true` pour <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>, appelé pour référencer le <xref:System.String> type.  
  
-   Le <xref:System.ComponentModel.TypeConverter> retourne `true` pour <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>, appelé pour référencer le <xref:System.String> type.  
  
> [!NOTE]
>  Les éléments suivants sont des cas spéciaux : <xref:System.DateTime> types retournent un <xref:System.Windows.Markup.DateTimeValueSerializer>; <xref:System.String> types retournent un sérialiseur interne mais fonctionnel (`StringValueSerializer`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor, context As IValueSerializerContext) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (descriptor, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="descriptor">Descripteur de la propriété à sérialiser.</param>
        <param name="context">Informations de contexte utilisées pour la conversion.</param>
        <summary>Obtient le <see cref="T:System.Windows.Markup.ValueSerializer" /> déclaré pour la propriété spécifiée en utilisant le contexte spécifié.</summary>
        <returns>Sérialiseur associé à la propriété spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu de s’appuyer uniquement sur les attributs signalés dans le système de type CLR, cette surcharge utilise le `context` en tant que service et appelle l’implémentation du service de <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>. Le <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> implémentation serait généralement toujours vous fier à la `descriptor`, mais peut implémenter un comportement spécial pour certains contextes.  
  
 Cette méthode doit être appelée lorsque l’appelant a un disponible <xref:System.Windows.Markup.IValueSerializerContext> à partir d’un service.  Cela permet d’assurer le bon <xref:System.Windows.Markup.ValueSerializer> est retourné pour le contexte spécifique.  
  
 Si le contexte retourne `null` à partir de son <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> votre spécifié `descriptor`, ou si le contexte que vous spécifiez est `null`, comportement est identique à l’appel le <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.ComponentModel.PropertyDescriptor%29> de surcharge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="descriptor" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (type, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="type">Type pour lequel obtenir <see cref="T:System.Windows.Markup.ValueSerializer" />.</param>
        <param name="context">Informations de contexte utilisées pour la conversion.</param>
        <summary>Obtient le <see cref="T:System.Windows.Markup.ValueSerializer" /> déclaré pour le type spécifié, à l’aide du contexte spécifié.</summary>
        <returns>Sérialiseur associé au type spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu de s’appuyer uniquement sur les attributs signalés dans le système de type CLR, cette surcharge utilise le `context` en tant que service et appelle l’implémentation du service de <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>. Le <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> implémentation serait généralement toujours vous fier à la `type`, mais peut implémenter un comportement spécial pour certains contextes.  
  
 Cette méthode doit être appelée lorsque l’appelant a un disponible <xref:System.Windows.Markup.IValueSerializerContext> à partir d’un service. Cela permet d’assurer le bon <xref:System.Windows.Markup.ValueSerializer> est retourné pour le contexte spécifique.  
  
 Si le contexte retourne `null` à partir de son <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> votre spécifié `type`, ou si le contexte que vous spécifiez est `null`, comportement est identique à l’appel le <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.Type%29> de surcharge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeReferences">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; TypeReferences (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; TypeReferences(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.TypeReferences(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TypeReferences (value As Object, context As IValueSerializerContext) As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ TypeReferences(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;&#xA;override this.TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;" Usage="valueSerializer.TypeReferences (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Valeur en cours de sérialisation.</param>
        <param name="context">Informations de contexte utilisées pour la conversion.</param>
        <summary>Obtient une énumération des types référencés par <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns>Types convertis par ce sérialiseur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tous les types un <xref:System.Windows.Markup.ValueSerializer> convertit doit être inclus dans l’énumération retournée.  Cela permet à un sérialiseur de garantir qu'un désérialiseur dispose de suffisamment d’informations sur les types convertit ce sérialiseur.  
  
 Substitution de cette méthode est un scénario avancé. Substitution ne doit être nécessaire si vous implémentez un système où CLR système TypePropriétaire-propriété relations des types disponibles pour un contexte de schéma XAML ne signalent pas de suffisamment d’informations.  
  
## <a name="wpf-usage-notes"></a>Remarques sur l’utilisation WPF  
 Le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] système de propriétés implémente un sérialiseur de valeur interne qui substitue <xref:System.Windows.Markup.ValueSerializer.TypeReferences%2A> , car une propriété de dépendance a un concept qu’il peut ajouter des propriétaires. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] expressions ont également une gestion interne spéciale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>