<Type Name="XmlReader" FullName="System.Xml.XmlReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="37a353caf29d29c75ad340309265d0f066961606" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48647326" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class XmlReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlReader" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XmlReader&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlReader abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type XmlReader = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un lecteur fournissant un accès rapide, non mis en cache et en avant uniquement vers les données XML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader> fournit l’accès avant uniquement et en lecture seule aux données XML dans un document ou un flux. Cette classe est conforme à la W3C [Extensible Markup Language (XML) 1.0 ((quatrième édition)](https://www.w3.org/TR/2006/REC-xml-20060816/) et [espaces de noms dans XML 1.0 (troisième édition)](https://www.w3.org/TR/REC-xml-names/) recommandations.  
  
 <xref:System.Xml.XmlReader> méthodes vous permettent de parcourir les données XML et de lire le contenu d’un nœud. Les propriétés de la classe reflètent la valeur du nœud actuel, c'est-à-dire où le lecteur est positionné. Le <xref:System.Xml.XmlReader.ReadState%2A> valeur de propriété indique l’état actuel du lecteur XML. Par exemple, la propriété est définie <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType> par le <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> (méthode) et <xref:System.Xml.ReadState.Closed?displayProperty=nameWithType> par le <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> (méthode). <xref:System.Xml.XmlReader> fournit également des vérifications de conformité des données et la validation par rapport à une DTD ou un schéma.  
  
 <xref:System.Xml.XmlReader> utilise un modèle d’extraction pour récupérer des données. Ce modèle :  
  
-   Simplifie la gestion de l’état par une amélioration de procédure naturelle de haut en bas.  
  
-   Prend en charge plusieurs flux d’entrée et superposition.  
  
-   Permet au client de donner à l’analyseur une mémoire tampon dans laquelle la chaîne est écrite directement et ainsi d’éviter une copie d’une chaîne supplémentaire.  
  
-   Traitement sélectif prend en charge. Le client peut ignorer des éléments et les traiter celles qui présentent un intérêt pour l’application. Vous pouvez également définir des propriétés à l’avance pour gérer le mode de traitement du flux XML (par exemple, la normalisation).  
  
 Dans cette section :  
  
 [Création d’un lecteur XML](#xmlreader_create)   
 [Validation des données XML](#xmlreader_validate)   
 [Conformité des données](#xmlreader_data)   
 [Parcourir les nœuds](#xmlreader_nodes)   
 [Éléments XML de lecture](#xmlreader_elements)   
 [Attributs de lecture de XML](#xmlreader_attributes)   
 [Contenu de la lecture de XML](#xmlreader_content)   
 [Conversion en types CLR](#xmlreader_clr)   
 [Programmation asynchrone](#xmlreader_async)   
 [Considérations relatives à la sécurité](#xmlreader_security)  
  
<a name="xmlreader_create"></a>   
## <a name="creating-an-xml-reader"></a>Création d’un lecteur XML  
 Utilisez le <xref:System.Xml.XmlReader.Create%2A> méthode pour créer un <xref:System.Xml.XmlReader> instance.  
  
 Bien que le .NET Framework fournit des implémentations concrètes de la <xref:System.Xml.XmlReader> classe, telle que la <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>et le <xref:System.Xml.XmlValidatingReader> classes, nous vous recommandons d’utiliser les classes spécialisées uniquement dans ces scénarios :  
  
-   Lorsque vous souhaitez lire une sous-arborescence de DOM XML à partir d’un <xref:System.Xml.XmlNode> de l’objet, utilisez la <xref:System.Xml.XmlNodeReader> classe. (Toutefois, cette classe ne prend en charge la validation DTD ou le schéma.)  
  
-   Si vous devez développer des entités sur demande, vous ne souhaitez pas votre texte contenu normalisées, ou vous ne souhaitez pas les attributs retournés par défaut, utilisez la <xref:System.Xml.XmlTextReader> classe.  
  
 Pour spécifier l’ensemble de fonctionnalités à activer sur le lecteur XML, transmettez un <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> de l’objet à le <xref:System.Xml.XmlReader.Create%2A> (méthode). Vous pouvez utiliser un seul <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> pour créer plusieurs lecteurs avec les mêmes fonctionnalités de l’objet, ou modifier le <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> objet à créer un nouveau lecteur avec un autre ensemble de fonctionnalités. Vous pouvez également facilement ajouter des fonctionnalités à un lecteur existant.  
  
 Si vous n’utilisez pas un <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> de l’objet, les paramètres par défaut sont utilisés. Consultez le <xref:System.Xml.XmlReader.Create%2A> page de référence pour plus d’informations.  
  
 <xref:System.Xml.XmlReader> lève une <xref:System.Xml.XmlException> erreurs d’analyse XML. Après qu’une exception est levée, l’état du lecteur n’est pas prévisible. Par exemple, le type de nœud rapporté peut être différent du type de nœud réel du nœud actuel. Utilisez le <xref:System.Xml.XmlReader.ReadState%2A> propriété pour vérifier si le lecteur est en état d’erreur.  
  
<a name="xmlreader_validate"></a>   
## <a name="validating-xml-data"></a>Validation des données XML  
 Pour définir la structure d’un document XML et ses relations entre les éléments, les types de données et les contraintes de contenu, vous utilisez une définition de type de document (DTD) ou un schéma XML Schema definition language (XSD). Un document XML est censé être correctement construit s’il répond à toutes les exigences syntaxiques définies par le [W3C XML 1.0 Recommendation](https://www.w3.org/TR/2006/REC-xml-20060816/). Il est considéré comme valide si elle est bien formée et conforme aux limites définies par sa DTD ou son schéma. (Consultez le [W3C XML Schema Part 1 : Structures](https://www.w3.org/TR/xmlschema-1/) et [W3C XML Schema Part 2 : Datatypes](https://www.w3.org/TR/xmlschema-2/) recommandations.) Par conséquent, même si tous les documents XML valides sont construits correctement, tous les documents XML construits correctement ne sont pas valides.  
  
 Vous pouvez valider les données par rapport à une DTD, un schéma XSD, inline ou un schéma XSD est stocké dans un <xref:System.Xml.Schema.XmlSchemaSet> objet (cache) ; ces scénarios sont décrits sur la <xref:System.Xml.XmlReader.Create%2A> page de référence. <xref:System.Xml.XmlReader> ne prend pas en charge la validation de schéma XML-Data Reduced (XDR).  
  
 Vous utilisez les paramètres suivants sur le <xref:System.Xml.XmlReaderSettings> classe pour spécifier le type de validation, le cas échéant, le <xref:System.Xml.XmlReader> instance prend en charge.  
  
|Utilisez cette <xref:System.Xml.XmlReaderSettings> membre|Pour spécifier|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|----------------|  
|Propriété <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|Indique s’il faut ou non autoriser le traitement des DTD. Par défaut, le traitement DTD n'est pas autorisé.|  
|Propriété <xref:System.Xml.XmlReaderSettings.ValidationType%2A>|Indique si le lecteur doit valider les données et le type de validation à effectuer (DTD ou schéma). Par défaut, les données ne sont pas validées.|  
|<xref:System.Xml.XmlReaderSettings.ValidationEventHandler> Événement|Un gestionnaire d’événements pour recevoir des informations sur les événements de validation. Si aucun gestionnaire d'événements n'est fourni, un objet <xref:System.Xml.XmlException> est levé sur la première erreur de validation.|  
|Propriété <xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|Options de validation supplémentaire via le <xref:System.Xml.Schema.XmlSchemaValidationFlags> membres de l’énumération :<br /><br /> -   `AllowXmlAttributes`--Autorise les attributs XML (`xml:*`) dans les documents d’instance même si elles ne sont pas définies dans le schéma. Les attributs sont validés en fonction de leur type de données. Consultez le <xref:System.Xml.Schema.XmlSchemaValidationFlags> page de référence pour le paramètre à utiliser dans des scénarios spécifiques. (Désactivé par défaut).<br />-   `ProcessIdentityConstraints` --Traite les contraintes d’identité (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, `xs:unique`) rencontrés pendant la validation. (Activé par défaut).<br />-   `ProcessSchemaLocation` --Traiter les schémas spécifiés par le `xsi:schemaLocation` ou `xsi:noNamespaceSchemaLocation` attribut. (Activé par défaut).<br />-   `ProcessInlineSchema`--Traiter inline de schémas XML pendant la validation. (Désactivé par défaut).<br />-   `ReportValidationWarnings`--Événements de rapport si un avertissement de validation se produit. Un avertissement est généralement émis lorsqu'un attribut ou élément particulier ne peut être validé par rapport à aucun schéma XML ou aucune DTD. Le <xref:System.Xml.XmlReaderSettings.ValidationEventHandler> est utilisé pour les notifications. (Désactivé par défaut).|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|<xref:System.Xml.Schema.XmlSchemaSet> à utiliser pour la validation.|  
|Propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|Le <xref:System.Xml.XmlResolver> pour la résolution et l’accès aux ressources externes. Cela peut inclure des entités externes telles que des DTD et des schémas et les `xs:include` ou `xs:import` éléments contenus dans le schéma XML. Si vous ne spécifiez pas un <xref:System.Xml.XmlResolver>, le <xref:System.Xml.XmlReader> utilise une valeur par défaut <xref:System.Xml.XmlUrlResolver> sans informations d’identification de l’utilisateur.|  
  
<a name="xmlreader_data"></a>   
## <a name="data-conformance"></a>Conformité des données  
 Lecteurs XML qui sont créés par le <xref:System.Xml.XmlReader.Create%2A> méthode remplir les conditions de conformité suivantes par défaut :  
  
-   Nouvelles lignes et la valeur d’attribut sont normalisés selon le W3C [XML 1.0 Recommendation](https://www.w3.org/TR/2006/REC-xml-20060816/).  
  
-   Toutes les entités sont automatiquement développées.  
  
-   Les attributs par défaut déclarés dans la définition de type de document sont toujours ajoutés même lorsque le lecteur ne valide pas.  
  
-   Déclaration de préfixe XML mappé à l’URI d’espace de noms XML correct est autorisée.  
  
-   Les noms de notation dans un seul `NotationType` déclaration d’attribut et `NmTokens` dans un seul `Enumeration` déclaration d’attribut sont distincts.  
  
 Utilisez ces <xref:System.Xml.XmlReaderSettings> propriétés pour spécifier le type de la conformité vérifie que vous souhaitez activer :  
  
|Utilisez cette <xref:System.Xml.XmlReaderSettings> propriété|À|Par défaut|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|-------------|  
|Propriété <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|Activer ou désactiver les vérifications pour les éléments suivants :<br /><br /> -Les caractères sont dans la plage de caractères XML légaux, tel que défini par le [2.2 Characters](https://www.w3.org/TR/2006/REC-xml-20060816/#charsets) section de la recommandation W3C XML 1.0.<br />-Tous les noms XML sont valides, comme défini par le [constructions syntaxiques communes 2.3](https://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name) section de la recommandation W3C XML 1.0.<br /><br /> Lorsque cette propriété a la valeur `true` (valeur par défaut), un <xref:System.Xml.XmlException> exception est levée si le fichier XML contient des caractères non valides ou des noms XML non valides (par exemple, un nom d’élément commence par un nombre).|Caractère et la vérification de nom est activée.<br /><br /> L'attribution à <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> de la valeur `false` désactive la vérification de caractères pour la recherche de références d'entité de caractère. Si le lecteur traite des données de texte, il vérifie toujours que les noms XML sont valides, indépendamment de ce paramètre. **Remarque :** la recommandation XML 1.0 nécessite la conformité au niveau du document lorsqu’une DTD est présente. Par conséquent, si le lecteur est configuré pour prendre en charge <xref:System.Xml.ConformanceLevel.Fragment?displayProperty=nameWithType>, mais les données XML contient une définition de type de document (DTD), un <xref:System.Xml.XmlException> est levée.|  
|Propriété <xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|Choisissez le niveau de conformité à appliquer :<br /><br /> -   <xref:System.Xml.ConformanceLevel.Document>. Est conforme aux règles d’un [document XML 1.0 correctement construit](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed).<br />-   <xref:System.Xml.ConformanceLevel.Fragment>. Est conforme aux règles d’un fragment de document bien formé qui peut être consommé comme un [externe d’entité analysée](https://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities).<br />-   <xref:System.Xml.ConformanceLevel.Auto>. Est conforme au niveau décidé par le lecteur.<br /><br /> Si les données n’est pas en conformité, un <xref:System.Xml.XmlException> exception est levée.|<xref:System.Xml.ConformanceLevel.Document>|  
  
<a name="xmlreader_nodes"></a>   
## <a name="navigating-through-nodes"></a>Parcourir les nœuds  
 Le nœud actuel est le nœud XML sur lequel le lecteur XML est actuellement positionné. Tous les <xref:System.Xml.XmlReader> méthodes effectuent des opérations par rapport à ce nœud et tous les <xref:System.Xml.XmlReader> propriétés reflètent la valeur du nœud actuel.  
  
 Les méthodes suivantes permettent de facilement naviguer parmi les nœuds et analyser les données.  
  
|Utilisez cette <xref:System.Xml.XmlReaderSettings> (méthode)|À|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Read%2A>|Lire le premier nœud, et faites avancer et le nœud d’un flux à la fois. Ces appels sont généralement effectuées à l’intérieur d’un `while` boucle.<br /><br /> Utilisez le <xref:System.Xml.XmlReader.NodeType%2A> propriété à obtenir le type (par exemple, attribut, commentaire, élément et ainsi de suite) du nœud actuel.|  
|<xref:System.Xml.XmlReader.Skip%2A>|Ignorer les enfants du nœud actuel et le déplacer vers le nœud suivant.|  
|<xref:System.Xml.XmlReader.MoveToContent%2A> et <xref:System.Xml.XmlReader.MoveToContentAsync%2A>|Ignorer des nœuds sans contenu et le déplacer vers le nœud de contenu suivant ou à la fin du fichier.<br /><br /> Incluent les nœuds non-content <xref:System.Xml.XmlNodeType.ProcessingInstruction>, <xref:System.Xml.XmlNodeType.DocumentType>, <xref:System.Xml.XmlNodeType.Comment>, <xref:System.Xml.XmlNodeType.Whitespace>, et <xref:System.Xml.XmlNodeType.SignificantWhitespace>.<br /><br /> Nœuds de contenu comprennent texte autre qu’un espace blanc, <xref:System.Xml.XmlNodeType.CDATA>, <xref:System.Xml.XmlNodeType.EntityReference> , et <xref:System.Xml.XmlNodeType.EndEntity>.|  
|<xref:System.Xml.XmlReader.ReadSubtree%2A>|Lire un élément et tous ses enfants et retournent un nouvel <xref:System.Xml.XmlReader> instance définie sur <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType>.<br /><br /> Cette méthode est utile pour créer des limites autour des éléments XML ; par exemple, si vous souhaitez passer à un autre composant pour le traitement des données et que vous souhaitez limiter la quantité de vos données, le composant peut accéder.|  
  
 Consultez le <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> page de référence pour obtenir un exemple de naviguer dans un un nœud flux de texte à la fois et d’afficher le type de chaque nœud.  
  
 Les sections suivantes décrivent comment vous pouvez lire les types de données, tels que les éléments, attributs, spécifiques et des données typées.  
  
<a name="xmlreader_elements"></a>   
## <a name="reading-xml-elements"></a>Éléments XML de lecture  
 Le tableau suivant répertorie les méthodes et propriétés qui la <xref:System.Xml.XmlReader> classe fournit pour le traitement des éléments. Une fois l'objet <xref:System.Xml.XmlReader> positionné sur un élément, les propriétés du nœud, telles que <xref:System.Xml.XmlReader.Name%2A>, reflètent les valeurs de l'élément. Outre les membres décrits ci-dessous, toutes les propriétés et méthodes générales de la classe <xref:System.Xml.XmlReader> peuvent également être utilisées pour le traitement des éléments. Par exemple, vous pouvez utiliser la méthode <xref:System.Xml.XmlReader.ReadInnerXml%2A> pour lire le contenu d'un élément.  
  
> [!NOTE]
>  Consultez la section 3.1 de la [W3C XML 1.0 Recommendation](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-starttags) pour les définitions de balises de début, fin et les balises élément vide.  
  
|Utilisez cette <xref:System.Xml.XmlReader> membre|À|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|Méthode <xref:System.Xml.XmlReader.IsStartElement%2A>|Vérifiez si le nœud actuel est une balise de début ou une balise d’élément vide.|  
|Méthode <xref:System.Xml.XmlReader.ReadStartElement%2A>|Vérifiez que le nœud actuel est un élément et avance le lecteur jusqu’au nœud suivant (appels <xref:System.Xml.XmlReader.IsStartElement%2A> suivie <xref:System.Xml.XmlReader.Read%2A>).|  
|Méthode <xref:System.Xml.XmlReader.ReadEndElement%2A>|Vérifiez que le nœud actuel est une balise de fin et avance le lecteur jusqu’au nœud suivant.|  
|Méthode <xref:System.Xml.XmlReader.ReadElementString%2A>|Lire un élément de texte.|  
|Méthode <xref:System.Xml.XmlReader.ReadToDescendant%2A>|Avance le lecteur XML à l’élément suivant de descendant (enfant) qui porte le nom spécifié.|  
|Méthode <xref:System.Xml.XmlReader.ReadToNextSibling%2A>|Avance le lecteur XML à l’élément frère suivant portant le nom spécifié.|  
|Propriété <xref:System.Xml.XmlReader.IsEmptyElement%2A>|Vérifiez si l’élément actuel a une balise d’élément de fin. Exemple :<br /><br /> -   `<item num="123"/>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> est `true`.)<br />-   `<item num="123"> </item>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> est `false`, bien que le contenu de l’élément est vide.)|  
  
 Pour obtenir un exemple de lire le contenu texte des éléments, consultez le <xref:System.Xml.XmlReader.ReadString%2A> (méthode). L’exemple suivant traite les éléments à l’aide un `while` boucle.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
<a name="xmlreader_attributes"></a>   
## <a name="reading-xml-attributes"></a>Attributs de lecture de XML  
 Attributs XML les plus couramment utilisés sur les éléments, mais ils sont également autorisés sur la déclaration XML et les nœuds de type de document.  
  
 Lorsque vous êtes positionné sur un nœud d’élément, le <xref:System.Xml.XmlReader.MoveToAttribute%2A> méthode vous permet de parcourir la liste d’attributs de l’élément. Notez qu’après <xref:System.Xml.XmlReader.MoveToAttribute%2A> a été appelée, les propriétés de nœud comme <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, et <xref:System.Xml.XmlReader.Prefix%2A> reflètent les propriétés de cet attribut, pas les propriétés de l’élément de l’attribut appartient.  
  
 Le <xref:System.Xml.XmlReader> classe fournit ces méthodes et propriétés pour lire et traiter les attributs d’éléments.  
  
|Utilisez cette <xref:System.Xml.XmlReader> membre|À|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|Propriété <xref:System.Xml.XmlReader.HasAttributes%2A>|Vérifiez si le nœud actuel possède des attributs.|  
|Propriété <xref:System.Xml.XmlReader.AttributeCount%2A>|Obtenir le nombre d’attributs sur l’élément actuel.|  
|Méthode <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>|Déplacer vers le premier attribut dans un élément.|  
|Méthode <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>|Déplacer vers l’attribut suivant dans un élément.|  
|Méthode <xref:System.Xml.XmlReader.MoveToAttribute%2A>|Déplacer vers un attribut spécifié.|  
|<xref:System.Xml.XmlReader.GetAttribute%2A> méthode ou <xref:System.Xml.XmlReader.Item%2A> propriété|Obtenir la valeur d’un attribut spécifié.|  
|Propriété <xref:System.Xml.XmlReader.IsDefault%2A>|Vérifiez si le nœud actuel est un attribut qui a été généré à partir de la valeur par défaut définie dans la DTD ou le schéma.|  
|Méthode <xref:System.Xml.XmlReader.MoveToElement%2A>|Déplacer vers l’élément qui possède l’attribut actuel. Utilisez cette méthode pour retourner à un élément après avoir navigué dans ses attributs.|  
|Méthode <xref:System.Xml.XmlReader.ReadAttributeValue%2A>|Analyser la valeur d’attribut dans un ou plusieurs `Text`, `EntityReference`, ou `EndEntity` nœuds.|  
  
 Toutes les méthodes et propriétés <xref:System.Xml.XmlReader> générales peuvent aussi être utilisées pour traiter des attributs. Par exemple, une fois que l'objet <xref:System.Xml.XmlReader> a été positionné sur un attribut, les propriétés <xref:System.Xml.XmlReader.Name%2A> et <xref:System.Xml.XmlReader.Value%2A> reflètent les valeurs de cet attribut. Vous pouvez aussi utiliser les méthodes `Read` de contenu pour obtenir la valeur de l'attribut.  
  
 Cet exemple utilise le <xref:System.Xml.XmlReader.AttributeCount%2A> propriété pour parcourir tous les attributs d’un élément.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 Cet exemple utilise le <xref:System.Xml.XmlReader.MoveToNextAttribute%2A> méthode dans un `while` boucle pour naviguer dans les attributs.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 **Lecture d’attributs sur des nœuds de déclaration XML**  
  
 Lorsque le lecteur XML est positionné sur un nœud de déclaration XML, le <xref:System.Xml.XmlReader.Value%2A> propriété retourne la version, autonome et des informations de codage comme une chaîne unique. <xref:System.Xml.XmlReader> objets créés par le <xref:System.Xml.XmlReader.Create%2A> (méthode), le <xref:System.Xml.XmlTextReader> (classe) et le <xref:System.Xml.XmlValidatingReader> classe exposent la version, l’autonome et l’encodage des éléments en tant qu’attributs.  
  
 **Lecture d’attributs sur les nœuds de type de document**  
  
 Lorsque le lecteur XML est positionné sur un nœud de type de document, le <xref:System.Xml.XmlReader.GetAttribute%2A> méthode et <xref:System.Xml.XmlReader.Item%2A> propriété peut être utilisée pour retourner les valeurs pour les littéraux SYSTEM et PUBLIC. Par exemple, un appel `reader.GetAttribute("PUBLIC")` retourne la valeur PUBLIC.  
  
 **Lecture d’attributs sur les nœuds d’instruction de traitement**  
  
 Lorsque l'objet <xref:System.Xml.XmlReader> est positionné sur un n_œud d'instruction de traitement, la propriété <xref:System.Xml.XmlReader.Value%2A> retourne tout le contenu textuel. Les éléments dans le nœud d’instruction de traitement ne sont pas traités en tant qu’attributs. Ils ne peuvent pas être lus avec le <xref:System.Xml.XmlReader.GetAttribute%2A> ou <xref:System.Xml.XmlReader.MoveToAttribute%2A> (méthode).  
  
<a name="xmlreader_content"></a>   
## <a name="reading-xml-content"></a>Contenu de la lecture de XML  
 La classe XMLReader inclut les membres suivants que vous lire le contenu d’un fichier XML et renvoyer le contenu en tant que valeurs de chaîne. (Pour retourner les types CLR, consultez la [section suivante](#xmlreader_clr).)  
  
|Utilisez cette <xref:System.Xml.XmlReader> membre|À|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|Propriété <xref:System.Xml.XmlReader.Value%2A>|Obtenir le contenu textuel du nœud actuel. La valeur retournée varie selon le type de nœud ; consultez le <xref:System.Xml.XmlReader.Value%2A> page de référence pour plus d’informations.|  
|Méthode <xref:System.Xml.XmlReader.ReadString%2A>|Obtenir le contenu d’un nœud d’élément ou de texte sous forme de chaîne. Cette méthode s’arrête sur le traitement des instructions et des commentaires.<br /><br /> Pour plus d’informations sur la façon dont cette méthode gère les types de nœud spécifique, consultez le <xref:System.Xml.XmlReader.ReadString%2A> page de référence.|  
|Méthodes <xref:System.Xml.XmlReader.ReadInnerXml%2A> et <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>|Obtenir tout le contenu du nœud actuel, y compris le balisage, mais à l’exclusion des balises de début et de fin. Par exemple, pour :<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadInnerXml%2A> Retourne :<br /><br /> `this<child id="123"/>`|  
|Méthodes <xref:System.Xml.XmlReader.ReadOuterXml%2A> et <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>|Obtenir tout le contenu du nœud actuel et ses enfants, y compris les balises de début/fin et de balisage. Par exemple, pour :<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadOuterXml%2A> Retourne :<br /><br /> `<node>this<child id="123"/></node>`|  
  
<a name="xmlreader_clr"></a>   
## <a name="converting-to-clr-types"></a>Conversion en types CLR  
 Vous pouvez utiliser les membres de la <xref:System.Xml.XmlReader> classe (répertoriée dans le tableau suivant) pour lire les données XML et types de retour valeurs en tant que le common language runtime (CLR) au lieu de chaînes. Ces membres permettent d’obtenir des valeurs dans la représentation qui convient le mieux pour votre tâche de codage sans devoir analyser manuellement ou de convertir des valeurs de chaîne.  
  
-   Le **ReadElementContentAs** méthodes peuvent uniquement être appelées sur des types de nœud d’élément. Elles peuvent être utilisées pour des éléments qui comportent des éléments enfants ou du contenu mixte. S'il est appelé, l'objet <xref:System.Xml.XmlReader> lit la balise de début et le contenu de l'élément, puis avance jusqu'après la balise d'élément de fin. Les instructions de traitement et les commentaires sont ignorés et les entités sont développées.  
  
-   Le **ReadContentAs** méthodes lire le contenu de texte à la position actuelle du lecteur et si les données XML n’aient pas de schéma ou les informations associées, de type de données de convertir le contenu de texte pour le type de retour demandé. Le texte, les espaces blancs, les espaces blancs significatifs et les sections CDATA sont concaténés. Les commentaires et instructions de traitement sont ignorées et les références d’entité sont automatiquement résolues.  
  
 Le <xref:System.Xml.XmlReader> classe utilise les règles définies par le [W3C XML Schema Part 2 : Datatypes](https://www.w3.org/TR/xmlschema-2/) recommandation.  
  
|Utilisez cette <xref:System.Xml.XmlReader> (méthode)|Pour retourner ce type CLR|  
|--------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|<xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> et <xref:System.Xml.XmlReader.ReadElementContentAsBoolean%2A>|<xref:System.Boolean>|  
|<xref:System.Xml.XmlReader.ReadContentAsDateTime%2A> et <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>|<xref:System.DateTime>|  
|<xref:System.Xml.XmlReader.ReadContentAsDouble%2A> et <xref:System.Xml.XmlReader.ReadElementContentAsDouble%2A>|<xref:System.Double>|  
|<xref:System.Xml.XmlReader.ReadContentAsLong%2A> et <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A>|<xref:System.Int64>|  
|<xref:System.Xml.XmlReader.ReadContentAsInt%2A> et <xref:System.Xml.XmlReader.ReadElementContentAsInt%2A>|<xref:System.Int32>|  
|<xref:System.Xml.XmlReader.ReadContentAsString%2A> et <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>|<xref:System.String>|  
|<xref:System.Xml.XmlReader.ReadContentAs%2A> et <xref:System.Xml.XmlReader.ReadElementContentAs%2A>|Le type que vous spécifiez avec la `returnType` paramètre|  
|<xref:System.Xml.XmlReader.ReadContentAsObject%2A> et <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>|Type le plus approprié, tel que spécifié par le <xref:System.Xml.XmlReader.ValueType%2A?displayProperty=nameWithType> propriété. Consultez [prise en charge des types dans les Classes System.Xml](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) pour des informations de mappage.|  
  
 Si un élément ne peut pas être aisément converti en un type CLR en raison de son format, vous pouvez utiliser un mappage de schéma pour garantir une conversion réussie. L’exemple suivant utilise un fichier .xsd pour convertir le `hire-date` élément à la `xs:date` type, puis utilise le <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> méthode pour retourner l’élément en tant qu’un <xref:System.DateTime> objet.  
  
 **Entrée (hireDate.xml) :**  
  
 [!code-xml[XmlReader.ReadElementContentAs#9](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xml#9)]  
  
 **Schéma (hireDate.xsd) :**  
  
 [!code-xml[XmlReader.ReadElementContentAs#10](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xsd#10)]  
  
 **Code :**  
  
 [!code-csharp[XmlReader.ReadElementContentAs#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#13)]
 [!code-vb[XmlReader.ReadElementContentAs#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#13)]  
  
 **Sortie :**  
  
```  
Six Month Review Date:  7/8/2003 12:00:00 AM  
```  
  
<a name="xmlreader_async"></a>   
## <a name="asynchronous-programming"></a>Programmation asynchrone  
 La plupart de la <xref:System.Xml.XmlReader> méthodes ont des équivalents asynchrones qui ont « Async » à la fin de leurs noms de méthode. Par exemple, l’équivalent asynchrone de <xref:System.Xml.XmlReader.ReadContentAsObject%2A> est <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 Les méthodes suivantes peuvent être utilisées avec les appels de méthode asynchrone :  
  
-   <xref:System.Xml.XmlReader.GetAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToElement%2A>  
  
-   <xref:System.Xml.XmlReader.ReadAttributeValue%2A>  
  
-   <xref:System.Xml.XmlReader.ReadSubtree%2A>  
  
-   <xref:System.Xml.XmlReader.ResolveEntity%2A>  
  
 Les sections suivantes décrivent l’utilisation asynchrone pour les méthodes qui n’ont pas équivalents asynchrones.  
  
 **ReadStartElement, méthode**  
  
 [!code-csharp[System.Xml.XmlReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#1)]
 [!code-vb[System.Xml.XmlReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#1)]  
  
 **ReadEndElement (méthode)**  
  
 [!code-csharp[System.Xml.XmlReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#2)]
 [!code-vb[System.Xml.XmlReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#2)]  
  
 **ReadToNextSibling (méthode)**  
  
 [!code-csharp[System.Xml.XmlReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#3)]
 [!code-vb[System.Xml.XmlReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#3)]  
  
 **ReadToFollowing (méthode)**  
  
 [!code-csharp[System.Xml.XmlReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#4)]
 [!code-vb[System.Xml.XmlReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#4)]  
  
 **ReadToDescendant (méthode)**  
  
 [!code-csharp[System.Xml.XmlReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#5)]
 [!code-vb[System.Xml.XmlReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#5)]  
  
<a name="xmlreader_security"></a>   
## <a name="security-considerations"></a>Considérations relatives à la sécurité  
 Considérez les éléments suivants lorsque vous travaillez avec le <xref:System.Xml.XmlReader> classe :  
  
-   Les exceptions levées par le <xref:System.Xml.XmlReader> peuvent divulguer des informations de chemin d’accès que vous ne souhaitez pas propagées de votre application. Votre application doit intercepter les exceptions et les traiter correctement.  
  
-   N’activez pas le traitement DTD si vous êtes soucieux de déni de service ou si vous avez affaire à des sources non approuvées. Le traitement DTD est désactivé par défaut pour <xref:System.Xml.XmlReader> objets créés par le <xref:System.Xml.XmlReader.Create%2A> (méthode).  
  
     Si le traitement DTD est activé, vous pouvez utiliser l'objet <xref:System.Xml.XmlSecureResolver> pour limiter les ressources auxquelles l'objet <xref:System.Xml.XmlReader> peut avoir accès. Vous pouvez également concevoir votre application afin que le traitement XML de la mémoire est limité et de temps. Par exemple, vous pouvez configurer des limites de délai d’attente dans votre application ASP.NET.  
  
-   Les données XML peuvent inclure des références à des ressources externes telles qu'un fichier de schéma. Par défaut, les ressources externes sont résolues à l’aide un <xref:System.Xml.XmlUrlResolver> objet sans informations d’identification de l’utilisateur. Vous pouvez renforcer la sécurité en procédant comme suit :  
  
    -   Limitez les ressources auxquelles <xref:System.Xml.XmlReader> peut accéder en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> sur un objet <xref:System.Xml.XmlSecureResolver>.  
  
    -   Empêchez l'objet <xref:System.Xml.XmlReader> d'ouvrir des ressources externes en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> sur `null`.  
  
-   Le <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> et <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> indicateurs de validation d’une <xref:System.Xml.XmlReaderSettings> objet ne sont pas définies par défaut. Cela contribue à protéger l'objet <xref:System.Xml.XmlReader> contre les attaques basées sur des schémas lorsqu'il traite des données XML provenant d'une source non fiable. Lorsque ces indicateurs sont activés, la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> de l'objet <xref:System.Xml.XmlReaderSettings> est utilisée pour résoudre les emplacements de schéma rencontrés dans le document d'instance dans l'objet <xref:System.Xml.XmlReader>. Si le <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> propriété est définie sur `null`, emplacements de schéma ne sont pas résolus même si le <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> et <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> indicateurs de validation sont définies.  
  
     Les schémas ajoutés lors de la validation ajoutent de nouveaux types et peuvent changer le résultat de la validation du document en cours de validation. Par conséquent, les schémas externes ne devraient être résolus que s'ils proviennent de sources fiables.  
  
     Nous recommandons de désactiver la <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> indicateur lors de la validation des documents XML volumineux non fiables, dans les scénarios de haute disponibilité par rapport à un schéma qui a des contraintes d’identité sur une grande partie du document. Cet indicateur est activé par défaut.  
  
-   Les données XML peuvent contenir un grand nombre d'attributs, de déclarations d'espaces de noms, d'éléments imbriqués, etc. exigeant un temps de traitement long. Pour limiter la taille de l’entrée qui est envoyée à la <xref:System.Xml.XmlReader>, vous pouvez :  
  
    -   Limiter la taille du document en définissant le <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A> propriété.  
  
    -   Limiter le nombre de caractères résultant du développement des entités en définissant le <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A> propriété.  
  
    -   Créer un personnalisé `IStream` implémentation pour le <xref:System.Xml.XmlReader>.  
  
-   Le <xref:System.Xml.XmlReader.ReadValueChunk%2A> méthode peut être utilisée pour gérer de grands flux de données. Cette méthode lit un petit nombre de caractères à la fois au lieu d'allouer une seule chaîne à toute la valeur.  
  
-   Lors de la lecture d’un document XML avec un grand nombre de noms locaux uniques, les espaces de noms ou les préfixes, un problème peut se produire. Si vous utilisez une classe qui dérive de <xref:System.Xml.XmlReader>, et que vous appelez le <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A>, ou <xref:System.Xml.XmlReader.NamespaceURI%2A> propriété pour chaque élément, la chaîne retournée est ajoutée à un <xref:System.Xml.NameTable>. La collection détenue par le <xref:System.Xml.NameTable> ne diminue jamais en taille et crée une fuite de mémoire virtuelle des handles de chaîne. Une atténuation pour cela consiste à dériver à partir de la <xref:System.Xml.NameTable> classe et imposer un quota de taille maximale. (Il n’existe aucun moyen pour empêcher l’utilisation d’un <xref:System.Xml.NameTable>, ou pour changer la <xref:System.Xml.NameTable> lorsqu’il est plein). Atténuation une autre consiste à éviter d’utiliser les propriétés mentionnées et utilisez plutôt le <xref:System.Xml.XmlReader.MoveToAttribute%2A> méthode avec le <xref:System.Xml.XmlReader.IsStartElement%2A> méthode lorsque cela est possible ; ces méthodes ne retourner des chaînes et ainsi éviter saturée le <xref:System.Xml.NameTable> collection.  
  
-   Les objets <xref:System.Xml.XmlReaderSettings> peuvent contenir des informations confidentielles telles que des informations d'identification de l'utilisateur. Un composant non fiable pourrait utiliser l'objet <xref:System.Xml.XmlReaderSettings> et ses informations d'identification pour créer des objets <xref:System.Xml.XmlReader> afin de lire des données. Soyez prudent lors de la mise en cache <xref:System.Xml.XmlReaderSettings> objets, ou lorsque vous passez le <xref:System.Xml.XmlReaderSettings> objet à partir d’un composant vers un autre.  
  
-   N'acceptez pas les composants de prise en charge, tels que les objets <xref:System.Xml.NameTable>, <xref:System.Xml.XmlNamespaceManager> et <xref:System.Xml.XmlResolver> provenant d'une source non fiable.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser l’API asynchrone pour analyser du code XML.  
  
 [!code-csharp[System.Xml.XmlReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#6)]
 [!code-vb[System.Xml.XmlReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#6)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="http://msdn.microsoft.com/library/e695047f-3c0f-4045-8708-5baea91cc380">Documents et données XML</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see langword="XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est appelé par les constructeurs de classes dérivées pour initialiser un état dans ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public abstract int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int AttributeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AttributeCount : int" Usage="System.Xml.XmlReader.AttributeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le nombre d'attributs du nœud actuel.</summary>
        <value>Nombre d'attributs du nœud actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété s’applique aux `Element`, `DocumentType` et `XmlDeclaration` uniquement les nœuds. (Autres types de nœuds n’ont pas d’attributs.)  
  
   
  
## Examples  
 L’exemple suivant affiche tous les attributs sur le nœud actuel.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public abstract string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlReader.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient l'URI de base du nœud actuel.</summary>
        <value>URI de base du nœud actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un document XML en réseau est constitué de segments de données agrégées à l’aide de divers mécanismes d’inclusion standard W3C et contient par conséquent des nœuds provenant de différents emplacements. Entités DTD sont un exemple de cela, mais ce n’est pas limité à la DTD. La base de URI indique la provenance de ces nœuds. S’il n’existe aucun URI de base pour les nœuds retournés (par exemple, ils ont été analysés à partir d’une chaîne en mémoire), `String.Empty` est retournée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public virtual bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadBinaryContent : bool" Usage="System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Xml.XmlReader" /> implémente les méthodes de lecture de contenu binaire.</summary>
        <value>
          <see langword="true" /> si les méthodes de lecture de contenu binaire sont implémentées ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le contenu binaire lire méthodes incluent le <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, et <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A> méthodes. Si cette propriété retourne `false` un <xref:System.NotSupportedException> est retournée lorsqu’un de la ressource binaire lire méthodes est appelée.  
  
 Toutes les implémentations de Microsoft .NET Framework de la <xref:System.Xml.XmlReader> classe retour `true` pour cette propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadValueChunk : bool" Usage="System.Xml.XmlReader.CanReadValueChunk" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Xml.XmlReader" /> implémente la méthode <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Xml.XmlReader" /> implémente la méthode <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’analyse de texte <xref:System.Xml.XmlReader> les objets qui ont été créés à partir de la méthode statique <xref:System.Xml.XmlReader.Create%2A> méthode retournent toujours `true`. Toutes les autres implémentations de Microsoft .NET Framework de la <xref:System.Xml.XmlReader> classe, y compris le <xref:System.Xml.XmlTextReader> class, retourner `false`.  
  
 Si cette propriété retourne `false` un <xref:System.NotSupportedException> est retourné lorsque la <xref:System.Xml.XmlReader.ReadValueChunk%2A> méthode est appelée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public virtual bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanResolveEntity : bool" Usage="System.Xml.XmlReader.CanResolveEntity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si ce lecteur peut analyser et résoudre les entités.</summary>
        <value>
          <see langword="true" /> si le lecteur peut analyser et résoudre les entités ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne toujours `false` pour les implémentations de <xref:System.Xml.XmlReader> qui ne prennent pas en charge les informations DTD. Dans ce cas, l’appel <xref:System.Xml.XmlReader.ResolveEntity%2A> lève une exception.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="xmlReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, modifie <see cref="P:System.Xml.XmlReader.ReadState" /> en <see cref="F:System.Xml.ReadState.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode libère également les ressources détenues pendant la lecture. Si <xref:System.Xml.XmlReader.Close%2A> a déjà été n’appelée, aucune action n’est effectuée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La plupart de la <xref:System.Xml.XmlReader.Create%2A> surcharges incluent un `settings` paramètre qui accepte un <xref:System.Xml.XmlReaderSettings> objet. Vous pouvez utiliser cet objet pour :  
  
-   Spécifier les fonctionnalités prises en charge sur le <xref:System.Xml.XmlReader> objet.  
  
-   Réutiliser la <xref:System.Xml.XmlReaderSettings> objet à créer plusieurs lecteurs. Vous pouvez utiliser les mêmes paramètres pour créer plusieurs lecteurs avec la même fonctionnalité. Ou, vous pouvez modifier les paramètres sur un <xref:System.Xml.XmlReaderSettings> de l’instance et créer un nouveau lecteur avec un autre ensemble de fonctionnalités.  
  
-   Ajouter des fonctionnalités à un lecteur XML existant. La méthode <xref:System.Xml.XmlReader.Create%2A> peut accepter un autre objet <xref:System.Xml.XmlReader>. Sous-jacent <xref:System.Xml.XmlReader> objet peut être un lecteur défini par l’utilisateur, un <xref:System.Xml.XmlTextReader> objet ou un autre <xref:System.Xml.XmlReader> instance que vous souhaitez ajouter d’autres fonctionnalités.  
  
-   Tirer pleinement parti des fonctionnalités comme une meilleure vérification de la conformité et la conformité à la [XML 1.0 ((quatrième édition)](https://www.w3.org/TR/2006/REC-xml-20060816/) recommandation qui sont disponibles uniquement sur <xref:System.Xml.XmlReader> objets créés par la méthode statique <xref:System.Xml.XmlReader.Create%2A> (méthode).  
  
> [!NOTE]
>  Bien que le .NET Framework inclut des implémentations concrètes de la <xref:System.Xml.XmlReader> classe, telle que la <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>et le <xref:System.Xml.XmlValidatingReader> classes, nous vous recommandons de créer <xref:System.Xml.XmlReader> instances à l’aide de la <xref:System.Xml.XmlReader.Create%2A> méthode.  
  
## <a name="default-settings"></a>Paramètres par défaut  
 Si vous utilisez un <xref:System.Xml.XmlReader.Create%2A> surcharge qui n’accepte pas un <xref:System.Xml.XmlReaderSettings> de l’objet, les paramètres de lecteur par défaut suivants sont utilisés :  
  
|Paramètre|Par défaut|  
|-------------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|Objet <xref:System.Xml.Schema.XmlSchemaSet> vide|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> Activé|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|Nouvel objet <xref:System.Xml.XmlUrlResolver>.  À compter de .NET Framework 4.5.2, ce paramètre a la valeur par défaut `null`.|  
  
## <a name="settings-for-common-scenarios"></a>Paramètres pour les scénarios courants  
 Voici le <xref:System.Xml.XmlReaderSettings> propriétés, vous devez définir pour certains des scénarios de lecteur XML standard.  
  
|Spécification|Définir|  
|-----------------|---------|  
|Données doivent être un document XML bien formé.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> à <xref:System.Xml.ConformanceLevel.Document>.|  
|Données doivent être une entité XML correctement formée.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> à <xref:System.Xml.ConformanceLevel.Fragment>.|  
|Données doivent être validées par rapport à une DTD.|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> à <xref:System.Xml.DtdProcessing.Parse><br /><xref:System.Xml.XmlReaderSettings.ValidationType%2A> à <xref:System.Xml.ValidationType.DTD>.|  
|Données doivent être validées par rapport à un schéma XML.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> à <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> à la <xref:System.Xml.Schema.XmlSchemaSet> à utiliser pour la validation. Notez que <xref:System.Xml.XmlReader> ne prend pas en charge la validation de schéma XML-Data Reduced (XDR).|  
|Données doivent être validées par rapport à un schéma XML inline.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> à <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> à <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>.|  
|Prise en charge du type.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> à <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> à la <xref:System.Xml.Schema.XmlSchemaSet> à utiliser.|  
  
 <xref:System.Xml.XmlReader> ne prend pas en charge la validation de schéma XML-Data Reduced (XDR).  
  
## <a name="asynchronous-programming"></a>Programmation asynchrone  
 En mode synchrone, le <xref:System.Xml.XmlReader.Create%2A> méthode lit le premier segment de données à partir de la mémoire tampon du lecteur de fichiers, flux ou du texte. Cela peut lever une exception si une opération d’e/s échoue. En mode asynchrone, la première opération d’e/s se produit avec une opération de lecture, afin que les exceptions qui surviennent seront levées lors de l’opération de lecture se produit.  
  
## <a name="security-considerations"></a>Considérations relatives à la sécurité  
 Par défaut, le <xref:System.Xml.XmlReader> utilise un <xref:System.Xml.XmlUrlResolver> objet sans informations d’identification utilisateur pour ouvrir des ressources. Cela signifie que, par défaut, le lecteur XML peut accéder à n’importe quel emplacement qui ne nécessite pas d’informations d’identification. Utilisez le <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> propriété pour contrôler l’accès aux ressources :  
  
-   Définissez <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> à un <xref:System.Xml.XmlSecureResolver> objet pour limiter les ressources accessibles par le lecteur XML.  
  
 - ou -  
  
-   Définissez <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> à `null` pour empêcher l’ouverture des ressources externes du lecteur XML.  
  
   
  
## Examples  
 Cet exemple crée un lecteur XML qui supprime les espaces blancs non significatifs, commentaires et effectue une vérification de la conformité au niveau du fragment.  
  
 [!code-csharp[XmlReader.Create#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#11)]
 [!code-vb[XmlReader.Create#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#11)]  
  
 L’exemple suivant utilise un <xref:System.Xml.XmlUrlResolver> avec informations d’identification par défaut pour accéder à un fichier.  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 [!code-cpp[XmlReaderSettings.cctor#2](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#2)]
 [!code-csharp[XmlReaderSettings.cctor#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#2)]
 [!code-vb[XmlReaderSettings.cctor#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#2)]  
  
 Le code suivant encapsule une instance de lecteur dans un autre lecteur.  
  
 [!code-csharp[XmlReader.Create#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#13)]
 [!code-vb[XmlReader.Create#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#13)]  
  
 Cet exemple associe plusieurs lecteurs pour ajouter la validation de schéma DTD et XML.  
  
 [!code-csharp[XmlReader.Create#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#12)]
 [!code-vb[XmlReader.Create#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input">Flux contenant les données XML.  
  
<see cref="T:System.Xml.XmlReader" /> analyse les premiers octets du flux à la recherche d’une marque d’ordre des octets ou d’un autre signe de codage. Quand l'encodage est déterminé, il est utilisé pour continuer à lire le flux, et le traitement continue à analyser l'entrée en tant que flux de caractères (Unicode).</param>
        <summary>Crée une instance de <see cref="T:System.Xml.XmlReader" /> à l’aide du flux spécifié avec les paramètres par défaut.</summary>
        <returns>Objet permettant de lire les données XML contenues dans le flux de données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Xml.XmlReaderSettings> objet avec les paramètres par défaut est utilisé pour créer le lecteur. Si vous souhaitez spécifier les fonctionnalités à prendre en charge sur le lecteur créé, utilisez la surcharge qui accepte un <xref:System.Xml.XmlReaderSettings> de l’objet en tant qu’un de ses arguments et passez un <xref:System.Xml.XmlReaderSettings> objet avec les paramètres corrects.  
  
 Une valeur par défaut <xref:System.Xml.XmlUrlResolver> sans informations d’identification est utilisé pour accéder aux ressources externes telles qu’une définition de type de document (DTD), des entités, des schémas et ainsi de suite.  
  
> [!IMPORTANT]
>  En commençant par le .NET Framework 4.5.2, sans valeur par défaut <xref:System.Xml.XmlUrlResolver> est fourni. Si votre solution cible .NET Framework 4.5.2 ou versions ultérieures, spécifiez un <xref:System.Xml.XmlResolver> à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
 Si la ressource externe se trouve sur une ressource réseau qui nécessite une authentification, spécifiez un <xref:System.Xml.XmlResolver> avec les informations d’identification nécessaires à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
 Créé <xref:System.Xml.XmlReader> objet développe les références d’entité et effectue la normalisation XML de caractères de nouvelle ligne.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Xml.XmlReader> objet qui lit à partir d’un <xref:System.IO.FileStream>.  
  
 [!code-csharp[XmlReader.Create#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#8)]
 [!code-vb[XmlReader.Create#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Xml.XmlReader" /> n’a pas d’autorisations suffisantes pour accéder à l’emplacement des données XML.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="input">Lecteur de texte à partir duquel lire les données XML. Comme un lecteur de texte retourne un flux de caractères Unicode, l'encodage spécifié dans la déclaration XML n'est pas utilisé par le lecteur XML pour décoder le flux de données.</param>
        <summary>Crée une instance de <see cref="T:System.Xml.XmlReader" /> à l’aide du lecteur de texte spécifié.</summary>
        <returns>Objet permettant de lire les données XML contenues dans le flux de données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Xml.XmlReaderSettings> objet avec les paramètres par défaut est utilisé pour créer le lecteur. Si vous souhaitez spécifier les fonctionnalités à prendre en charge sur le lecteur créé, utilisez la surcharge qui accepte un <xref:System.Xml.XmlReaderSettings> de l’objet en tant qu’un de ses arguments et passez un <xref:System.Xml.XmlReaderSettings> objet avec les paramètres corrects.  
  
 Une valeur par défaut <xref:System.Xml.XmlUrlResolver> sans informations d’identification est utilisé pour accéder aux ressources externes telles qu’une définition de type de document (DTD), des entités, des schémas et ainsi de suite.  
  
> [!IMPORTANT]
>  En commençant par le .NET Framework 4.5.2, sans valeur par défaut <xref:System.Xml.XmlUrlResolver> est fourni. Si votre solution cible .NET Framework 4.5.2 ou versions ultérieures, spécifiez un <xref:System.Xml.XmlResolver> à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
 Si la ressource externe se trouve sur une ressource réseau qui nécessite une authentification, spécifiez un <xref:System.Xml.XmlResolver> avec les informations d’identification nécessaires à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
 Créé <xref:System.Xml.XmlReader> objet développe les références d’entité et effectue la normalisation XML de caractères de nouvelle ligne.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.IO.StringReader> classe pour lire une chaîne XML.  
  
 [!code-csharp[XmlReader.Create#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#7)]
 [!code-vb[XmlReader.Create#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create inputUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="inputUri">URI du fichier qui contient les données XML. La classe <see cref="T:System.Xml.XmlUrlResolver" /> permet de convertir le chemin en représentation de données canonique.</param>
        <summary>Crée une instance de <see cref="T:System.Xml.XmlReader" /> avec l’URI spécifié.</summary>
        <returns>Objet permettant de lire les données XML contenues dans le flux de données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Xml.XmlReaderSettings> objet avec les paramètres par défaut est utilisé pour créer le lecteur. Si vous souhaitez spécifier les fonctionnalités à prendre en charge sur le lecteur créé, utilisez la surcharge qui accepte un <xref:System.Xml.XmlReaderSettings> de l’objet en tant qu’un de ses arguments et passez un <xref:System.Xml.XmlReaderSettings> objet avec les paramètres corrects.  
  
 Une valeur par défaut <xref:System.Xml.XmlUrlResolver> sans informations d’identification est utilisé pour accéder aux ressources externes telles qu’une définition de type de document (DTD), des entités, des schémas et ainsi de suite.  
  
> [!IMPORTANT]
>  En commençant par le .NET Framework 4.5.2, sans valeur par défaut <xref:System.Xml.XmlUrlResolver> est fourni. Si votre solution cible .NET Framework 4.5.2 ou versions ultérieures, spécifiez un <xref:System.Xml.XmlResolver> à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
 Si la ressource externe se trouve sur une ressource réseau qui nécessite une authentification, spécifiez un <xref:System.Xml.XmlResolver> avec les informations d’identification nécessaires à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
 Créé <xref:System.Xml.XmlReader> objet développe les références d’entité et effectue la normalisation XML de caractères de nouvelle ligne.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Xml.XmlReader> objet qui lit le fichier de données XML spécifié par l’URI.  
  
 [!code-csharp[XmlReader.Create#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#6)]
 [!code-vb[XmlReader.Create#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputUri" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Xml.XmlReader" /> n’a pas d’autorisations suffisantes pour accéder à l’emplacement des données XML.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier identifié par l’URI n’existe pas.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.FormatException" />, à la place.  
  
</para>
          </block>  
  
Le format d’URI n’est pas correct.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">Flux contenant les données XML.  
  
<see cref="T:System.Xml.XmlReader" /> analyse les premiers octets du flux à la recherche d’une marque d’ordre des octets ou d’un autre signe de codage. Quand l'encodage est déterminé, il est utilisé pour continuer à lire le flux, et le traitement continue à analyser l'entrée en tant que flux de caractères (Unicode).</param>
        <param name="settings">Paramètres de la nouvelle instance de <see cref="T:System.Xml.XmlReader" />. Cette valeur peut être <see langword="null" />.</param>
        <summary>Crée une instance de <see cref="T:System.Xml.XmlReader" /> avec le flux et les paramètres spécifiés.</summary>
        <returns>Objet permettant de lire les données XML contenues dans le flux de données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut un <xref:System.Xml.XmlUrlResolver> sans informations d’identification est utilisé pour accéder aux ressources externes telles qu’une définition de type de document (DTD), des entités, des schémas et ainsi de suite.  
  
> [!IMPORTANT]
>  En commençant par le .NET Framework 4.5.2, sans valeur par défaut <xref:System.Xml.XmlUrlResolver> est fourni. Si votre solution cible .NET Framework 4.5.2 ou versions ultérieures, spécifiez un <xref:System.Xml.XmlResolver> à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
 Si la ressource externe se trouve sur une ressource réseau qui nécessite une authentification, utilisez le <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété pour spécifier un <xref:System.Xml.XmlResolver> avec les informations d’identification nécessaires.  
  
> [!IMPORTANT]
>  Vous pouvez utiliser une des méthodes suivantes pour contrôler les ressources auxquelles le <xref:System.Xml.XmlReader> peuvent accéder à :  
>   
>  -   Limitez les ressources auxquelles <xref:System.Xml.XmlReader> peut accéder en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> sur un objet <xref:System.Xml.XmlSecureResolver>.  
>   
>  - ou -  
>   
>  -   Empêchez l'objet <xref:System.Xml.XmlReader> d'ouvrir des ressources externes en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> sur `null`.  
  
 Créé <xref:System.Xml.XmlReader> objet développe les références d’entité et effectue la normalisation XML de caractères de nouvelle ligne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">Lecteur de texte à partir duquel lire les données XML. Comme un lecteur de texte retourne un flux de caractères Unicode, l'encodage spécifié dans la déclaration XML n'est pas utilisé par le lecteur XML pour décoder le flux de données.</param>
        <param name="settings">Paramètres du nouveau <see cref="T:System.Xml.XmlReader" />. Cette valeur peut être <see langword="null" />.</param>
        <summary>Crée une instance de <see cref="T:System.Xml.XmlReader" /> à l’aide du lecteur de texte et des paramètres spécifiés.</summary>
        <returns>Objet permettant de lire les données XML contenues dans le flux de données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut un <xref:System.Xml.XmlUrlResolver> sans informations d’identification est utilisé pour accéder aux ressources externes telles qu’une définition de type de document (DTD), des entités, des schémas et ainsi de suite.  
  
> [!IMPORTANT]
>  En commençant par le .NET Framework 4.5.2, sans valeur par défaut <xref:System.Xml.XmlUrlResolver> est fourni. Si votre solution cible .NET Framework 4.5.2 ou versions ultérieures, spécifiez un <xref:System.Xml.XmlResolver> à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
 Si la ressource externe se trouve sur une ressource réseau qui nécessite une authentification, utilisez le <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété pour spécifier un <xref:System.Xml.XmlResolver> avec les informations d’identification nécessaires.  
  
> [!IMPORTANT]
>  Vous pouvez utiliser une des méthodes suivantes pour contrôler les ressources auxquelles le <xref:System.Xml.XmlReader> peuvent accéder à :  
>   
>  -   Limitez les ressources auxquelles <xref:System.Xml.XmlReader> peut accéder en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> sur un objet <xref:System.Xml.XmlSecureResolver>.  
>   
>  - ou -  
>   
>  -   Empêchez l'objet <xref:System.Xml.XmlReader> d'ouvrir des ressources externes en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> sur `null`.  
  
 Créé <xref:System.Xml.XmlReader> objet développe les références d’entité et effectue la normalisation XML de caractères de nouvelle ligne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="inputUri">URI du fichier contenant les données XML. L’objet <see cref="T:System.Xml.XmlResolver" /> de l’objet <see cref="T:System.Xml.XmlReaderSettings" /> permet de convertir le chemin en représentation de données canonique. Si <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> a la valeur <see langword="null" />, un nouvel objet <see cref="T:System.Xml.XmlUrlResolver" /> est utilisé.</param>
        <param name="settings">Paramètres de la nouvelle instance de <see cref="T:System.Xml.XmlReader" />. Cette valeur peut être <see langword="null" />.</param>
        <summary>Crée une instance de <see cref="T:System.Xml.XmlReader" /> en utilisant l’URI et les paramètres spécifiés.</summary>
        <returns>Objet permettant de lire les données XML contenues dans le flux de données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut un <xref:System.Xml.XmlUrlResolver> sans informations d’identification est utilisé pour accéder aux ressources externes telles qu’une définition de type de document (DTD), des entités, des schémas et ainsi de suite.  
  
> [!IMPORTANT]
>  En commençant par le .NET Framework 4.5.2, sans valeur par défaut <xref:System.Xml.XmlUrlResolver> est fourni. Si votre solution cible .NET Framework 4.5.2 ou versions ultérieures, spécifiez un <xref:System.Xml.XmlResolver> à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
 Cela signifie que le <xref:System.Xml.XmlReader> peut accéder à tous les emplacements qui ne nécessite pas d’authentification. Si la ressource externe se trouve sur une ressource réseau qui nécessite une authentification, utilisez le <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété pour spécifier un <xref:System.Xml.XmlResolver> avec les informations d’identification nécessaires.  
  
> [!IMPORTANT]
>  Vous pouvez limiter les ressources qui le <xref:System.Xml.XmlReader> peut accéder en définissant le <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> propriété un <xref:System.Xml.XmlSecureResolver> objet.  
  
 Créé <xref:System.Xml.XmlReader> objet développe les références d’entité et effectue la normalisation XML de caractères de nouvelle ligne.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Xml.XmlReader> objet qui prend en charge la validation de DTD (définition) de type de document.  
  
 [!code-csharp[XmlReader.Create#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#3)]
 [!code-vb[XmlReader.Create#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputUri" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié par l’URI est introuvable.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.FormatException" />, à la place.  
  
</para>
          </block>  
  
Le format d’URI n’est pas correct.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.Xml.XmlReader reader, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.Xml.XmlReader reader, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.Xml.XmlReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (reader As XmlReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::Xml::XmlReader ^ reader, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.Xml.XmlReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (reader, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="reader">L'objet à utiliser comme lecteur XML sous-jacent.</param>
        <param name="settings">Paramètres de la nouvelle instance de <see cref="T:System.Xml.XmlReader" />.  
  
Le niveau de conformité de l’objet <see cref="T:System.Xml.XmlReaderSettings" /> doit soit correspondre au niveau de conformité du lecteur sous-jacent, soit avoir la valeur <see cref="F:System.Xml.ConformanceLevel.Auto" />.</param>
        <summary>Crée une instance de <see cref="T:System.Xml.XmlReader" /> à l’aide des paramètres et du lecteur XML spécifiés.</summary>
        <returns>Objet autour de l’objet <see cref="T:System.Xml.XmlReader" /> spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode vous permet d’ajouter des fonctionnalités supplémentaires à un sous-jacent <xref:System.Xml.XmlReader> objet. Sous-jacent <xref:System.Xml.XmlReader> objet peut être une autre <xref:System.Xml.XmlReader> objet créé par le <xref:System.Xml.XmlReader.Create%2A> (méthode), ou un <xref:System.Xml.XmlReader> objet créé à l’aide de la concret <xref:System.Xml.XmlReader> implémentations.  
  
 Une valeur par défaut <xref:System.Xml.XmlUrlResolver> sans informations d’identification est utilisé pour accéder aux ressources externes, tel qu’un schéma.  
  
> [!IMPORTANT]
>  En commençant par le .NET Framework 4.5.2, sans valeur par défaut <xref:System.Xml.XmlUrlResolver> est fourni. Si votre solution cible .NET Framework 4.5.2 ou versions ultérieures, spécifiez un <xref:System.Xml.XmlResolver> à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
 Si la ressource externe se trouve sur une ressource réseau qui nécessite une authentification, spécifiez un <xref:System.Xml.XmlResolver> avec les informations d’identification nécessaires à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
> [!IMPORTANT]
>  Vous pouvez utiliser une des méthodes suivantes pour contrôler les ressources auxquelles le <xref:System.Xml.XmlReader> peuvent accéder à :  
>   
>  -   Limitez les ressources auxquelles <xref:System.Xml.XmlReader> peut accéder en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> sur un objet <xref:System.Xml.XmlSecureResolver>.  
>   
>  - ou -  
>   
>  -   Empêchez l'objet <xref:System.Xml.XmlReader> d'ouvrir des ressources externes en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> sur `null`.  
  
 Créé <xref:System.Xml.XmlReader> objet développe les références d’entité et effectue la normalisation XML de caractères de nouvelle ligne.  
  
   
  
## Examples  
 L’exemple suivant crée une validation <xref:System.Xml.XmlReader> objet enveloppé autour d’un <xref:System.Xml.XmlNodeReader> objet.  
  
 [!code-csharp[XmlReader.Create#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#5)]
 [!code-vb[XmlReader.Create#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Si l’objet <see cref="T:System.Xml.XmlReaderSettings" /> spécifie un niveau de conformité qui n’est pas cohérent avec le niveau de conformité du lecteur sous-jacent.  
  
- ou - 
Le <see cref="T:System.Xml.XmlReader" /> sous-jacent se trouve dans un état <see cref="F:System.Xml.ReadState.Error" /> ou <see cref="F:System.Xml.ReadState.Closed" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Flux contenant les données XML.  
  
<see cref="T:System.Xml.XmlReader" /> analyse les premiers octets du flux à la recherche d’une marque d’ordre des octets ou d’un autre signe de codage. Quand l'encodage est déterminé, il est utilisé pour continuer à lire le flux, et le traitement continue à analyser l'entrée en tant que flux de caractères (Unicode).</param>
        <param name="settings">Paramètres de la nouvelle instance de <see cref="T:System.Xml.XmlReader" />. Cette valeur peut être <see langword="null" />.</param>
        <param name="baseUri">URI de base pour l'entité ou le document en cours de lecture. Cette valeur peut être <see langword="null" />.  
  
 **Note sur la sécurité** L’URI de base est utilisé pour résoudre l’URI relatif du document XML. N'utilisez pas un URI de base provenant d'une source non fiable.</param>
        <summary>Crée une instance de <see cref="T:System.Xml.XmlReader" /> en utilisant le flux, l’URI de base et les paramètres spécifiés.</summary>
        <returns>Objet permettant de lire les données XML contenues dans le flux de données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut un <xref:System.Xml.XmlUrlResolver> sans informations d’identification est utilisé pour accéder aux ressources externes telles qu’une définition de type de document (DTD), des entités, des schémas et ainsi de suite.  
  
> [!IMPORTANT]
>  En commençant par le .NET Framework 4.5.2, sans valeur par défaut <xref:System.Xml.XmlUrlResolver> est fourni. Si votre solution cible .NET Framework 4.5.2 ou versions ultérieures, spécifiez un <xref:System.Xml.XmlResolver> à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
 Si la ressource externe se trouve sur une ressource réseau qui nécessite une authentification, utilisez le <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété pour spécifier un <xref:System.Xml.XmlResolver> avec les informations d’identification nécessaires.  
  
> [!IMPORTANT]
>  Vous pouvez utiliser une des méthodes suivantes pour contrôler les ressources auxquelles le <xref:System.Xml.XmlReader> peuvent accéder à :  
>   
>  -   Limitez les ressources auxquelles <xref:System.Xml.XmlReader> peut accéder en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> sur un objet <xref:System.Xml.XmlSecureResolver>.  
>   
>  - ou -  
>   
>  -   Empêchez l'objet <xref:System.Xml.XmlReader> d'ouvrir des ressources externes en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> sur `null`.  
  
 Créé <xref:System.Xml.XmlReader> objet développe les références d’entité et effectue la normalisation XML de caractères de nouvelle ligne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">Flux contenant les données XML.  
  
<see cref="T:System.Xml.XmlReader" /> analyse les premiers octets du flux à la recherche d’une marque d’ordre des octets ou d’un autre signe de codage. Quand l'encodage est déterminé, il est utilisé pour continuer à lire le flux, et le traitement continue à analyser l'entrée en tant que flux de caractères (Unicode).</param>
        <param name="settings">Paramètres de la nouvelle instance de <see cref="T:System.Xml.XmlReader" />. Cette valeur peut être <see langword="null" />.</param>
        <param name="inputContext">Les informations de contexte nécessaires à l'analyse du fragment XML. Les informations de contexte peuvent inclure le <see cref="T:System.Xml.XmlNameTable" /> à utiliser, l’encodage, la portée d’espace de noms, la portée <c>xml:lang</c> et <c>xml:space</c> actuelle, l’URI de base et la définition de type de document.  
  
Cette valeur peut être <see langword="null" />.</param>
        <summary>Crée une instance de <see cref="T:System.Xml.XmlReader" /> à l’aide du flux, des paramètres et des informations de contexte d’analyse spécifiés.</summary>
        <returns>Objet permettant de lire les données XML contenues dans le flux de données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut un <xref:System.Xml.XmlUrlResolver> sans informations d’identification est utilisé pour accéder aux ressources externes telles qu’une définition de type de document (DTD), des entités, des schémas et ainsi de suite.  
  
> [!IMPORTANT]
>  En commençant par le .NET Framework 4.5.2, sans valeur par défaut <xref:System.Xml.XmlUrlResolver> est fourni. Si votre solution cible .NET Framework 4.5.2 ou versions ultérieures, spécifiez un <xref:System.Xml.XmlResolver> à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
 Si la ressource externe se trouve sur une ressource réseau qui nécessite une authentification, utilisez le <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété pour spécifier un <xref:System.Xml.XmlResolver> avec les informations d’identification nécessaires.  
  
> [!IMPORTANT]
>  Vous pouvez utiliser une des méthodes suivantes pour contrôler les ressources auxquelles le <xref:System.Xml.XmlReader> peuvent accéder à :  
>   
>  -   Limitez les ressources auxquelles <xref:System.Xml.XmlReader> peut accéder en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> sur un objet <xref:System.Xml.XmlSecureResolver>.  
>   
>  - ou -  
>   
>  -   Empêchez l'objet <xref:System.Xml.XmlReader> d'ouvrir des ressources externes en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> sur `null`.  
  
 Créé <xref:System.Xml.XmlReader> objet développe les références d’entité et effectue la normalisation XML de caractères de nouvelle ligne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Lecteur de texte à partir duquel lire les données XML. Comme un lecteur de texte retourne un flux de caractères Unicode, l’encodage spécifié dans la déclaration XML n’est pas utilisé par le lecteur <see cref="T:System.Xml.XmlReader" /> pour décoder le flux de données.</param>
        <param name="settings">Paramètres de la nouvelle instance de <see cref="T:System.Xml.XmlReader" />. Cette valeur peut être <see langword="null" />.</param>
        <param name="baseUri">URI de base pour l'entité ou le document en cours de lecture. Cette valeur peut être <see langword="null" />.  
  
 **Note sur la sécurité** L’URI de base est utilisé pour résoudre l’URI relatif du document XML. N'utilisez pas un URI de base provenant d'une source non fiable.</param>
        <summary>Crée une instance de <see cref="T:System.Xml.XmlReader" /> à l’aide du lecteur de texte, des paramètres et de l’URI de base spécifiés.</summary>
        <returns>Objet permettant de lire les données XML contenues dans le flux de données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut un <xref:System.Xml.XmlUrlResolver> sans informations d’identification est utilisé pour accéder aux ressources externes telles qu’une définition de type de document (DTD), des entités, des schémas et ainsi de suite.  
  
> [!IMPORTANT]
>  En commençant par le .NET Framework 4.5.2, sans valeur par défaut <xref:System.Xml.XmlUrlResolver> est fourni. Si votre solution cible .NET Framework 4.5.2 ou versions ultérieures, spécifiez un <xref:System.Xml.XmlResolver> à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
 Si la ressource externe se trouve sur une ressource réseau qui nécessite une authentification, utilisez le <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété pour spécifier un <xref:System.Xml.XmlResolver> avec les informations d’identification nécessaires.  
  
> [!IMPORTANT]
>  Vous pouvez utiliser une des méthodes suivantes pour contrôler les ressources auxquelles le <xref:System.Xml.XmlReader> peuvent accéder à :  
>   
>  -   Limitez les ressources auxquelles <xref:System.Xml.XmlReader> peut accéder en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> sur un objet <xref:System.Xml.XmlSecureResolver>.  
>   
>  - ou -  
>   
>  -   Empêchez l'objet <xref:System.Xml.XmlReader> d'ouvrir des ressources externes en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> sur `null`.  
  
 Créé <xref:System.Xml.XmlReader> objet développe les références d’entité et effectue la normalisation XML de caractères de nouvelle ligne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">Lecteur de texte à partir duquel lire les données XML. Comme un lecteur de texte retourne un flux de caractères Unicode, l'encodage spécifié dans la déclaration XML n'est pas utilisé par le lecteur XML pour décoder le flux de données.</param>
        <param name="settings">Paramètres de la nouvelle instance de <see cref="T:System.Xml.XmlReader" />. Cette valeur peut être <see langword="null" />.</param>
        <param name="inputContext">Les informations de contexte nécessaires à l'analyse du fragment XML. Les informations de contexte peuvent inclure le <see cref="T:System.Xml.XmlNameTable" /> à utiliser, l’encodage, la portée d’espace de noms, la portée <c>xml:lang</c> et <c>xml:space</c> actuelle, l’URI de base et la définition de type de document.  
  
Cette valeur peut être <see langword="null" />.</param>
        <summary>Crée une instance de <see cref="T:System.Xml.XmlReader" /> à l’aide du lecteur de texte, des paramètres et des informations de contexte d’analyse spécifiés.</summary>
        <returns>Objet permettant de lire les données XML contenues dans le flux de données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut un <xref:System.Xml.XmlUrlResolver> sans informations d’identification est utilisé pour accéder aux ressources externes telles qu’une définition de type de document (DTD), des entités, des schémas et ainsi de suite.  
  
> [!IMPORTANT]
>  En commençant par le .NET Framework 4.5.2, sans valeur par défaut <xref:System.Xml.XmlUrlResolver> est fourni. Si votre solution cible .NET Framework 4.5.2 ou versions ultérieures, spécifiez un <xref:System.Xml.XmlResolver> à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
 Si la ressource externe se trouve sur une ressource réseau qui nécessite une authentification, utilisez le <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété pour spécifier un <xref:System.Xml.XmlResolver> avec les informations d’identification nécessaires.  
  
> [!IMPORTANT]
>  Vous pouvez utiliser une des méthodes suivantes pour contrôler les ressources auxquelles le <xref:System.Xml.XmlReader> peuvent accéder à :  
>   
>  -   Limitez les ressources auxquelles <xref:System.Xml.XmlReader> peut accéder en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> sur un objet <xref:System.Xml.XmlSecureResolver>.  
>   
>  - ou -  
>   
>  -   Empêchez l'objet <xref:System.Xml.XmlReader> d'ouvrir des ressources externes en définissant la propriété <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> sur `null`.  
  
 Créé <xref:System.Xml.XmlReader> objet développe les références d’entité et effectue la normalisation XML de caractères de nouvelle ligne.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Xml.XmlReader> objet qui lit un fragment XML.  
  
 [!code-csharp[XmlReader.Create#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#1)]
 [!code-vb[XmlReader.Create#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Les propriétés <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> et <see cref="P:System.Xml.XmlParserContext.NameTable" /> contiennent toutes deux des valeurs. (Vous ne pouvez définir et utiliser qu’une seule de ces propriétés <see langword="NameTable" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="inputUri">URI du fichier contenant les données XML. L’objet <see cref="T:System.Xml.XmlResolver" /> de l’objet <see cref="T:System.Xml.XmlReaderSettings" /> permet de convertir le chemin en représentation de données canonique. Si <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> a la valeur <see langword="null" />, un nouvel objet <see cref="T:System.Xml.XmlUrlResolver" /> est utilisé.</param>
        <param name="settings">Paramètres de la nouvelle instance de <see cref="T:System.Xml.XmlReader" />. Cette valeur peut être <see langword="null" />.</param>
        <param name="inputContext">Les informations de contexte nécessaires à l'analyse du fragment XML. Les informations de contexte peuvent inclure le <see cref="T:System.Xml.XmlNameTable" /> à utiliser, l’encodage, la portée d’espace de noms, la portée <c>xml:lang</c> et <c>xml:space</c> actuelle, l’URI de base et la définition de type de document.  
  
Cette valeur peut être <see langword="null" />.</param>
        <summary>Crée une instance de <see cref="T:System.Xml.XmlReader" /> en utilisant l’URI, les paramètres et les informations de contexte spécifiés pour l’analyse.</summary>
        <returns>Objet permettant de lire les données XML contenues dans le flux de données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut un <xref:System.Xml.XmlUrlResolver> sans informations d’identification est utilisé pour accéder aux ressources externes telles qu’une définition de type de document (DTD), des entités, des schémas et ainsi de suite.  
  
> [!IMPORTANT]
>  En commençant par le .NET Framework 4.5.2, sans valeur par défaut <xref:System.Xml.XmlUrlResolver> est fourni. Si votre solution cible .NET Framework 4.5.2 ou versions ultérieures, spécifiez un <xref:System.Xml.XmlResolver> à l’aide de la <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété.  
  
 Cela signifie que le <xref:System.Xml.XmlReader> peut accéder à tous les emplacements qui ne nécessite pas d’authentification. Si la ressource externe se trouve sur une ressource réseau qui nécessite une authentification, utilisez le <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriété pour spécifier un <xref:System.Xml.XmlResolver> avec les informations d’identification nécessaires.  
  
> [!IMPORTANT]
>  Vous pouvez limiter les ressources qui le <xref:System.Xml.XmlReader> peut accéder en définissant le <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> propriété un <xref:System.Xml.XmlSecureResolver> objet.  
  
 Créé <xref:System.Xml.XmlReader> objet développe les références d’entité et effectue la normalisation XML de caractères de nouvelle ligne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see langword="inputUri" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Xml.XmlReader" /> n’a pas d’autorisations suffisantes pour accéder à l’emplacement des données XML.</exception>
        <exception cref="T:System.ArgumentException">Les propriétés <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> et <see cref="P:System.Xml.XmlParserContext.NameTable" /> contiennent toutes deux des valeurs. (Vous ne pouvez définir et utiliser qu’une seule de ces propriétés <see langword="NameTable" />).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié par l’URI est introuvable.</exception>
        <exception cref="T:System.UriFormatException">Le format d’URI n’est pas correct.</exception>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public abstract int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Xml.XmlReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient la profondeur du nœud actuel dans le document XML.</summary>
        <value>Profondeur du nœud actuel dans le document XML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Consultez <xref:System.Xml.XmlTextReader.Depth%2A> (dans le `XmlTextReader` classe) pour obtenir un exemple à l’aide de cette propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Libère les ressources utilisées par la classe <see cref="T:System.Xml.XmlReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="xmlReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="xmlReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.Xml.XmlReader" /> et libère éventuellement les ressources managées.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public abstract bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool EOF { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EOF : bool" Usage="System.Xml.XmlReader.EOF" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient une valeur indiquant si le lecteur est placé à la fin du flux.</summary>
        <value>
          <see langword="true" /> si le lecteur est placé à la fin du flux ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>En cas de substitution dans une classe dérivée, obtient la valeur d'un attribut.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : int -&gt; string" Usage="xmlReader.GetAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Index de l'attribut. L'index est de base zéro. Le premier attribut possède l'index 0.</param>
        <summary>En cas de substitution dans une classe dérivée, obtient la valeur de l'attribut avec l'index spécifié.</summary>
        <returns>Valeur de l'attribut spécifié. Cette méthode ne déplace pas le lecteur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant obtient la valeur de l’attribut tiers.  
  
 [!code-csharp[XmlReaderBasic#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#2)]
 [!code-vb[XmlReaderBasic#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="i" /> est hors limites. Il doit être non négatif et inférieur à la taille de la collection d'attributs.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string -&gt; string" Usage="xmlReader.GetAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom qualifié de l'attribut.</param>
        <summary>En cas de substitution dans une classe dérivée, obtient la valeur de l'attribut avec le <see cref="P:System.Xml.XmlReader.Name" /> spécifié.</summary>
        <returns>Valeur de l'attribut spécifié. Si l'attribut est introuvable ou si la valeur est <see langword="String.Empty" />, <see langword="null" /> est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne déplace pas le lecteur.  
  
 Si le lecteur est positionné sur un `DocumentType` nœud, cette méthode peut être utilisée pour obtenir les littéraux PUBLIC et SYSTEM, par exemple, `reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 L’exemple suivant obtient la valeur de l’attribut de numéro ISBN.  
  
 [!code-csharp[XmlReaderBasic#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#3)]
 [!code-vb[XmlReaderBasic#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string * string -&gt; string" Usage="xmlReader.GetAttribute (name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Le nom local de l'attribut.</param>
        <param name="namespaceURI">L'URI de l'espace de noms de l'attribut.</param>
        <summary>En cas de substitution dans une classe dérivée, obtient la valeur de l'attribut avec le <see cref="P:System.Xml.XmlReader.LocalName" /> et le <see cref="P:System.Xml.XmlReader.NamespaceURI" /> spécifiés.</summary>
        <returns>Valeur de l'attribut spécifié. Si l'attribut est introuvable ou si la valeur est <see langword="String.Empty" />, <see langword="null" /> est retourné. Cette méthode ne déplace pas le lecteur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le code XML suivant contient un attribut dans un espace de noms spécifique :  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 Vous pouvez rechercher le `dt:type` attribut à l’aide d’un argument (préfixe et nom local) ou les deux arguments (nom local et URI de l’espace de noms) :  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 À rechercher le `xmlns:dt` d’attribut, utilisez un des arguments suivants :  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 Vous pouvez également obtenir cette information à l’aide de la <xref:System.Xml.XmlReader.Prefix%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; GetValueAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; GetValueAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetValueAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ GetValueAsync();" />
      <MemberSignature Language="F#" Value="abstract member GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.GetValueAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient de façon asynchrone la valeur du nœud actuel.</summary>
        <returns>Valeur du nœud actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public virtual bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasAttributes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasAttributes { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAttributes : bool" Usage="System.Xml.XmlReader.HasAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le nœud actuel a des attributs.</summary>
        <value>
          <see langword="true" /> si le nœud actuel possède des attributs ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant affiche tous les attributs sur le nœud actuel.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public virtual bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValue : bool" Usage="System.Xml.XmlReader.HasValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient une valeur indiquant si le nœud actuel peut posséder <see cref="P:System.Xml.XmlReader.Value" />.</summary>
        <value>
          <see langword="true" /> si le nœud sur lequel le lecteur est placé actuellement peut avoir un <see langword="Value" /> ; sinon, <see langword="false" />. Si <see langword="false" />, le nœud a une valeur de <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie les types de nœuds possédant une valeur de retour.  
  
|Type de nœud|Value|  
|---------------|-----------|  
|`Attribute`|Valeur de l'attribut.|  
|`CDATA`|Contenu de la section CDATA.|  
|`Comment`|Contenu du commentaire.|  
|`DocumentType`|Sous-ensemble interne.|  
|`ProcessingInstruction`|Contenu entier, cible exclue.|  
|`SignificantWhitespace`|Espace blanc entre les balisages dans un modèle de contenu mixte.|  
|`Text`|Contenu du nœud de texte.|  
|`Whitespace`|Espace blanc entre les balises.|  
|`XmlDeclaration`|Contenu de la déclaration.|  
  
   
  
## Examples  
 Consultez <xref:System.Xml.XmlTextReader.HasValue%2A> (dans le `XmlTextReader` classe) pour obtenir un exemple à l’aide de cette méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public virtual bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefault : bool" Usage="System.Xml.XmlReader.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient une valeur indiquant si le nœud actuel est un attribut généré à partir de la valeur par défaut définie dans le DTD ou le schéma.</summary>
        <value>
          <see langword="true" /> si le nœud actuel est un attribut dont la valeur a été générée à partir de la valeur par défaut définie dans le DTD ou le schéma ; <see langword="false" /> si la valeur d'attribut a été définie explicitement.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsDefault` Retourne toujours `false` pour les implémentations de `XmlReader` qui ne prennent pas en charge les informations de schéma ou DTD. Cette propriété s’applique uniquement à un nœud d’attribut.  
  
   
  
## Examples  
 L’exemple suivant affiche tous les attributs sur l’élément racine.  
  
```csharp  
using System;  
using System.IO;  
using System.Xml;  
  
public class Sample   
{  
  public static void Main(){  
  
    // Create the reader.  
    XmlReader reader = XmlReader.Create("book4.xml");  
  
    reader.MoveToContent();  
  
    // Display each of the attribute nodes, including default attributes.  
    while (reader.MoveToNextAttribute()){  
        if (reader.IsDefault)  
          Console.Write("(default attribute) ");  
        Console.WriteLine("{0} = {1}", reader.Name, reader.Value);    
    }             
  
    //Close the reader.  
    reader.Close();       
  
  }  
} // End class  
```  
  
 L’exemple utilise les fichiers suivants en tant qu’entrée.  
  
 `book4.xml`  
  
```xml  
<!DOCTYPE book SYSTEM 'book.dtd'>  
<book ISBN = '1-861001-57-5'>  
  <title>Pride And Prejudice</title>  
  <price>19.95</price>  
</book>  
```  
  
 `book.dtd`  
  
```  
<!ELEMENT book (title,price)>   
<!ATTLIST book   
   genre CDATA "novel"  
   ISBN CDATA #REQUIRED>  
<!ELEMENT title (#PCDATA)>  
<!ELEMENT price (#PCDATA)>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public abstract bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsEmptyElement { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmptyElement : bool" Usage="System.Xml.XmlReader.IsEmptyElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient une valeur indiquant si le nœud actuel est un élément vide (par exemple, <c>&lt;MyElement/&gt;</c>).</summary>
        <value>
          <see langword="true" /> Si le nœud actuel est un élément (<see cref="P:System.Xml.XmlReader.NodeType" /> est égal à <see langword="XmlNodeType.Element" />) qui se termine par <c> / &gt; </c>; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété permet de déterminer la différence entre les balises suivantes :  
  
 `<item num="123"/>` (`IsEmptyElement` est `true`).  
  
 `<item num="123"></item>` (`IsEmptyElement` est `false`, bien que le contenu de l’élément est vide).  
  
 Correspondante `EndElement` nœud n’est pas généré pour les éléments vides.  
  
 Si le contenu par défaut a été ajouté à un élément en raison de la validation de schéma, `IsEmptyElement` retourne toujours `true`. Il n’a aucune incidence sur l’élément ait ou non une valeur par défaut. En d’autres termes, `IsEmptyElement` signale simplement si l’élément dans le document source a une balise d’élément de fin.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de texte de chaque élément.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 L’exemple utilise le fichier `elems.xml`comme entrée.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="IsName">
      <MemberSignature Language="C#" Value="public static bool IsName (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsName(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsName (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsName(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsName : string -&gt; bool" Usage="System.Xml.XmlReader.IsName str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Nom à valider.</param>
        <summary>Retourne une valeur indiquant si l’argument de chaîne est un nom XML valide.</summary>
        <returns>
          <see langword="true" /> si le nom est valide ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [W3C XML 1.0 Recommendation](http://go.microsoft.com/fwlink/?LinkId=49863) pour déterminer si le nom est valid.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNameToken">
      <MemberSignature Language="C#" Value="public static bool IsNameToken (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNameToken(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsNameToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNameToken (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNameToken(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsNameToken : string -&gt; bool" Usage="System.Xml.XmlReader.IsNameToken str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Jeton de nom à valider.</param>
        <summary>Retourne une valeur indiquant si l’argument de chaîne est un jeton de nom XML valide.</summary>
        <returns>
          <see langword="true" /> si le jeton de nom est valide ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [W3C XML 1.0 Recommendation](http://go.microsoft.com/fwlink/?LinkId=49863) pour déterminer si le jeton de nom est valid.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Vérifie si le nœud de contenu est une étiquette de début.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement();" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : unit -&gt; bool&#xA;override this.IsStartElement : unit -&gt; bool" Usage="xmlReader.IsStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appelle <see cref="M:System.Xml.XmlReader.MoveToContent" /> et vérifie si le nœud de contenu actuel est une balise de début ou une balise d'élément vide.</summary>
        <returns>
          <see langword="true" /> si <see cref="M:System.Xml.XmlReader.MoveToContent" /> trouve une balise de début ou une balise d'élément vide ; <see langword="false" /> si un type de nœud autre que <see langword="XmlNodeType.Element" /> est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ignore les espaces blancs, les commentaires et instructions de traitement jusqu'à ce que le lecteur est positionné sur un nœud de contenu. La méthode vérifie ensuite si le nœud actuel est un élément.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de texte de chaque élément.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 L’exemple utilise le fichier `elems.xml`comme entrée.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Code XML incorrect dans le flux d'entrée.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string -&gt; bool&#xA;override this.IsStartElement : string -&gt; bool" Usage="xmlReader.IsStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne comparée à la propriété <see langword="Name" /> de l'élément trouvé.</param>
        <summary>Appelle <see cref="M:System.Xml.XmlReader.MoveToContent" />, vérifie si le nœud de contenu actuel est une balise de début ou une balise d'élément vide, puis vérifie également si la propriété <see cref="P:System.Xml.XmlReader.Name" /> de l'élément trouvé correspond à l'argument spécifié.</summary>
        <returns>
          <see langword="true" /> si le nœud résultant est un élément et si la propriété <see langword="Name" /> correspond à la chaîne spécifiée. <see langword="false" /> si un type de nœud autre que <see langword="XmlNodeType.Element" /> a été trouvé ou si la propriété <see langword="Name" /> de l'élément ne correspond pas à la chaîne spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ignore les espaces blancs, les commentaires et instructions de traitement jusqu'à ce que le lecteur est positionné sur un nœud de contenu. La méthode vérifie ensuite si le nœud actuel est un élément.  
  
   
  
## Examples  
 L’exemple suivant affiche chaque élément de prix.  
  
 [!code-csharp[XmlReaderBasic#17](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#17)]
 [!code-vb[XmlReaderBasic#17](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Code XML incorrect dans le flux d'entrée.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (localname As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string * string -&gt; bool&#xA;override this.IsStartElement : string * string -&gt; bool" Usage="xmlReader.IsStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Chaîne à comparer à la propriété <see langword="LocalName" /> de l'élément trouvé.</param>
        <param name="ns">Chaîne à comparer à la propriété <see langword="NamespaceURI" /> de l'élément trouvé.</param>
        <summary>Appelle <see cref="M:System.Xml.XmlReader.MoveToContent" />, vérifie si le nœud de contenu actuel est une balise de début ou une balise d'élément vide, puis vérifie également si les propriétés <see cref="P:System.Xml.XmlReader.LocalName" /> et <see cref="P:System.Xml.XmlReader.NamespaceURI" /> de l'élément trouvé correspondent aux chaînes spécifiées.</summary>
        <returns>
          <see langword="true" /> si le nœud résultant est un élément. <see langword="false" /> si un type de nœud autre que <see langword="XmlNodeType.Element" /> a été trouvé ou si les propriétés <see langword="LocalName" /> et <see langword="NamespaceURI" /> de l'élément ne correspondent pas aux chaînes spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ignore les espaces blancs, les commentaires et instructions de traitement jusqu'à ce que le lecteur est positionné sur un nœud de contenu. La méthode vérifie ensuite si le nœud actuel est un élément.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Code XML incorrect dans le flux d'entrée.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>En cas de substitution dans une classe dérivée, obtient la valeur de l'attribut.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[int i] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[int] { System::String ^ get(int i); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Index de l'attribut.</param>
        <summary>En cas de substitution dans une classe dérivée, obtient la valeur de l'attribut avec l'index spécifié.</summary>
        <value>Valeur de l'attribut spécifié.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété ne déplace pas le lecteur.  
  
   
  
## Examples  
 L’exemple suivant affiche tous les attributs sur le nœud actuel.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom qualifié de l'attribut.</param>
        <summary>En cas de substitution dans une classe dérivée, obtient la valeur de l'attribut avec le <see cref="P:System.Xml.XmlReader.Name" /> spécifié.</summary>
        <value>Valeur de l'attribut spécifié. Si l'attribut est introuvable, <see langword="null" /> est retourné.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété ne déplace pas le lecteur.  
  
 Si le lecteur est positionné sur un `DocumentType` nœud, cette méthode peut être utilisée pour obtenir les littéraux PUBLIC et SYSTEM, par exemple, `reader["PUBLIC"]`  
  
   
  
## Examples  
 L’exemple suivant obtient la valeur de l’attribut de numéro ISBN.  
  
 [!code-csharp[XmlReaderBasic#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#7)]
 [!code-vb[XmlReaderBasic#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name, string namespaceURI] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^, System::String ^] { System::String ^ get(System::String ^ name, System::String ^ namespaceURI); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Le nom local de l'attribut.</param>
        <param name="namespaceURI">L'URI de l'espace de noms de l'attribut.</param>
        <summary>En cas de substitution dans une classe dérivée, obtient la valeur de l'attribut avec le <see cref="P:System.Xml.XmlReader.LocalName" /> et le <see cref="P:System.Xml.XmlReader.NamespaceURI" /> spécifiés.</summary>
        <value>Valeur de l'attribut spécifié. Si l'attribut est introuvable, <see langword="null" /> est retourné.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété ne déplace pas le lecteur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public abstract string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlReader.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le nom local du nœud actuel.</summary>
        <value>Nom du nœud actuel dont le préfixe est supprimé. Par exemple, <see langword="LocalName" /> est <see langword="book" /> pour l’élément <c> &lt;bk : Book&gt;</c>.  
  
Pour les types de nœuds qui n'ont pas de nom (par exemple <see langword="Text" />, <see langword="Comment" />, etc.), cette propriété retourne <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant affiche le nom local de chaque nœud, et, s’ils existent, le préfixe et l’URI de l’espace de noms.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 L’exemple utilise le fichier book2.xml, en tant qu’entrée.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="P:System.Xml.XmlReader.Name" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public abstract string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member LookupNamespace : string -&gt; string" Usage="xmlReader.LookupNamespace prefix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Préfixe dont vous souhaitez résoudre l'URI de l'espace de noms. Pour établir une correspondance avec l'espace de noms par défaut, passez une chaîne vide.</param>
        <summary>En cas de substitution dans une classe dérivée, résout un préfixe de l'espace de noms dans la portée de l'élément actuel.</summary>
        <returns>URI de l'espace de noms vers lequel le préfixe est mappé ou <see langword="null" /> si aucun préfixe correspondant n'est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans la chaîne XML suivante, si le lecteur est positionné sur le `href` d’attribut, le préfixe `a` est résolu en appelant `reader.LookupNamespace("a")`. La chaîne retournée est `urn:456`.  
  
```xml  
<root xmlns:a="urn:456">  
  <item>  
  <ref href="a:b"/>  
  </item>  
 </root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>En cas de substitution dans une classe dérivée, se déplace vers l'attribut spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public virtual void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MoveToAttribute (i As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveToAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : int -&gt; unit&#xA;override this.MoveToAttribute : int -&gt; unit" Usage="xmlReader.MoveToAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Index de l'attribut.</param>
        <summary>En cas de substitution dans une classe dérivée, se déplace vers l'attribut avec l'index spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant affiche tous les attributs sur le nœud actuel.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre a une valeur négative.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string -&gt; bool" Usage="xmlReader.MoveToAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom qualifié de l'attribut.</param>
        <summary>En cas de substitution dans une classe dérivée, se déplace vers l'attribut avec le <see cref="P:System.Xml.XmlReader.Name" /> spécifié.</summary>
        <returns>
          <see langword="true" /> si l'attribut est trouvé ; sinon, <see langword="false" />. Si la valeur est <see langword="false" />, la position du lecteur ne change pas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Après avoir appelé `MoveToAttribute`, le <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, et <xref:System.Xml.XmlReader.Prefix%2A> propriétés reflètent les propriétés de cet attribut.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.ArgumentException">Le paramètre est une chaîne vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string * string -&gt; bool" Usage="xmlReader.MoveToAttribute (name, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Le nom local de l'attribut.</param>
        <param name="ns">L'URI de l'espace de noms de l'attribut.</param>
        <summary>En cas de substitution dans une classe dérivée, se déplace vers l'attribut avec le <see cref="P:System.Xml.XmlReader.LocalName" /> et le <see cref="P:System.Xml.XmlReader.NamespaceURI" /> spécifiés.</summary>
        <returns>
          <see langword="true" /> si l'attribut est trouvé ; sinon, <see langword="false" />. Si la valeur est <see langword="false" />, la position du lecteur ne change pas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Après avoir appelé `MoveToAttribute`, le <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, et <xref:System.Xml.XmlReader.Prefix%2A> propriétés reflètent les propriétés de cet attribut.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.ArgumentNullException">La valeur des deux paramètres est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContent">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeType MoveToContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Xml.XmlNodeType MoveToContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContent () As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeType MoveToContent();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContent : unit -&gt; System.Xml.XmlNodeType&#xA;override this.MoveToContent : unit -&gt; System.Xml.XmlNodeType" Usage="xmlReader.MoveToContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie si le nœud actuel est un nœud de contenu (texte non constitué d'espaces blancs, <see langword="CDATA" />, <see langword="Element" />, <see langword="EndElement" />, <see langword="EntityReference" /> ou <see langword="EndEntity" />). Si le nœud n'est pas un nœud de contenu, le lecteur avance jusqu'au nœud de contenu suivant ou jusqu'à la fin du fichier. Il ignore les nœuds possédant les types suivants : <see langword="ProcessingInstruction" />, <see langword="DocumentType" />, <see langword="Comment" />, <see langword="Whitespace" /> ou <see langword="SignificantWhitespace" />.</summary>
        <returns>L’élément <see cref="P:System.Xml.XmlReader.NodeType" /> du nœud actuel trouvé par la méthode ou <see langword="XmlNodeType.None" /> si le lecteur a atteint la fin du flux d'entrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le nœud actuel est un nœud d’attribut, cette méthode déplace le lecteur à l’élément qui possède l’attribut.  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.MoveToContentAsync%2A>.  
  
   
  
## Examples  
 Cela est utile lorsque vous souhaitez écrire du code qui permet d’ignorer un balisage XML aléatoire sans rupture. Par exemple, supposons que vous avez le code suivant :  
  
 [!code-cpp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/VB/source.vb#1)]  
  
 Ce code peut gérer les entrées suivantes sans rupture :  
  
```xml  
<price>123.4</price>  
```  
  
 et  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM  
  "abc"><price>123.4</price>  
```  
  
 et  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM "abc"  
  [<!ENTTIY p  
  "123.4">]><price>&p;</price>  
```  
  
 et  
  
```xml  
<!-- some test comment --><?processing  
  instruction?><price>123.4</price>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Code XML incorrect dans le flux d'entrée.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt; MoveToContentAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;valuetype System.Xml.XmlNodeType&gt; MoveToContentAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContentAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContentAsync () As Task(Of XmlNodeType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Xml::XmlNodeType&gt; ^ MoveToContentAsync();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;&#xA;override this.MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;" Usage="xmlReader.MoveToContentAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie de façon asynchrone si le nœud actuel est un nœud de contenu. Si le nœud n'est pas un nœud de contenu, le lecteur avance jusqu'au nœud de contenu suivant ou jusqu'à la fin du fichier.</summary>
        <returns>L’élément <see cref="P:System.Xml.XmlReader.NodeType" /> du nœud actuel trouvé par la méthode ou <see langword="XmlNodeType.None" /> si le lecteur a atteint la fin du flux d'entrée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.MoveToContent%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public abstract bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToElement();" />
      <MemberSignature Language="F#" Value="abstract member MoveToElement : unit -&gt; bool" Usage="xmlReader.MoveToElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, se déplace vers l'élément contenant le nœud d'attribut actuel.</summary>
        <returns>
          <see langword="true" /> si le lecteur est placé sur un attribut (le lecteur se déplace vers l'élément qui possède l'attribut) ; <see langword="false" /> si le lecteur n'est pas placé sur un attribut (la position du lecteur ne change pas).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour retourner à un élément après avoir navigué dans ses attributs. Cette méthode déplace le lecteur vers un des types de nœuds suivants : `Element`, `DocumentType`, ou `XmlDeclaration`.  
  
   
  
## Examples  
 L’exemple suivant affiche tous les attributs sur le nœud actuel.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToFirstAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToFirstAttribute : unit -&gt; bool" Usage="xmlReader.MoveToFirstAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, se déplace vers le premier attribut.</summary>
        <returns>
          <see langword="true" /> si un attribut existe (le lecteur se déplace vers le premier attribut) ; sinon, <see langword="false" /> (la position du lecteur ne change pas).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant obtient la valeur du premier attribut.  
  
 [!code-csharp[XmlReaderBasic#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#5)]
 [!code-vb[XmlReaderBasic#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToNextAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToNextAttribute : unit -&gt; bool" Usage="xmlReader.MoveToNextAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, se déplace vers l'attribut suivant.</summary>
        <returns>
          <see langword="true" /> s'il existe un attribut suivant ; <see langword="false" /> s'il n'existe plus d'attributs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le nœud actuel est un nœud d’élément, cette méthode équivaut à <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>. Si `MoveToNextAttribute` retourne `true`, le lecteur se déplace vers l’attribut suivant ; sinon, la position du lecteur ne change pas.  
  
   
  
## Examples  
 L’exemple suivant affiche tous les attributs sur le nœud actuel.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlReader.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le nom qualifié du nœud actuel.</summary>
        <value>Nom qualifié du nœud actuel. Par exemple, <see langword="Name" /> est <see langword="bk:book" /> pour l’élément <c> &lt;bk : Book&gt;</c>.  
  
Le nom retourné dépend du <see cref="P:System.Xml.XmlReader.NodeType" /> du nœud. Les types de nœuds suivants retournent les valeurs répertoriées. Tous les autres types de nœuds retournent une chaîne vide.  
  
 <list type="table"><listheader><term> Type de nœud 
 </term><description> Name 
 </description></listheader><item><term><see langword="Attribute" /></term><description> Nom de l'attribut.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> Nom du type de document.  
  
 </description></item><item><term><see langword="Element" /></term><description> Nom de l’étiquette.  
  
 </description></item><item><term><see langword="EntityReference" /></term><description> Nom de l'entité référencée.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Cible de l'instruction de traitement.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> Chaîne littérale <see langword="xml" />.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant lit un fichier XML et affiche chacun des nœuds.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 L’exemple utilise le `items.xml` fichier.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="P:System.Xml.XmlReader.LocalName" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public abstract string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceURI : string" Usage="System.Xml.XmlReader.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient l'URI de l'espace de noms (tel qu'il est défini dans la spécification relative aux espaces de noms du W3C) du nœud sur lequel le lecteur est placé.</summary>
        <value>URI d'espace de noms du nœud actuel ; sinon, une chaîne vide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété s’applique aux `Element` et `Attribute` uniquement les nœuds.  
  
   
  
## Examples  
 L’exemple suivant affiche le nom local de chaque nœud, et, s’ils existent, le préfixe et l’URI de l’espace de noms.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 L’exemple utilise le fichier book2.xml, en tant qu’entrée.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlReader.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le <see cref="T:System.Xml.XmlNameTable" /> associé à cette implémentation.</summary>
        <value>
          <see langword="XmlNameTable" /> vous permettant d'obtenir la version atomisée d'une chaîne au sein du nœud.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tous les noms de nœuds et d’attributs retournés à partir <xref:System.Xml.XmlReader> sont atomisés à l’aide de la `NameTable`. Lorsque le même nom est retourné plusieurs fois (par exemple, `Customer`), puis dans le même `String` objet sera retourné pour ce nom. Cela rend possible d’écrire un code efficace qui effectue des comparaisons sur ces chaînes au lieu de comparaisons de chaînes coûteux d’objets.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlReader.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le type du nœud actuel.</summary>
        <value>Une des valeurs d'énumération qui spécifient le type du nœud actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant lit un fichier XML et affiche chacun des nœuds.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 L’exemple utilise le `items.xml` fichier.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public abstract string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string" Usage="System.Xml.XmlReader.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le préfixe de l'espace de noms associé au nœud actuel.</summary>
        <value>Préfixe de l'espace de noms associé au nœud actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant affiche le nom local de chaque nœud, et, s’ils existent, le préfixe et l’URI de l’espace de noms.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 L’exemple utilise le fichier book2.xml, en tant qu’entrée.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public virtual char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.QuoteChar : char" Usage="System.Xml.XmlReader.QuoteChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le caractère guillemet permettant de délimiter la valeur d'un nœud d'attribut.</summary>
        <value>Caractère guillemet (" ou ') permettant de délimiter la valeur d'un nœud d'attribut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété s’applique uniquement à un nœud d’attribut.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Read();" />
      <MemberSignature Language="F#" Value="abstract member Read : unit -&gt; bool" Usage="xmlReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, lit le nœud suivant à partir du flux.</summary>
        <returns>
          <see langword="true" /> si le nœud suivant est correctement lu ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand un <xref:System.Xml.XmlReader> est d’abord créé et initialisé, il n’existe aucune information disponible. Vous devez appeler <xref:System.Xml.XmlReader.Read%2A> pour lire le premier nœud. Le <xref:System.Xml.XmlReader.Read%2A> méthode définit l’état du lecteur XML pour lancer <xref:System.Xml.ReadState> et déplace via le fichier XML de façon séquentielle jusqu'à ce qu’il atteigne la fin du fichier, auquel cas la méthode retourne une valeur de `false`.  
  
 Cette méthode nécessite au moins quatre octets à partir du flux de données pour commencer l’analyse. Si moins de quatre octets est renvoyés et il n’existe plus aucune donnée dans le flux, la méthode retourne `false`. S’il existe plus de données dans le flux, la méthode se bloque jusqu'à la réception du quatrième octet d’analyse.  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.ReadAsync%2A>.  
  
   
  
## Examples  
 L’exemple suivant lit un fichier XML et affiche chacun des nœuds.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 L’exemple utilise le `items.xml` fichier.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 **Sortie :**  
  
```  
<Item>Test with an entity: 123</Item><Item>Test with a child element <more> stuff</Item><Item>Test with a CDATA section <![CDATA[<456>]]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Une erreur s’est produite lors de l’analyse du XML.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;bool&gt; ReadAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;bool&gt; ReadAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadAsync () As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;bool&gt; ^ ReadAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;&#xA;override this.ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="xmlReader.ReadAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit de façon asynchrone le nœud suivant à partir du flux de données.</summary>
        <returns>
          <see langword="true" /> si le nœud suivant a été lu correctement ; <see langword="false" /> s'il n'y a plus de nœuds à lire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.Read%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public abstract bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool ReadAttributeValue();" />
      <MemberSignature Language="F#" Value="abstract member ReadAttributeValue : unit -&gt; bool" Usage="xmlReader.ReadAttributeValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, analyse la valeur d'attribut dans un ou plusieurs nœuds <see langword="Text" />, <see langword="EntityReference" /> ou <see langword="EndEntity" />.</summary>
        <returns>
          <see langword="true" /> s'il y a des nœuds à retourner.  
  
 <see langword="false" /> si le lecteur n'est pas placé sur un nœud d'attribut quand l'appel initial est effectué ou si toutes les valeurs d'attributs ont été lues.  
  
Un attribut vide, tel que <c>misc=""</c>, retourne <see langword="true" /> avec un nœud unique et la valeur <see langword="String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode après avoir appelé <xref:System.Xml.XmlReader.MoveToAttribute%2A> pour lire les nœuds de référence de texte ou une entité qui composent la valeur d’attribut. Le <xref:System.Xml.XmlReader.Depth%2A> les valeur nœuds d’attribut est la profondeur du nœud d’attribut ; il incrémente et décrémente de 1 lorsque vous arrivez dans et en dehors des références d’entité générales.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Type de la valeur à retourner.  
  
 **Remarque** Avec le .NET Framework version 3.5, la valeur du paramètre <c>returnType</c> peut maintenant être le type <see cref="T:System.DateTimeOffset" />.</param>
        <param name="namespaceResolver">Objet <see cref="T:System.Xml.IXmlNamespaceResolver" /> permettant de résoudre tous les préfixes d'espaces de noms liés à la conversion de type. Par exemple, il peut être utilisé lors de la conversion d’un objet <see cref="T:System.Xml.XmlQualifiedName" /> en <c>xs:string</c>.  
  
Cette valeur peut être <see langword="null" />.</param>
        <summary>Lit le contenu en tant qu'objet du type spécifié.</summary>
        <returns>Contenu de texte concaténé ou valeur d'attribut converti(e) en type demandé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit le contenu de texte à la position actuelle du lecteur et le convertit en type de retour demandé. Le texte, les espaces blancs, les espaces blancs significatifs et les sections CDATA sont concaténés. Les commentaires et les instructions de traitement sont ignorés et les références d'entité sont automatiquement résolues.  
  
 Cette méthode est utilisée pour lire, convertir si nécessaire et retourner les éléments de valeur atomique à partir du nœud actuel du contenu. Si le type d’entrée est des mappages valides pour le type du nœud actuel, une instance du type cible contenant la valeur du nœud actuel est retourné. Consultez la section Notes dans le <xref:System.Xml.XmlReader> referencepage pour obtenir la liste des mappages par défaut.  
  
 Par exemple, si vous aviez le texte XML suivant :  
  
```xml  
<elem>123 <!-- comment --> <?pi my_text?> 456 <?pi another_pi?></elem>  
```  
  
 Si les données sont typées et un tableau de chaînes est fourni à la <xref:System.Xml.XmlReader.ReadContentAs%2A> appel de méthode, puis les valeurs entières sont converties à partir de chaînes en fonction de la liste des mappages de type CLR valides.  
  
 Si les données ne soient pas typées et un tableau de chaînes est fourni à la <xref:System.Xml.XmlReader.ReadContentAs%2A> appel de méthode, puis le contenu est analysé dans des chaînes séparées. Un tableau contenant deux chaînes est retourné avec les valeurs « 123 » et « 456 ». Les espaces ne sont pas conservées à partir du contenu.  
  
 En général lors de la lecture des données non typées le contenu est analysé en fonction du type fourni. Par exemple, si un tableau d’entiers est fourni à la <xref:System.Xml.XmlReader.ReadContentAs%2A> appel de méthode, la chaîne est analysée en un tableau d’entiers {123,456}.  
  
 Dans l’exemple suivant le texte XML n’est pas séparé par des espaces  
  
```xml  
<elem>123<!-- comment --><?pi my_text?>456789<?pi another_pi?></elem>  
```  
  
 Si le contenu est non typé et un tableau de chaînes est fourni à la <xref:System.Xml.XmlReader.ReadContentAs%2A> appel de méthode ensuite un tableau contenant une chaîne concaténée est retourné avec la valeur « 123456789 ».  
  
 Le tableau suivant décrit la manière dont cette méthode traite chaque type de nœud.  
  
|XmlNodeType|Valeur de retour|Comportement du lecteur|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Nœuds de contenus de texte, CDATA, d'espace blanc et d'espace blanc significatif concaténés convertis en type demandé.|Avance jusqu’à l’étiquette d’élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`Attribute`|Même que si vous appelez `XmlConvert.ToXxx` sur la valeur d’attribut.|Le lecteur reste dans sa position actuelle.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignore l'instruction de traitement ou le commentaire et lit le contenu du texte concaténé qui suit l'instruction ou le commentaire.|Avance jusqu'à la balise d'élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`EndElement`|Chaîne vide.|Le lecteur reste dans sa position actuelle.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Un objet <xref:System.InvalidOperationException> est levé.|Non défini, bien que le lecteur reste généralement dans sa position actuelle.|  
  
 Pour plus d’informations, consultez la section Notes de la <xref:System.Xml.XmlReader> page de référence et le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.ReadContentAsAsync%2A>.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Xml.XmlReader.ReadContentAs%2A> méthode pour retourner le contenu de l’élément de couleurs dans un tableau d’objets string.  
  
 [!code-csharp[XmlReader.ReadContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#2)]
 [!code-vb[XmlReader.ReadContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#2)]  
  
 L'exemple prend le fichier `dataFile_2.xml` comme entrée.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Le format du contenu n'est pas correct pour le type cible.</exception>
        <exception cref="T:System.InvalidCastException">La tentative de cast n'est pas valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="returnType" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.OverflowException">Lire <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Type de la valeur à retourner.</param>
        <param name="namespaceResolver">Objet <see cref="T:System.Xml.IXmlNamespaceResolver" /> permettant de résoudre tous les préfixes d'espaces de noms liés à la conversion de type.</param>
        <summary>Lit de façon asynchrone le contenu en tant qu'objet du type spécifié.</summary>
        <returns>Contenu de texte concaténé ou valeur d'attribut converti(e) en type demandé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.ReadContentAs%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dans laquelle copier le texte obtenu. Cette valeur ne peut pas être <see langword="null" />.</param>
        <param name="index">Offset de la mémoire tampon où commence la copie du résultat.</param>
        <param name="count">Nombre maximal d'octets à copier dans la mémoire tampon. Le nombre réel d'octets copiés est retourné à partir de cette méthode.</param>
        <summary>Lit le contenu et retourne les octets binaires décodés au format Base64.</summary>
        <returns>Nombre d'octets écrits dans la mémoire tampon.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diffuse le contenu de cette méthode, décode le `Base64` de contenu et retourne les octets binaires décodés (par exemple, une ligne `Base64` encodé image GIF) dans la mémoire tampon. Cette méthode peut être appelée successivement pour lire des flux importants de texte incorporé. Pour plus d’informations, consultez RFC 1521, « partie MIME (Multipurpose Internet Mail Extensions) un : mécanismes pour la spécification et qui décrit le Format du corps de Message Internet ». Vous pouvez obtenir les RFC sur le [site Web de commentaires des](http://go.microsoft.com/fwlink/?LinkId=37119).  
  
> [!NOTE]
>  Vous ne devez accéder à des propriétés du lecteur entre les appels à la <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> méthode jusqu'à ce que la méthode retourne la valeur `0`.  
  
 Cette méthode a le comportement suivant :  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> Retourne la valeur `0` quand il a atteint la fin du flux d’octets il s’exécutait. Le lecteur est positionné sur le premier nœud sans contenu.  
  
-   Si vous demandez au maximum, ou le nombre exact d’octets sont laissés dans le flux que le lecteur reste dans sa position actuelle.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> n’est pas pris en charge sur les types de nœud XML suivants : `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.ReadContentAsBase64Async%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index de la mémoire tampon (ou l'index augmenté de la valeur du paramètre count) est supérieur à la taille de la mémoire tampon allouée.</exception>
        <exception cref="T:System.NotSupportedException">L'implémentation de <see cref="T:System.Xml.XmlReader" /> ne prend pas en charge cette méthode.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dans laquelle copier le texte obtenu. Cette valeur ne peut pas être <see langword="null" />.</param>
        <param name="index">Offset de la mémoire tampon où commence la copie du résultat.</param>
        <param name="count">Nombre maximal d'octets à copier dans la mémoire tampon. Le nombre réel d'octets copiés est retourné à partir de cette méthode.</param>
        <summary>Lit de façon asynchrone le contenu et retourne les octets binaires décodés au format Base64.</summary>
        <returns>Nombre d'octets écrits dans la mémoire tampon.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dans laquelle copier le texte obtenu. Cette valeur ne peut pas être <see langword="null" />.</param>
        <param name="index">Offset de la mémoire tampon où commence la copie du résultat.</param>
        <param name="count">Nombre maximal d'octets à copier dans la mémoire tampon. Le nombre réel d'octets copiés est retourné à partir de cette méthode.</param>
        <summary>Lit le contenu et retourne les octets binaires décodés au format <see langword="BinHex" />.</summary>
        <returns>Nombre d'octets écrits dans la mémoire tampon.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diffuse le contenu de cette méthode, décode le `BinHex` de contenu et retourne les octets binaires décodés (par exemple, une ligne `BinHex` encodé image GIF) dans la mémoire tampon. Cette méthode peut être appelée successivement pour lire des flux importants de texte incorporé.  
  
> [!NOTE]
>  Vous ne devez accéder à des propriétés du lecteur entre les appels à la <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> méthode jusqu'à ce que la méthode retourne la valeur `0`.  
  
 Cette méthode a le comportement suivant :  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> Retourne la valeur `0` quand il a atteint la fin du flux d’octets il s’exécutait. Le lecteur est positionné sur le premier nœud sans contenu.  
  
-   Si vous demandez à moins, ou le nombre exact, des octets encore dans le flux du lecteur reste dans sa position actuelle.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> n’est pas pris en charge sur les types de nœud XML suivants : `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation, Entity`, `DocumentFragment`.  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.ReadContentAsBinHexAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index de la mémoire tampon (ou l'index augmenté de la valeur du paramètre count) est supérieur à la taille de la mémoire tampon allouée.</exception>
        <exception cref="T:System.NotSupportedException">L'implémentation de <see cref="T:System.Xml.XmlReader" /> ne prend pas en charge cette méthode.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dans laquelle copier le texte obtenu. Cette valeur ne peut pas être <see langword="null" />.</param>
        <param name="index">Offset de la mémoire tampon où commence la copie du résultat.</param>
        <param name="count">Nombre maximal d'octets à copier dans la mémoire tampon. Le nombre réel d'octets copiés est retourné à partir de cette méthode.</param>
        <summary>Lit de façon asynchrone le contenu et retourne les octets binaires décodés au format <see langword="BinHex" />.</summary>
        <returns>Nombre d'octets écrits dans la mémoire tampon.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBoolean : unit -&gt; bool&#xA;override this.ReadContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le contenu de texte à la position actuelle comme un <see langword="Boolean" />.</summary>
        <returns>Contenu de texte sous la forme d'un objet <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode concatène le texte, les espaces, les espaces blancs significatifs et les sections CDATA et ignore des commentaires ou des instructions de traitement. Références d’entité sont automatiquement résolues.  
  
 Si le contenu est de type `xsd:boolean`, le lecteur retourne un unboxed <xref:System.Boolean> objet. Si le contenu n’est pas typé `xsd:boolean`, le lecteur tente du convertir en un <xref:System.Boolean> objet selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Le tableau suivant décrit la manière dont cette méthode traite chaque type de nœud.  
  
|XmlNodeType|Valeur de retour|Comportement du lecteur|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Nœuds de contenus de texte, CDATA, d'espace blanc et d'espace blanc significatif concaténés convertis en type demandé.|Avance jusqu’à l’étiquette d’élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`Attribute`|Même que si vous appelez `XmlConvert.ToXxx` sur la valeur d’attribut.|Le lecteur reste dans sa position actuelle.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignore l'instruction de traitement ou le commentaire et lit le contenu du texte concaténé qui suit l'instruction ou le commentaire.|Avance jusqu'à la balise d'élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`EndElement`|Chaîne vide.|Le lecteur reste dans sa position actuelle.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Un objet <xref:System.InvalidOperationException> est levé.|Non défini, bien que le lecteur reste généralement dans sa position actuelle.|  
  
 Pour plus d’informations, consultez le <xref:System.Xml.XmlReader> page de référence et le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> méthode pour lire l’attribut sous la forme d’un B`oolean` valeur.  
  
 [!code-csharp[XmlReader.ReadContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#1)]
 [!code-vb[XmlReader.ReadContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#1)]  
  
 L'exemple prend le fichier `dataFile_2.xml` comme entrée.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La tentative de cast n'est pas valide.</exception>
        <exception cref="T:System.FormatException">Le format de chaîne n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le contenu de texte à la position actuelle comme un objet <see cref="T:System.DateTime" />.</summary>
        <returns>Contenu de texte sous la forme d'un objet <see cref="T:System.DateTime" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode concatène le texte, les espaces, les espaces blancs significatifs et les sections CDATA et ignore des commentaires ou des instructions de traitement. Références d’entité sont automatiquement résolues.  
  
 Si le contenu est de type `xsd:dateTime`, le lecteur retourne un unboxed <xref:System.DateTime> objet. Si le contenu n’est pas typé `xsd:dateTime`, le lecteur tente du convertir en un <xref:System.DateTime> objet selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
> [!NOTE]
>  Vous ne pouvez pas compter sur la valeur <xref:System.DateTime.Year%2A?displayProperty=nameWithType> lorsque le contenu est de type `xsd:gMonthDay`. <xref:System.Xml.XmlReader> définit toujours la <xref:System.DateTime.Year%2A?displayProperty=nameWithType> valeur sur 1904 dans ce cas.  
  
 Le tableau suivant décrit la manière dont cette méthode traite chaque type de nœud.  
  
|XmlNodeType|Valeur de retour|Comportement du lecteur|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Nœuds de contenus de texte, CDATA, d'espace blanc et d'espace blanc significatif concaténés convertis en type demandé.|Avance jusqu’à l’étiquette d’élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`Attribute`|Même que si vous appelez `XmlConvert.ToXxx` sur la valeur d’attribut.|Le lecteur reste dans sa position actuelle.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignore l'instruction de traitement ou le commentaire et lit le contenu du texte concaténé qui suit l'instruction ou le commentaire.|Avance jusqu'à la balise d'élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`EndElement`|Chaîne vide.|Le lecteur reste dans sa position actuelle.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Un objet <xref:System.InvalidOperationException> est levé.|Non défini, bien que le lecteur reste généralement dans sa position actuelle.|  
  
 Pour plus d’informations, consultez le <xref:System.Xml.XmlReader> page de référence et le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La tentative de cast n'est pas valide.</exception>
        <exception cref="T:System.FormatException">Le format de chaîne n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTimeOffset">
      <MemberSignature Language="C#" Value="public virtual DateTimeOffset ReadContentAsDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTimeOffset ReadContentAsDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTimeOffset ReadContentAsDateTimeOffset();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset&#xA;override this.ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset" Usage="xmlReader.ReadContentAsDateTimeOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le contenu de texte à la position actuelle comme un objet <see cref="T:System.DateTimeOffset" />.</summary>
        <returns>Contenu de texte sous la forme d'un objet <see cref="T:System.DateTimeOffset" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le contenu de texte à la position actuelle comme un objet <see cref="T:System.Decimal" />.</summary>
        <returns>Contenu de texte à la position actuelle comme un objet <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode concatène le texte, les espaces, les espaces blancs significatifs et les sections CDATA et ignore des commentaires ou des instructions de traitement. Références d’entité sont automatiquement résolues.  
  
 Si le contenu est de type `xsd:decimal`, le lecteur retourne un unboxed <xref:System.Decimal> objet. Si le contenu n’est pas typé `xsd:decimal`, le lecteur tente du convertir en un <xref:System.Decimal> objet selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Le tableau suivant décrit la manière dont cette méthode traite chaque type de nœud.  
  
|XmlNodeType|Valeur de retour|Comportement du lecteur|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Nœuds de contenus de texte, CDATA, d'espace blanc et d'espace blanc significatif concaténés convertis en type demandé.|Avance jusqu’à l’étiquette d’élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`Attribute`|Même que si vous appelez `XmlConvert.ToXxx` sur la valeur d’attribut.|Le lecteur reste dans sa position actuelle.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignore l'instruction de traitement ou le commentaire et lit le contenu du texte concaténé qui suit l'instruction ou le commentaire.|Avance jusqu'à la balise d'élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`EndElement`|Chaîne vide.|Le lecteur reste dans sa position actuelle.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Un objet <xref:System.InvalidOperationException> est levé.|Non défini, bien que le lecteur reste généralement dans sa position actuelle.|  
  
 Pour plus d’informations, consultez le <xref:System.Xml.XmlReader> page de référence et le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La tentative de cast n'est pas valide.</exception>
        <exception cref="T:System.FormatException">Le format de chaîne n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDouble : unit -&gt; double&#xA;override this.ReadContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le contenu de texte à la position actuelle en tant que nombre à virgule flottante double précision.</summary>
        <returns>Contenu de texte sous la forme d'un nombre à virgule flottante double précision.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode concatène le texte, les espaces, les espaces blancs significatifs et les sections CDATA et ignore des commentaires ou des instructions de traitement. Références d’entité sont automatiquement résolues.  
  
 Si le contenu est de type `xsd:double`, le lecteur retourne un nombre à virgule flottante double précision. Si le contenu n’est pas typé `xsd:double`, le lecteur tente de convertir en un nombre à virgule flottante double précision selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Le tableau suivant décrit la manière dont cette méthode traite chaque type de nœud.  
  
|XmlNodeType|Valeur de retour|Comportement du lecteur|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Nœuds de contenus de texte, CDATA, d'espace blanc et d'espace blanc significatif concaténés convertis en type demandé.|Avance jusqu’à l’étiquette d’élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`Attribute`|Même que si vous appelez `XmlConvert.ToXxx` sur la valeur d’attribut.|Le lecteur reste dans sa position actuelle.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignore l'instruction de traitement ou le commentaire et lit le contenu du texte concaténé qui suit l'instruction ou le commentaire.|Avance jusqu'à la balise d'élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`EndElement`|Chaîne vide.|Le lecteur reste dans sa position actuelle.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Un objet <xref:System.InvalidOperationException> est levé.|Non défini, bien que le lecteur reste généralement dans sa position actuelle.|  
  
 Pour plus d’informations, consultez le <xref:System.Xml.XmlReader> page de référence et le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La tentative de cast n'est pas valide.</exception>
        <exception cref="T:System.FormatException">Le format de chaîne n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsFloat : unit -&gt; single&#xA;override this.ReadContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le contenu de texte à la position actuelle en tant que nombre à virgule flottante simple précision.</summary>
        <returns>Contenu de texte à la position actuelle en tant que nombre à virgule flottante simple précision.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode concatène le texte, les espaces, les espaces blancs significatifs et les sections CDATA et ignore des commentaires ou des instructions de traitement. Références d’entité sont automatiquement résolues.  
  
 Si le contenu est de type `xsd:float`, le lecteur retourne un unboxed un nombre à virgule flottante simple précision. Si le contenu n’est pas typé `xsd:float`, le lecteur tente de convertir en un nombre à virgule flottante simple précision selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Le tableau suivant décrit la manière dont cette méthode traite chaque type de nœud.  
  
|XmlNodeType|Valeur de retour|Comportement du lecteur|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Nœuds de contenus de texte, CDATA, d'espace blanc et d'espace blanc significatif concaténés convertis en type demandé.|Avance jusqu’à l’étiquette d’élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`Attribute`|Même que si vous appelez `XmlConvert.ToXxx` sur la valeur d’attribut.|Le lecteur reste dans sa position actuelle.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignore l'instruction de traitement ou le commentaire et lit le contenu du texte concaténé qui suit l'instruction ou le commentaire.|Avance jusqu'à la balise d'élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`EndElement`|Chaîne vide.|Le lecteur reste dans sa position actuelle.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Un objet <xref:System.InvalidOperationException> est levé.|Non défini, bien que le lecteur reste généralement dans sa position actuelle.|  
  
 Pour plus d’informations, consultez la section Notes de la <xref:System.Xml.XmlReader> page de référence et le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La tentative de cast n'est pas valide.</exception>
        <exception cref="T:System.FormatException">Le format de chaîne n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsInt : unit -&gt; int&#xA;override this.ReadContentAsInt : unit -&gt; int" Usage="xmlReader.ReadContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le contenu de texte à la position actuelle comme un entier signé de 32 bits.</summary>
        <returns>Contenu de texte sous la forme d'un entier signé de 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode concatène le texte, les espaces, les espaces blancs significatifs et les sections CDATA et ignore des commentaires ou des instructions de traitement. Références d’entité sont automatiquement résolues.  
  
 Si le contenu est de type `xsd:integer`, le lecteur retourne un entier signé 32 bits unboxed. Si le contenu n’est pas typé `xsd:integer`, le lecteur tente de convertir en un entier signé 32 bits selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Le tableau suivant décrit la manière dont cette méthode traite chaque type de nœud.  
  
|XmlNodeType|Valeur de retour|Comportement du lecteur|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Nœuds de contenus de texte, CDATA, d'espace blanc et d'espace blanc significatif concaténés convertis en type demandé.|Avance jusqu’à l’étiquette d’élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`Attribute`|Même que si vous appelez `XmlConvert.ToXxx` sur la valeur d’attribut.|Le lecteur reste dans sa position actuelle.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignore l'instruction de traitement ou le commentaire et lit le contenu du texte concaténé qui suit l'instruction ou le commentaire.|Avance jusqu'à la balise d'élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`EndElement`|Chaîne vide.|Le lecteur reste dans sa position actuelle.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Un objet <xref:System.InvalidOperationException> est levé.|Non défini, bien que le lecteur reste généralement dans sa position actuelle.|  
  
 Pour plus d’informations, consultez la section Notes de la <xref:System.Xml.XmlReader> page de référence et le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La tentative de cast n'est pas valide.</exception>
        <exception cref="T:System.FormatException">Le format de chaîne n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsLong : unit -&gt; int64&#xA;override this.ReadContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le contenu de texte à la position actuelle comme un entier signé de 64 bits.</summary>
        <returns>Contenu de texte sous la forme d'un entier signé de 64 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode concatène le texte, les espaces, les espaces blancs significatifs et les sections CDATA et ignore des commentaires ou des instructions de traitement. Références d’entité sont automatiquement résolues.  
  
 Si le contenu est de type `xsd:long`, le lecteur retourne un entier signé 64 bits unboxed. Si le contenu n’est pas typé `xsd:long`, le lecteur tente de convertir en un entier signé 64 bits selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Le tableau suivant décrit cette méthode traite chaque type de nœud.  
  
|XmlNodeType|Valeur de retour|Comportement du lecteur|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Nœuds de contenus de texte, CDATA, d'espace blanc et d'espace blanc significatif concaténés convertis en type demandé.|Avance jusqu’à l’étiquette d’élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`Attribute`|Identique à `XmlConvert.ToXxx` sur la valeur d’attribut.|Le lecteur reste dans sa position actuelle|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignore l'instruction de traitement ou le commentaire et lit le contenu du texte concaténé qui suit l'instruction ou le commentaire.|Avance jusqu'à la balise d'élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`EndElement`|Chaîne vide.|Le lecteur reste dans sa position actuelle.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Un objet <xref:System.InvalidOperationException> est levé.|Non défini, bien que le lecteur reste généralement dans sa position actuelle.|  
  
 Pour plus d'informations, consultez la section Notes de la page de référence <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La tentative de cast n'est pas valide.</exception>
        <exception cref="T:System.FormatException">Le format de chaîne n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObject : unit -&gt; obj&#xA;override this.ReadContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le contenu de texte à la position actuelle comme un <see cref="T:System.Object" />.</summary>
        <returns>Contenu de texte sous la forme de l'objet CLR le plus approprié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode concatène le texte, les espaces, les espaces blancs significatifs et les sections CDATA et ignore des commentaires ou des instructions de traitement. Références d’entité sont automatiquement résolues.  
  
 Si le contenu est typé, le lecteur retourne un CLR boxed du type plus approprié, spécifié par le <xref:System.Xml.XmlReader.ValueType%2A> propriété. Si le contenu est un type de liste, le lecteur retourne un tableau d’objets boxed du type approprié.  
  
> [!NOTE]
>  Si une erreur de validation se produit lors de l’analyse du contenu et le lecteur est un <xref:System.Xml.XmlReader> objet créé par le <xref:System.Xml.XmlReader.Create%2A> (méthode), le lecteur retourne le contenu sous forme de chaîne. En d’autres termes lorsqu’une erreur de validation ou un avertissement se produit, le contenu est considéré comme non typé.  
  
 Si le contenu n'est pas typé, le lecteur retourne le contenu sous la forme d'une chaîne.  
  
 Le tableau suivant décrit la manière dont cette méthode traite chaque type de nœud.  
  
|XmlNodeType|Valeur de retour|Comportement du lecteur|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Nœuds de contenus de texte, CDATA, d'espace blanc et d'espace blanc significatif concaténés convertis en type demandé.|Avance jusqu’à l’étiquette d’élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`Attribute`|Même que si vous appelez `XmlConvert.ToXxx` sur la valeur d’attribut.|Le lecteur reste dans sa position actuelle|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignore l'instruction de traitement ou le commentaire et lit le contenu du texte concaténé qui suit l'instruction ou le commentaire.|Avance jusqu'à la balise d'élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`EndElement`|La valeur de l’élément si le lecteur est un lecteur de validation de schéma (<xref:System.Xml.XmlReaderSettings.ValidationType%2A> a la valeur <xref:System.Xml.ValidationType.Schema>) ; sinon, une chaîne vide.|Le lecteur reste dans sa position actuelle.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Un objet <xref:System.InvalidOperationException> est levé.|Non défini, bien que le lecteur reste généralement dans sa position actuelle.|  
  
 Pour plus d’informations, consultez la section Notes de la <xref:System.Xml.XmlReader> page de référence et le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La tentative de cast n'est pas valide.</exception>
        <exception cref="T:System.FormatException">Le format de chaîne n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit de façon asynchrone le contenu de texte à la position actuelle comme un objet <see cref="T:System.Object" />.</summary>
        <returns>Contenu de texte sous la forme de l'objet CLR le plus approprié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.ReadContentAsObject%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsString : unit -&gt; string&#xA;override this.ReadContentAsString : unit -&gt; string" Usage="xmlReader.ReadContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le contenu de texte à la position actuelle comme un objet <see cref="T:System.String" />.</summary>
        <returns>Contenu de texte sous la forme d'un objet <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode concatène le texte, les espaces, les espaces blancs significatifs et les sections CDATA et ignore des commentaires ou des instructions de traitement. Références d’entité sont automatiquement résolues.  
  
 Cette méthode peut être utilisée convertir des valeurs typées en une chaîne, ou pour lire le contenu de texte tout en ignorant les commentaires et instructions de traitement.  
  
 Le tableau suivant décrit la manière dont cette méthode traite chaque type de nœud.  
  
|XmlNodeType|Valeur de retour|Comportement du lecteur|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Nœuds de contenus de texte, CDATA, d'espace blanc et d'espace blanc significatif concaténés convertis en type demandé.|Avance jusqu’à l’étiquette d’élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`Attribute`|Même que si vous appelez `XmlConvert.ToXxx` sur la valeur d’attribut.|Le lecteur reste dans sa position actuelle.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignore l'instruction de traitement ou le commentaire et lit le contenu du texte concaténé qui suit l'instruction ou le commentaire.|Avance jusqu'à la balise d'élément de début ou de fin suivante. Les références d’entité sont automatiquement développées.|  
|`EndElement`|Chaîne vide.|Le lecteur reste dans sa position actuelle.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Un objet <xref:System.InvalidOperationException> est levé.|Non défini, bien que le lecteur reste généralement dans sa position actuelle.|  
  
 Pour plus d’informations, consultez la section Notes de la <xref:System.Xml.XmlReader> page de référence et le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.ReadContentAsStringAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">La tentative de cast n'est pas valide.</exception>
        <exception cref="T:System.FormatException">Le format de chaîne n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit de façon asynchrone le contenu de texte à la position actuelle comme un objet <see cref="T:System.String" />.</summary>
        <returns>Contenu de texte sous la forme d'un objet <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.ReadContentAsString%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAs">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Lit la valeur de l'élément actuel et retourne le contenu en tant qu'objet du type spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Type de la valeur à retourner.  
  
 **Remarque** Avec le .NET Framework version 3.5, la valeur du paramètre <c>returnType</c> peut maintenant être le type <see cref="T:System.DateTimeOffset" />.</param>
        <param name="namespaceResolver">Objet <see cref="T:System.Xml.IXmlNamespaceResolver" /> permettant de résoudre tous les préfixes d'espaces de noms liés à la conversion de type.</param>
        <summary>Lit le contenu de l'élément en tant que type demandé.</summary>
        <returns>Contenu d'élément converti en l'objet typé demandé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Pour plus d’informations, consultez la section Notes de la <xref:System.Xml.XmlReader> page de référence et le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.ReadElementContentAsAsync%2A>.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Xml.XmlReader.ReadElementContentAs%2A> méthode pour lire le contenu de la `date` nœud.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#5)]
 [!code-vb[XmlReader.ReadElementContentAs#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#5)]  
  
 L'exemple prend le fichier `dataFile.xml` comme entrée.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Impossible de convertir le contenu de l'élément en type demandé.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Lire <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver, localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="returnType">Type de la valeur à retourner.  
  
 **Remarque** Avec le .NET Framework version 3.5, la valeur du paramètre <c>returnType</c> peut maintenant être le type <see cref="T:System.DateTimeOffset" />.</param>
        <param name="namespaceResolver">Objet <see cref="T:System.Xml.IXmlNamespaceResolver" /> permettant de résoudre tous les préfixes d'espaces de noms liés à la conversion de type.</param>
        <param name="localName">Le nom local de l'élément.</param>
        <param name="namespaceURI">L'URI de l'espace de noms de l'élément.</param>
        <summary>Vérifie que le nom local spécifié et l'URI de l'espace de noms correspondent à ceux de l'élément actuel, puis lit le contenu d'élément en tant que type demandé.</summary>
        <returns>Contenu d'élément converti en l'objet typé demandé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Pour plus d’informations, consultez la section Notes de la <xref:System.Xml.XmlReader> page de référence et le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Impossible de convertir le contenu de l'élément en type demandé.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nom local et l'URI de l'espace de noms spécifiés ne correspondent pas à l'élément actuel lu.</exception>
        <exception cref="T:System.OverflowException">Lire <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">Type de la valeur à retourner.</param>
        <param name="namespaceResolver">Objet <see cref="T:System.Xml.IXmlNamespaceResolver" /> permettant de résoudre tous les préfixes d'espaces de noms liés à la conversion de type.</param>
        <summary>Lit de façon asynchrone le contenu de l'élément en tant que type demandé.</summary>
        <returns>Contenu d'élément converti en l'objet typé demandé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.ReadElementContentAs%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dans laquelle copier le texte obtenu. Cette valeur ne peut pas être <see langword="null" />.</param>
        <param name="index">Offset de la mémoire tampon où commence la copie du résultat.</param>
        <param name="count">Nombre maximal d'octets à copier dans la mémoire tampon. Le nombre réel d'octets copiés est retourné à partir de cette méthode.</param>
        <summary>Lit l'élément et décode le contenu au format <see langword="Base64" />.</summary>
        <returns>Nombre d'octets écrits dans la mémoire tampon.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit le contenu de l’élément, le décode à l’aide de `Base64` encodage et retourne les octets binaires décodés (par exemple, une ligne `Base64`-image GIF encodées) dans la mémoire tampon. Pour plus d’informations, consultez RFC 1521, « partie MIME (Multipurpose Internet Mail Extensions) un : mécanismes pour la spécification et qui décrit le Format du corps de Message Internet ». Vous pouvez obtenir les RFC sur le [site Web de commentaires des](http://go.microsoft.com/fwlink/?LinkId=37119).  
  
 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A> peut uniquement lire les éléments de contenu simple. L’élément peut contenir de texte, un espace blanc, espace blanc significatif, sections CDATA, commentaires et instructions de traitement. Il peut également contenir des références d’entité sont automatiquement développées. L’élément ne peut pas avoir d’éléments enfants.  
  
 Cette méthode est très similaire à la <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> (méthode), sauf qu’elle peut uniquement être appelée sur des types de nœud d’élément.  
  
 Si le `count` valeur est supérieure au nombre d’octets dans le document, ou si elle est égale au nombre d’octets dans le document, le <xref:System.Xml.XmlReader> lit tous les octets restants dans le document et retourne le nombre d’octets lus. La prochaine <xref:System.Xml.XmlReader> appel de méthode retourne un zéro et déplace le lecteur vers le nœud qui suit le `EndElement`.  
  
 Si vous appelez <xref:System.Xml.XmlReader.Read%2A> avant tout le contenu de l’élément est utilisé, le lecteur peut se comporter comme si le premier contenu a été consommé, puis le <xref:System.Xml.XmlReader.Read%2A> méthode a été appelée. Cela signifie que le lecteur lit tout le texte jusqu'à ce que l’élément de fin. Il sera ensuite lire le nœud de balise de fin, lit le nœud suivant, puis se positionne sur le nœud qui suit.  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.ReadElementContentAsBase64Async%2A>.  
  
   
  
## Examples  
 L’exemple suivant lit une ligne `Base64` image encodée. Le `Base64` les données sont incorporées dans le `<image>` élément. Un <xref:System.IO.BinaryWriter> est utilisé pour créer un nouveau fichier de données binaires.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#4)]
 [!code-vb[XmlReader_Read_Write_Binary#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index de la mémoire tampon (ou l'index augmenté de la valeur du paramètre count) est supérieur à la taille de la mémoire tampon allouée.</exception>
        <exception cref="T:System.NotSupportedException">L'implémentation de <see cref="T:System.Xml.XmlReader" /> ne prend pas en charge cette méthode.</exception>
        <exception cref="T:System.Xml.XmlException">L'élément contient un contenu mixte.</exception>
        <exception cref="T:System.FormatException">Impossible de convertir le contenu en type demandé.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dans laquelle copier le texte obtenu. Cette valeur ne peut pas être <see langword="null" />.</param>
        <param name="index">Offset de la mémoire tampon où commence la copie du résultat.</param>
        <param name="count">Nombre maximal d'octets à copier dans la mémoire tampon. Le nombre réel d'octets copiés est retourné à partir de cette méthode.</param>
        <summary>Lit de façon asynchrone l'élément et décode le contenu au format <see langword="Base64" />.</summary>
        <returns>Nombre d'octets écrits dans la mémoire tampon.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dans laquelle copier le texte obtenu. Cette valeur ne peut pas être <see langword="null" />.</param>
        <param name="index">Offset de la mémoire tampon où commence la copie du résultat.</param>
        <param name="count">Nombre maximal d'octets à copier dans la mémoire tampon. Le nombre réel d'octets copiés est retourné à partir de cette méthode.</param>
        <summary>Lit l'élément et décode le contenu au format <see langword="BinHex" />.</summary>
        <returns>Nombre d'octets écrits dans la mémoire tampon.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit le contenu de l’élément, le décode à l’aide de `BinHex` encodage et retourne les octets binaires décodés (par exemple, une ligne `BinHex`-image GIF encodées) dans la mémoire tampon.  
  
 Cette méthode peut uniquement lire les éléments de contenu simple. L’élément peut contenir de texte, un espace blanc, espace blanc significatif, sections CDATA, commentaires et instructions de traitement. Il peut également contenir des références d’entité sont automatiquement développées. L’élément ne peut pas avoir d’éléments enfants.  
  
 Cette méthode est très similaire à la <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> (méthode), sauf qu’elle peut uniquement être appelée sur des types de nœud d’élément.  
  
 Si le `count` valeur est supérieure au nombre d’octets dans le document, ou si elle est égale au nombre d’octets dans le document, le <xref:System.Xml.XmlReader> lit tous les octets restants dans le document et retourne le nombre d’octets lus. La prochaine <xref:System.Xml.XmlReader> appel de méthode retourne un zéro et déplace le lecteur vers le nœud qui suit le `EndElement`.  
  
 Si vous appelez <xref:System.Xml.XmlReader.Read%2A> avant tout le contenu de l’élément est utilisé, le lecteur peut se comporter comme si le premier contenu a été consommé, puis le <xref:System.Xml.XmlReader.Read%2A> méthode a été appelée. Cela signifie que le lecteur lit tout le texte jusqu'à ce que l’élément de fin. Il sera ensuite lire le nœud de balise de fin, lit le nœud suivant, puis se positionne sur le nœud qui suit.  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.ReadElementContentAsBinHexAsync%2A>.  
  
   
  
## Examples  
 L’exemple suivant lit une ligne `BinHex` image encodée. Le `BinHex` les données sont incorporées dans le `<image>` élément. Un <xref:System.IO.BinaryWriter> est utilisé pour créer un nouveau fichier de données binaires.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#2)]
 [!code-vb[XmlReader_Read_Write_Binary#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index de la mémoire tampon (ou l'index augmenté de la valeur du paramètre count) est supérieur à la taille de la mémoire tampon allouée.</exception>
        <exception cref="T:System.NotSupportedException">L'implémentation de <see cref="T:System.Xml.XmlReader" /> ne prend pas en charge cette méthode.</exception>
        <exception cref="T:System.Xml.XmlException">L'élément contient un contenu mixte.</exception>
        <exception cref="T:System.FormatException">Impossible de convertir le contenu en type demandé.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dans laquelle copier le texte obtenu. Cette valeur ne peut pas être <see langword="null" />.</param>
        <param name="index">Offset de la mémoire tampon où commence la copie du résultat.</param>
        <param name="count">Nombre maximal d'octets à copier dans la mémoire tampon. Le nombre réel d'octets copiés est retourné à partir de cette méthode.</param>
        <summary>Lit de façon asynchrone l'élément et décode le contenu au format <see langword="BinHex" />.</summary>
        <returns>Nombre d'octets écrits dans la mémoire tampon.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsBoolean">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Lit la valeur de l'élément actuel en tant qu'objet <see cref="T:System.Boolean" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : unit -&gt; bool&#xA;override this.ReadElementContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit l'élément actuel et retourne le contenu en tant qu'objet <see cref="T:System.Boolean" />.</summary>
        <returns>Contenu de l'élément sous la forme d'un objet <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Si le contenu de l’élément est de type `xsd:boolean`, le lecteur retourne un unboxed <xref:System.Boolean> objet. Si le contenu n’est pas typé `xsd:boolean`, le lecteur tente du convertir en un <xref:System.Boolean> objet selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour plus d'informations, consultez la section Notes de la page de référence <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Le contenu de l'élément ne peut pas être converti en objet <see cref="T:System.Boolean" />.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : string * string -&gt; bool&#xA;override this.ReadElementContentAsBoolean : string * string -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Le nom local de l'élément.</param>
        <param name="namespaceURI">L'URI de l'espace de noms de l'élément.</param>
        <summary>Vérifie que le nom local spécifié et l'URI de l'espace de noms correspondent à ceux de l'élément actuel, puis lit l'élément actuel et retourne le contenu en tant qu'objet <see cref="T:System.Boolean" />.</summary>
        <returns>Contenu de l'élément sous la forme d'un objet <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Si le contenu est de type `xsd:boolean`, le lecteur retourne un unboxed <xref:System.Boolean> objet. Si le contenu n’est pas typé `xsd:boolean`, le lecteur tente du convertir en un <xref:System.Boolean> objet selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour plus d'informations, consultez la section Notes de la page de référence <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Impossible de convertir le contenu de l'élément en type demandé.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nom local et l'URI de l'espace de noms spécifiés ne correspondent pas à l'élément actuel lu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDateTime">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Lit l'élément actuel et retourne le contenu en tant qu'objet <see cref="T:System.DateTime" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit l'élément actuel et retourne le contenu en tant qu'objet <see cref="T:System.DateTime" />.</summary>
        <returns>Contenu de l'élément sous la forme d'un objet <see cref="T:System.DateTime" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Si le contenu est de type `xsd:dateTime`, le lecteur retourne un unboxed <xref:System.DateTime> objet. Si le contenu n’est pas typé `xsd:dateTime`, le lecteur tente du convertir en un <xref:System.DateTime> objet selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
> [!NOTE]
>  Vous ne pouvez pas compter sur la valeur <xref:System.DateTime.Year%2A?displayProperty=nameWithType> lorsque le contenu est de type `xsd:gMonthDay`. <xref:System.Xml.XmlReader> définit toujours la <xref:System.DateTime.Year%2A?displayProperty=nameWithType> valeur sur 1904 dans ce cas.  
  
 Pour plus d'informations, consultez la section Notes de la page de référence <xref:System.Xml.XmlReader>.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> méthode pour lire le contenu de la `date` élément.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#4)]
 [!code-vb[XmlReader.ReadElementContentAs#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#4)]  
  
 L'exemple prend le fichier `dataFile.xml` comme entrée.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Le contenu de l'élément ne peut pas être converti en objet <see cref="T:System.DateTime" />.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime (localName As String, namespaceURI As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : string * string -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : string * string -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Le nom local de l'élément.</param>
        <param name="namespaceURI">L'URI de l'espace de noms de l'élément.</param>
        <summary>Vérifie que le nom local spécifié et l'URI de l'espace de noms correspondent à ceux de l'élément actuel, puis lit l'élément actuel et retourne le contenu en tant qu'objet <see cref="T:System.DateTime" />.</summary>
        <returns>Contenu de l'élément sous la forme d'un objet <see cref="T:System.DateTime" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Si le contenu est de type `xsd:dateTime`, le lecteur retourne un unboxed <xref:System.DateTime> objet. Si le contenu n’est pas typé `xsd:dateTime`, le lecteur tente du convertir en un <xref:System.DateTime> objet selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
> [!NOTE]
>  Vous ne pouvez pas compter sur la valeur <xref:System.DateTime.Year%2A?displayProperty=nameWithType> lorsque le contenu est de type `xsd:gMonthDay`. <xref:System.Xml.XmlReader> définit toujours la <xref:System.DateTime.Year%2A?displayProperty=nameWithType> valeur sur 1904 dans ce cas.  
  
 Pour plus d'informations, consultez la section Notes de la page de référence <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Impossible de convertir le contenu de l'élément en type demandé.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nom local et l'URI de l'espace de noms spécifiés ne correspondent pas à l'élément actuel lu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDecimal">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Lit la valeur de l'élément actuel en tant qu'objet <see cref="T:System.Decimal" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit l'élément actuel et retourne le contenu en tant qu'objet <see cref="T:System.Decimal" />.</summary>
        <returns>Contenu de l'élément sous la forme d'un objet <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Le lecteur tente de convertir le contenu de l’élément une <xref:System.Decimal> objet selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour plus d'informations, consultez la section Notes de la page de référence <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Le contenu de l'élément ne peut pas être converti en <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal (localName As String, namespaceURI As String) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : string * string -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : string * string -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Le nom local de l'élément.</param>
        <param name="namespaceURI">L'URI de l'espace de noms de l'élément.</param>
        <summary>Vérifie que le nom local spécifié et l'URI de l'espace de noms correspondent à ceux de l'élément actuel, puis lit l'élément actuel et retourne le contenu en tant qu'objet <see cref="T:System.Decimal" />.</summary>
        <returns>Contenu de l'élément sous la forme d'un objet <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Le lecteur tente de convertir le contenu de l’élément une <xref:System.Decimal> objet selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour plus d'informations, consultez la section Notes de la page de référence <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Le contenu de l'élément ne peut pas être converti en <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nom local et l'URI de l'espace de noms spécifiés ne correspondent pas à l'élément actuel lu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDouble">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Lit l'élément actuel et retourne le contenu en tant que nombre à virgule flottante double précision.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : unit -&gt; double&#xA;override this.ReadElementContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadElementContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit l'élément actuel et retourne le contenu en tant que nombre à virgule flottante double précision.</summary>
        <returns>Contenu d'élément sous la forme d'un nombre à virgule flottante double précision.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Si le contenu est de type `xsd:double`, le lecteur retourne un nombre à virgule flottante double précision. Si le contenu n’est pas typé `xsd:double`, le lecteur tente de convertir en un nombre à virgule flottante double précision selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour plus d'informations, consultez la section Notes de la page de référence <xref:System.Xml.XmlReader>.  
  
   
  
## Examples  
 L’exemple suivant utilise la méthode pour retourner le contenu de l’élément sous la forme d’un nombre à virgule flottante double précision.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#7)]
 [!code-vb[XmlReader.ReadElementContentAs#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#7)]  
  
 L'exemple prend le fichier `dataFile.xml` comme entrée.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Le contenu de l'élément ne peut pas être converti en nombre à virgule flottante double précision.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble (localName As String, namespaceURI As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : string * string -&gt; double&#xA;override this.ReadElementContentAsDouble : string * string -&gt; double" Usage="xmlReader.ReadElementContentAsDouble (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Le nom local de l'élément.</param>
        <param name="namespaceURI">L'URI de l'espace de noms de l'élément.</param>
        <summary>Vérifie que le nom local et l'URI de l'espace de noms spécifiés correspondent à ceux de l'élément actuel, puis lit l'élément actuel et retourne le contenu sous la forme d'un nombre à virgule flottante double précision.</summary>
        <returns>Contenu d'élément sous la forme d'un nombre à virgule flottante double précision.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Si le contenu est de type `xsd:double`, le lecteur retourne un nombre à virgule flottante double précision. Si le contenu n’est pas typé `xsd:double`, le lecteur tente de convertir en un nombre à virgule flottante double précision selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour plus d'informations, consultez la section Notes de la page de référence <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Impossible de convertir le contenu de l'élément en type demandé.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nom local et l'URI de l'espace de noms spécifiés ne correspondent pas à l'élément actuel lu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsFloat">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Lit la valeur d'élément actuelle en tant que nombre à virgule flottante simple précision.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : unit -&gt; single&#xA;override this.ReadElementContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadElementContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit l'élément actuel et retourne le contenu en tant que nombre à virgule flottante simple précision.</summary>
        <returns>Contenu d'élément sous la forme d'un nombre à virgule flottante simple précision.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Le lecteur tente de convertir le contenu de l’élément à un nombre à virgule flottante simple précision selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour plus d'informations, consultez la section Notes de la page de référence <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Le contenu de l'élément ne peut pas être converti en nombre à virgule flottante simple précision.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat (localName As String, namespaceURI As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : string * string -&gt; single&#xA;override this.ReadElementContentAsFloat : string * string -&gt; single" Usage="xmlReader.ReadElementContentAsFloat (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Le nom local de l'élément.</param>
        <param name="namespaceURI">L'URI de l'espace de noms de l'élément.</param>
        <summary>Vérifie que le nom local et l'URI de l'espace de noms spécifiés correspondent à ceux de l'élément actuel, puis lit l'élément actuel et retourne le contenu sous la forme d'un nombre à virgule flottante simple précision.</summary>
        <returns>Contenu d'élément sous la forme d'un nombre à virgule flottante simple précision.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Le lecteur tente de convertir le contenu de l’élément à un nombre à virgule flottante simple précision selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour plus d'informations, consultez la section Notes de la page de référence <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Le contenu de l'élément ne peut pas être converti en nombre à virgule flottante simple précision.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nom local et l'URI de l'espace de noms spécifiés ne correspondent pas à l'élément actuel lu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsInt">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Lit l'élément actuel et retourne le contenu comme un entier signé de 32 bits.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : unit -&gt; int&#xA;override this.ReadElementContentAsInt : unit -&gt; int" Usage="xmlReader.ReadElementContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit l'élément actuel et retourne le contenu comme un entier signé de 32 bits.</summary>
        <returns>Contenu d'élément sous la forme d'un entier signé de 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Si le contenu est de type `xsd:integer`, le lecteur retourne un entier signé 32 bits unboxed. Si le contenu n’est pas typé `xsd:integer`, le lecteur tente de convertir en un entier signé 32 bits selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour plus d'informations, consultez la section Notes de la page de référence <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Le contenu de l'élément ne peut pas être converti en un entier signé de 32 bits.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt (localName As String, namespaceURI As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : string * string -&gt; int&#xA;override this.ReadElementContentAsInt : string * string -&gt; int" Usage="xmlReader.ReadElementContentAsInt (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Le nom local de l'élément.</param>
        <param name="namespaceURI">L'URI de l'espace de noms de l'élément.</param>
        <summary>Vérifie que le nom local spécifié et l'URI de l'espace de noms correspondent à ceux de l'élément actuel, puis lit l'élément actuel et retourne le contenu en tant qu'entier signé de 32 bits.</summary>
        <returns>Contenu d'élément sous la forme d'un entier signé de 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Si le contenu est de type `xsd:integer`, le lecteur retourne un entier signé 32 bits unboxed. Si le contenu n’est pas typé `xsd:integer`, le lecteur tente de convertir en un entier signé 32 bits selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour plus d'informations, consultez la section Notes de la page de référence <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Le contenu de l'élément ne peut pas être converti en un entier signé de 32 bits.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nom local et l'URI de l'espace de noms spécifiés ne correspondent pas à l'élément actuel lu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsLong">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Lit l'élément actuel et retourne le contenu comme un entier signé de 64 bits.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : unit -&gt; int64&#xA;override this.ReadElementContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadElementContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit l'élément actuel et retourne le contenu comme un entier signé de 64 bits.</summary>
        <returns>Contenu d'élément sous la forme d'un entier signé de 64 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Si le contenu est de type `xsd:long`, le lecteur retourne un entier signé 64 bits unboxed. Si le contenu n’est pas typé `xsd:long`, le lecteur tente de convertir en un entier signé 64 bits selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour plus d'informations, consultez la section Notes de la page de référence <xref:System.Xml.XmlReader>.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A> méthode pour lire le contenu de la `longValue` élément.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#3)]
 [!code-vb[XmlReader.ReadElementContentAs#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#3)]  
  
 L'exemple prend le fichier `dataFile.xml` comme entrée.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Le contenu de l’élément ne peut pas être converti en entier signé de 64 bits.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong (localName As String, namespaceURI As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : string * string -&gt; int64&#xA;override this.ReadElementContentAsLong : string * string -&gt; int64" Usage="xmlReader.ReadElementContentAsLong (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Le nom local de l'élément.</param>
        <param name="namespaceURI">L'URI de l'espace de noms de l'élément.</param>
        <summary>Vérifie que le nom local spécifié et l'URI de l'espace de noms correspondent à ceux de l'élément actuel, puis lit l'élément actuel et retourne le contenu en tant qu'entier signé de 64 bits.</summary>
        <returns>Contenu d'élément sous la forme d'un entier signé de 64 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Si le contenu est de type `xsd:long`, le lecteur retourne un entier signé 64 bits unboxed. Si le contenu n’est pas typé `xsd:long`, le lecteur tente de convertir en un entier signé 64 bits selon les règles définies par le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour plus d'informations, consultez la section Notes de la page de référence <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Le contenu de l’élément ne peut pas être converti en entier signé de 64 bits.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nom local et l'URI de l'espace de noms spécifiés ne correspondent pas à l'élément actuel lu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsObject">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Lit l'élément actuel et retourne le contenu en tant que <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : unit -&gt; obj&#xA;override this.ReadElementContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadElementContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit l'élément actuel et retourne le contenu en tant que <see cref="T:System.Object" />.</summary>
        <returns>Objet CLR boxed du type le plus approprié. La propriété <see cref="P:System.Xml.XmlReader.ValueType" /> détermine le type CLR approprié. Si le contenu est de type liste, cette méthode retourne un tableau d'objets boxed du type approprié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Pour plus d’informations, consultez la section Notes de la <xref:System.Xml.XmlReader> page de référence et le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.ReadElementContentAsObjectAsync%2A>.  
  
   
  
## Examples  
 L’exemple suivant utilise la méthode pour lire le contenu de la `price` nœud. Le lecteur utilise les informations dans le schéma pour mapper le contenu pour le type de données correct.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#6)]
 [!code-vb[XmlReader.ReadElementContentAs#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#6)]  
  
 L’exemple utilise les deux fichiers suivants en tant qu’entrée.  
  
 `item.xml`  
  
 [!code-xml[XmlReader.ReadElementContentAs#11](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xml#11)]  
  
 `item.xsd`  
  
 [!code-xml[XmlReader.ReadElementContentAs#12](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xsd#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Impossible de convertir le contenu de l'élément en type demandé</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject (localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : string * string -&gt; obj&#xA;override this.ReadElementContentAsObject : string * string -&gt; obj" Usage="xmlReader.ReadElementContentAsObject (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Le nom local de l'élément.</param>
        <param name="namespaceURI">L'URI de l'espace de noms de l'élément.</param>
        <summary>Vérifie que le nom local et l'URI de l'espace de noms spécifiés correspondent à ceux de l'élément actuel, puis lit l'élément actuel et retourne le contenu en tant qu'objet <see cref="T:System.Object" />.</summary>
        <returns>Objet CLR boxed du type le plus approprié. La propriété <see cref="P:System.Xml.XmlReader.ValueType" /> détermine le type CLR approprié. Si le contenu est de type liste, cette méthode retourne un tableau d'objets boxed du type approprié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Pour plus d’informations, consultez la section Notes de la <xref:System.Xml.XmlReader> page de référence et le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Impossible de convertir le contenu de l'élément en type demandé.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nom local et l'URI de l'espace de noms spécifiés ne correspondent pas à l'élément actuel lu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit de façon asynchrone l'élément actuel et retourne le contenu en tant que <see cref="T:System.Object" />.</summary>
        <returns>Objet CLR boxed du type le plus approprié. La propriété <see cref="P:System.Xml.XmlReader.ValueType" /> détermine le type CLR approprié. Si le contenu est de type liste, cette méthode retourne un tableau d'objets boxed du type approprié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Lit l'élément actuel et retourne le contenu en tant qu'objet <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : unit -&gt; string&#xA;override this.ReadElementContentAsString : unit -&gt; string" Usage="xmlReader.ReadElementContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit l'élément actuel et retourne le contenu en tant qu'objet <see cref="T:System.String" />.</summary>
        <returns>Contenu de l'élément sous la forme d'un objet <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Pour plus d’informations, consultez la section Notes de la <xref:System.Xml.XmlReader> page de référence et le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.ReadElementContentAsStringAsync%2A>.  
  
   
  
## Examples  
 L’exemple suivant lit le `stringValue` élément et retourne le contenu de texte (en ignorant le commentaire et l’instruction de traitement).  
  
 [!code-csharp[XmlReader.ReadElementContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#1)]
 [!code-vb[XmlReader.ReadElementContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#1)]  
  
 L'exemple prend le fichier `dataFile.xml` comme entrée.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Le contenu de l'élément ne peut pas être converti en objet <see cref="T:System.String" />.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : string * string -&gt; string&#xA;override this.ReadElementContentAsString : string * string -&gt; string" Usage="xmlReader.ReadElementContentAsString (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Le nom local de l'élément.</param>
        <param name="namespaceURI">L'URI de l'espace de noms de l'élément.</param>
        <summary>Vérifie que le nom local spécifié et l'URI de l'espace de noms correspondent à ceux de l'élément actuel, puis lit l'élément actuel et retourne le contenu en tant qu'objet <see cref="T:System.String" />.</summary>
        <returns>Contenu de l'élément sous la forme d'un objet <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit la balise de début, le contenu de l’élément, puis déplace le lecteur au-delà de la balise d’élément de fin. Il développe des entités et ignore les commentaires et instructions de traitement. L’élément ne peut contenir un contenu simple. Autrement dit, il ne peut pas avoir d’éléments enfants.  
  
 Pour plus d’informations, consultez la section Notes de la <xref:System.Xml.XmlReader> page de référence et le [W3C XML Schema Part 2 : Datatypes](http://go.microsoft.com/fwlink/?LinkId=4871) recommandation.  
  
   
  
## Examples  
 L’exemple suivant lit le `stringValue` élément et retourne le contenu de texte (en ignorant le commentaire et l’instruction de traitement).  
  
 [!code-csharp[XmlReader.ReadElementContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#2)]
 [!code-vb[XmlReader.ReadElementContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#2)]  
  
 L'exemple prend le fichier `dataFile.xml` comme entrée.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.Xml.XmlException">L'élément en cours contient des éléments enfants.  
  
- ou - 
Le contenu de l'élément ne peut pas être converti en objet <see cref="T:System.String" />.</exception>
        <exception cref="T:System.ArgumentNullException">La méthode est appelée avec des arguments <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nom local et l'URI de l'espace de noms spécifiés ne correspondent pas à l'élément actuel lu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadElementContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadElementContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadElementContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadElementContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit de façon asynchrone l'élément actuel et retourne le contenu en tant qu'objet <see cref="T:System.String" />.</summary>
        <returns>Contenu de l'élément sous la forme d'un objet <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementString">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Lit les éléments de texte brut. Toutefois, nous vous recommandons d’utiliser plutôt la méthode <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" />, car elle permet de gérer cette opération de façon plus directe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nous vous recommandons d’utiliser le <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> méthode pour lire un élément de texte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : unit -&gt; string&#xA;override this.ReadElementString : unit -&gt; string" Usage="xmlReader.ReadElementString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit un élément texte uniquement. Toutefois, nous vous recommandons d’utiliser plutôt la méthode <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />, car elle permet de gérer cette opération de façon plus directe.</summary>
        <returns>Le texte contenu dans l'élément lu. Une chaîne vide si l'élément est vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nous vous recommandons d’utiliser le <xref:System.Xml.XmlReader.ReadElementContentAsString> méthode pour lire un élément de texte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Le nœud de contenu suivant n'est pas une balise de début ; ou l'élément trouvé ne contient pas de valeur texte brut.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string -&gt; string&#xA;override this.ReadElementString : string -&gt; string" Usage="xmlReader.ReadElementString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom à vérifier.</param>
        <summary>Vérifie que la propriété <see cref="P:System.Xml.XmlReader.Name" /> de l'élément trouvé correspond à la chaîne spécifiée avant de lire un élément de texte brut. Toutefois, nous vous recommandons d’utiliser plutôt la méthode <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />, car elle permet de gérer cette opération de façon plus directe.</summary>
        <returns>Le texte contenu dans l'élément lu. Une chaîne vide si l'élément est vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nous vous recommandons d’utiliser le <xref:System.Xml.XmlReader.ReadElementContentAsString> méthode pour lire un élément de texte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Si le nœud de contenu suivant n'est pas une balise de début ; si l'élément <see langword="Name" /> ne correspond pas à l'argument spécifié ; ou si l'élément trouvé ne contient pas de valeur texte brut.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (localname As String, ns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string * string -&gt; string&#xA;override this.ReadElementString : string * string -&gt; string" Usage="xmlReader.ReadElementString (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Nom local à vérifier.</param>
        <param name="ns">URI de l'espace de noms à vérifier.</param>
        <summary>Vérifie que les propriétés <see cref="P:System.Xml.XmlReader.LocalName" /> et <see cref="P:System.Xml.XmlReader.NamespaceURI" /> de l'élément trouvé correspondent aux chaînes spécifiées avant de lire un élément de texte brut. Toutefois, nous vous recommandons d’utiliser plutôt la méthode <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />, car elle permet de gérer cette opération de façon plus directe.</summary>
        <returns>Le texte contenu dans l'élément lu. Une chaîne vide si l'élément est vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nous vous recommandons d’utiliser le <xref:System.Xml.XmlReader.ReadElementContentAsString%28System.String%2CSystem.String%29> méthode pour lire un élément de texte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Si le nœud de contenu suivant n'est pas une balise de début ; si les éléments <see langword="LocalName" /> ou <see langword="NamespaceURI" /> ne correspondent pas aux arguments spécifiés ; ou si l'élément trouvé ne contient pas de valeur texte brut.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEndElement">
      <MemberSignature Language="C#" Value="public virtual void ReadEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadEndElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadEndElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadEndElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadEndElement : unit -&gt; unit&#xA;override this.ReadEndElement : unit -&gt; unit" Usage="xmlReader.ReadEndElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie que le nœud de contenu actuel est une étiquette de fin et avance le lecteur jusqu’au nœud suivant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant affiche le contenu de texte de chaque élément.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 L’exemple utilise le `book3.xml` fichier.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Le nœud actuel n'est pas une balise de fin ou un code XML incorrect est trouvé dans le flux d'entrée.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadStartElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXml">
      <MemberSignature Language="C#" Value="public virtual string ReadInnerXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadInnerXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadInnerXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXml : unit -&gt; string&#xA;override this.ReadInnerXml : unit -&gt; string" Usage="xmlReader.ReadInnerXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, lit tout le contenu, y compris le balisage, sous forme de chaîne.</summary>
        <returns>Tout le contenu XML, y compris le balisage, du nœud actuel. Si le nœud actuel n'a pas d'enfants, une chaîne vide est retournée.  
  
Si le nœud actuel n'est ni un élément ni un attribut, une chaîne vide est retournée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne tout le contenu du nœud actuel, y compris le balisage. Le nœud actuel (balise de début) et le nœud de fin correspondant (balise de fin) ne sont pas retournés. Par exemple, si vous aviez les éléments suivants :  
  
```xml  
<node>  
 this <child id="123"/>  
</node>  
```  
  
 `ReadInnerXml` retourne « `this <child id="123"/>` »  
  
 Cette méthode gère les nœuds d’élément et attribut de la manière suivante :  
  
|Type de nœud|Position avant l’appel|Fragment XML|Valeur de retour|Position après l’appel|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|Sur la balise de début `item1`.|\<item1>text1\</item1>\<item2>text2\</item2>|text1|Sur la balise de début `item2`.|  
|`Attribute`|Sur le nœud d'attribut `attr1`.|\<élément attr1 = « val1 » attr2 = « val2 » > texte\</Item >|val1|Reste sur le nœud d'attribut `attr1`.|  
  
 Si le lecteur se trouve sur un nœud sans descendant, appeler la méthode `ReadInnerXml` équivaut à appeler la méthode <xref:System.Xml.XmlReader.Read%2A>. La méthode retourne `String.Empty` (sauf pour les nœuds d’attribut, auquel cas la valeur de l’attribut est retournée).  
  
 Cette méthode vérifie le XML bien formé. Si `ReadInnerXml` est appelée à partir d’un <xref:System.Xml.XmlValidatingReader>, cette méthode valide également le contenu retourné.  
  
 Tel qu’implémenté dans le <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> et `XmlValidatingReader` classes le `ReadOuterXml` méthode est conscient de l’espace de noms.  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>.  
  
   
  
## Examples  
 L’exemple suivant compare le `ReadInnerXml` et <xref:System.Xml.XmlReader.ReadOuterXml%2A> méthodes.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 L’exemple utilise `2books.xml` de fichiers en tant qu’entrée.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML était incorrect ou une erreur s'est produite lors de l'analyse XML.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadInnerXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadInnerXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadInnerXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadInnerXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit de façon asynchrone tout le contenu, notamment le balisage, en tant que chaîne.</summary>
        <returns>Tout le contenu XML, y compris le balisage, du nœud actuel. Si le nœud actuel n'a pas d'enfants, une chaîne vide est retournée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.ReadInnerXml%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXml">
      <MemberSignature Language="C#" Value="public virtual string ReadOuterXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadOuterXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadOuterXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXml : unit -&gt; string&#xA;override this.ReadOuterXml : unit -&gt; string" Usage="xmlReader.ReadOuterXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, lit le contenu, y compris le balisage, représentant ce nœud et tous ses enfants.</summary>
        <returns>Si le lecteur est placé sur un nœud d'élément ou d'attribut, cette méthode retourne tout le contenu XML, y compris le balisage, du nœud actuel et de tous ses enfants ; sinon, elle retourne une chaîne vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est similaire à <xref:System.Xml.XmlReader.ReadInnerXml%2A> , à ceci près qu’il retourne également les balises de début et de fin.  
  
 Cette méthode gère les nœuds d’élément et attribut de la manière suivante :  
  
|Type de nœud|Position avant l’appel|Fragment XML|Valeur de retour|Position après l’appel|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|Sur la balise de début `item1`.|\<item1>text1\</item1>\<item2>text2\</item2>|\<item1>text1\</item1>|Sur la balise de début `item2`.|  
|`Attribute`|Sur le nœud d'attribut `attr1`.|\<élément attr1 = « val1 » attr2 = « val2 » > texte\</Item >|attr1 = « val1 »|Reste sur le nœud d'attribut `attr1`.|  
  
 Si le lecteur se trouve sur un nœud sans descendant, appeler la méthode `ReadOuterXml` équivaut à appeler la méthode <xref:System.Xml.XmlReader.Read%2A>. La méthode retourne `String.Empty` (sauf pour les nœuds d’attribut, auquel cas la balise d’attribut est retournée).  
  
 Cette méthode vérifie le XML bien formé. Si `ReadOuterXml` est appelée à partir d’un <xref:System.Xml.XmlValidatingReader>, cette méthode valide également le contenu retourné  
  
 Tel qu’implémenté dans le <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> et `XmlValidatingReader` classes le `ReadOuterXml` méthode est conscient de l’espace de noms. Le texte XML suivant `<A xmlns:S="urn:1"><S:B>hello</S:B></A>`, si le lecteur est positionné sur le `S:B` balise, début `ReadOuterXml` retourne `<S:B xmlns:S="urn:1">hello<S:B/>`.  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>.  
  
   
  
## Examples  
 L’exemple suivant compare le `ReadInnerXml` et `ReadOuterXml` méthodes.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 L’exemple utilise `2books.xml` de fichiers en tant qu’entrée.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML était incorrect ou une erreur s'est produite lors de l'analyse XML.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadOuterXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadOuterXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadOuterXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadOuterXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit de façon asynchrone le contenu, notamment le balisage, qui représente ce nœud et tous ses enfants.</summary>
        <returns>Si le lecteur est placé sur un nœud d'élément ou d'attribut, cette méthode retourne tout le contenu XML, y compris le balisage, du nœud actuel et de tous ses enfants ; sinon, elle retourne une chaîne vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.ReadOuterXml%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Vérifie que le nœud actuel est un élément et avance le lecteur jusqu'au nœud suivant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : unit -&gt; unit&#xA;override this.ReadStartElement : unit -&gt; unit" Usage="xmlReader.ReadStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie que le nœud actuel est un élément et avance le lecteur jusqu'au nœud suivant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle <xref:System.Xml.XmlReader.IsStartElement%2A> suivie <xref:System.Xml.XmlReader.Read%2A> pour vous positionner sur le contenu de l’élément trouvé dans le flux d’entrée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Code XML incorrect dans le flux d'entrée.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string -&gt; unit&#xA;override this.ReadStartElement : string -&gt; unit" Usage="xmlReader.ReadStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom qualifié de l'élément.</param>
        <summary>Vérifie que le nœud de contenu actuel est un élément avec le <see cref="P:System.Xml.XmlReader.Name" /> spécifié, puis avance le lecteur jusqu'au nœud suivant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un appel à cette méthode correspond à un appel à <xref:System.Xml.XmlReader.IsStartElement%2A> suivie d’un appel à <xref:System.Xml.XmlReader.Read%2A>.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de texte de chaque élément.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 L’exemple utilise le `book3.xml` fichier.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Code XML incorrect dans le flux d'entrée.  
  
- ou - 
Le <see cref="P:System.Xml.XmlReader.Name" /> de l'élément ne correspond pas au <paramref name="name" /> donné.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (localname As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string * string -&gt; unit&#xA;override this.ReadStartElement : string * string -&gt; unit" Usage="xmlReader.ReadStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Le nom local de l'élément.</param>
        <param name="ns">L'URI de l'espace de noms de l'élément.</param>
        <summary>Vérifie que le nœud de contenu actuel est un élément avec le <see cref="P:System.Xml.XmlReader.LocalName" /> et le <see cref="P:System.Xml.XmlReader.NamespaceURI" /> spécifiés, puis avance le lecteur jusqu'au nœud suivant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un appel à cette méthode correspond à un appel à <xref:System.Xml.XmlReader.IsStartElement%2A> suivie d’un appel à <xref:System.Xml.XmlReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Code XML incorrect dans le flux d'entrée.  
  
- ou - 
Les propriétés <see cref="P:System.Xml.XmlReader.LocalName" /> et <see cref="P:System.Xml.XmlReader.NamespaceURI" /> de l'élément trouvé ne correspondent pas aux arguments spécifiés.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public abstract System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadState : System.Xml.ReadState" Usage="System.Xml.XmlReader.ReadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient l'état du lecteur.</summary>
        <value>L'une des valeurs d'énumération qui spécifie l'état du lecteur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Xml.XmlReader.ReadState%2A> propriété a une des valeurs suivantes :  
  
-   <xref:System.Xml.ReadState.Initial>, lorsque le <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> méthode est appelée.  
  
-   <xref:System.Xml.ReadState.Interactive>, lorsque le <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> méthode a été appelée, et des méthodes supplémentaires peuvent être appelées sur le lecteur.  
  
-   <xref:System.Xml.ReadState.EndOfFile>, lorsque la fin du document XML a été atteinte avec succès.  
  
-   <xref:System.Xml.ReadState.Closed>, lorsque le <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> méthode est appelée.  
  
-   <xref:System.Xml.ReadState.Error>, lorsqu’une erreur empêche l’opération de lecture de se poursuivre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public virtual string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadString();" />
      <MemberSignature Language="F#" Value="abstract member ReadString : unit -&gt; string&#xA;override this.ReadString : unit -&gt; string" Usage="xmlReader.ReadString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, lit le contenu d'un nœud d'élément ou de texte sous forme de chaîne. Toutefois, nous vous recommandons d’utiliser plutôt la méthode <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" />, car elle permet de gérer cette opération de façon plus directe.</summary>
        <returns>Contenu de l'élément ou chaîne vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nous vous recommandons d’utiliser le <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> méthode pour lire le contenu d’un nœud d’élément ou de texte sous forme de chaîne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Une erreur s’est produite lors de l’analyse du XML.</exception>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSubtree">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReader ReadSubtree ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlReader ReadSubtree() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadSubtree" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadSubtree () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlReader ^ ReadSubtree();" />
      <MemberSignature Language="F#" Value="abstract member ReadSubtree : unit -&gt; System.Xml.XmlReader&#xA;override this.ReadSubtree : unit -&gt; System.Xml.XmlReader" Usage="xmlReader.ReadSubtree " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une nouvelle instance de <see langword="XmlReader" /> qui permet de lire le nœud actuel, ainsi que tous ses descendants.</summary>
        <returns>Nouvelle instance du lecteur XML définie sur <see cref="F:System.Xml.ReadState.Initial" />. L’appel de la méthode <see cref="M:System.Xml.XmlReader.Read" /> place le nouveau lecteur sur le nœud qui était actuel avant l’appel à la méthode <see cref="M:System.Xml.XmlReader.ReadSubtree" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadSubtree%2A> peut être appelée uniquement sur les nœuds d’élément. Lorsque la sous-arborescence entière a été lue, les appels à la <xref:System.Xml.XmlReader.Read%2A> retourne de la méthode `false`. Lorsque le nouveau lecteur XML a été fermé, le readeris d’origine positionné sur le `EndElement` nœud de la sous-arborescence. Par conséquent, si vous avez appelé la <xref:System.Xml.XmlReader.ReadSubtree%2A> méthode sur la balise de début de l’élément « book », une fois la sous-arborescence a été lu et le nouveau lecteur XML a été fermé, le lecteur XML original est positionné sur la balise de fin de l’élément « book ».  
  
 Vous ne devez pas effectuer d'opérations sur le lecteur original avant la fermeture du nouveau lecteur. Cette action n'est pas prise en charge et peut provoquer un comportement imprévisible.  
  
> [!NOTE]
>  Le <xref:System.Xml.XmlReader.ReadSubtree%2A> méthode n’est pas destinée à être creatingcopies des données XML que vous pouvez utiliser indépendamment. Designedto de créer une limite autour d’un élément XML. Cela est utile si vous souhaitez passer à un autre composant pour le traitement des données et que vous souhaitez limiter la quantité de vos données, le composant peut accéder. Lorsque vous passez d’un lecteur XML retourné par la <xref:System.Xml.XmlReader.ReadSubtree%2A> méthode à une autre application, l’application peut accéder uniquement cet élément XML, pas le document XML entier.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Xml.XmlReader.ReadSubtree%2A>.  
  
 [!code-csharp[XmlReaderBasic#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#13)]
 [!code-vb[XmlReaderBasic#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#13)]  
  
 Utilisez les données XML suivantes pour exécuter les exemples de cette rubrique :  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<Books>  
  <Book>  
    <Title>A Brief History of Time</Title>  
  </Book>  
  <Book>  
    <Title>Principle Of Relativity</Title>  
  </Book>  
  <Book>  
    <Title>Victory of Reason</Title>  
  </Book>  
  <Book>  
    <Title>The Unicorn that did not Fail</Title>  
  </Book>  
  <Book>  
    <Title>Rational Ontology</Title>  
  </Book>  
  <Book>  
    <Title>The Meaning of Pizza</Title>  
  </Book>  
</Books>  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToDescendant">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Avance <see cref="T:System.Xml.XmlReader" /> vers l'élément descendant correspondant suivant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string -&gt; bool&#xA;override this.ReadToDescendant : string -&gt; bool" Usage="xmlReader.ReadToDescendant name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom qualifié de l'élément vers lequel se déplacer.</param>
        <summary>Avance le <see cref="T:System.Xml.XmlReader" /> vers l'élément descendant suivant portant le nom qualifié spécifié.</summary>
        <returns>
          <see langword="true" /> si un élément descendant correspondant est trouvé ; sinon, <see langword="false" />. Si aucun élément enfant correspondant n'est trouvé, le <see cref="T:System.Xml.XmlReader" /> est placé sur la balise de fin (<see cref="P:System.Xml.XmlReader.NodeType" /> est <see langword="XmlNodeType.EndElement" />) de l'élément.  
  
Si <see cref="T:System.Xml.XmlReader" /> n'est pas placé sur un élément lorsque <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" /> est appelé, cette méthode retourne <see langword="false" /> et la position de <see cref="T:System.Xml.XmlReader" /> ne change pas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant analyse le second nœud book.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 L’exemple utilise le fichier `2books.xml`comme entrée.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.ArgumentException">Le paramètre est une chaîne vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string * string -&gt; bool&#xA;override this.ReadToDescendant : string * string -&gt; bool" Usage="xmlReader.ReadToDescendant (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nom local de l'élément vers lequel se déplacer.</param>
        <param name="namespaceURI">URI de l'espace de noms de l'élément vers lequel se déplacer.</param>
        <summary>Avance <see cref="T:System.Xml.XmlReader" /> vers le nœud descendant suivant doté du nom local et de l'URI de l'espace de noms spécifiés.</summary>
        <returns>
          <see langword="true" /> si un élément descendant correspondant est trouvé ; sinon, <see langword="false" />. Si aucun élément enfant correspondant n'est trouvé, le <see cref="T:System.Xml.XmlReader" /> est placé sur la balise de fin (<see cref="P:System.Xml.XmlReader.NodeType" /> est <see langword="XmlNodeType.EndElement" />) de l'élément.  
  
Si <see cref="T:System.Xml.XmlReader" /> n'est pas placé sur un élément lorsque <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" /> est appelé, cette méthode retourne <see langword="false" /> et la position de <see cref="T:System.Xml.XmlReader" /> ne change pas.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.ArgumentNullException">La valeur des deux paramètres est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToFollowing">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Lit jusqu'à trouver l'élément nommé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string -&gt; bool&#xA;override this.ReadToFollowing : string -&gt; bool" Usage="xmlReader.ReadToFollowing name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom qualifié de l'élément.</param>
        <summary>Lit jusqu'à trouver un élément avec le nom qualifié spécifié.</summary>
        <returns>
          <see langword="true" /> si un élément correspondant est trouvé ; sinon, <see langword="false" /> et <see cref="T:System.Xml.XmlReader" /> est dans un état de fin de fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fonctionnellement équivalente à l’exécution du `following::name` expression XPath du nœud actuel. Il fournit un moyen rapide de rechercher un élément nommé dans le document XML. Il avance le lecteur à l’élément suivant qui correspond au nom spécifié et retourne `true` si aucun élément correspondant est trouvé. À l’aide de l’exemple ci-dessous, le lecteur lit la première instance de l’élément spécifié lors de la lecture vers l’avant.  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item");  
  
```  
  
 Cette méthode peut être appelée sur tous les types de nœud.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.ArgumentException">Le paramètre est une chaîne vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string * string -&gt; bool&#xA;override this.ReadToFollowing : string * string -&gt; bool" Usage="xmlReader.ReadToFollowing (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Le nom local de l'élément.</param>
        <param name="namespaceURI">L'URI de l'espace de noms de l'élément.</param>
        <summary>Lit jusqu'à trouver un élément avec le nom local et l'URI de l'espace de noms spécifiés.</summary>
        <returns>
          <see langword="true" /> si un élément correspondant est trouvé ; sinon, <see langword="false" /> et <see cref="T:System.Xml.XmlReader" /> est dans un état de fin de fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fonctionnellement équivalente à l’exécution du `following::name` expression XPath du nœud actuel. Il fournit un moyen rapide de rechercher un élément nommé dans le document XML. Il avance le lecteur à l’élément suivant qui correspond au nom spécifié et retourne `true` si aucun élément correspondant est trouvé.  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item", "urn:1");  
  
```  
  
 Cette méthode peut être appelée sur tous les types de nœud.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.ArgumentNullException">La valeur des deux paramètres est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToNextSibling">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <summary>Avance <see langword="XmlReader" /> jusqu'au prochain élément frère correspondant.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string -&gt; bool&#xA;override this.ReadToNextSibling : string -&gt; bool" Usage="xmlReader.ReadToNextSibling name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom qualifié de l'élément frère vers lequel se déplacer.</param>
        <summary>Avance le <see langword="XmlReader" /> vers l'élément frère suivant portant le nom qualifié spécifié.</summary>
        <returns>
          <see langword="true" /> si un élément frère correspondant est trouvé ; sinon, <see langword="false" />. Si aucun élément frère correspondant n’est trouvé, le <see langword="XmlReader" /> est placé sur la balise de fin (<see cref="P:System.Xml.XmlReader.NodeType" /> est <see langword="XmlNodeType.EndElement" />) de l’élément parent.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  N’appelez pas <xref:System.Xml.XmlReader.ReadToNextSibling%2A> lorsque le `XmlReader` est un état initial (<xref:System.Xml.XmlReader.ReadState%2A> est <xref:System.Xml.ReadState.Initial>). Vous pouvez appeler <xref:System.Xml.XmlReader.Read%2A> pour faire avancer le `XmlReader` , puis appelez le <xref:System.Xml.XmlReader.ReadToNextSibling%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant lit l’attribut ISBN sur chaque nœud book.  
  
 [!code-csharp[XmlReaderBasic#15](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#15)]
 [!code-vb[XmlReaderBasic#15](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.ArgumentException">Le paramètre est une chaîne vide.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string * string -&gt; bool&#xA;override this.ReadToNextSibling : string * string -&gt; bool" Usage="xmlReader.ReadToNextSibling (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Nom local de l'élément frère vers lequel se déplacer.</param>
        <param name="namespaceURI">URI de l'espace de noms de l'élément frère vers lequel se déplacer.</param>
        <summary>Avance <see langword="XmlReader" /> vers l’élément frère suivant doté du nom local et de l’URI de l’espace de noms spécifiés.</summary>
        <returns>
          <see langword="true" /> si un élément frère correspondant est trouvé ; sinon, <see langword="false" />. Si aucun élément frère correspondant n’est trouvé, le <see langword="XmlReader" /> est placé sur la balise de fin (<see cref="P:System.Xml.XmlReader.NodeType" /> est <see langword="XmlNodeType.EndElement" />) de l’élément parent.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  N’appelez pas <xref:System.Xml.XmlReader.ReadToNextSibling%2A> lorsque le `XmlReader` est un état initial (<xref:System.Xml.XmlReader.ReadState%2A> est <xref:System.Xml.ReadState.Initial>). Vous pouvez appeler <xref:System.Xml.XmlReader.Read%2A> pour faire avancer le `XmlReader` , puis appelez le <xref:System.Xml.XmlReader.ReadToNextSibling%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.ArgumentNullException">La valeur des deux paramètres est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual int ReadValueChunk (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadValueChunk(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunk (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadValueChunk(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunk : char[] * int * int -&gt; int&#xA;override this.ReadValueChunk : char[] * int * int -&gt; int" Usage="xmlReader.ReadValueChunk (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de caractères servant de mémoire tampon dans laquelle le texte est écrit. Cette valeur ne peut pas être <see langword="null" />.</param>
        <param name="index">Offset dans la mémoire tampon où le <see cref="T:System.Xml.XmlReader" /> peut commencer à copier les résultats.</param>
        <param name="count">Nombre maximal de caractères à copier dans la mémoire tampon. Le nombre réel de caractères copiés est retourné à partir de cette méthode.</param>
        <summary>Lit des flux de texte volumineux incorporés dans un document XML.</summary>
        <returns>Nombre total de caractères lus dans la mémoire tampon. La valeur zéro est retournée quand il n'y a plus de contenu de texte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet de lire de très grands flux de texte incorporé dans un document XML dans un flux continu, autrement dit, un petit nombre de caractères à la fois au lieu d’allouer une chaîne unique pour la valeur entière. Cette méthode peut être appelée sur n’importe quel nœud qui a comme valeur (<xref:System.Xml.XmlReader.HasValue%2A> est `true`), mais la diffusion en continu réelle de la valeur du nœud se produit uniquement lorsqu’elle est appelée sur un texte, un espace blanc et nœuds d’espace blanc significatif. Autres valeurs de type de nœud sont mis en cache, notamment les attributs et les nœuds CDATA.  
  
 Cette méthode retourne uniquement le contenu de la <xref:System.Xml.XmlReader.Value%2A> propriété et ne déplace pas le <xref:System.Xml.XmlReader>.  
  
 Cette méthode lit le nombre spécifié de caractères (`count`) de la valeur du nœud dans une mémoire tampon de caractères (`buffer`) à l’offset spécifié (`index`) et retourne le nombre de caractères écrits dans la mémoire tampon. Elle retourne le `0` quand il a atteint la fin de la valeur. Il ne peut pas être redémarré pour relire la valeur.  
  
 Entre les appels de <xref:System.Xml.XmlReader.ReadValueChunk%2A> le <xref:System.Xml.XmlReader> propriétés ne changent pas à l’exception de la <xref:System.Xml.XmlReader.Value%2A> propriété. Lorsque le <xref:System.Xml.XmlReader.Value%2A> propriété est accessible qu’il peut retourner une valeur partielle (avec les caractères pas encore retournés par <xref:System.Xml.XmlReader.ReadValueChunk%2A>) ou une valeur selon l’implémentation complète. Tous les le <xref:System.Xml.XmlReader> implémentations dans les <xref:System.Xml> espace de noms retournent une valeur partielle pour le <xref:System.Xml.XmlReader.Value%2A> implémentation de la propriété.  
  
 Une lecture méthode peut être appelée entre des appels à <xref:System.Xml.XmlReader.ReadValueChunk%2A>. Si cela se produit, le <xref:System.Xml.XmlReader> se déplace vers la prochaine <xref:System.Xml.XmlNodeType> dans le flux de données et tous les caractères ne sont pas encore retournés sont ignorés.  
  
 Il peut y avoir un cas lorsque <xref:System.Xml.XmlReader.ReadValueChunk%2A> retourne inférieur au nombre demandé de caractères. Par exemple, si vous aviez une valeur de 200 caractères avec une paire de substitution aux positions 127 et 128 et que vous avez appelé <xref:System.Xml.XmlReader.ReadValueChunk%2A> avec une mémoire tampon de 128 caractères, l’appel de méthode retournerait 127 caractères au lieu de 128 demandés. La paire de substitution serait ensuite retournée dans les prochains <xref:System.Xml.XmlReader.ReadValueChunk%2A> appeler. Dans ce cas, <xref:System.Xml.XmlReader.ReadValueChunk%2A> n’a pas retourné les 128 caractères demandés, car cela aurait entraîné une paire de substitution incomplète à la fin de la mémoire tampon.  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.ReadValueChunkAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index de la mémoire tampon, ou l'index augmenté de la valeur du paramètre count, est supérieur à la taille de la mémoire tampon allouée.</exception>
        <exception cref="T:System.NotSupportedException">L'implémentation de <see cref="T:System.Xml.XmlReader" /> ne prend pas en charge cette méthode.</exception>
        <exception cref="T:System.Xml.XmlException">La forme des données XML n'est pas correcte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunkAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadValueChunkAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadValueChunkAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunkAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunkAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadValueChunkAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadValueChunkAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de caractères servant de mémoire tampon dans laquelle le texte est écrit. Cette valeur ne peut pas être <see langword="null" />.</param>
        <param name="index">Offset dans la mémoire tampon où le <see cref="T:System.Xml.XmlReader" /> peut commencer à copier les résultats.</param>
        <param name="count">Nombre maximal de caractères à copier dans la mémoire tampon. Le nombre réel de caractères copiés est retourné à partir de cette méthode.</param>
        <summary>Lit de façon asynchrone des flux de texte volumineux incorporés dans un document XML.</summary>
        <returns>Nombre total de caractères lus dans la mémoire tampon. La valeur zéro est retournée quand il n'y a plus de contenu de texte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.ReadValueChunk%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public abstract void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResolveEntity();" />
      <MemberSignature Language="F#" Value="abstract member ResolveEntity : unit -&gt; unit" Usage="xmlReader.ResolveEntity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, résout la référence d'entité des nœuds <see langword="EntityReference" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le lecteur est positionné sur un `EntityReference` nœud (`XmlNodeType.EntityReference`), si <xref:System.Xml.XmlReader.Read%2A> est appelée après avoir appelé cette méthode, le texte de remplacement d’entité est analysée. Lorsque le texte de remplacement d’entité est terminé, un `EndEntity` nœud est retourné pour fermer la portée de référence d’entité.  
  
> [!NOTE]
>  Après avoir appelé cette méthode, si l’entité fait partie d’une valeur d’attribut, vous devez appeler <xref:System.Xml.XmlReader.ReadAttributeValue%2A> à l’étape dans l’entité.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="P:System.Xml.XmlReader.CanResolveEntity" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public virtual System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlReader.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les informations de schéma qui ont été assignées au nœud actuel à la suite de la validation du schéma.</summary>
        <value>Objet <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> qui contient les informations de schéma du nœud actuel. Les informations de schéma peuvent être définies sur des nœuds d'élément, d'attribut ou de texte avec un <see cref="P:System.Xml.XmlReader.ValueType" /> non NULL (valeurs typées).  
  
Si le nœud actuel n'appartient pas à l'un des types précités ou si l'instance de <see langword="XmlReader" /> ne signale pas d'informations de schéma, cette propriété retourne <see langword="null" />.  
  
Si cette propriété est appelée à partir d'un objet <see cref="T:System.Xml.XmlTextReader" /> ou <see cref="T:System.Xml.XmlValidatingReader" />, cette propriété retourne toujours <see langword="null" />. Ces implémentations <see langword="XmlReader" /> n'exposent pas d'informations de schéma par le biais de la propriété <see langword="SchemaInfo" />.  
  
 <block subset="none" type="note"><para>  
 Si vous devez obtenir le jeu d’informations postérieur à la validation du schéma (PSVI) pour un élément, positionnez le lecteur sur la balise de fin de l’élément plutôt que sur la balise de début. Le PSVI s'obtient par le biais de la propriété <see langword="SchemaInfo" /> d'un lecteur. Le lecteur validant créé par l'intermédiaire de <see cref="Overload:System.Xml.XmlReader.Create" /> avec la propriété <see cref="P:System.Xml.XmlReaderSettings.ValidationType" /> définie à <see cref="F:System.Xml.ValidationType.Schema" /> possède un PSVI complet pour un élément seulement lorsque le lecteur est positionné sur la balise de fin d'un élément.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Xml.Schema.IXmlSchemaInfo> interface expose un sous-ensemble de billet de schéma de Validation post-schéma (PSVI) associé à un nœud XML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReaderSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlReaderSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Settings" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Settings As XmlReaderSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlReaderSettings ^ Settings { System::Xml::XmlReaderSettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Settings : System.Xml.XmlReaderSettings" Usage="System.Xml.XmlReader.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Xml.XmlReaderSettings" /> permettant de créer cette instance de <see cref="T:System.Xml.XmlReader" />.</summary>
        <value>Objet <see cref="T:System.Xml.XmlReaderSettings" /> permettant de créer cette instance du lecteur. Si ce lecteur n'a pas été créé à l'aide de la méthode <see cref="Overload:System.Xml.XmlReader.Create" />, cette propriété retourne <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Le <xref:System.Xml.XmlReaderSettings> objet peut contenir des informations sensibles telles que des informations d’identification de l’utilisateur. Les applications doivent être prudent quand la mise en cache de cet objet ou passer à un autre composant.  
  
 Le <xref:System.Xml.XmlReaderSettings> classe est utilisée pour spécifier l’ensemble de fonctionnalités pour prendre en charge sur l’instance de lecteur créé. Le <xref:System.Xml.XmlReaderSettings> objet retourné par cette propriété ne peut pas être modifié. Toute tentative de modification des paramètres individuels entraîne une exception est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public virtual void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Skip();" />
      <MemberSignature Language="F#" Value="abstract member Skip : unit -&gt; unit&#xA;override this.Skip : unit -&gt; unit" Usage="xmlReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ignore les enfants du nœud actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le code XML suivant d’entrée si le lecteur est positionné sur le `<a>` nœud ou l’un de ses attributs, l’appel `Skip` positionne le lecteur à la `<b>` nœud.  
  
 Si le lecteur est déjà positionné sur un nœud sans descendant (comme le `<x>` ou le nœud texte `abc`), l’appel `Skip` est le même que si vous appelez <xref:System.Xml.XmlReader.Read%2A>.  
  
```xml  
<a name="bob" age="123">  
 <x/>abc<y/>  
</a>  
<b>  
...  
</b>  
```  
  
 Cette méthode vérifie le XML bien formé.  
  
 Si le lecteur est un <xref:System.Xml.XmlValidatingReader>, cette méthode valide également le contenu ignoré.  
  
 Le `XmlReader` implémentation détermine si le `Skip` méthode développera les entités externes. Le tableau suivant décrit si les entités externes sont développées pour les différents types de `XmlReader` objets.  
  
|Type de XmlReader|Développe les entités externes|  
|-----------------------|-------------------------------|  
|<xref:System.Xml.XmlTextReader>|Non.|  
|<xref:System.Xml.XmlReader> instance créée par le <xref:System.Xml.XmlReader.Create%2A> méthode qui lit les données de texte.|Non.|  
|<xref:System.Xml.XmlReader> instance créée par le <xref:System.Xml.XmlReader.Create%2A> méthode qui lit des données binaires.|Non applicable.|  
|Une validation de schéma <xref:System.Xml.XmlReader> instance créée par le <xref:System.Xml.XmlReader.Create%2A> (méthode).|Oui.|  
|<xref:System.Xml.XmlValidatingReader>|Oui.|  
|<xref:System.Xml.XmlReader> instance retournée par un <xref:System.Xml.XPath.XPathNavigator> objet.|Non applicable.|  
|<xref:System.Xml.XmlNodeReader>|Non.|  
|<xref:System.Xml.XmlReader> instance encapsulé autour d’un autre <xref:System.Xml.XmlReader> instance.|Dépend de l’implémentation de sous-jacent <xref:System.Xml.XmlReader>. (Le `Skip` méthode sur sous-jacent <xref:System.Xml.XmlReader> est appelée).|  
  
 Pour obtenir la version asynchrone de cette méthode, consultez <xref:System.Xml.XmlReader.SkipAsync%2A>.  
  
   
  
## Examples  
 L’exemple suivant analyse un fichier XML à partir sur le second nœud book.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 L’exemple utilise le fichier `2books.xml`comme entrée.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task SkipAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task SkipAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.SkipAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SkipAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ SkipAsync();" />
      <MemberSignature Language="F#" Value="abstract member SkipAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.SkipAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlReader.SkipAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ignore de façon asynchrone les enfants du nœud actuel.</summary>
        <returns>Nœud actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est la version asynchrone de <xref:System.Xml.XmlReader.Skip%2A>, avec la même fonctionnalité. Pour utiliser cette méthode, vous devez définir le <xref:System.Xml.XmlReaderSettings.Async%2A> indicateur `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode asynchrone <see cref="T:System.Xml.XmlReader" /> a été appelée sans définir l’indicateur <see cref="P:System.Xml.XmlReaderSettings.Async" /> sur <see langword="true" />. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Attribuez à XmlReaderSettings.Async la valeur True si vous voulez utiliser des méthodes asynchrones ».</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Programmation asynchrone avec Async et Await (C# et Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IDisposable.Dispose" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Xml.XmlReader> est castée en interface <xref:System.IDisposable>.

Ce membre peut se comporter différemment lorsqu’il est utilisé dans un [bibliothèque de classes Portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) projet. Pour plus d’informations, consultez [Differences API dans la bibliothèque de classes Portable](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/gg597392(v=vs.100)).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public abstract string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Xml.XmlReader.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient la valeur texte du nœud actuel.</summary>
        <value>La valeur retournée dépend du <see cref="P:System.Xml.XmlReader.NodeType" /> du nœud. Le tableau suivant répertorie les types de nœuds possédant une valeur de retour. Tous les autres types de nœuds retournent <see langword="String.Empty" />.  
  
 <list type="table"><listheader><term> Type de nœud 
 </term><description> Value 
 </description></listheader><item><term><see langword="Attribute" /></term><description> Valeur de l'attribut.  
  
 </description></item><item><term><see langword="CDATA" /></term><description> Contenu de la section CDATA.  
  
 </description></item><item><term><see langword="Comment" /></term><description> Contenu du commentaire.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> Sous-ensemble interne.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Contenu entier, cible exclue.  
  
 </description></item><item><term><see langword="SignificantWhitespace" /></term><description> Espace blanc entre les balisages dans un modèle de contenu mixte.  
  
 </description></item><item><term><see langword="Text" /></term><description> Contenu du nœud de texte.  
  
 </description></item><item><term><see langword="Whitespace" /></term><description> Espace blanc entre les balises.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> Contenu de la déclaration.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir la version asynchrone de cette propriété, consultez le <xref:System.Xml.XmlReader.GetValueAsync%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant lit un fichier XML et affiche chacun des nœuds.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 L’exemple utilise le `items.xml` fichier.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
      </Docs>
    </Member>
    <Member MemberName="ValueType">
      <MemberSignature Language="C#" Value="public virtual Type ValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ValueType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ValueType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ValueType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ValueType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueType : Type" Usage="System.Xml.XmlReader.ValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type de CLR du nœud actuel.</summary>
        <value>Type CLR qui correspond à la valeur typée du nœud. La valeur par défaut est <see langword="System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consultez [prise en charge des types dans les Classes System.Xml](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) pour obtenir la liste des mappages par défaut.  
  
 Un élément de type `xs:int` a un `ValueType` de `System.Int32` par défaut. Toutefois, le `ValueType` peut être un des types valides qui peuvent être mappés aux `xs:int`, tel que `System.Int16` ou `System.Double`.  
  
 Si un nœud n’est pas typé, ou si le nœud est un élément qui contient un contenu mixte, la valeur du nœud est mappée à la `System.String` type.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <block subset="none" type="overrides">
          <para>Les implémenteurs doivent fournir un <see langword="ValueType" /> pour chaque nœud, même s’il est uniquement le <see langword="System.String" /> type.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public virtual string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlLang : string" Usage="System.Xml.XmlReader.XmlLang" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient la portée <see langword="xml:lang" /> en cours.</summary>
        <value>Portée de <see langword="xml:lang" /> actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété représente le `xml:lang` étendue dans laquelle réside le nœud actuel. Par exemple, Voici un fragment XML avec `xml:lang` a la valeur anglais (États-Unis) dans l’élément racine :  
  
```xml  
<root xml:lang="en-us">   
<name>Fred</name>   
</root>   
```  
  
 Lorsque le lecteur est positionné sur le `name` élément, vous pouvez utiliser cette propriété pour pense qu’il est dans la portée d’un anglais (États-Unis) `xml:lang` attribut.  
  
   
  
## Examples  
 Consultez <xref:System.Xml.XmlTextReader.XmlLang%2A?displayProperty=nameWithType> pour obtenir un exemple d’utilisation de cette propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlSpace" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlSpace : System.Xml.XmlSpace" Usage="System.Xml.XmlReader.XmlSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient la portée <see langword="xml:space" /> en cours.</summary>
        <value>Une des valeurs de <see cref="T:System.Xml.XmlSpace" />. S'il n'existe pas de portée de <see langword="xml:space" />, cette propriété prend la valeur par défaut <see langword="XmlSpace.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Consultez <xref:System.Xml.XmlTextReader.XmlSpace%2A> (dans le `XmlTextReader` classe) pour obtenir un exemple à l’aide de cette propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une méthode <see cref="T:System.Xml.XmlReader" /> a été appelée avant la fin d’une opération asynchrone précédente. Dans ce cas, l’exception <see cref="T:System.InvalidOperationException" /> est levée avec le message « Une opération asynchrone est déjà en cours ».</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlLang" />
      </Docs>
    </Member>
  </Members>
</Type>