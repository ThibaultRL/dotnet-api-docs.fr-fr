<Type Name="RegistryKey" FullName="Microsoft.Win32.RegistryKey">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e7c10b2ed065c4a0eea41da116af932466f8473c" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52253103" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RegistryKey : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed RegistryKey extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.RegistryKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistryKey&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistryKey sealed : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type RegistryKey = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un nœud de niveau clé dans le Registre Windows. Cette classe est une encapsulation du Registre.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir une instance de <xref:Microsoft.Win32.RegistryKey>, utilisez un des membres statiques de la <xref:Microsoft.Win32.Registry> classe.  
  
 Le Registre agit comme un référentiel central des informations pour le système d’exploitation et les applications sur un ordinateur. Le Registre est organisé dans un format hiérarchique, selon un ordre logique des éléments qu’il stockés (consultez <xref:Microsoft.Win32.Registry> pour les éléments de niveau de base de cette hiérarchie). Lorsque vous stockez des informations dans le Registre, sélectionnez l’emplacement approprié en fonction du type d’informations sont stockées. Veillez à ne pas détruire des informations créées par d’autres applications, car cela peut entraîner un comportement inattendu de ces applications et peut avoir également un effet négatif sur votre propre application.  
  
> [!IMPORTANT]
>  Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez supprimer il directement ou indirectement. Pour supprimer le type directement, appelez sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.  
  
 Clés de Registre sont l’unité de base de l’organisation dans le Registre et peuvent être comparés aux dossiers dans l’Explorateur de fichiers. Une clé particulière peut avoir des sous-clés, tout comme un dossier peut contenir des sous-dossiers. Chaque clé peut être supprimé, tant que l’utilisateur dispose des autorisations appropriées pour ce faire, et la clé n’est pas une clé de base ou au niveau du directement sous les clés de base. Chaque clé peut également avoir plusieurs valeurs associés (une valeur peut être comparée à un fichier), qui sont utilisés pour stocker les informations — par exemple, les informations relatives à une application installée sur l’ordinateur. Chaque valeur conserve un type particulier d’information, qui peut être récupéré ou mis à jour si nécessaire. Par exemple, vous pouvez créer un <xref:Microsoft.Win32.RegistryKey> pour votre entreprise, sous la clé HKEY_LOCAL_MACHINE\Software, puis une sous-clé pour chaque application créée par votre société. Chaque sous-clé conserve les informations spécifiques à cette application, tels que les paramètres de couleur, emplacement de l’écran et la taille, ou extensions de fichier reconnues.  
  
 Notez que les informations stockées dans le Registre sont disponibles pour les autres applications et les utilisateurs et ne doivent donc pas utilisées pour stocker les données de sécurité ou des informations sur l’application critique.  
  
> [!CAUTION]
>  N’exposez pas <xref:Microsoft.Win32.RegistryKey> objets de sorte qu’un programme malveillant pourrait créer des milliers de sous-clés sans signification ou paires clé/valeur. Par exemple, n’autorisent pas les appelants à entrer des clés arbitraires ou des valeurs.  
  
 À compter de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la longueur d’une clé de Registre n’est plus limitée à 255 caractères.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une sous-clé sous HKEY_CURRENT_USER, manipuler son contenu et puis supprimer la sous-clé.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.Registry" />
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="registryKey.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme la clé et la vide sur le disque en cas de modification de son contenu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette méthode sur les clés système n’aura aucun effet, étant donné que les clés système ne sont jamais fermées.  
  
 Cette méthode ne fait rien si vous l’appelez sur une instance de `RegistryKey` qui est déjà fermé.  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.Win32.RegistryKey.Flush" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une sous-clé ou en ouvre une existante.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">Nom ou chemin d’accès de la sous-clé à créer ou ouvrir. Cette chaîne n'est pas sensible à la casse.</param>
        <summary>Crée une sous-clé ou en ouvre une existante pour l'accès en écriture.</summary>
        <returns>Sous-clé nouvellement créée ou <see langword="null" /> si l’opération a échoué. Si une chaîne de longueur nulle est spécifiée pour <paramref name="subkey" />, l’objet <see cref="T:Microsoft.Win32.RegistryKey" /> actuel est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour pouvoir effectuer cette action, l’utilisateur doit disposer des autorisations à ce niveau et en dessous dans la hiérarchie du Registre.  
  
> [!CAUTION]
>  N’exposez pas <xref:Microsoft.Win32.RegistryKey> objets de sorte qu’un programme malveillant pourrait créer des milliers de sous-clés sans signification ou paires clé/valeur. Par exemple, n’autorisent pas les appelants à entrer des clés arbitraires ou des valeurs.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une sous-clé sous HKEY_CURRENT_USER, manipuler son contenu et puis supprimer la sous-clé.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’a pas les autorisations requises pour créer ni ouvrir la clé de Registre.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> sur lequel cette méthode est appelée est fermé (les clés fermées sont inaccessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> n'est pas accessible en écriture ; par exemple, il n'a pas été ouvert en tant que clé accessible en écriture ou l'utilisateur ne dispose pas des droits d'accès nécessaires.</exception>
        <exception cref="T:System.IO.IOException">Le niveau d’imbrication dépasse 510.  
  
- ou - 
Une erreur système s’est produite, telle que la suppression de la clé ou une tentative de création d’une clé dans la racine <see cref="F:Microsoft.Win32.Registry.LocalMachine" />.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour la possibilité de modifier la clé de Registre spécifiée si elle existe, ou pour la capacité de créer la clé si de Registre qu’il n’existe pas. Énumérations associées : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
      </Parameters>
      <Docs>
        <param name="subkey">Nom ou chemin d’accès de la sous-clé à créer ou ouvrir. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="permissionCheck">L'une des valeurs d'énumération qui spécifie si la clé est ouverte pour un accès en lecture ou en lecture/écriture.</param>
        <summary>Crée une sous-clé ou en ouvre une existante pour l'accès en écriture, à l'aide de l'option de vérification des autorisations spécifiées.</summary>
        <returns>Sous-clé nouvellement créée ou <see langword="null" /> si l’opération a échoué. Si une chaîne de longueur nulle est spécifiée pour <paramref name="subkey" />, l’objet <see cref="T:Microsoft.Win32.RegistryKey" /> actuel est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour pouvoir effectuer cette action, l’utilisateur doit disposer des autorisations à ce niveau et en dessous dans la hiérarchie du Registre.  
  
> [!CAUTION]
>  N’exposez pas <xref:Microsoft.Win32.RegistryKey> objets de sorte qu’un programme malveillant pourrait créer des milliers de sous-clés sans signification ou paires clé/valeur. Par exemple, n’autorisent pas les appelants à entrer des clés arbitraires ou des valeurs.  
  
 Pour pouvoir utiliser le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> (méthode), vous devez avoir une instance de la <xref:Microsoft.Win32.RegistryKey> classe. Pour obtenir une instance de <xref:Microsoft.Win32.RegistryKey>, utilisez un des membres statiques de la <xref:Microsoft.Win32.Registry> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’a pas les autorisations requises pour créer ni ouvrir la clé de Registre.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> contient une valeur non valide.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> sur lequel cette méthode est appelée est fermé (les clés fermées sont inaccessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> n’est pas accessible en écriture ; par exemple, il n’a pas été ouvert en tant que clé accessible en écriture ou l’utilisateur ne dispose pas des droits d’accès nécessaires.</exception>
        <exception cref="T:System.IO.IOException">Le niveau d’imbrication dépasse 510.  
  
- ou - 
Une erreur système s’est produite, telle que la suppression de la clé ou une tentative de création d’une clé dans la racine <see cref="F:Microsoft.Win32.Registry.LocalMachine" />.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour la possibilité de modifier la clé de Registre spécifiée si elle existe, ou pour la capacité de créer la clé si de Registre qu’il n’existe pas. Énumérations associées : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, writable As Boolean) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, bool writable);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * bool -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, writable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">Nom ou chemin d’accès de la sous-clé à créer ou ouvrir. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="writable">
          <see langword="true" /> pour indiquer que la nouvelle sous-clé est accessible en écriture ; sinon, <see langword="false" />.</param>
        <summary>Crée une sous-clé ou en ouvre une existante avec l’accès spécifié.  
  
Disponible à partir de [!INCLUDE[net_v46](~/includes/net-v46-md.md)]</summary>
        <returns>Sous-clé nouvellement créée ou <see langword="null" /> si l’opération a échoué. Si une chaîne de longueur nulle est spécifiée pour <paramref name="subkey" />, l’objet <see cref="T:Microsoft.Win32.RegistryKey" /> actuel est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour pouvoir effectuer cette action, l’utilisateur doit disposer des autorisations à ce niveau et en dessous dans la hiérarchie du Registre.  
  
> [!CAUTION]
>  N’exposez pas <xref:Microsoft.Win32.RegistryKey> objets de sorte qu’un programme malveillant pourrait créer des milliers de sous-clés sans signification ou paires clé/valeur. Par exemple, n’autorisent pas les appelants à entrer des clés arbitraires ou des valeurs.  
  
 Pour pouvoir utiliser le <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A> (méthode), vous devez avoir une instance de la <xref:Microsoft.Win32.RegistryKey> classe. Pour obtenir une instance de <xref:Microsoft.Win32.RegistryKey>, utilisez un des membres statiques de la <xref:Microsoft.Win32.Registry> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’a pas les autorisations requises pour créer ni ouvrir la clé de Registre.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Impossible d’écrire dans la <see cref="T:Microsoft.Win32.RegistryKey" /> actuelle ; par exemple, elle n’a pas été ouverte en tant que clé accessible en écriture ou l’utilisateur ne dispose pas des droits d’accès nécessaires.</exception>
        <exception cref="T:System.IO.IOException">Le niveau d’imbrication dépasse 510.  
  
- ou - 
Une erreur système s’est produite, telle que la suppression de la clé ou une tentative de création d’une clé dans la racine <see cref="F:Microsoft.Win32.Registry.LocalMachine" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * System.Security.AccessControl.RegistrySecurity -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, registrySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" />
      </Parameters>
      <Docs>
        <param name="subkey">Nom ou chemin d’accès de la sous-clé à créer ou ouvrir. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="permissionCheck">L'une des valeurs d'énumération qui spécifie si la clé est ouverte pour un accès en lecture ou en lecture/écriture.</param>
        <param name="registrySecurity">Sécurité du contrôle d'accès pour la nouvelle clé.</param>
        <summary>Crée une sous-clé ou en ouvre une existante pour l'accès en écriture, à l'aide de l'option de vérification des autorisations spécifiées et de la sécurité du Registre.</summary>
        <returns>Sous-clé nouvellement créée ou <see langword="null" /> si l’opération a échoué. Si une chaîne de longueur nulle est spécifiée pour <paramref name="subkey" />, l’objet <see cref="T:Microsoft.Win32.RegistryKey" /> actuel est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A> méthode crée une clé de Registre ayant le contrôle d’accès spécifié par le `registrySecurity` paramètre. Le <xref:Microsoft.Win32.RegistryKey> objet qui est retourné représente la clé de Registre, mais cet objet n’est pas limité par le contrôle d’accès spécifié dans le `registrySecurity` paramètre.  
  
 Si `permissionCheck` est <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>, la clé est ouverte pour un accès en lecture/écriture. Si `permissionCheck` est <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType>, la clé est ouverte pour un accès en lecture.  
  
 Pour la compatibilité descendante, la clé est ouverte pour lire et écrire si `permissionCheck` est <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType> et la clé parente a également <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>. Si la clé parente possède un autre paramètre, état de lecture/écriture est contrôlé par le paramètre de la clé de parent.  
  
 Pour pouvoir effectuer cette action, l’utilisateur doit disposer des autorisations à ce niveau et en dessous dans la hiérarchie du Registre.  
  
> [!CAUTION]
>  N’exposez pas <xref:Microsoft.Win32.RegistryKey> objets de sorte qu’un programme malveillant pourrait créer des milliers de sous-clés sans signification ou paires clé/valeur. Par exemple, n’autorisent pas les appelants à entrer des clés arbitraires ou des valeurs.  
  
 Pour pouvoir utiliser le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> (méthode), vous devez avoir une instance de la <xref:Microsoft.Win32.RegistryKey> classe. Pour obtenir une instance de <xref:Microsoft.Win32.RegistryKey>, utilisez un des membres statiques de la <xref:Microsoft.Win32.Registry> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’a pas les autorisations requises pour créer ni ouvrir la clé de Registre.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> contient une valeur non valide.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> sur lequel cette méthode est appelée est fermé (les clés fermées sont inaccessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Impossible d’écrire dans la <see cref="T:Microsoft.Win32.RegistryKey" /> actuelle ; par exemple, elle n’a pas été ouverte en tant que clé accessible en écriture ou l’utilisateur ne dispose pas des droits d’accès nécessaires.</exception>
        <exception cref="T:System.IO.IOException">Le niveau d’imbrication dépasse 510.  
  
- ou - 
Une erreur système s’est produite, telle que la suppression de la clé ou une tentative de création d’une clé dans la racine <see cref="F:Microsoft.Win32.Registry.LocalMachine" />.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour la possibilité de modifier la clé de Registre spécifiée si elle existe, ou pour la capacité de créer la clé si de Registre qu’il n’existe pas. Énumérations associées : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable, Microsoft.Win32.RegistryOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable, valuetype Microsoft.Win32.RegistryOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean,Microsoft.Win32.RegistryOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, writable As Boolean, options As RegistryOptions) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, bool writable, Microsoft::Win32::RegistryOptions options);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * bool * Microsoft.Win32.RegistryOptions -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, writable, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryOptions" />
      </Parameters>
      <Docs>
        <param name="subkey">Nom ou chemin d’accès de la sous-clé à créer ou ouvrir. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="writable">
          <see langword="true" /> pour indiquer que la nouvelle sous-clé est accessible en écriture ; sinon, <see langword="false" />.</param>
        <param name="options">Option de Registre à utiliser.</param>
        <summary>Crée une sous-clé ou en ouvre une existante avec l’accès spécifié.  
  
Disponible à partir de [!INCLUDE[net_v46](~/includes/net-v46-md.md)]</summary>
        <returns>Sous-clé nouvellement créée ou <see langword="null" /> si l’opération a échoué. Si une chaîne de longueur nulle est spécifiée pour <paramref name="subkey" />, l’objet <see cref="T:Microsoft.Win32.RegistryKey" /> actuel est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour pouvoir effectuer cette action, l’utilisateur doit disposer des autorisations à ce niveau et en dessous dans la hiérarchie du Registre.  
  
> [!CAUTION]
>  N’exposez pas <xref:Microsoft.Win32.RegistryKey> objets de sorte qu’un programme malveillant pourrait créer des milliers de sous-clés sans signification ou paires clé/valeur. Par exemple, n’autorisent pas les appelants à entrer des clés arbitraires ou des valeurs.  
  
 Pour pouvoir utiliser le <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A> (méthode), vous devez avoir une instance de la <xref:Microsoft.Win32.RegistryKey> classe. Pour obtenir une instance de <xref:Microsoft.Win32.RegistryKey>, utilisez un des membres statiques de la <xref:Microsoft.Win32.Registry> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> ne spécifie pas d’option valide</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’a pas les autorisations requises pour créer ni ouvrir la clé de Registre.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Impossible d’écrire dans la <see cref="T:Microsoft.Win32.RegistryKey" /> actuelle ; par exemple, elle n’a pas été ouverte en tant que clé accessible en écriture ou l’utilisateur ne dispose pas des droits d’accès nécessaires.</exception>
        <exception cref="T:System.IO.IOException">Le niveau d’imbrication dépasse 510.  
  
- ou - 
Une erreur système s’est produite, telle que la suppression de la clé ou une tentative de création d’une clé dans la racine <see cref="F:Microsoft.Win32.Registry.LocalMachine" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions options);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions options) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.0;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions)" />
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions);" FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions registryOptions) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions options);" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck, options As RegistryOptions) As RegistryKey" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * Microsoft.Win32.RegistryOptions -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.0;netframework-4.8" />
        <Parameter Name="registryOptions" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2" />
      </Parameters>
      <Docs>
        <param name="subkey">Nom ou chemin d’accès de la sous-clé à créer ou ouvrir.</param>
        <param name="permissionCheck">L'une des valeurs d'énumération qui spécifie si la clé est ouverte pour un accès en lecture ou en lecture/écriture.</param>
        <param name="options">Option de Registre à utiliser ; par exemple, option qui crée une clé volatile.</param>
        <param name="registryOptions">To be added.</param>
        <summary>Crée une sous-clé ou en ouvre une pour l'accès en écriture, à l'aide des options de vérification des autorisations et de registre spécifiées.</summary>
        <returns>Sous-clé nouvellement créée ou <see langword="null" /> si l’opération a échoué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir des cours <xref:Microsoft.Win32.RegistryKey> d’objet, spécifiez une chaîne vide (" ») pour `subkey`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet <see cref="T:Microsoft.Win32.RegistryKey" /> actuel est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'objet <see cref="T:Microsoft.Win32.RegistryKey" /> actuel n'est pas accessible en écriture ; par exemple, il n'a pas été ouvert en tant que clé accessible en écriture ou l'utilisateur ne dispose pas des droits d'accès requis.</exception>
        <exception cref="T:System.IO.IOException">Le niveau d’imbrication dépasse 510.  
  
- ou - 
Une erreur système s'est produite, telle que la suppression de la clé ou une tentative de création d'une clé à la racine de <see cref="F:Microsoft.Win32.Registry.LocalMachine" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’a pas les autorisations requises pour créer ni ouvrir la clé de Registre.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions, System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions registryOptions, class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions,System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions registryOptions, System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * Microsoft.Win32.RegistryOptions * System.Security.AccessControl.RegistrySecurity -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, registryOptions, registrySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
        <Parameter Name="registryOptions" Type="Microsoft.Win32.RegistryOptions" />
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" />
      </Parameters>
      <Docs>
        <param name="subkey">Nom ou chemin d’accès de la sous-clé à créer ou ouvrir.</param>
        <param name="permissionCheck">L'une des valeurs d'énumération qui spécifie si la clé est ouverte pour un accès en lecture ou en lecture/écriture.</param>
        <param name="registryOptions">Option de Registre à utiliser.</param>
        <param name="registrySecurity">Sécurité du contrôle d'accès pour la nouvelle sous-clé.</param>
        <summary>Crée une sous-clé ou en ouvre une pour l'accès en écriture, à l'aide de l'option de vérification des autorisations, de l'option de Registre et de la sécurité du Registre spécifiées.</summary>
        <returns>Sous-clé nouvellement créée ou <see langword="null" /> si l’opération a échoué.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir des cours <xref:Microsoft.Win32.RegistryKey> d’objet, spécifiez une chaîne vide (" ») pour `subkey`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">L'objet <see cref="T:Microsoft.Win32.RegistryKey" /> actuel est fermé. Les clés fermées ne sont pas accessibles.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'objet <see cref="T:Microsoft.Win32.RegistryKey" /> actuel n'est pas accessible en écriture ; par exemple, il n'a pas été ouvert en tant que clé accessible en écriture ou l'utilisateur ne dispose pas des droits d'accès requis.</exception>
        <exception cref="T:System.IO.IOException">Le niveau d’imbrication dépasse 510.  
  
- ou - 
Une erreur système s'est produite, telle que la suppression de la clé ou une tentative de création d'une clé à la racine de <see cref="F:Microsoft.Win32.Registry.LocalMachine" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’a pas les autorisations requises pour créer ni ouvrir la clé de Registre.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime la sous-clé spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteSubKey">
      <MemberSignature Language="C#" Value="public void DeleteSubKey (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKey(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKey (subkey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKey(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKey : string -&gt; unit" Usage="registryKey.DeleteSubKey subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">Nom de la sous-clé à supprimer. Cette chaîne n'est pas sensible à la casse.</param>
        <summary>Supprime la sous-clé spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour supprimer les sous-clés enfants, utilisez <xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>.  
  
 Soyez prudent lors de la suppression des clés de Registre.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser <xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A>.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source2.cpp#5)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source2.cs#5)]
 [!code-vb[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="subkey" /> possède des sous-clés enfants.</exception>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="subkey" /> ne spécifie pas une clé de Registre valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour supprimer la clé.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> en cours de manipulation est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Pour pouvoir modifier la clé de Registre spécifiée. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSubKey">
      <MemberSignature Language="C#" Value="public void DeleteSubKey (string subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKey(string subkey, bool throwOnMissingSubKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKey (subkey As String, throwOnMissingSubKey As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKey(System::String ^ subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKey : string * bool -&gt; unit" Usage="registryKey.DeleteSubKey (subkey, throwOnMissingSubKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="throwOnMissingSubKey" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">Nom de la sous-clé à supprimer. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="throwOnMissingSubKey">Indique si une exception doit être déclenchée lorsque la sous-clé spécifiée est introuvable. Si cet argument a la valeur <see langword="true" /> et que la sous-clé spécifiée n'existe pas, une exception est levée. Si cet argument a la valeur <see langword="false" /> et que la sous-clé spécifiée n'existe pas, aucune action n'est entreprise.</param>
        <summary>Supprime la sous-clé spécifiée et spécifie si une exception est levée lorsque la sous-clé est introuvable.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour supprimer les sous-clés enfants, utilisez <xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>.  
  
 Soyez prudent lors de la suppression des clés de Registre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="subkey" /> possède des sous-clés enfants.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="subkey" /> ne spécifie pas une clé de Registre valide et <paramref name="throwOnMissingSubKey" /> a la valeur <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour supprimer la clé.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> en cours de manipulation est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Pour pouvoir modifier la clé de Registre spécifiée. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteSubKeyTree">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime de manière récursive une sous-clé et toutes les sous-clés enfants, avec gestion des exceptions facultative.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteSubKeyTree">
      <MemberSignature Language="C#" Value="public void DeleteSubKeyTree (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKeyTree(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKeyTree (subkey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKeyTree(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKeyTree : string -&gt; unit" Usage="registryKey.DeleteSubKeyTree subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">Sous-clé à supprimer. Cette chaîne n'est pas sensible à la casse.</param>
        <summary>Supprime récursivement une sous-clé et toutes les sous-clés enfants.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez disposer des autorisations appropriées pour supprimer la sous-clé et son arborescence.  
  
> [!CAUTION]
>  Supprimer une clé particulière supprimera toutes les entrées sous la clé dans l’arborescence. Aucun avertissement ne sera fourni. Si vous souhaitez supprimer une sous-clé uniquement lorsqu’il n’a aucune sous-clés enfants, utilisez le <xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A> (méthode).  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Une tentative de suppression d'une ruche racine est effectuée.  
  
- ou - 
 <paramref name="subkey" /> ne spécifie pas une sous-clé de Registre valide.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour supprimer la clé.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> en cours de manipulation est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Pour pouvoir modifier la clé de Registre spécifiée. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSubKeyTree">
      <MemberSignature Language="C#" Value="public void DeleteSubKeyTree (string subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKeyTree (subkey As String, throwOnMissingSubKey As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKeyTree(System::String ^ subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKeyTree : string * bool -&gt; unit" Usage="registryKey.DeleteSubKeyTree (subkey, throwOnMissingSubKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="throwOnMissingSubKey" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">Nom de la sous-clé à supprimer. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="throwOnMissingSubKey">Indique si une exception doit être déclenchée lorsque la sous-clé spécifiée est introuvable. Si cet argument a la valeur <see langword="true" /> et que la sous-clé spécifiée n'existe pas, une exception est levée. Si cet argument a la valeur <see langword="false" /> et que la sous-clé spécifiée n'existe pas, aucune action n'est entreprise.</param>
        <summary>Supprime de manière récursive la sous-clé spécifiée et toutes les sous-clés enfants, et spécifie si une exception est levée si la sous-clé est introuvable.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Une tentative a été faite pour supprimer la ruche racine de l'arborescence.  
  
- ou - 
 <paramref name="subkey" /> ne spécifie pas une sous-clé de Registre valide et <paramref name="throwOnMissingSubKey" /> a la valeur <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subkey" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour supprimer la clé.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Pour pouvoir modifier la clé de Registre spécifiée. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime la valeur spécifiée de cette clé et lève une exception si la valeur est introuvable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteValue">
      <MemberSignature Language="C#" Value="public void DeleteValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteValue (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DeleteValue : string -&gt; unit" Usage="registryKey.DeleteValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la valeur à supprimer.</param>
        <summary>Supprime la valeur spécifiée de cette clé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sur Windows 95, Windows 98, Windows 98 Deuxième Édition et Windows Millennium Edition, en spécifiant une chaîne vide pour le `name` paramètre ne supprime pas la valeur par défaut.  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#3)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#3)]
 [!code-vb[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> n'est pas une référence valide à une valeur.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour supprimer la valeur.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> en cours de manipulation est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> en cours de manipulation est en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Pour pouvoir supprimer la clé de Registre spécifiée. Énumérations associées : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="DeleteValue">
      <MemberSignature Language="C#" Value="public void DeleteValue (string name, bool throwOnMissingValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteValue(string name, bool throwOnMissingValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteValue (name As String, throwOnMissingValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteValue(System::String ^ name, bool throwOnMissingValue);" />
      <MemberSignature Language="F#" Value="member this.DeleteValue : string * bool -&gt; unit" Usage="registryKey.DeleteValue (name, throwOnMissingValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnMissingValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la valeur à supprimer.</param>
        <param name="throwOnMissingValue">Indique si une exception doit être déclenchée lorsque la valeur spécifiée est introuvable. Si cet argument a la valeur <see langword="true" /> et que la valeur spécifiée n'existe pas, une exception est levée. Si cet argument a la valeur <see langword="false" /> et que la valeur spécifiée n'existe pas, aucune action n'est entreprise.</param>
        <summary>Supprime la valeur spécifiée de cette clé et spécifie si une exception est levée lorsque la valeur est introuvable.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `throwOnMissingValue` est `false`, il n’existe aucun moyen de savoir si la suppression a réussi, sans par la suite que vous tentez d’accéder à la valeur qui vient d’être supprimée. Par conséquent, soyez prudent lors de la suppression des valeurs à partir du Registre de cette manière.  
  
 Sur Windows 95, Windows 98, Windows 98 Deuxième Édition et Windows Millennium Edition, en spécifiant une chaîne vide pour le `name` paramètre ne supprime pas la valeur par défaut.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> n'est pas une référence valide à une valeur et <paramref name="throwOnMissingValue" /> est <see langword="true" />.  
  
- ou - 
 <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour supprimer la valeur.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> en cours de manipulation est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> en cours de manipulation est en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Pour pouvoir supprimer la clé de Registre spécifiée. Énumérations associées : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="registryKey.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:Microsoft.Win32.RegistryKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez la méthode `Dispose` une fois que vous avez terminé d'utiliser <xref:Microsoft.Win32.RegistryKey>. La méthode `Dispose` rend le <xref:Microsoft.Win32.RegistryKey> inutilisable. Après avoir appelé `Dispose`, vous devez libérer toutes les références à la <xref:Microsoft.Win32.RegistryKey> pour que le garbage collector puisse récupérer la mémoire qui le <xref:Microsoft.Win32.RegistryKey> occupée.  
  
 Pour plus d’informations, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Appelez toujours `Dispose` avant de libérer votre dernière référence à <xref:Microsoft.Win32.RegistryKey>. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:Microsoft.Win32.RegistryKey> de l'objet `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~RegistryKey ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!RegistryKey ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="registryKey.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="registryKey.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Écrit tous les attributs de la clé de Registre ouverte spécifiée dans le Registre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’est pas nécessaire d’appeler `Flush` pour écrire les modifications à une clé. Modifications du Registre sont vidées disque lorsque le Registre utilise son vidage « paresseux ». Vidage « paresseux » se produit automatiquement et régulièrement après un intervalle de temps système spécifié. Modifications du Registre sont également vidées sur le disque à l’arrêt du système.  
  
 Contrairement aux <xref:Microsoft.Win32.RegistryKey.Close%2A>, le `Flush` fonction retourne uniquement lorsque toutes les données ont été écrites dans le Registre.  
  
 Le `Flush` fonction peut également écrire tout ou partie des autres clés. Appel de cette fonction excessivement peut avoir un effet négatif sur les performances d’une application.  
  
 Une application doit uniquement appeler `Flush` si elle doit être absolu certains que les modifications du Registre sont enregistrées sur le disque. En règle générale, `Flush` rarement, voire jamais, doivent être utilisés.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.Win32.RegistryKey.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FromHandle">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une clé de Registre à partir d'un handle spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey FromHandle(class Microsoft.Win32.SafeHandles.SafeRegistryHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As SafeRegistryHandle) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ FromHandle(Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ handle);" />
      <MemberSignature Language="F#" Value="static member FromHandle : Microsoft.Win32.SafeHandles.SafeRegistryHandle -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.FromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeRegistryHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Handle de la clé de Registre.</param>
        <summary>Crée une clé de Registre à partir d'un handle spécifié.</summary>
        <returns>Clé de Registre.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour exécuter cette action.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey FromHandle(class Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As SafeRegistryHandle, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ FromHandle(Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ handle, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member FromHandle : Microsoft.Win32.SafeHandles.SafeRegistryHandle * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.FromHandle (handle, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeRegistryHandle" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" />
      </Parameters>
      <Docs>
        <param name="handle">Handle de la clé de Registre.</param>
        <param name="view">Affichage du Registre à utiliser.</param>
        <summary>Crée une clé de Registre à partir d'un handle spécifié et de la configuration d'affichage du Registre.</summary>
        <returns>Clé de Registre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `view` paramètre pour cette méthode est utilisée dans les opérations suivantes, telles que l’ouverture de sous-clés.  
  
 Si `view` est <xref:Microsoft.Win32.RegistryView.Registry64> mais que l’ordinateur exécute un système d’exploitation 32 bits, la clé retournée utilisera le <xref:Microsoft.Win32.RegistryView.Registry32> vue.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="view" /> n'est pas valide.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour exécuter cette action.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne la sécurité du contrôle d'accès pour la clé de Registre actuelle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistrySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.RegistrySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As RegistrySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::RegistrySecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.RegistrySecurity" Usage="registryKey.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistrySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la sécurité du contrôle d'accès pour la clé de Registre actuelle.</summary>
        <returns>Objet qui décrit les autorisations de contrôle d'accès sur la clé de Registre représentée par le <see cref="T:Microsoft.Win32.RegistryKey" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de méthode revient à appeler le <xref:Microsoft.Win32.RegistryKey.GetAccessControl%28System.Security.AccessControl.AccessControlSections%29> surcharge de méthode avec la combinaison au niveau du bit des indicateurs suivants : <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, et <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>. Vous pouvez utiliser cette surcharge pour rechercher d’autres autorisations.  
  
 L’utilisateur doit avoir <xref:System.Security.AccessControl.RegistryRights.ReadPermissions?displayProperty=nameWithType> droits d’appeler cette méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> en cours de manipulation est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.InvalidOperationException">La clé actuelle a été supprimée.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistrySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.RegistrySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As RegistrySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::RegistrySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.RegistrySecurity" Usage="registryKey.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistrySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">Combinaison d'opérations de bits de valeurs d'énumération qui spécifie le type d'informations de sécurité à obtenir.</param>
        <summary>Retourne les sections spécifiées de la sécurité du contrôle d'accès pour la clé de Registre actuelle.</summary>
        <returns>Objet qui décrit les autorisations de contrôle d'accès sur la clé de Registre représentée par le <see cref="T:Microsoft.Win32.RegistryKey" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour demander les autorisations d’accès actuellement accordées aux utilisateurs, spécifiez la combinaison au niveau du bit des indicateurs suivants : <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, et <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>. Vous pouvez également utiliser le <xref:Microsoft.Win32.RegistryKey.GetAccessControl> surcharge de méthode, qui spécifie exactement cette combinaison de valeurs.  
  
 L’utilisateur doit avoir <xref:System.Security.AccessControl.RegistryRights.ReadPermissions?displayProperty=nameWithType> droits d’appeler cette méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> en cours de manipulation est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.InvalidOperationException">La clé actuelle a été supprimée.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSubKeyNames">
      <MemberSignature Language="C#" Value="public string[] GetSubKeyNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetSubKeyNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSubKeyNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetSubKeyNames();" />
      <MemberSignature Language="F#" Value="member this.GetSubKeyNames : unit -&gt; string[]" Usage="registryKey.GetSubKeyNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère un tableau de chaînes qui contient tous les noms de sous-clés.</summary>
        <returns>Tableau de chaînes qui contient les noms des sous-clés pour la clé active.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne pas les noms de recherche de manière récursive. Elle retourne les noms de niveau de base à partir de laquelle elle a été appelée.  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour lire dans la clé.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> en cours de manipulation est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <exception cref="T:System.IO.IOException">Une erreur système s'est produite, telle que la suppression de la clé actuelle.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour la capacité à lire à partir du Registre. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère la valeur associée au nom spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string -&gt; obj" Usage="registryKey.GetValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la valeur à récupérer. Cette chaîne n'est pas sensible à la casse.</param>
        <summary>Récupère la valeur associée au nom spécifié. Retourne <see langword="null" /> si la paire nom/valeur n'existe pas dans le Registre.</summary>
        <returns>La valeur associée à <paramref name="name" />, ou <see langword="null" /> si <paramref name="name" /> est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Une clé de Registre peut avoir une valeur qui n’est pas associée à n’importe quel nom. Lorsque cette valeur sans nom est affichée dans l’Éditeur du Registre, la chaîne « (par défaut) » s’affiche au lieu d’un nom. Pour récupérer cette valeur sans nom, spécifiez soit `null` ou une chaîne vide (" ») pour `name`.  
  
 Lorsque le <xref:Microsoft.Win32.RegistryKey.GetValue%2A> méthode récupère les valeurs de chaîne extensible (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), il développe des chaînes d’environnement à l’aide de données à partir de l’environnement local. Pour récupérer les valeurs de chaîne extensible à partir du Registre sur un ordinateur distant, utilisez le <xref:Microsoft.Win32.RegistryKey.GetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueOptions%29> surcharge de méthode pour spécifier que vous ne souhaitez pas développer les chaînes d’environnement.  
  
> [!NOTE]
>  Si une valeur contenant des références extensibles aux variables d’environnement a été stockée sous forme de chaîne (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), plutôt que comme une chaîne extensible (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> ne s’étend pas. Vous pouvez développer une telle chaîne après qu’il a été récupéré en appelant le <xref:System.Environment.ExpandEnvironmentVariables%2A> (méthode).  
  
> [!NOTE]
>  La méthode recommandée pour récupérer des données à partir de la <xref:Microsoft.Win32.Registry.PerformanceData> clé consiste à utiliser le <xref:System.Diagnostics.PerformanceCounter> classe plutôt que <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> (méthode).  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> ne prend pas en charge la lecture de valeurs de type REG_NONE ou REG_LINK.  Dans les deux cas, la valeur par défaut (`null`) est retournée au lieu de la valeur réelle.  
  
   
  
## Examples  
 L’exemple de code suivant crée une clé de test et ajoute les valeurs de différents types de données à la clé. L’exemple lit les paires nom/valeur, puis les affiche dans la console, à l’aide de la <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> méthode pour récupérer les types de données de Registre correspondants.  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour lire dans la clé de Registre.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> qui contient la valeur spécifiée est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.IO.IOException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> qui contient la valeur spécifiée a été marqué pour suppression.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour lire à partir du Registre. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour lire une clé de Registre de type REG_EXPAND_SZ. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string * obj -&gt; obj" Usage="registryKey.GetValue (name, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la valeur à récupérer. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="defaultValue">Valeur à retourner si <paramref name="name" /> n'existe pas.</param>
        <summary>Récupère la valeur associée au nom spécifié. Si le nom est introuvable, la valeur par défaut que vous fournissez est retournée.</summary>
        <returns>La valeur associée à <paramref name="name" />, avec toutes les variables d'environnement incorporées non développées, ou <paramref name="defaultValue" /> si <paramref name="name" /> est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge de <xref:Microsoft.Win32.RegistryKey.GetValue%2A> pour gérer le cas où un nom n’existe pas encore, par exemple, la première fois que votre application est exécutée. Lorsque vous appelez cette surcharge, utilisez le `defaultValue` paramètre pour spécifier la valeur à retourner si `name` n’existe pas.  
  
> [!NOTE]
>  Une clé de Registre peut avoir une valeur qui n’est pas associée à n’importe quel nom. Lorsque cette valeur sans nom est affichée dans l’Éditeur du Registre, la chaîne « (par défaut) » s’affiche au lieu d’un nom. Pour récupérer cette valeur sans nom, spécifiez soit `null` ou une chaîne vide (" ») pour `name`.  
  
 Lorsque le <xref:Microsoft.Win32.RegistryKey.GetValue%2A> méthode récupère les valeurs de chaîne extensible (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), il développe des chaînes d’environnement à l’aide de données à partir de l’environnement local. Pour récupérer les valeurs de chaîne extensible à partir du Registre sur un ordinateur distant, utilisez le <xref:Microsoft.Win32.RegistryKey.GetValue%2A> surcharge pour spécifier que vous ne souhaitez pas développer les chaînes d’environnement.  
  
> [!NOTE]
>  Si une valeur contenant des références extensibles aux variables d’environnement a été stockée sous forme de chaîne (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), plutôt que comme une chaîne extensible (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), la <xref:Microsoft.Win32.RegistryKey.GetValue%2A> méthode ne s’étend pas. Vous pouvez développer une telle chaîne après qu’il a été récupéré en appelant le <xref:System.Environment.ExpandEnvironmentVariables%2A> (méthode).  
  
> [!NOTE]
>  La méthode recommandée pour récupérer des données à partir de la <xref:Microsoft.Win32.Registry.PerformanceData> clé consiste à utiliser le <xref:System.Diagnostics.PerformanceCounter> classe plutôt que <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> (méthode).  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> ne prend pas en charge la lecture de valeurs de type REG_NONE ou REG_LINK.  Dans les deux cas, la valeur par défaut (`null`) est retournée au lieu de la valeur réelle.  
  
   
  
## Examples  
 L’exemple de code suivant crée une clé de test avec une valeur et récupère cette valeur. L’exemple tente ensuite de récupérer une valeur qui n’existe pas dans la clé ; Dans ce cas le <xref:Microsoft.Win32.RegistryKey.GetValue%2A> méthode retourne la valeur par défaut spécifiée.  
  
 [!code-cpp[Classic RegistryKey.GetValue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RegistryKey.GetValue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/CS/source.cs#1)]
 [!code-vb[Classic RegistryKey.GetValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour lire dans la clé de Registre.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> qui contient la valeur spécifiée est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.IO.IOException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> qui contient la valeur spécifiée a été marqué pour suppression.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour lire à partir du Registre. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour lire une clé de Registre de type REG_EXPAND_SZ. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name, object defaultValue, Microsoft.Win32.RegistryValueOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name, object defaultValue, valuetype Microsoft.Win32.RegistryValueOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object,Microsoft.Win32.RegistryValueOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String, defaultValue As Object, options As RegistryValueOptions) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name, System::Object ^ defaultValue, Microsoft::Win32::RegistryValueOptions options);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string * obj * Microsoft.Win32.RegistryValueOptions -&gt; obj" Usage="registryKey.GetValue (name, defaultValue, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryValueOptions" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la valeur à récupérer. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="defaultValue">Valeur à retourner si <paramref name="name" /> n'existe pas.</param>
        <param name="options">Une des valeurs d'énumération qui spécifie le traitement facultatif de la valeur récupérée.</param>
        <summary>Récupère la valeur associée au nom spécifié et aux options de récupération. Si le nom est introuvable, la valeur par défaut que vous fournissez est retournée.</summary>
        <returns>Valeur associée à <paramref name="name" />, traitée conformément aux <paramref name="options" /> spécifiées, ou <paramref name="defaultValue" /> si <paramref name="name" /> est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour spécifier un traitement spécial de la valeur récupérée. Par exemple, vous pouvez spécifier <xref:Microsoft.Win32.RegistryValueOptions.DoNotExpandEnvironmentNames?displayProperty=nameWithType> lors de la récupération d’une valeur de Registre de type <xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType> pour récupérer la chaîne sans développer les variables d’environnement incorporées.  
  
 Utilisez le `defaultValue` paramètre pour spécifier la valeur à retourner si `name` n’existe pas.  
  
> [!NOTE]
>  Une clé de Registre peut avoir une valeur qui n’est pas associée à n’importe quel nom. Lorsque cette valeur sans nom est affichée dans l’Éditeur du Registre, la chaîne « (par défaut) » s’affiche au lieu d’un nom. Pour récupérer cette valeur sans nom, spécifiez soit `null` ou une chaîne vide (" ») pour `name`.  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> ne prend pas en charge la lecture de valeurs de type REG_NONE ou REG_LINK.  Dans les deux cas, la valeur par défaut (`null`) est retournée au lieu de la valeur réelle.  
  
   
  
## Examples  
 L’exemple de code suivant crée une clé de test ajoute une valeur avec une variable d’environnement incorporée et récupère la valeur dans les étendues et forms.  
  
 [!code-cpp[RegistryValueOptions#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryValueOptions/CPP/RegistryValueOptions.cpp#1)]
 [!code-csharp[RegistryValueOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryValueOptions/CS/source.cs#1)]
 [!code-vb[RegistryValueOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryValueOptions/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour lire dans la clé de Registre.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> qui contient la valeur spécifiée est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.IO.IOException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> qui contient la valeur spécifiée a été marqué pour suppression.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> n'est pas une valeur <see cref="T:Microsoft.Win32.RegistryValueOptions" /> valide ; par exemple, une valeur non valide est castée en <see cref="T:Microsoft.Win32.RegistryValueOptions" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour lire à partir du Registre. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour lire une clé de Registre de type REG_EXPAND_SZ. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.Win32.RegistryValueOptions" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValueKind">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryValueKind GetValueKind (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.Win32.RegistryValueKind GetValueKind(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValueKind (name As String) As RegistryValueKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryValueKind GetValueKind(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetValueKind : string -&gt; Microsoft.Win32.RegistryValueKind" Usage="registryKey.GetValueKind name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryValueKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la valeur dont le type de données de Registre doit être récupéré. Cette chaîne n'est pas sensible à la casse.</param>
        <summary>Récupère le type de données de Registre de la valeur associée au nom spécifié.</summary>
        <returns>Type de données de Registre de la valeur associée à <paramref name="name" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Une clé de Registre peut avoir une valeur qui n’est pas associée à n’importe quel nom. Lorsque cette valeur sans nom est affichée dans l’Éditeur du Registre, la chaîne « (par défaut) » s’affiche au lieu d’un nom. Pour récupérer le type de données de Registre de cette valeur sans nom, spécifiez soit `null` ou une chaîne vide (" ») pour `name`.  
  
 Pour obtenir une description des types de données de Registre pris en charge, consultez le <xref:Microsoft.Win32.RegistryValueKind> énumération.  
  
   
  
## Examples  
 L’exemple de code suivant crée une clé de test et ajoute les valeurs de différents types de données à la clé. L’exemple lit les paires nom/valeur, puis les affiche dans la console, à l’aide de la <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> méthode pour récupérer les types de données de Registre correspondants.  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour lire dans la clé de Registre.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> qui contient la valeur spécifiée est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.IO.IOException">La sous-clé qui contient la valeur spécifiée n'existe pas.  
  
- ou - 
La paire nom/valeur spécifiée par <paramref name="name" /> n'existe pas.  
  
Cette exception n'est pas levée dans Windows 95, Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour lire à partir du Registre. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)" />
        <altmember cref="T:Microsoft.Win32.RegistryValueKind" />
      </Docs>
    </Member>
    <Member MemberName="GetValueNames">
      <MemberSignature Language="C#" Value="public string[] GetValueNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetValueNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValueNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValueNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetValueNames();" />
      <MemberSignature Language="F#" Value="member this.GetValueNames : unit -&gt; string[]" Usage="registryKey.GetValueNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère un tableau de chaînes qui contient tous les noms de valeurs associés à cette clé.</summary>
        <returns>Tableau de chaînes qui contient les noms de valeurs pour la clé active.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucun nom de valeur pour la clé n’est trouvée, un tableau vide est retourné.  
  
 Une clé de Registre peut avoir une valeur par défaut, autrement dit, une paire nom/valeur dans laquelle le nom est une chaîne vide ( » »). Si une valeur par défaut a été définie pour une clé de Registre, le tableau retourné par la <xref:Microsoft.Win32.RegistryKey.GetValueNames%2A> méthode inclut la chaîne vide.  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour lire dans la clé de Registre.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> en cours de manipulation est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <exception cref="T:System.IO.IOException">Une erreur système s'est produite, telle que la suppression de la clé actuelle.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour la capacité à lire à partir du Registre. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeRegistryHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeRegistryHandle Handle" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeRegistryHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeRegistryHandle" Usage="Microsoft.Win32.RegistryKey.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeRegistryHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:Microsoft.Win32.SafeHandles.SafeRegistryHandle" /> qui représente la clé de Registre que l'objet <see cref="T:Microsoft.Win32.RegistryKey" /> actuel encapsule.</summary>
        <value>Handle de la clé de Registre.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">La clé de Registre est fermée. Les clés fermées ne sont pas accessibles.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <exception cref="T:System.IO.IOException">Une erreur système s'est produite, telle que la suppression de la clé actuelle.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour lire la clé.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="Microsoft.Win32.RegistryKey.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Récupère le nom de la clé.</summary>
        <value>Nom absolu (complet) de la clé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le nom de la clé inclut le chemin d’accès absolu de cette clé dans le Registre, en commençant toujours à une clé de base, par exemple, HKEY_LOCAL_MACHINE.  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> est fermé (les clés fermées ne sont pas accessibles).</exception>
        <altmember cref="M:Microsoft.Win32.RegistryKey.ToString" />
      </Docs>
    </Member>
    <Member MemberName="OpenBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenBaseKey (Microsoft.Win32.RegistryHive hKey, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenBaseKey(Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenBaseKey (hKey As RegistryHive, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenBaseKey(Microsoft::Win32::RegistryHive hKey, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member OpenBaseKey : Microsoft.Win32.RegistryHive * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenBaseKey (hKey, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" />
      </Parameters>
      <Docs>
        <param name="hKey">Clé HKEY à ouvrir.</param>
        <param name="view">Affichage du Registre à utiliser.</param>
        <summary>Ouvre une nouvelle <see cref="T:Microsoft.Win32.RegistryKey" /> qui représente la clé demandée sur l'ordinateur local avec la vue spécifiée.</summary>
        <returns>Clé de Registre demandée.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hKey" /> ou <paramref name="view" /> n'est pas valide.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour exécuter cette action.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenRemoteBaseKey">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre une nouvelle T:Microsoft.Win32.RegistryKey qui représente la clé demandée sur un ordinateur distant, avec l'option d'affichage de Registre spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenRemoteBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenRemoteBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRemoteBaseKey (hKey As RegistryHive, machineName As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenRemoteBaseKey(Microsoft::Win32::RegistryHive hKey, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member OpenRemoteBaseKey : Microsoft.Win32.RegistryHive * string -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenRemoteBaseKey (hKey, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hKey">Clé HKEY à ouvrir à partir de l'énumération <see cref="T:Microsoft.Win32.RegistryHive" />.</param>
        <param name="machineName">Ordinateur distant.</param>
        <summary>Ouvre une nouvelle <see cref="T:Microsoft.Win32.RegistryKey" /> qui représente la clé demandée sur un ordinateur distant.</summary>
        <returns>Clé de Registre demandée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le Registre de l’ordinateur local est ouvert si `machineName` est <xref:System.String.Empty?displayProperty=nameWithType>. La clé demandée doit être une clé racine sur l’ordinateur distant et est identifiée par le texte approprié <xref:Microsoft.Win32.RegistryHive> valeur.  
  
 Dans l’ordre d’une clé être ouvert à distance, les machines à la fois le serveur et le client doivent être exécutant le service Registre distant et administration distante est activée.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment ouvrir une clé de Registre sur un ordinateur distant et énumérer les valeurs de la clé. L’ordinateur distant doit exécuter le service Registre distant. Spécifiez le nom de l’ordinateur distant comme un argument de ligne de commande lors de l’appel du programme.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hKey" /> n'est pas valide.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="machineName" /> est introuvable.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur ne dispose pas des autorisations nécessaires pour exécuter cette opération.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:Microsoft.Win32.RegistryHive" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="OpenRemoteBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenRemoteBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, string machineName, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRemoteBaseKey (hKey As RegistryHive, machineName As String, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenRemoteBaseKey(Microsoft::Win32::RegistryHive hKey, System::String ^ machineName, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member OpenRemoteBaseKey : Microsoft.Win32.RegistryHive * string * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenRemoteBaseKey (hKey, machineName, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" />
      </Parameters>
      <Docs>
        <param name="hKey">Clé HKEY à ouvrir à partir de l'énumération <see cref="T:Microsoft.Win32.RegistryHive" />.</param>
        <param name="machineName">Ordinateur distant.</param>
        <param name="view">Affichage du Registre à utiliser.</param>
        <summary>Ouvre une nouvelle clé de Registre qui représente la clé demandée sur un ordinateur distant avec l'affichage spécifié.</summary>
        <returns>Clé de Registre demandée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le Registre de l’ordinateur local est ouvert si `machineName` est <xref:System.String.Empty?displayProperty=nameWithType>. La clé demandée doit être une clé racine sur l’ordinateur distant et est identifiée par le texte approprié <xref:Microsoft.Win32.RegistryHive> valeur.  
  
 Dans l’ordre d’une clé être ouvert à distance, les machines à la fois le serveur et le client doivent être exécutant le service Registre distant et administration distante est activée.  
  
 Sur les versions 64 bits de Windows, les parties du Registre sont stockées séparément pour les applications 32 bits et 64 bits. Il existe une vue 32 bits pour les applications 32 bits et une vue 64 bits pour les applications 64 bits. Si `view` est <xref:Microsoft.Win32.RegistryView.Registry64> mais l’ordinateur distant exécute un système d’exploitation 32 bits, la clé retournée utilisera le <xref:Microsoft.Win32.RegistryView.Registry32> vue.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hKey" /> ou <paramref name="view" /> n'est pas valide.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="machineName" /> est introuvable.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur ne dispose pas des autorisations requises pour exécuter cette opération.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère la sous-clé spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom ou chemin d'accès de la sous-clé à ouvrir en lecture seule.</param>
        <summary>Récupère une sous-clé en lecture seule.</summary>
        <returns>Sous-clé demandée ou <see langword="null" /> en cas d'échec de l'opération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elles peuvent être manipulées avec d’autres méthodes et propriétés, vous devez ouvrir une clé. Pour modifier une clé, vous devez l’ouvrir avec une surcharge de la <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode qui vous permet de spécifier un accès en écriture, comme le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CMicrosoft.Win32.RegistryKeyPermissionCheck%29> surcharger ou le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CSystem.Boolean%29> de surcharge.  
  
 Si la sous-clé spécifiée est introuvable, puis `null` est retourné.  
  
 Pour pouvoir utiliser le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> (méthode), vous devez avoir une instance de <xref:Microsoft.Win32.RegistryKey>. Pour obtenir une instance de <xref:Microsoft.Win32.RegistryKey>, utilisez l’un des membres statiques de la <xref:Microsoft.Win32.Registry> classe.  
  
   
  
## Examples  
 L’exemple de code suivant crée une clé de test et utilise le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour l’ouvrir, présentant les deux surcharges de la méthode.  
  
 [!code-cpp[RegistryKey.OpenSubKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CPP/opensubkey.cpp#1)]
 [!code-csharp[RegistryKey.OpenSubKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CS/opensubkey.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey/VB/opensubkey.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour lire la clé de Registre.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour la capacité à lire la clé de Registre spécifiée. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, permissionCheck As RegistryKeyPermissionCheck) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, permissionCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
      </Parameters>
      <Docs>
        <param name="name">Nom ou chemin d’accès de la sous-clé à créer ou ouvrir.</param>
        <param name="permissionCheck">L'une des valeurs d'énumération qui spécifie si la clé est ouverte pour un accès en lecture ou en lecture/écriture.</param>
        <summary>Récupère la sous-clé spécifiée pour un accès en lecture ou en lecture/écriture.</summary>
        <returns>Sous-clé demandée ou <see langword="null" /> en cas d'échec de l'opération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu de lever une exception, cette méthode retourne `null` si la clé demandée n’existe pas.  
  
 Si `permissionCheck` est <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>, la clé est ouverte pour la lecture et écriture ; si `permissionCheck` est <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType> ou <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>, la clé est ouverte pour la lecture, sauf si la clé parente a été ouvert avec <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>.  
  
 Pour pouvoir utiliser le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> (méthode), vous devez avoir une instance de la <xref:Microsoft.Win32.RegistryKey> classe. Pour obtenir une instance de <xref:Microsoft.Win32.RegistryKey>, utilisez un des membres statiques de la <xref:Microsoft.Win32.Registry> classe.  
  
   
  
## Examples  
 L’exemple de code suivant crée une sous-clé contenant 100 paires clé/valeur et le ferme. L’exemple ouvre la sous-clé avec <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default>, enregistre le temps nécessaire pour lire toutes les valeurs, puis ferme la sous-clé. L’exemple ouvre la sous-clé avec <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree> et enregistre le temps nécessaire pour lire toutes les valeurs. Enfin, l’exemple calcule et affiche le pourcentage d’amélioration.  
  
 [!code-csharp[RegistryKey.OpenSubKey_PermCheck#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey_PermCheck/cs/source.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey_PermCheck#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey_PermCheck/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> contient une valeur non valide.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour lire la clé de Registre.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour la capacité à lire la clé de Registre spécifiée. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, writable As Boolean) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, bool writable);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * bool -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, writable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nom ou chemin d'accès de la sous-clé à ouvrir.</param>
        <param name="writable">A la valeur <see langword="true" /> si vous avez besoin d'accéder à la clé en écriture.</param>
        <summary>Extrait une sous-clé spécifiée et spécifie si l'accès en écriture doit s'appliquer à la clé.</summary>
        <returns>Sous-clé demandée ou <see langword="null" /> en cas d'échec de l'opération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clé demandée n’existe pas, cette méthode retourne `null` au lieu de lever une exception.  
  
 Si `writable` est `true`, la clé doit être ouvert pour lire et écrire, dans le cas contraire, la clé sera ouvert en lecture seule.  
  
 Pour pouvoir utiliser le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> (méthode), vous devez avoir une instance de la <xref:Microsoft.Win32.RegistryKey> (méthode). Pour obtenir une instance de <xref:Microsoft.Win32.RegistryKey>, utilisez un des membres statiques de la <xref:Microsoft.Win32.Registry> classe.  
  
   
  
## Examples  
 L’exemple de code suivant crée une clé de test et utilise le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode pour l’ouvrir, présentant les deux surcharges de la méthode.  
  
 [!code-cpp[RegistryKey.OpenSubKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CPP/opensubkey.cpp#1)]
 [!code-csharp[RegistryKey.OpenSubKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CS/opensubkey.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey/VB/opensubkey.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour accéder à la clé de Registre dans le mode spécifié.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour la capacité à lire la clé de Registre spécifiée. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, System.Security.AccessControl.RegistryRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype System.Security.AccessControl.RegistryRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Security.AccessControl.RegistryRights)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, rights As RegistryRights) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, System::Security::AccessControl::RegistryRights rights);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * System.Security.AccessControl.RegistryRights -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.RegistryRights" />
      </Parameters>
      <Docs>
        <param name="name">Nom ou chemin d’accès de la sous-clé à créer ou ouvrir.</param>
        <param name="rights">Droits pour la clé de Registre.</param>
        <summary>Récupère une sous-clé portant le nom spécifié.  
  
Disponible à partir de .NET Framework 4.6</summary>
        <returns>Sous-clé demandée ou <see langword="null" /> en cas d'échec de l'opération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elles peuvent être manipulées avec d’autres méthodes et propriétés, vous devez ouvrir une clé. Pour modifier une clé, vous devez l’ouvrir avec une surcharge de la <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> méthode qui vous permet de spécifier un accès en écriture.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour accéder à la clé de Registre dans le mode spécifié.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistryRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype System.Security.AccessControl.RegistryRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistryRights)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, permissionCheck As RegistryKeyPermissionCheck, rights As RegistryRights) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistryRights rights);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * System.Security.AccessControl.RegistryRights -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, permissionCheck, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" />
        <Parameter Name="rights" Type="System.Security.AccessControl.RegistryRights" />
      </Parameters>
      <Docs>
        <param name="name">Nom ou chemin d’accès de la sous-clé à créer ou ouvrir.</param>
        <param name="permissionCheck">L'une des valeurs d'énumération qui spécifie si la clé est ouverte pour un accès en lecture ou en lecture/écriture.</param>
        <param name="rights">Combinaison d'opérations de bits des valeurs d'énumération qui spécifie l'accès de sécurité souhaité.</param>
        <summary>Récupère la sous-clé spécifiée pour un accès en lecture ou en lecture/écriture, en demandant les droits d'accès spécifiés.</summary>
        <returns>Sous-clé demandée ou <see langword="null" /> en cas d'échec de l'opération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Au lieu de lever une exception, cette méthode retourne `null` si la clé demandée n’existe pas.  
  
 Si `permissionCheck` est <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>, la clé est ouverte pour la lecture et écriture ; si `permissionCheck` est <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType> ou <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>, la clé est ouverte pour la lecture, sauf si la clé parente a été ouvert avec <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>.  
  
 L’accès spécifié pour `permissionCheck` est prioritaire sur l’accès spécifié pour `rights`. Par exemple, si vous spécifiez <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType> pour `permissionCheck` et <xref:System.Security.AccessControl.RegistryRights.WriteKey?displayProperty=nameWithType> pour `rights`, une tentative d’écriture à la sous-clé lève une exception.  
  
 Pour pouvoir utiliser le <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> (méthode), vous devez avoir une instance de la <xref:Microsoft.Win32.RegistryKey> classe. Pour obtenir une instance de <xref:Microsoft.Win32.RegistryKey>, utilisez un des membres statiques de la <xref:Microsoft.Win32.Registry> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="permissionCheck" /> contient une valeur non valide.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.Security.SecurityException">
          <paramref name="rights" /> inclut les valeurs non valides de droits d'accès à la base de registres.  
  
- ou - 
L'utilisateur n'a pas les autorisations demandées.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour la capacité à lire la clé de Registre spécifiée. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetAccessControl(System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.RegistrySecurity -&gt; unit" Usage="registryKey.SetAccessControl registrySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" />
      </Parameters>
      <Docs>
        <param name="registrySecurity">Sécurité du contrôle d'accès à appliquer à la sous-clé actuelle.</param>
        <summary>Applique la sécurité du contrôle d'accès Windows à une clé de Registre existante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour modifier les autorisations pour une clé de Registre, utilisez la <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A> méthode pour obtenir un <xref:System.Security.AccessControl.RegistrySecurity> de l’objet qui représente la sécurité de contrôle d’accès Windows existante, modifiez cet <xref:System.Security.AccessControl.RegistrySecurity> objet, puis utiliser le <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A> méthode pour mettre à jour de sécurité pour La clé.  
  
> [!CAUTION]
>  Le <xref:System.Security.AccessControl.RegistrySecurity> objet spécifié pour `registrySecurity` remplace la sécurité existante pour la clé de Registre. Pour ajouter des autorisations pour un nouvel utilisateur, utilisez la <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A> méthode pour obtenir l’accès existant contrôler la sécurité, puis le modifier.  
  
   
  
## Examples  
 L’exemple de code suivant crée une clé de test. L’utilisateur actuel est autorisé <xref:System.Security.AccessControl.RegistryRights.ReadKey> et <xref:System.Security.AccessControl.RegistryRights.Delete> droits refusés mais <xref:System.Security.AccessControl.RegistryRights.ChangePermissions> et <xref:System.Security.AccessControl.RegistryRights.WriteKey> droits. Lors, toute tentative de manipulation de la clé réussissent ou échouent en fonction de ces autorisations.  
  
 Avant la suppression de la clé, le code s’interrompt. Vous pouvez basculer vers l’Éditeur du Registre et vérifiez que les droits d’accès s’appliquent lorsque la clé est accédée à l’aide de l’Éditeur du Registre. (Cela fonctionne mieux si vous utilisez **RunAs** à partir de la ligne de commande pour exécuter l’Éditeur du Registre et l’exemple de code en tant qu’utilisateur local sans droits d’administrateur. L’Éditeur du Registre permet toujours à un administrateur de modifier les autorisations, même si l’administrateur particulier a été refusé à ces droits. Si vous avez défini un utilisateur local nommé TestUser, la commande `runas /user:TestUser cmd` ouvre une fenêtre de commande à partir de laquelle vous pouvez exécuter l’Éditeur du Registre, puis l’exemple de code.)  
  
 [!code-cpp[RegistrySecurity101#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistrySecurity101/cpp/source.cpp#1)]
 [!code-csharp[RegistrySecurity101#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistrySecurity101/CS/source.cs#1)]
 [!code-vb[RegistrySecurity101#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistrySecurity101/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'objet <see cref="T:Microsoft.Win32.RegistryKey" /> en cours représente une clé avec sécurité du contrôle d'accès et l'appelant n'a pas de droits <see cref="F:System.Security.AccessControl.RegistryRights.ChangePermissions" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="registrySecurity" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> en cours de manipulation est fermé (les clés fermées ne sont pas accessibles).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit la valeur d'une paire nom/valeur dans la clé de Registre. Selon la surcharge, le type de données de Registre est déterminé par le type des données en cours de stockage ou par un <see cref="T:Microsoft.Win32.RegistryValueKind" /> spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (string name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(string name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (name As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::String ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : string * obj -&gt; unit" Usage="registryKey.SetValue (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la valeur à stocker.</param>
        <param name="value">Données à stocker.</param>
        <summary>Définit la paire nom/valeur spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nombre de valeurs pouvant être stockées dans chaque clé dans le Registre, vous devez utiliser le `name` paramètre pour spécifier la valeur particulière que vous souhaitez définir.  
  
> [!NOTE]
>  Une clé de Registre peut avoir une valeur qui n’est pas associée à n’importe quel nom. Lorsque cette valeur sans nom est affichée dans l’Éditeur du Registre, la chaîne « (par défaut) » s’affiche au lieu d’un nom. Pour définir cette valeur sans nom, spécifiez soit `null` ou une chaîne vide (" ») pour `name`.  
  
 Pour définir les valeurs d’une clé, vous devez ouvrir la clé avec un accès en écriture. Une fois que vous avez ouvert une clé avec un accès en écriture, vous pouvez modifier une des paires nom/valeur dans cette clé.  
  
 Si spécifié `name` n’existe pas dans la clé, il est créé et la valeur associée est définie sur `value`.  
  
 Cette surcharge de <xref:Microsoft.Win32.RegistryKey.SetValue%2A> stocke les entiers 64 bits sous forme de chaînes (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). Pour stocker les nombres de 64 bits en tant que <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> valeurs, utilisez le <xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> surcharge spécifie <xref:Microsoft.Win32.RegistryValueKind>.  
  
 Cette surcharge de <xref:Microsoft.Win32.RegistryKey.SetValue%2A> stocke toutes les valeurs de chaîne comme <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>, même s’ils contiennent des références extensibles aux variables d’environnement. Pour enregistrer les valeurs de chaîne extensibles comme chaînes (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), utilisez le <xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> surcharge spécifie <xref:Microsoft.Win32.RegistryValueKind>.  
  
 Les types numériques autres que des entiers 32 bits sont stockés sous forme de chaînes par cette surcharge de méthode. Éléments de l’énumération sont stockés sous forme de chaînes contenant les noms d’élément.  
  
> [!CAUTION]
>  N’exposez pas <xref:Microsoft.Win32.RegistryKey> objets de sorte qu’un programme malveillant pourrait créer des milliers de sous-clés sans signification ou paires clé/valeur. Par exemple, n’autorisent pas les appelants à entrer des clés arbitraires ou des valeurs.  
  
> [!NOTE]
>  Sur Windows 98 et Windows Millennium Edition le Registre n’est pas Unicode, et pas tous les caractères Unicode sont valides pour toutes les pages de code. Un caractère Unicode qui n’est pas valide pour la page de codes actuelle est remplacée par la meilleure correspondance disponible. Aucune exception n'est levée.  
  
   
  
## Examples  
 Le code suivant montre l’exemple comment la <xref:Microsoft.Win32.RegistryKey.SetValue%2A> méthode détermine le type de données de Registre lorsqu’elle définit des valeurs. L’exemple crée une clé de test et ajoute les valeurs de différents types de données à la clé. L’exemple lit les paires nom/valeur, puis les affiche dans la console, à l’aide de la <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> méthode pour afficher les types de données de Registre correspondants.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> est un type de données non pris en charge.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> qui contient la valeur spécifiée est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> est en lecture seule et n'est pas accessible en écriture ; par exemple, la clé n'a pas été ouverte avec un accès en écriture.  
  
- ou - 
L'objet <see cref="T:Microsoft.Win32.RegistryKey" /> représente un nœud de niveau racine, et le système d'exploitation est Windows Millennium Edition ou Windows 98.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour créer ou modifier des clés de Registre.</exception>
        <exception cref="T:System.IO.IOException">L'objet <see cref="T:Microsoft.Win32.RegistryKey" /> représente un nœud de niveau racine, et le système d'exploitation est Windows 2000, Windows XP ou Windows Server 2003.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Pour modifier la clé de Registre spécifiée si elle existe, ou pour créer la clé de Registre si elle n’existe pas déjà. Énumérations associées : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (string name, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(string name, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (name As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::String ^ name, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="member this.SetValue : string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="registryKey.SetValue (name, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la valeur à stocker.</param>
        <param name="value">Données à stocker.</param>
        <param name="valueKind">Type de données de Registre à utiliser lors du stockage des données.</param>
        <summary>Définit la valeur d'une paire nom/valeur dans la clé de Registre à l'aide du type de données de Registre spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nombre de valeurs pouvant être stockées dans chaque clé dans le Registre, vous devez utiliser le `name` paramètre pour spécifier la valeur particulière que vous souhaitez définir.  
  
> [!NOTE]
>  Une clé de Registre peut avoir une valeur qui n’est pas associée à n’importe quel nom. Lorsque cette valeur sans nom est affichée dans l’Éditeur du Registre, la chaîne « (par défaut) » s’affiche au lieu d’un nom. Pour définir cette valeur sans nom, spécifiez soit `null` ou une chaîne vide (" ») pour `name`.  
  
 Pour définir les valeurs d’une clé, vous devez ouvrir la clé avec un accès en écriture. Une fois que vous avez ouvert une clé avec un accès en écriture, vous pouvez modifier une des paires nom/valeur dans cette clé.  
  
 Si spécifié `name` n’existe pas dans la clé, il est créé, et la valeur associée est définie sur `value`.  
  
> [!NOTE]
>  En spécifiant le type de données de Registre <xref:Microsoft.Win32.RegistryValueKind.Unknown> est identique à l’aide de la <xref:Microsoft.Win32.RegistryKey.SetValue%2A> de surcharge.  
  
 Si le type de l’objet `value` ne correspond pas à spécifié `valueKind`, et les données ne peut pas être converti, <xref:System.ArgumentException> est levée. Par exemple, vous pouvez stocker un <xref:System.Int64?displayProperty=nameWithType> comme un <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, mais uniquement si sa valeur est inférieure à la valeur maximale d’un <xref:System.Int32?displayProperty=nameWithType>. Vous ne pouvez pas stocker une valeur de chaîne unique comme un <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Si des valeurs boxed sont passées pour <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> ou <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, la conversion s’effectue à l’aide de la culture dite indifférente.  
  
> [!CAUTION]
>  N’exposez pas <xref:Microsoft.Win32.RegistryKey> objets de sorte qu’un programme malveillant pourrait créer des milliers de sous-clés sans signification ou paires clé/valeur. Par exemple, n’autorisent pas les appelants à entrer des clés arbitraires ou des valeurs.  
  
> [!NOTE]
>  Sur Windows 98 et Windows Millennium Edition le Registre n’est pas Unicode, et pas tous les caractères Unicode sont valides pour toutes les pages de code. Un caractère Unicode qui n’est pas valide pour la page de codes actuelle est remplacée par la meilleure correspondance disponible. Aucune exception n'est levée.  
  
   
  
## Examples  
 L’exemple de code suivant crée une clé de test et utilise le <xref:Microsoft.Win32.RegistryKey.SetValue%2A> méthode pour stocker plusieurs valeurs, en spécifiant le type de données de Registre pour chaque valeur. L’exemple lit les paires nom/valeur, puis les affiche dans la console, à l’aide de la <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> méthode pour afficher les types de données de Registre correspondants.  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le type de <paramref name="value" /> ne correspondait pas au type de données de Registre spécifié par <paramref name="valueKind" />, par conséquent les données n'ont pas pu être converties correctement.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> qui contient la valeur spécifiée est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <see cref="T:Microsoft.Win32.RegistryKey" /> est en lecture seule et n'est pas accessible en écriture ; par exemple, la clé n'a pas été ouverte avec un accès en écriture.  
  
- ou - 
L'objet <see cref="T:Microsoft.Win32.RegistryKey" /> représente un nœud de niveau racine, et le système d'exploitation est Windows Millennium Edition ou Windows 98.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises pour créer ou modifier des clés de Registre.</exception>
        <exception cref="T:System.IO.IOException">L'objet <see cref="T:Microsoft.Win32.RegistryKey" /> représente un nœud de niveau racine, et le système d'exploitation est Windows 2000, Windows XP ou Windows Server 2003.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Pour modifier la clé de Registre spécifiée si elle existe, ou pour créer la clé de Registre si elle n’existe pas déjà. Énumérations associées : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir accéder au si de clé de Registre spécifiée est une clé à distance. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="T:Microsoft.Win32.RegistryValueKind" />
      </Docs>
    </Member>
    <Member MemberName="SubKeyCount">
      <MemberSignature Language="C#" Value="public int SubKeyCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubKeyCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SubKeyCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubKeyCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SubKeyCount : int" Usage="Microsoft.Win32.RegistryKey.SubKeyCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Récupère le nombre de sous-clés de la clé actuelle.</summary>
        <value>Nombre de sous-clés de la clé actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété ne prend pas de manière récursive les noms count. Elle renvoie uniquement le nombre de noms de niveau de base à partir de laquelle elle a été appelée.  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas d'autorisation en lecture pour la clé.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> en cours de manipulation est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <exception cref="T:System.IO.IOException">Une erreur système s'est produite, telle que la suppression de la clé actuelle.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour la capacité à lire la clé de Registre spécifiée. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="registryKey.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une représentation de type chaîne de cette clé.</summary>
        <returns>Chaîne représentant la clé. Si la clé spécifiée n'est pas valide (introuvable), <see langword="null" /> est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de retour inclut le chemin d’accès de Registre de la clé spécifiée et la valeur hexadécimale pour la clé. Le chemin d’accès de Registre inclut la racine absolue de la clé spécifiée, démarre toujours à une des clés de base pour le Registre, par exemple, HKEY_LOCAL_MACHINE.  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> qui fait l'objet d'un accès est fermé (les clés fermées ne sont pas accessibles).</exception>
        <altmember cref="P:Microsoft.Win32.RegistryKey.Name" />
      </Docs>
    </Member>
    <Member MemberName="ValueCount">
      <MemberSignature Language="C#" Value="public int ValueCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ValueCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.ValueCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ValueCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueCount : int" Usage="Microsoft.Win32.RegistryKey.ValueCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Récupère le nombre de valeurs dans la clé.</summary>
        <value>Nombre de paires nom/valeur dans la clé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé de Registre a une valeur par défaut qui n’est pas associée à n’importe quel nom. Cette valeur sans nom peut être définie à l’aide de la <xref:Microsoft.Win32.RegistryKey.SetValue%2A> méthode et en spécifiant `null` ou une chaîne vide (" ») pour `name`. Si la valeur par défaut n’a jamais été définie, il ne contribue pas au nombre total retourné par la <xref:Microsoft.Win32.RegistryKey.ValueCount%2A> propriété ; une fois qu’il a été défini, toutefois, il est toujours comptabilisé.  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:Microsoft.Win32.RegistryKey> classe.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas d'autorisation en lecture pour la clé.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:Microsoft.Win32.RegistryKey" /> en cours de manipulation est fermé (les clés fermées ne sont pas accessibles).</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne dispose pas des droits d'accès à la base de registres appropriés.</exception>
        <exception cref="T:System.IO.IOException">Une erreur système s'est produite, telle que la suppression de la clé actuelle.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">pour la capacité à lire la clé de Registre spécifiée. Énumération associée : <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="View">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryView View { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Win32.RegistryView View" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.View" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property View As RegistryView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::RegistryView View { Microsoft::Win32::RegistryView get(); };" />
      <MemberSignature Language="F#" Value="member this.View : Microsoft.Win32.RegistryView" Usage="Microsoft.Win32.RegistryKey.View" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la vue utilisée pour créer la clé de Registre.</summary>
        <value>Vue utilisée pour créer la clé de Registre.  
  
- ou - 
 <see cref="F:Microsoft.Win32.RegistryView.Default" />, si aucune vue n'a été utilisée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sur les versions 64 bits de Windows, les parties du Registre sont stockées séparément pour les applications 32 bits et 64 bits. Il existe une vue 32 bits pour les applications 32 bits et une vue 64 bits pour les applications 64 bits.  
  
 Ne supposez pas que la vue correspond toujours à l’affichage réel de le <xref:Microsoft.Win32.RegistryKey>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>