<Type Name="Queue&lt;T&gt;" FullName="System.Collections.Generic.Queue&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="daef28e829e1db6957477f7c6d292e59ec71ea6b" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52254559" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Queue&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Queue`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Queue`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Queue(Of T)&#xA;Implements ICollection, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Queue : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type Queue&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_QueueDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Spécifie le type d'éléments dans la file d'attente.</typeparam>
    <summary>Représente une collection d’objets premier entré, premier sorti.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette classe implémente une file d’attente générique sous forme de tableau circulaire. Objets stockés dans un <xref:System.Collections.Generic.Queue%601> sont insérés à une extrémité et supprimés à l’autre. Les piles et les files d’attente sont utiles lorsque vous avez besoin de stockage temporaire des informations ; Autrement dit, lorsque vous souhaitez ignorer un élément après avoir récupéré sa valeur. Utilisez <xref:System.Collections.Generic.Queue%601> si vous avez besoin accéder aux informations dans le même ordre que celui qu’elles sont stockées dans la collection. Utilisez <xref:System.Collections.Generic.Stack%601> si vous avez besoin accéder aux informations dans l’ordre inverse. Utilisez <xref:System.Collections.Concurrent.ConcurrentQueue%601> ou <xref:System.Collections.Concurrent.ConcurrentStack%601> si vous avez besoin pour accéder à la collection à partir de plusieurs threads simultanément.  
  
 Trois opérations principales peuvent être effectuées sur un <xref:System.Collections.Generic.Queue%601> et ses éléments :  
  
-   <xref:System.Collections.Generic.Queue%601.Enqueue%2A> Ajoute un élément à la fin de la <xref:System.Collections.Generic.Queue%601>.  
  
-   <xref:System.Collections.Generic.Queue%601.Dequeue%2A> Supprime l’élément le plus ancien à partir du début de la <xref:System.Collections.Generic.Queue%601>.  
  
-   <xref:System.Collections.Generic.Queue%601.Peek%2A> Peek retourne l’élément le plus ancien qui se trouve au début de la <xref:System.Collections.Generic.Queue%601> mais ne supprime ne pas de la <xref:System.Collections.Generic.Queue%601>.  
  
 La capacité d’un <xref:System.Collections.Generic.Queue%601> est le nombre d’éléments du <xref:System.Collections.Generic.Queue%601> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.Generic.Queue%601>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne. La capacité peut être diminuée en appelant <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>.  
  
 <xref:System.Collections.Generic.Queue%601> accepte `null` comme une valeur valide pour la référence de types et autorise les éléments en double.  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs méthodes de la <xref:System.Collections.Generic.Queue%601> classe générique. L’exemple de code crée une file d’attente de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Queue%601.Enqueue%2A> méthode en file d’attente de cinq chaînes. Les éléments de la file d’attente sont énumérés, ce qui ne modifie pas l’état de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la première chaîne de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant dans la file d’attente, puis le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la file d’attente il.  
  
 Le <xref:System.Collections.Generic.Queue%601.ToArray%2A> méthode est utilisée pour créer un tableau et de copier les éléments de la file d’attente, puis le tableau est passé à la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, créant une copie de la file d’attente. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la file d’attente est créé et le <xref:System.Collections.Generic.Queue%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur est utilisé à nouveau pour créer une deuxième copie de la file d’attente qui contient trois éléments null au début.  
  
 Le <xref:System.Collections.Generic.Queue%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » dans la première copie de la file d’attente, après laquelle le <xref:System.Collections.Generic.Queue%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Queue%601.Count%2A> propriété montre que la file d’attente est vide.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statique public (<see langword="Shared" /> en Visual Basic) de ce type sont thread-safe. Il n'est pas garanti que les membres d'instance soient thread-safe.  
  
Un <see cref="T:System.Collections.Generic.Queue`1" /> peut prendre en charge plusieurs lecteurs simultanément, tant que la collection n’est pas modifiée.  Même dans ce cas, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.  Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.Queue`1" /> qui est vide et possède la capacité initiale par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité d’un <xref:System.Collections.Generic.Queue%601> est le nombre d’éléments qui le <xref:System.Collections.Generic.Queue%601> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.Generic.Queue%601>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Generic.Queue%601>.  
  
 La capacité peut être diminuée en appelant <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>.  
  
 Ce constructeur est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant illustre ce constructeur et plusieurs autres méthodes de la <xref:System.Collections.Generic.Queue%601> classe générique. L’exemple de code crée une file d’attente de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Queue%601.Enqueue%2A> méthode en file d’attente de cinq chaînes. Les éléments de la file d’attente sont énumérés, ce qui ne modifie pas l’état de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la première chaîne de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant dans la file d’attente, puis le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la file d’attente il.  
  
 Le <xref:System.Collections.Generic.Queue%601.ToArray%2A> méthode est utilisée pour créer un tableau et de copier les éléments de la file d’attente, puis le tableau est passé à la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, créant une copie de la file d’attente. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la file d’attente est créé et le <xref:System.Collections.Generic.Queue%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur est utilisé à nouveau pour créer une deuxième copie de la file d’attente qui contient trois éléments null au début.  
  
 Le <xref:System.Collections.Generic.Queue%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » dans la première copie de la file d’attente, après laquelle le <xref:System.Collections.Generic.Queue%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Queue%601.Count%2A> propriété montre que la file d’attente est vide.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Queue&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.Queue&lt;'T&gt;" Usage="new System.Collections.Generic.Queue&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Collection dont les éléments sont copiés dans la nouvelle <see cref="T:System.Collections.Generic.Queue`1" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.Queue`1" /> qui contient des éléments copiés à partir de la collection spécifiée et qui possède une capacité suffisante pour accepter le nombre d’éléments copiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité d’un <xref:System.Collections.Generic.Queue%601> est le nombre d’éléments qui le <xref:System.Collections.Generic.Queue%601> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.Generic.Queue%601>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Generic.Queue%601>.  
  
 La capacité peut être diminuée en appelant <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>.  
  
 Les éléments sont copiés dans le <xref:System.Collections.Generic.Queue%601> dans le même ordre qu’ils sont lus par le <xref:System.Collections.Generic.IEnumerator%601> de la collection.  
  
 Ce constructeur est un O (`n`) opération, où `n` est le nombre d’éléments dans `collection`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre ce constructeur et plusieurs autres méthodes de la <xref:System.Collections.Generic.Queue%601> classe générique. L’exemple de code crée une file d’attente de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Queue%601.Enqueue%2A> méthode en file d’attente de cinq chaînes. Les éléments de la file d’attente sont énumérés, ce qui ne modifie pas l’état de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la première chaîne de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant dans la file d’attente, puis le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la file d’attente il.  
  
 Le <xref:System.Collections.Generic.Queue%601.ToArray%2A> méthode est utilisée pour créer un tableau et de copier les éléments de la file d’attente, puis le tableau est passé à la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, créant une copie de la file d’attente. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la file d’attente est créé et le <xref:System.Collections.Generic.Queue%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur est utilisé à nouveau pour créer une deuxième copie de la file d’attente qui contient trois éléments null au début.  
  
 Le <xref:System.Collections.Generic.Queue%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » dans la première copie de la file d’attente, après laquelle le <xref:System.Collections.Generic.Queue%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Queue%601.Count%2A> propriété montre que la file d’attente est vide.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Queue&lt;'T&gt; : int -&gt; System.Collections.Generic.Queue&lt;'T&gt;" Usage="new System.Collections.Generic.Queue&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Nombre initial d'éléments que <see cref="T:System.Collections.Generic.Queue`1" /> peut contenir.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.Queue`1" /> qui est vide et a la capacité initiale spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité d’un <xref:System.Collections.Generic.Queue%601> est le nombre d’éléments qui le <xref:System.Collections.Generic.Queue%601> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.Generic.Queue%601>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Generic.Queue%601>.  
  
 La capacité peut être diminuée en appelant <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>.  
  
 Ce constructeur est un O (`n`) opération, où `n` est `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="queue.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les objets du <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Queue%601.Count%2A> est défini sur zéro et les références à d’autres objets à partir des éléments de la collection sont également libérées.  
  
 La capacité reste inchangée. Pour rétablir la capacité de la <xref:System.Collections.Generic.Queue%601>, appelez <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>. Suppression vide <xref:System.Collections.Generic.Queue%601> définit la capacité de la <xref:System.Collections.Generic.Queue%601> à la capacité par défaut.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs méthodes de la <xref:System.Collections.Generic.Queue%601> classe générique, y compris le <xref:System.Collections.Generic.Queue%601.Clear%2A> (méthode).  
  
 L’exemple de code crée une file d’attente de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Queue%601.Enqueue%2A> méthode en file d’attente de cinq chaînes. Les éléments de la file d’attente sont énumérés, ce qui ne modifie pas l’état de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la première chaîne de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant dans la file d’attente, puis le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la file d’attente il.  
  
 Le <xref:System.Collections.Generic.Queue%601.ToArray%2A> méthode est utilisée pour créer un tableau et de copier les éléments de la file d’attente, puis le tableau est passé à la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, créant une copie de la file d’attente. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la file d’attente est créé et le <xref:System.Collections.Generic.Queue%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur est utilisé à nouveau pour créer une deuxième copie de la file d’attente qui contient trois éléments null au début.  
  
 Le <xref:System.Collections.Generic.Queue%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » dans la première copie de la file d’attente, après laquelle le <xref:System.Collections.Generic.Queue%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Queue%601.Count%2A> propriété montre que la file d’attente est vide.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.TrimExcess" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(T item);" />
      <MemberSignature Language="F#" Value="member this.Contains : 'T -&gt; bool" Usage="queue.Contains item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objet à rechercher dans <see cref="T:System.Collections.Generic.Queue`1" />. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <summary>Détermine si le <see cref="T:System.Collections.Generic.Queue`1" /> contient un élément.</summary>
        <returns>
          <see langword="true" /> si <paramref name="item" /> existe dans <see cref="T:System.Collections.Generic.Queue`1" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine l’égalité à l’aide du comparateur d’égalité par défaut <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> pour `T`, le type des valeurs dans la file d’attente.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs méthodes de la <xref:System.Collections.Generic.Queue%601> classe générique, y compris le <xref:System.Collections.Generic.Queue%601.Contains%2A> (méthode).  
  
 L’exemple de code crée une file d’attente de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Queue%601.Enqueue%2A> méthode en file d’attente de cinq chaînes. Les éléments de la file d’attente sont énumérés, ce qui ne modifie pas l’état de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la première chaîne de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant dans la file d’attente, puis le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la file d’attente il.  
  
 Le <xref:System.Collections.Generic.Queue%601.ToArray%2A> méthode est utilisée pour créer un tableau et de copier les éléments de la file d’attente, puis le tableau est passé à la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, créant une copie de la file d’attente. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la file d’attente est créé et le <xref:System.Collections.Generic.Queue%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur est utilisé à nouveau pour créer une deuxième copie de la file d’attente qui contient trois éléments null au début.  
  
 Le <xref:System.Collections.Generic.Queue%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » dans la première copie de la file d’attente, après laquelle le <xref:System.Collections.Generic.Queue%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Queue%601.Count%2A> propriété montre que la file d’attente est vide.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Exécution d'opérations de chaînes indépendantes de la culture</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="queue.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Collections.Generic.Queue`1" />. Le <see cref="T:System.Array" /> doit avoir une indexation de base zéro.</param>
        <param name="arrayIndex">Index de base zéro dans l'<paramref name="array" /> à partir duquel la copie commence.</param>
        <summary>Copie les éléments <see cref="T:System.Collections.Generic.Queue`1" /> dans un <see cref="T:System.Array" /> unidimensionnel existant, en commençant au niveau de l'index de tableau spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments sont copiés dans le <xref:System.Array> dans le même ordre que celui dans lequel l’énumérateur itère au sein du <xref:System.Collections.Generic.Queue%601>.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">Le nombre d’éléments dans le <see cref="T:System.Collections.Generic.Queue`1" /> source est supérieur à la quantité d’espace disponible entre <paramref name="arrayIndex" /> et la fin du <paramref name="array" /> de destination.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Queue`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.Queue&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d'éléments contenus dans le <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <value>Nombre d'éléments contenus dans <see cref="T:System.Collections.Generic.Queue`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité d’un <xref:System.Collections.Generic.Queue%601> est le nombre d’éléments qui le <xref:System.Collections.Generic.Queue%601> peut stocker. <xref:System.Collections.Generic.Queue%601.Count%2A> est le nombre d’éléments réellement contenus dans le <xref:System.Collections.Generic.Queue%601>.  
  
 La capacité est toujours supérieure ou égale à <xref:System.Collections.Generic.Queue%601.Count%2A>. Si <xref:System.Collections.Generic.Queue%601.Count%2A> dépasse la capacité lors de l’ajout d’éléments, la capacité est augmentée en réallouant automatiquement le tableau interne avant de copier les anciens éléments et d’ajouter les nouveaux éléments.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
   
  
## Examples  
 L’exemple de code suivant montre plusieurs propriétés et méthodes de la <xref:System.Collections.Generic.Queue%601> classe générique, y compris le <xref:System.Collections.Generic.Queue%601.Count%2A> propriété.  
  
 L’exemple de code crée une file d’attente de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Queue%601.Enqueue%2A> méthode en file d’attente de cinq chaînes. Les éléments de la file d’attente sont énumérés, ce qui ne modifie pas l’état de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la première chaîne de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant dans la file d’attente, puis le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la file d’attente il.  
  
 Le <xref:System.Collections.Generic.Queue%601.ToArray%2A> méthode est utilisée pour créer un tableau et de copier les éléments de la file d’attente, puis le tableau est passé à la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, créant une copie de la file d’attente. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la file d’attente est créé et le <xref:System.Collections.Generic.Queue%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur est utilisé à nouveau pour créer une deuxième copie de la file d’attente qui contient trois éléments null au début.  
  
 Le <xref:System.Collections.Generic.Queue%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » dans la première copie de la file d’attente, après laquelle le <xref:System.Collections.Generic.Queue%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Queue%601.Count%2A> propriété montre que la file d’attente est vide.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dequeue">
      <MemberSignature Language="C#" Value="public T Dequeue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Dequeue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Dequeue" />
      <MemberSignature Language="VB.NET" Value="Public Function Dequeue () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Dequeue();" />
      <MemberSignature Language="F#" Value="member this.Dequeue : unit -&gt; 'T" Usage="queue.Dequeue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime et renvoie l'objet au début de la <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <returns>Objet supprimé du début de la <see cref="T:System.Collections.Generic.Queue`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est analogue à la méthode <xref:System.Collections.Generic.Queue%601.Peek%2A>, mais <xref:System.Collections.Generic.Queue%601.Peek%2A> ne modifie pas la <xref:System.Collections.Generic.Queue%601>.  
  
 Si type `T` est un type référence, `null` peuvent être ajoutés à la <xref:System.Collections.Generic.Queue%601> en tant que valeur.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs méthodes de la <xref:System.Collections.Generic.Queue%601> classe générique, y compris le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> (méthode).  
  
 L’exemple de code crée une file d’attente de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Queue%601.Enqueue%2A> méthode en file d’attente de cinq chaînes. Les éléments de la file d’attente sont énumérés, ce qui ne modifie pas l’état de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la première chaîne de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant dans la file d’attente, puis le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la file d’attente il.  
  
 Le <xref:System.Collections.Generic.Queue%601.ToArray%2A> méthode est utilisée pour créer un tableau et de copier les éléments de la file d’attente, puis le tableau est passé à la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, créant une copie de la file d’attente. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la file d’attente est créé et le <xref:System.Collections.Generic.Queue%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur est utilisé à nouveau pour créer une deuxième copie de la file d’attente qui contient trois éléments null au début.  
  
 Le <xref:System.Collections.Generic.Queue%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » dans la première copie de la file d’attente, après laquelle le <xref:System.Collections.Generic.Queue%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Queue%601.Count%2A> propriété montre que la file d’attente est vide.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La <see cref="T:System.Collections.Generic.Queue`1" /> est vide.</exception>
        <altmember cref="M:System.Collections.Generic.Queue`1.Enqueue(`0)" />
        <altmember cref="M:System.Collections.Generic.Queue`1.Peek" />
      </Docs>
    </Member>
    <Member MemberName="Enqueue">
      <MemberSignature Language="C#" Value="public void Enqueue (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Enqueue(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Enqueue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Enqueue (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Enqueue(T item);" />
      <MemberSignature Language="F#" Value="member this.Enqueue : 'T -&gt; unit" Usage="queue.Enqueue item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objet à ajouter à <see cref="T:System.Collections.Generic.Queue`1" />. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <summary>Ajoute un objet à la fin de la <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Collections.Generic.Queue%601.Count%2A> est déjà égale à la capacité, la capacité de la <xref:System.Collections.Generic.Queue%601> est augmentée en réallouant automatiquement le tableau interne, et les éléments existants sont copiés vers le nouveau tableau avant le nouvel élément est ajouté.  
  
 Si <xref:System.Collections.Generic.Queue%601.Count%2A> est inférieure à la capacité du tableau interne, cette méthode est une opération o (1). Si le tableau interne doit être réalloué pour intégrer un nouvel élément, cette méthode devient un O (`n`) opération, où `n` est <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs méthodes de la <xref:System.Collections.Generic.Queue%601> classe générique, y compris le <xref:System.Collections.Generic.Queue%601.Enqueue%2A> (méthode).  
  
 L’exemple de code crée une file d’attente de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Queue%601.Enqueue%2A> méthode en file d’attente de cinq chaînes. Les éléments de la file d’attente sont énumérés, ce qui ne modifie pas l’état de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la première chaîne de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant dans la file d’attente, puis le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la file d’attente il.  
  
 Le <xref:System.Collections.Generic.Queue%601.ToArray%2A> méthode est utilisée pour créer un tableau et de copier les éléments de la file d’attente, puis le tableau est passé à la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, créant une copie de la file d’attente. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la file d’attente est créé et le <xref:System.Collections.Generic.Queue%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur est utilisé à nouveau pour créer une deuxième copie de la file d’attente qui contient trois éléments null au début.  
  
 Le <xref:System.Collections.Generic.Queue%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » dans la première copie de la file d’attente, après laquelle le <xref:System.Collections.Generic.Queue%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Queue%601.Count%2A> propriété montre que la file d’attente est vide.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.Dequeue" />
        <altmember cref="M:System.Collections.Generic.Queue`1.Peek" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Queue&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Queue`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Queue(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::Queue&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.Queue&lt;'T&gt;.Enumerator" Usage="queue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Queue&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein de <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.Queue`1.Enumerator" /> pour <see cref="T:System.Collections.Generic.Queue`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs. Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. À cette position, <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> n'est pas défini. Par conséquent, vous devez appeler <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> pour avancer l’énumérateur jusqu’au premier élément de la collection avant de lire la valeur de <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A>.  
  
 <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> retourne le même objet jusqu'à ce que <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> soit appelé. <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A>.  
  
 Si <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> n’est pas défini. Vous ne pouvez pas attribuer de nouveau <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> au premier élément de la collection ; vous devez créer une nouvelle instance de l'énumérateur à la place.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> ou <xref:System.Collections.Generic.Queue%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> lève une <xref:System.InvalidOperationException>.  
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe. Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Implémentations par défaut de collections dans <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre que la <xref:System.Collections.Generic.Queue%601> classe générique est énumérable. Le `foreach` instruction (`For Each` en Visual Basic, `for each` en C++) est utilisé pour énumérer la file d’attente.  
  
 L’exemple de code crée une file d’attente de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Queue%601.Enqueue%2A> méthode en file d’attente de cinq chaînes. Les éléments de la file d’attente sont énumérés, ce qui ne modifie pas l’état de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la première chaîne de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant dans la file d’attente, puis le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la file d’attente il.  
  
 Le <xref:System.Collections.Generic.Queue%601.ToArray%2A> méthode est utilisée pour créer un tableau et de copier les éléments de la file d’attente, puis le tableau est passé à la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, créant une copie de la file d’attente. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la file d’attente est créé et le <xref:System.Collections.Generic.Queue%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur est utilisé à nouveau pour créer une deuxième copie de la file d’attente qui contient trois éléments null au début.  
  
 Le <xref:System.Collections.Generic.Queue%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » dans la première copie de la file d’attente, après laquelle le <xref:System.Collections.Generic.Queue%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Queue%601.Count%2A> propriété montre que la file d’attente est vide.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Queue`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public T Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; 'T" Usage="queue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Renvoie l'objet situé au début de la <see cref="T:System.Collections.Generic.Queue`1" /> sans le supprimer.</summary>
        <returns>Objet situé au début de la <see cref="T:System.Collections.Generic.Queue`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est analogue à la méthode <xref:System.Collections.Generic.Queue%601.Dequeue%2A>, mais <xref:System.Collections.Generic.Queue%601.Peek%2A> ne modifie pas la <xref:System.Collections.Generic.Queue%601>.  
  
 Si type `T` est un type référence, `null` peuvent être ajoutés à la <xref:System.Collections.Generic.Queue%601> en tant que valeur.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs méthodes de la <xref:System.Collections.Generic.Queue%601> classe générique, y compris le <xref:System.Collections.Generic.Queue%601.Peek%2A> (méthode).  
  
 L’exemple de code crée une file d’attente de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Queue%601.Enqueue%2A> méthode en file d’attente de cinq chaînes. Les éléments de la file d’attente sont énumérés, ce qui ne modifie pas l’état de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la première chaîne de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant dans la file d’attente, puis le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la file d’attente il.  
  
 Le <xref:System.Collections.Generic.Queue%601.ToArray%2A> méthode est utilisée pour créer un tableau et de copier les éléments de la file d’attente, puis le tableau est passé à la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, créant une copie de la file d’attente. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la file d’attente est créé et le <xref:System.Collections.Generic.Queue%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur est utilisé à nouveau pour créer une deuxième copie de la file d’attente qui contient trois éléments null au début.  
  
 Le <xref:System.Collections.Generic.Queue%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » dans la première copie de la file d’attente, après laquelle le <xref:System.Collections.Generic.Queue%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Queue%601.Count%2A> propriété montre que la file d’attente est vide.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La <see cref="T:System.Collections.Generic.Queue`1" /> est vide.</exception>
        <altmember cref="M:System.Collections.Generic.Queue`1.Enqueue(`0)" />
        <altmember cref="M:System.Collections.Generic.Queue`1.Dequeue" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein d’une collection.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" /> qui peut être utilisé pour itérer au sein de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs. Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. À cette position, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> n'est pas défini. Par conséquent, vous devez appeler <xref:System.Collections.IEnumerator.MoveNext%2A> pour avancer l’énumérateur jusqu’au premier élément de la collection avant de lire la valeur de <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> retourne le même objet jusqu'à ce que <xref:System.Collections.IEnumerator.MoveNext%2A> soit appelé. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> n’est pas défini. Vous ne pouvez pas attribuer de nouveau <xref:System.Collections.Generic.IEnumerator%601.Current%2A> au premier élément de la collection ; vous devez créer une nouvelle instance de l'énumérateur à la place.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> lève une <xref:System.InvalidOperationException>.  
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe. Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Implémentations par défaut de collections dans <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.GetEnumerator" />
        <altmember cref="M:System.Collections.IEnumerable.GetEnumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Collections.ICollection" />. Le <see cref="T:System.Array" /> doit avoir une indexation de base zéro.</param>
        <param name="index">Index de base zéro dans l'<paramref name="array" /> à partir duquel la copie commence.</param>
        <summary>Copie les éléments de <see cref="T:System.Collections.ICollection" /> dans <see cref="T:System.Array" />, à partir d'un index particulier de <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si le type de la source <xref:System.Collections.ICollection> ne peut pas être casté automatiquement au type de la destination `array`, les implémentations non génériques de <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> lever <xref:System.InvalidCastException>, tandis que les implémentations génériques lèvent <xref:System.ArgumentException>.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> est multidimensionnel.  
  
- ou - 
 <paramref name="array" /> n’a pas d’indexation de base zéro.  
  
- ou - 
Le nombre d’éléments dans la <see cref="T:System.Collections.ICollection" /> source est supérieur à la quantité d’espace disponible entre <paramref name="index" /> et la fin du <paramref name="array" /> de destination.  
  
- ou - 
Le type du <see cref="T:System.Collections.ICollection" /> source ne peut pas être converti automatiquement en type du <paramref name="array" /> de destination.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Queue`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'accès à <see cref="T:System.Collections.ICollection" /> est synchronisé (thread-safe).</summary>
        <value>
          <see langword="true" /> si l'accès à <see cref="T:System.Collections.ICollection" /> est synchronisé (thread-safe) ; sinon <see langword="false" />.  Dans l'implémentation par défaut de <see cref="T:System.Collections.Generic.Queue`1" />, cette propriété retourne toujours <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implémentations par défaut de collections dans <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.  Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> retourne un objet qui peut être utilisé pour synchroniser l'accès à <xref:System.Collections.ICollection>. La synchronisation est effective uniquement si tous les threads de verrouillent de cet objet avant d’accéder à la collection.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Queue`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.ICollection" />.  Dans l'implémentation par défaut de <see cref="T:System.Collections.Generic.Queue`1" />, cette propriété retourne toujours l'instance actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implémentations par défaut de collections dans <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.  Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> retourne un objet qui peut être utilisé pour synchroniser l'accès à <xref:System.Collections.ICollection>. La synchronisation est effective uniquement si tous les threads de verrouillent de cet objet avant d’accéder à la collection. Le code suivant illustre l’utilisation de la <xref:System.Collections.ICollection.SyncRoot%2A> propriété pour c#, C++ et Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As IColletion = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein d'une collection.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> qui peut être utilisé pour itérer au sein de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs. Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. <xref:System.Collections.IEnumerator.Reset%2A> replace également l'énumérateur à cette position.  À cette position, <xref:System.Collections.IEnumerator.Current%2A> n'est pas défini. Par conséquent, vous devez appeler <xref:System.Collections.IEnumerator.MoveNext%2A> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> n'est pas appelé. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.IEnumerator.Current%2A> n’est pas défini. Pour attribuer une nouvelle fois <xref:System.Collections.IEnumerator.Current%2A> au premier élément de la collection, vous pouvez appeler <xref:System.Collections.IEnumerator.Reset%2A> suivi de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> lève une <xref:System.InvalidOperationException>. 
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.  Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Implémentations par défaut de collections dans <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.GetEnumerator" />
        <altmember cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="queue.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copie les éléments <see cref="T:System.Collections.Generic.Queue`1" /> vers un nouveau tableau.</summary>
        <returns>Nouveau tableau contenant les éléments copiés à partir de <see cref="T:System.Collections.Generic.Queue`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.Queue%601> n’est pas modifié. L’ordre des éléments dans le nouveau tableau est le même que l’ordre des éléments à partir du début de la <xref:System.Collections.Generic.Queue%601> à sa fin.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre plusieurs méthodes de la <xref:System.Collections.Generic.Queue%601> classe générique, y compris le <xref:System.Collections.Generic.Queue%601.ToArray%2A> (méthode).  
  
 L’exemple de code crée une file d’attente de chaînes avec une capacité par défaut et utilise le <xref:System.Collections.Generic.Queue%601.Enqueue%2A> méthode en file d’attente de cinq chaînes. Les éléments de la file d’attente sont énumérés, ce qui ne modifie pas l’état de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la première chaîne de la file d’attente. Le <xref:System.Collections.Generic.Queue%601.Peek%2A> méthode est utilisée pour rechercher l’élément suivant dans la file d’attente, puis le <xref:System.Collections.Generic.Queue%601.Dequeue%2A> méthode est utilisée pour la file d’attente il.  
  
 Le <xref:System.Collections.Generic.Queue%601.ToArray%2A> méthode est utilisée pour créer un tableau et de copier les éléments de la file d’attente, puis le tableau est passé à la <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur qui accepte <xref:System.Collections.Generic.IEnumerable%601>, créant une copie de la file d’attente. Les éléments de la copie sont affichés.  
  
 Un tableau à deux reprises la taille de la file d’attente est créé et le <xref:System.Collections.Generic.Queue%601.CopyTo%2A> méthode est utilisée pour copier les éléments du tableau commençant au milieu du tableau. Le <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructeur est utilisé à nouveau pour créer une deuxième copie de la file d’attente qui contient trois éléments null au début.  
  
 Le <xref:System.Collections.Generic.Queue%601.Contains%2A> méthode est utilisée pour indiquer que la chaîne « 4 » dans la première copie de la file d’attente, après laquelle le <xref:System.Collections.Generic.Queue%601.Clear%2A> méthode efface la copie et le <xref:System.Collections.Generic.Queue%601.Count%2A> propriété montre que la file d’attente est vide.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="queue.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Définit la capacité au nombre réel d'éléments dans <see cref="T:System.Collections.Generic.Queue`1" />, si ce nombre est inférieur à 90 pour cent de la capacité actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour réduire une surcharge de mémoire d’une collection si aucun nouvel élément ne doit être ajouté à la collection. Le coût de réallocation et de copie d’un grand <xref:System.Collections.Generic.Queue%601> peut être considérable, toutefois, par conséquent, le <xref:System.Collections.Generic.Queue%601.TrimExcess%2A> méthode ne fait rien si la liste est à plus de 90 pour cent de la capacité. Cela évite de devoir engager un coût de réallocation élevé pour un gain relativement faible.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
 Pour réinitialiser un <xref:System.Collections.Generic.Queue%601> à son état initial, appelez le <xref:System.Collections.Generic.Queue%601.Clear%2A> méthode avant d’appeler <xref:System.Collections.Generic.Queue%601.TrimExcess%2A> (méthode). Suppression vide <xref:System.Collections.Generic.Queue%601> définit la capacité de la <xref:System.Collections.Generic.Queue%601> à la capacité par défaut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.Clear" />
        <altmember cref="P:System.Collections.Generic.Queue`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="public bool TryDequeue (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryDequeue([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.TryDequeue(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryDequeue (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryDequeue([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryDequeue :  -&gt; bool" Usage="queue.TryDequeue result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.TryPeek(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPeek (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPeek([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryPeek :  -&gt; bool" Usage="queue.TryPeek result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>