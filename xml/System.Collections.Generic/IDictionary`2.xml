<Type Name="IDictionary&lt;TKey,TValue&gt;" FullName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e711e8893beec361781ecb39b6d3b35cf53a30c2" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58749690" /></Metadata><TypeSignature Language="C#" Value="public interface IDictionary&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDictionary`2&lt;TKey, TValue&gt; implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.IDictionary`2" />
  <TypeSignature Language="VB.NET" Value="Public Interface IDictionary(Of TKey, TValue)&#xA;Implements ICollection(Of KeyValuePair(Of TKey, TValue)), IEnumerable(Of KeyValuePair(Of TKey, TValue))" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public interface class IDictionary : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;" />
  <TypeSignature Language="F#" Value="type IDictionary&lt;'Key, 'Value&gt; = interface&#xA;    interface ICollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TKey">Type des clés du dictionnaire.</typeparam>
    <typeparam name="TValue">Type des valeurs du dictionnaire.</typeparam>
    <summary>Représente une collection générique de paires clé/valeur.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.IDictionary%602> interface est l’interface de base pour les collections génériques de paires clé/valeur.  
  
 Chaque élément est une paire clé/valeur stockée dans un <xref:System.Collections.Generic.KeyValuePair%602> objet.  
  
 Chaque paire doit avoir une clé unique. Les implémentations peuvent varier selon si elles autorisent `key` être `null`. La valeur peut être `null` et ne doivent pas être uniques. Le <xref:System.Collections.Generic.IDictionary%602> interface permet les clés et les valeurs à énumérer, mais elle n’implique pas de n’importe quel ordre de tri particulier.  
  
 Le `foreach` instruction du langage c# (`For Each` en Visual Basic, `for each` dans C++) retourne un objet du type des éléments dans la collection. Étant donné que chaque élément de la <xref:System.Collections.Generic.IDictionary%602> est une paire clé/valeur, le type d’élément n’est pas le type de la clé ou le type de la valeur. Au lieu de cela, le type d’élément est <xref:System.Collections.Generic.KeyValuePair%602>. Par exemple :  
  
 [!code-cpp[Generic.IDictionary#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source2.cpp#11)]
 [!code-csharp[Generic.IDictionary#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source2.cs#11)]
 [!code-vb[Generic.IDictionary#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source2.vb#11)]  
  
 La `foreach` instruction est un wrapper autour de l’énumérateur, qui permet la lecture à partir n’écrit ne pas à la collection.  
  
> [!NOTE]
>  Étant donné que les clés peuvent être héritées et leur comportement modifié, leur unicité absolue ne peut pas être garantie par des comparaisons à l’aide de la <xref:System.Type.Equals%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant crée un vide <xref:System.Collections.Generic.Dictionary%602> de chaînes, avec des clés de chaîne et y accède via le <xref:System.Collections.Generic.IDictionary%602> interface.  
  
 L’exemple de code utilise le <xref:System.Collections.Generic.IDictionary%602.Add%2A> méthode pour ajouter des éléments. L’exemple montre que le <xref:System.Collections.Generic.IDictionary%602.Add%2A> méthode lève une exception <xref:System.ArgumentException> lorsque vous tentez d’ajouter une clé dupliquée.  
  
 L’exemple utilise le <xref:System.Collections.Generic.IDictionary%602.Item%2A> propriété (l’indexeur en c#) pour récupérer des valeurs, ce qui démontre qu’un <xref:System.Collections.Generic.KeyNotFoundException> est levée lorsqu’une clé demandée n’est pas présente et indiquant que la valeur associée à une clé peut être remplacée.  
  
 L’exemple montre comment utiliser le <xref:System.Collections.Generic.IDictionary%602.TryGetValue%2A> méthode comme un moyen plus efficace pour récupérer des valeurs si un programme doit souvent essayer des valeurs de clés qui ne sont pas dans le dictionnaire et comment utiliser le <xref:System.Collections.Generic.IDictionary%602.ContainsKey%2A> méthode pour tester si une clé existe avant d’appeler le <xref:System.Collections.Generic.IDictionary%602.Add%2A>(méthode).  
  
 Enfin, l’exemple montre comment énumérer les clés et valeurs dans le dictionnaire et comment énumérer les valeurs uniquement à l’aide de la <xref:System.Collections.Generic.IDictionary%602.Values%2A> propriété.  
  
 [!code-cpp[Generic.IDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#1)]
 [!code-csharp[Generic.IDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#1)]
 [!code-vb[Generic.IDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>La classe d’implémentation doit avoir un moyen de comparer des clés.</para></block>
    <altmember cref="T:System.Collections.Generic.ICollection`1" />
    <altmember cref="N:System.Collections" />
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'Key * 'Value -&gt; unit" Usage="iDictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Objet à utiliser comme clé de l'élément à ajouter.</param>
        <param name="value">Objet à utiliser comme valeur de l'élément à ajouter.</param>
        <summary>Ajoute un élément avec la clé et la valeur fournies à <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez également utiliser le <xref:System.Collections.Generic.IDictionary%602.Item%2A> propriété à ajouter de nouveaux éléments en définissant la valeur d’une clé qui n’existe pas dans le dictionnaire ; par exemple, `myCollection["myNonexistentKey"] = myValue` en c# (`myCollection("myNonexistentKey") = myValue` en Visual Basic). Toutefois, si la clé spécifiée existe déjà dans le dictionnaire, la définition du <xref:System.Collections.Generic.IDictionary%602.Item%2A> propriété remplace l’ancienne valeur. En revanche, le <xref:System.Collections.Generic.IDictionary%602.Add%2A> méthode ne modifie pas les éléments existants.  
  
 Les implémentations peuvent déterminer l’égalité des objets ; par exemple, le <xref:System.Collections.Generic.List%601> classe utilise <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, tandis que le <xref:System.Collections.Generic.Dictionary%602> classe permet à l’utilisateur de spécifier le <xref:System.Collections.Generic.IComparer%601> implémentation à utiliser pour comparer des clés.  
  
 Les implémentations peuvent varier selon si elles autorisent `key` être `null`.  
  
   
  
## Examples  
 L’exemple de code suivant crée un vide <xref:System.Collections.Generic.Dictionary%602> de chaînes avec des clés de type entier et y accède via le <xref:System.Collections.Generic.IDictionary%602> interface. L’exemple de code utilise le <xref:System.Collections.Generic.IDictionary%602.Add%2A> méthode pour ajouter des éléments. L’exemple montre que le <xref:System.Collections.Generic.IDictionary%602.Add%2A> méthode lève un <xref:System.ArgumentException> lorsque vous tentez d’ajouter une clé dupliquée.  
  
 Ce code fait partie d’un exemple plus complet qui peut être compilé et exécuté. Consultez <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#2)]
 [!code-csharp[Generic.IDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#2)]
 [!code-vb[Generic.IDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un élément possédant la même clé existe déjà dans <see cref="T:System.Collections.Generic.IDictionary`2" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.Generic.IDictionary`2" /> est en lecture seule.</exception>
        <altmember cref="P:System.Collections.Generic.IDictionary`2.Item(`0)" />
        <altmember cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsKey(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : 'Key -&gt; bool" Usage="iDictionary.ContainsKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé à rechercher dans <see cref="T:System.Collections.Generic.IDictionary`2" />.</param>
        <summary>Détermine si <see cref="T:System.Collections.Generic.IDictionary`2" /> contient un élément avec la clé spécifiée.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Collections.Generic.IDictionary`2" /> contient un élément avec la clé ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les implémentations peuvent déterminer l’égalité des objets ; par exemple, le <xref:System.Collections.Generic.List%601> classe utilise <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, tandis que le <xref:System.Collections.Generic.Dictionary%602> classe permet à l’utilisateur de spécifier le <xref:System.Collections.Generic.IComparer%601> implémentation à utiliser pour comparer des clés.  
  
 Les implémentations peuvent varier selon si elles autorisent `key` être `null`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Collections.Generic.IDictionary%602.ContainsKey%2A> méthode pour tester si une clé existe avant d’appeler le <xref:System.Collections.Generic.IDictionary%602.Add%2A> (méthode). Il montre également comment utiliser le <xref:System.Collections.Generic.IDictionary%602.TryGetValue%2A> (méthode), qui peut être un moyen plus efficace pour récupérer des valeurs si un programme essaie souvent des valeurs de clés qui ne sont pas dans le dictionnaire. Enfin, il montre comment insérer des éléments à l’aide de <xref:System.Collections.Generic.IDictionary%602.Item%2A> propriété (l’indexeur en c#).  
  
 Ce code fait partie d’un exemple plus complet qui peut être compilé et exécuté. Consultez <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#6](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#6)]
 [!code-csharp[Generic.IDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#6)]
 [!code-vb[Generic.IDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#6)]  
[!code-cpp[Generic.IDictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#5)]
[!code-csharp[Generic.IDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#5)]
[!code-vb[Generic.IDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#5)]  
[!code-cpp[Generic.IDictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.IDictionary`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TValue default[TKey] { TValue get(TKey key); void set(TKey key, TValue value); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Value with get, set" Usage="System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'élément à obtenir ou définir.</param>
        <summary>Obtient ou définit l'élément à l'aide de la clé spécifiée.</summary>
        <value>Élément correspondant à la clé spécifiée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété permet d’accéder à un élément spécifique dans la collection à l’aide de la syntaxe suivante : `myCollection[key]` (`myCollection(key)` en Visual Basic).  
  
 Vous pouvez également utiliser le <xref:System.Collections.Generic.IDictionary%602.Item%2A> propriété à ajouter de nouveaux éléments en définissant la valeur d’une clé qui n’existe pas dans le dictionnaire ; par exemple, `myCollection["myNonexistentKey"] = myValue` en c# (`myCollection("myNonexistentKey") = myValue` en Visual Basic). Toutefois, si la clé spécifiée existe déjà dans le dictionnaire, la définition du <xref:System.Collections.Generic.IDictionary%602.Item%2A> propriété remplace l’ancienne valeur. En revanche, le <xref:System.Collections.Generic.IDictionary%602.Add%2A> méthode ne modifie pas les éléments existants.  
  
 Les implémentations peuvent déterminer l’égalité des objets ; par exemple, le <xref:System.Collections.Generic.List%601> classe utilise <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, tandis que le <xref:System.Collections.Generic.Dictionary%602> classe permet à l’utilisateur de spécifier le <xref:System.Collections.Generic.IComparer%601> implémentation à utiliser pour comparer des clés.  
  
 Le langage c# utilise le mot clé pour définir les indexeurs au lieu d’implémenter le <xref:System.Collections.Generic.IDictionary%602.Item%2A> propriété. Visual Basic implémente <xref:System.Collections.Generic.IDictionary%602.Item%2A> comme propriété par défaut, ce qui fournit les mêmes fonctionnalités d'indexation.  
  
 Les implémentations peuvent varier selon si elles autorisent `key` être `null`.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Collections.Generic.IDictionary%602.Item%2A> propriété (l’indexeur en c#) pour récupérer des valeurs, ce qui démontre qu’un <xref:System.Collections.Generic.KeyNotFoundException> est levée lorsqu’une clé demandée n’est pas présente et indiquant que la valeur associée à une clé peut être remplacée.  
  
 L’exemple montre également comment utiliser le <xref:System.Collections.Generic.IDictionary%602.TryGetValue%2A> méthode comme un moyen plus efficace pour récupérer des valeurs si un programme doit souvent essayer des valeurs de clés qui ne sont pas dans le dictionnaire.  
  
 Ce code fait partie d’un exemple plus complet qui peut être compilé et exécuté. Consultez <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#3](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#3)]
 [!code-csharp[Generic.IDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#3)]
 [!code-vb[Generic.IDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#3)]  
[!code-cpp[Generic.IDictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#4)]  
[!code-cpp[Generic.IDictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#5)]
[!code-csharp[Generic.IDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#5)]
[!code-vb[Generic.IDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">La propriété est récupérée et <paramref name="key" /> est introuvable.</exception>
        <exception cref="T:System.NotSupportedException">La propriété est définie et <see cref="T:System.Collections.Generic.IDictionary`2" /> est en lecture seule.</exception>
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;TKey&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.IDictionary`2.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;TKey&gt; ^ Keys { System::Collections::Generic::ICollection&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.ICollection&lt;'Key&gt;" Usage="System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt;.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Collections.Generic.ICollection`1" /> contenant les clés de <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
        <value><see cref="T:System.Collections.Generic.ICollection`1" /> contenant les clés de l'objet qui implémente <see cref="T:System.Collections.Generic.IDictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre des clés dans retourné <xref:System.Collections.Generic.ICollection%601> n’est pas spécifié, mais il est garanti pour être le même ordre que les valeurs correspondantes dans le <xref:System.Collections.Generic.ICollection%601> retourné par la <xref:System.Collections.Generic.IDictionary%602.Values%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment énumérer les clés autonome à l’aide de la <xref:System.Collections.Generic.IDictionary%602.Keys%2A> propriété.  
  
 Ce code fait partie d’un exemple plus complet qui peut être compilé et exécuté. Consultez <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#9](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#9)]
 [!code-csharp[Generic.IDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#9)]
 [!code-vb[Generic.IDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.ICollection`1" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.IDictionary`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'Key -&gt; bool" Usage="iDictionary.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'élément à supprimer.</param>
        <summary>Supprime l'élément avec la clé spécifiée d'<see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
        <returns><see langword="true" /> si la suppression de l'élément réussit ; sinon, <see langword="false" />.  Cette méthode retourne également <see langword="false" /> si <paramref name="key" /> est introuvable dans le <see cref="T:System.Collections.Generic.IDictionary`2" /> d'origine.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les implémentations peuvent déterminer l’égalité des objets ; par exemple, le <xref:System.Collections.Generic.List%601> classe utilise <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, tandis que le <xref:System.Collections.Generic.Dictionary%602> classe permet à l’utilisateur de spécifier le <xref:System.Collections.Generic.IComparer%601> implémentation à utiliser pour comparer des clés.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment supprimer une paire clé/valeur à partir d’un dictionnaire à l’aide de la <xref:System.Collections.Generic.IDictionary%602.Remove%2A> (méthode).  
  
 Ce code fait partie d’un exemple plus complet qui peut être compilé et exécuté. Consultez <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#10](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#10)]
 [!code-csharp[Generic.IDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#10)]
 [!code-vb[Generic.IDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.Generic.IDictionary`2" /> est en lecture seule.</exception>
        <altmember cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'Key *  -&gt; bool" Usage="iDictionary.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Clé dont la valeur doit être obtenue.</param>
        <param name="value">Lorsque cette méthode est retournée, la valeur associée à la clé spécifiée, si la clé est trouvée ; sinon, la valeur par défaut pour le type du paramètre <paramref name="value" />. Ce paramètre est passé sans être initialisé.</param>
        <summary>Obtient la valeur associée à la clé spécifiée.</summary>
        <returns><see langword="true" /> si l’objet qui implémente <see cref="T:System.Collections.Generic.IDictionary`2" /> contient un élément correspondant à la clé spécifiée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode combine les fonctionnalités de la <xref:System.Collections.Generic.IDictionary%602.ContainsKey%2A> (méthode) et le <xref:System.Collections.Generic.IDictionary%602.Item%2A> propriété.  
  
 Si la clé est introuvable, la `value` paramètre Obtient la valeur par défaut appropriée pour le type `TValue`; par exemple, zéro (0) pour les types d’entiers, `false` pour les types booléens et `null` pour les types référence.  
  
   
  
## Examples  
 L’exemple montre comment utiliser le <xref:System.Collections.Generic.IDictionary%602.TryGetValue%2A> méthode pour récupérer des valeurs. Si un programme essaie souvent des valeurs de clés qui ne sont pas dans un dictionnaire, la <xref:System.Collections.Generic.IDictionary%602.TryGetValue%2A> méthode peut être plus efficace que l’utilisation de la <xref:System.Collections.Generic.IDictionary%602.Item%2A> propriété (l’indexeur en c#), qui lève des exceptions lorsque vous tentez de récupérer les clés qui n’existe pas.  
  
 Ce code fait partie d’un exemple plus complet qui peut être compilé et exécuté. Consultez <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#5)]
 [!code-csharp[Generic.IDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#5)]
 [!code-vb[Generic.IDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#5)]  
[!code-cpp[Generic.IDictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.IDictionary`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;TValue&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.IDictionary`2.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection(Of TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;TValue&gt; ^ Values { System::Collections::Generic::ICollection&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.ICollection&lt;'Value&gt;" Usage="System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt;.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient <see cref="T:System.Collections.Generic.ICollection`1" /> contenant les valeurs de <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
        <value><see cref="T:System.Collections.Generic.ICollection`1" /> contenant les valeurs de l'objet qui implémente <see cref="T:System.Collections.Generic.IDictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre des valeurs dans la liste retournée <xref:System.Collections.Generic.ICollection%601> n’est pas spécifié, mais il est garanti pour être le même ordre que les clés correspondantes dans le <xref:System.Collections.Generic.ICollection%601> retourné par la <xref:System.Collections.Generic.IDictionary%602.Keys%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment énumérer uniquement à l’aide de valeurs le <xref:System.Collections.Generic.IDictionary%602.Values%2A> propriété.  
  
 Ce code fait partie d’un exemple plus complet qui peut être compilé et exécuté. Consultez <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#8](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#8)]
 [!code-csharp[Generic.IDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#8)]
 [!code-vb[Generic.IDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.ICollection`1" />
      </Docs>
    </Member>
  </Members>
</Type>