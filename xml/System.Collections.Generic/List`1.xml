<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9136a331e3d60d7fbfbdec6c6af6d62811171f34" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52594155" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Type d'éléments de la liste.</typeparam>
    <summary>Représente une liste fortement typée d'objets accessibles par index. Fournit des méthodes de recherche, de tri et de manipulation de listes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.List%601> classe est l’équivalent générique de la <xref:System.Collections.ArrayList> classe. Il implémente la <xref:System.Collections.Generic.IList%601> requis de l’interface générique à l’aide d’un tableau dont la taille est augmentée de manière dynamique.  
  
 Vous pouvez ajouter des éléments à un <xref:System.Collections.Generic.List%601> à l’aide de la <xref:System.Collections.Generic.List%601.Add%2A> ou <xref:System.Collections.Generic.List%601.AddRange%2A> méthodes.  
  
 Le <xref:System.Collections.Generic.List%601> classe utilise un comparateur d’égalité et un comparateur de classement.  
  
-   Méthodes telles que <xref:System.Collections.Generic.List%601.Contains%2A>, <xref:System.Collections.Generic.List%601.IndexOf%2A>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A>, et <xref:System.Collections.Generic.Dictionary%602.Remove%2A> utilisent un comparateur d’égalité pour les éléments de liste. Le comparateur d’égalité par défaut pour le type `T` est déterminé comme suit. Si type `T` implémente le <xref:System.IEquatable%601> interface générique, le comparateur d’égalité est la <xref:System.IEquatable%601.Equals%28%600%29> méthode de cette interface ; sinon, le comparateur d’égalité par défaut est <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.  
  
-   Méthodes telles que <xref:System.Collections.Generic.List%601.BinarySearch%2A> et <xref:System.Collections.Generic.List%601.Sort%2A> utilisent un comparateur de classement pour les éléments de liste. Le comparateur par défaut pour le type `T` est déterminé comme suit.  Si type `T` implémente le <xref:System.IComparable%601> interface générique, le comparateur par défaut est le <xref:System.IComparable%601.CompareTo%28%600%29> méthode de cette interface ; sinon, si type `T` implémente non générique <xref:System.IComparable> interface, puis la valeur par défaut comparateur est le <xref:System.IComparable.CompareTo%28System.Object%29> méthode de cette interface. Si type `T` n’implémente aucune interface, il n’existe aucun comparateur par défaut et un délégué de comparateur de comparaison doit être fourni explicitement.  
  
 Le <xref:System.Collections.Generic.List%601> le tri n’est pas garanti.  Vous devez trier les <xref:System.Collections.Generic.List%601> avant d’effectuer des opérations (telles que <xref:System.Collections.Generic.List%601.BinarySearch%2A>) qui nécessitent le <xref:System.Collections.Generic.List%601> à trier.  
  
 Éléments de cette collection est accessible à l’aide d’un index d’entiers.  Index de cette collection sont de base zéro.  
  
 Pour les très volumineux <xref:System.Collections.Generic.List%601> objets, vous pouvez augmenter la capacité maximale à 2 milliards des éléments sur un système 64 bits en définissant le `enabled` attribut de l’élément de configuration `true` dans l’environnement d’exécution.  
  
 <xref:System.Collections.Generic.List%601> accepte `null` comme une valeur valide pour la référence de types et autorise les éléments en double.  
  
 Pour obtenir une version immuable de le <xref:System.Collections.Generic.List%601> de classe, consultez <xref:System.Collections.Immutable.ImmutableList%601>.  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Afin de décider s’il faut utiliser le <xref:System.Collections.Generic.List%601> ou <xref:System.Collections.ArrayList> (classe), qui ont des fonctionnalités similaires, n’oubliez pas que la <xref:System.Collections.Generic.List%601> classe performant dans la plupart des cas, est de type sécurisé. Si un type référence est utilisé pour le type `T` de la <xref:System.Collections.Generic.List%601> (classe), le comportement des deux classes est identique. Toutefois, si un type valeur est utilisé pour le type `T`, vous devez tenir compte des problèmes d’implémentation et le boxing.  
  
 Si un type valeur est utilisé pour le type `T`, le compilateur génère une implémentation de la <xref:System.Collections.Generic.List%601> classe spécifiquement pour ce type de valeur. Cela signifie qu’un élément de liste d’un <xref:System.Collections.Generic.List%601> objet ne devra pas être converti (boxed) avant que l’élément peut être utilisé, et après environ 500 éléments de liste sont créés la mémoire enregistrée boxing ne pas les éléments de liste est supérieure à la mémoire utilisée pour générer l’implémentation de classe.  
  
 Vérifiez que le type de valeur utilisé pour le type `T` implémente le <xref:System.IEquatable%601> interface générique. Si non, les méthodes telles que <xref:System.Collections.Generic.List%601.Contains%2A> doit appeler le <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> (méthode), qui procède à l’élément de liste affecté. Si le type de valeur implémente la <xref:System.IComparable> interface et que vous possédez le code source, implémentez également la <xref:System.IComparable%601> interface générique pour empêcher le <xref:System.Collections.Generic.List%601.BinarySearch%2A> et <xref:System.Collections.Generic.List%601.Sort%2A> méthodes à partir de la conversion boxing d’éléments de liste. Si vous ne possédez pas le code source, passez un <xref:System.Collections.Generic.IComparer%601> de l’objet à la <xref:System.Collections.Generic.List%601.BinarySearch%2A> et <xref:System.Collections.Generic.List%601.Sort%2A> méthodes  
  
 Il est à votre avantage à utiliser l’implémentation spécifique au type de la <xref:System.Collections.Generic.List%601> classe au lieu d’utiliser la <xref:System.Collections.ArrayList> classe ou écrire vous-même une collection de wrappers fortement typés. La raison est votre implémentation doit faire ce que le .NET Framework fait pour vous déjà, le common language runtime peut partager le code de langage intermédiaire de Microsoft et aux métadonnées qui ne peut pas de votre implémentation.  
  
## <a name="f-considerations"></a>F#Considérations relatives à la  
 Le <xref:System.Collections.Generic.List%601> classe est utilisée rarement dans F# code.  Au lieu de cela, [répertorie](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d), qui sont des listes immuables, liaison unique, sont généralement préférables. Un F# liste fournit une série chronologique et immuable de valeurs et est pris en charge pour une utilisation dans le développement de style fonctionnel. Lorsqu’il est utilisé à partir de F#, le <xref:System.Collections.Generic.List%601> classe est généralement appelée par le [ResizeArray\<' t >](https://msdn.microsoft.com/library/ee353447.aspx) abréviation afin d’éviter les conflits de nom avec de type F# répertorie  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter, supprimer et insérer un objet métier simple dans un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 L’exemple suivant montre plusieurs propriétés et méthodes de la <xref:System.Collections.Generic.List%601> classe générique de type chaîne. (Pour obtenir un exemple d’un <xref:System.Collections.Generic.List%601> de types complexes, consultez le <xref:System.Collections.Generic.List%601.Contains%2A> méthode.)  
  
 Le constructeur par défaut est utilisé pour créer une liste de chaînes avec la capacité par défaut. Le <xref:System.Collections.Generic.List%601.Capacity%2A> propriété s’affiche, puis le <xref:System.Collections.Generic.List%601.Add%2A> méthode est utilisée pour ajouter plusieurs éléments. Les éléments sont répertoriés et la <xref:System.Collections.Generic.List%601.Capacity%2A> propriété s’affiche à nouveau, avec le <xref:System.Collections.Generic.List%601.Count%2A> propriété, pour indiquer que la capacité a été augmentée en fonction des besoins.  
  
 Le <xref:System.Collections.Generic.List%601.Contains%2A> méthode est utilisée pour tester la présence d’un élément dans la liste, le <xref:System.Collections.Generic.List%601.Insert%2A> méthode est utilisée pour insérer un nouvel élément au milieu de la liste, et le contenu de la liste s’affiche à nouveau.  
  
 La valeur par défaut <xref:System.Collections.Generic.List%601.Item%2A> propriété (l’indexeur en c#) est utilisée pour récupérer un élément, le <xref:System.Collections.Generic.List%601.Remove%2A> méthode est utilisée pour supprimer la première instance de l’élément dupliqué ajouté précédemment, et le contenu s’affiche à nouveau. Le <xref:System.Collections.Generic.List%601.Remove%2A> méthode supprime toujours la première instance qu’il rencontre.  
  
 Le <xref:System.Collections.Generic.List%601.TrimExcess%2A> méthode est utilisée pour réduire la capacité à correspondre au nombre et le <xref:System.Collections.Generic.List%601.Capacity%2A> et <xref:System.Collections.Generic.List%601.Count%2A> propriétés sont affichées. Si la capacité inutilisée avait été inférieure à 10 % de la capacité totale, la liste n’aurait pas été redimensionnée.  
  
 Enfin, le <xref:System.Collections.Generic.List%601.Clear%2A> méthode est utilisée pour supprimer tous les éléments dans la liste et le <xref:System.Collections.Generic.List%601.Capacity%2A> et <xref:System.Collections.Generic.List%601.Count%2A> propriétés sont affichées.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>Statique public (<see langword="Shared" /> en Visual Basic) de ce type sont thread-safe. Il n'est pas garanti que les membres d'instance soient thread-safe.  
  
Il est déconseillé d’effectuer plusieurs opérations de lecture sur un <see cref="T:System.Collections.Generic.List`1" />, mais les problèmes peuvent se produire si la collection est modifiée alors qu’il est en cours de lecture. Pour garantir la cohérence de thread, verrouiller la collection pendant une lecture ou l’opération d’écriture. Pour activer une collection accessible par plusieurs threads pour lire et écrire, vous devez implémenter votre propre synchronisation. Pour les collections avec synchronisation incorporée, consultez les classes dans le <see cref="N:System.Collections.Concurrent" /> espace de noms. Pour une alternative thread-safe, consultez la <see cref="T:System.Collections.Immutable.ImmutableList`1" /> classe.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">Itérateurs (C# et Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.List`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.List`1" /> qui est vide et possède la capacité initiale par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité d’un <xref:System.Collections.Generic.List%601> est le nombre d’éléments qui le <xref:System.Collections.Generic.List%601> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.Generic.List%601>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée à l’aide de la <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> constructeur et en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Generic.List%601>.  
  
 La capacité peut être diminuée en appelant le <xref:System.Collections.Generic.List%601.TrimExcess%2A> méthode ou en définissant le <xref:System.Collections.Generic.List%601.Capacity%2A> propriété explicitement. Réduction de la capacité réalloue la mémoire et copie tous les éléments dans le <xref:System.Collections.Generic.List%601>.  
  
 Ce constructeur est une opération o (1).  
  
   
  
## Examples  
 L’exemple suivant montre le constructeur par défaut de la <xref:System.Collections.Generic.List%601> classe générique. Le constructeur par défaut crée une liste avec la capacité par défaut, comme indiqué en affichant la <xref:System.Collections.Generic.List%601.Capacity%2A> propriété.  
  
 L’exemple ajoute, insère et supprime des éléments en montrant comment la capacité change à mesure que ces méthodes sont utilisées.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Collection dont les éléments sont copiés dans la nouvelle liste.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.List`1" /> qui contient des éléments copiés à partir de la collection spécifiée et qui possède une capacité suffisante pour accepter le nombre d’éléments copiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments sont copiés dans le <xref:System.Collections.Generic.List%601> dans le même ordre qu’ils sont lus par l’énumérateur de la collection.  
  
 Ce constructeur est un O (*n*) opération, où *n* est le nombre d’éléments dans `collection`.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.%23ctor%2A> constructeur et diverses méthodes de la <xref:System.Collections.Generic.List%601> classe qui agissent sur les plages. Un tableau de chaînes est créé et passé au constructeur, remplissage de la liste avec les éléments du tableau. Le <xref:System.Collections.Generic.List%601.Capacity%2A> propriété s’affiche ensuite pour indiquer que la capacité initiale est exactement ce qui est nécessaire pour contenir les éléments d’entrée.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Nombre d'éléments que la nouvelle liste peut initialement stocker.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.List`1" /> qui est vide et a la capacité initiale spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacité d’un <xref:System.Collections.Generic.List%601> est le nombre d’éléments qui le <xref:System.Collections.Generic.List%601> peut contenir. Comme les éléments sont ajoutés à un <xref:System.Collections.Generic.List%601>, la capacité est augmentée automatiquement selon les besoins en réallouant le tableau interne.  
  
 Si la taille de la collection peut être estimée, en spécifiant la capacité initiale évite de devoir effectuer un certain nombre d’opérations de redimensionnement lors de l’ajout d’éléments à la <xref:System.Collections.Generic.List%601>.  
  
 La capacité peut être diminuée en appelant le <xref:System.Collections.Generic.List%601.TrimExcess%2A> méthode ou en définissant le <xref:System.Collections.Generic.List%601.Capacity%2A> propriété explicitement. Réduction de la capacité réalloue la mémoire et copie tous les éléments dans le <xref:System.Collections.Generic.List%601>.  
  
 Ce constructeur est un O (*n*) opération, où *n* est `capacity`.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> constructeur. Un <xref:System.Collections.Generic.List%601> de chaînes avec une capacité de 4 est créé, parce que la dernière taille de la liste doit être exactement de 4. La liste est remplie avec quatre chaînes, et une copie en lecture seule est créée à l’aide de la <xref:System.Collections.Generic.List%601.AsReadOnly%2A> (méthode).  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> est inférieur à 0.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="list.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objet à ajouter à la fin de <see cref="T:System.Collections.Generic.List`1" />. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <summary>Ajoute un objet à la fin de la <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accepte `null` comme une valeur valide pour la référence de types et autorise les éléments en double.  
  
 Si <xref:System.Collections.Generic.List%601.Count%2A> est déjà égale à <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacité de la <xref:System.Collections.Generic.List%601> est augmentée en réallouant automatiquement le tableau interne, et les éléments existants sont copiés vers le nouveau tableau avant le nouvel élément est ajouté.  
  
 Si <xref:System.Collections.Generic.List%601.Count%2A> est inférieure à <xref:System.Collections.Generic.List%601.Capacity%2A>, cette méthode est une opération o (1). Si la capacité doit être augmentée pour intégrer un nouvel élément, cette méthode devient un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter, supprimer et insérer un objet métier simple dans un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 L’exemple suivant montre plusieurs propriétés et méthodes de la <xref:System.Collections.Generic.List%601> classe générique, y compris le <xref:System.Collections.Generic.List%601.Add%2A> (méthode). Le constructeur par défaut est utilisé pour créer une liste de chaînes avec une capacité de 0. Le <xref:System.Collections.Generic.List%601.Capacity%2A> propriété s’affiche, puis le <xref:System.Collections.Generic.List%601.Add%2A> méthode est utilisée pour ajouter plusieurs éléments. Les éléments sont répertoriés et la <xref:System.Collections.Generic.List%601.Capacity%2A> propriété s’affiche à nouveau, avec le <xref:System.Collections.Generic.List%601.Count%2A> propriété, pour indiquer que la capacité a été augmentée en fonction des besoins.  
  
 Autres propriétés et méthodes permettent de rechercher, insérer et supprimer des éléments dans la liste et enfin d’effacer la liste.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;'T&gt; -&gt; unit" Usage="list.AddRange collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Collection dont les éléments devraient être ajoutés à la fin de <see cref="T:System.Collections.Generic.List`1" />. La collection elle-même ne peut pas avoir la valeur <see langword="null" />, mais elle peut contenir des éléments qui sont <see langword="null" />, si le type <paramref name="T" /> est un type référence.</param>
        <summary>Ajoute les éléments de la collection spécifiée à la fin de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre des éléments dans la collection est conservé dans le <xref:System.Collections.Generic.List%601>.  
  
 Si la nouvelle <xref:System.Collections.Generic.List%601.Count%2A> (actuel <xref:System.Collections.Generic.List%601.Count%2A> plus la taille de la collection) sera supérieur à <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacité de la <xref:System.Collections.Generic.List%601> est augmentée en réallouant automatiquement le tableau interne pour prendre en compte les nouveaux éléments et le éléments existants sont copiés vers le nouveau tableau avant que les nouveaux éléments sont ajoutés.  
  
 Si le <xref:System.Collections.Generic.List%601> peut prendre en charge les nouveaux éléments sans augmenter la <xref:System.Collections.Generic.List%601.Capacity%2A>, cette méthode est un O (*n*) opération, où *n* est le nombre d’éléments à ajouter. Si la capacité doit être augmentée pour intégrer les nouveaux éléments, cette méthode devient un O (*n* + *m*) opération, où *n* est le nombre d’éléments doit être ajouté et *m* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.AddRange%2A> (méthode) et diverses autres méthodes de la <xref:System.Collections.Generic.List%601> classe qui agissent sur les plages. Un tableau de chaînes est créé et passé au constructeur, remplissage de la liste avec les éléments du tableau. Le <xref:System.Collections.Generic.List%601.AddRange%2A> méthode est appelée, avec la liste en tant que son argument. Le résultat est que les éléments en cours de la liste sont ajoutés à la fin de la liste, la duplication de tous les éléments.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.AsReadOnly : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="list.AsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un wrapper <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> en lecture seule pour la collection actuelle.</summary>
        <returns>Objet qui joue le rôle de wrapper en lecture seule autour du <see cref="T:System.Collections.Generic.List`1" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour empêcher toute modification apportée à la <xref:System.Collections.Generic.List%601> de l’objet, il expose uniquement par le biais de ce wrapper. Un <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> objet n’expose pas de méthodes qui modifient la collection. Toutefois, si des modifications sont apportées à sous-jacent <xref:System.Collections.Generic.List%601> de l’objet, la collection en lecture seule reflète ces modifications.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.AsReadOnly%2A> (méthode). Un <xref:System.Collections.Generic.List%601> de chaînes avec une capacité de 4 est créé, parce que la dernière taille de la liste doit être exactement de 4. La liste est remplie avec quatre chaînes et le <xref:System.Collections.Generic.List%601.AsReadOnly%2A> méthode est utilisée pour obtenir en lecture seule <xref:System.Collections.Generic.IList%601> implémentation d’interface générique qui encapsule la liste d’origine.  
  
 Un élément de la liste d’origine est défini sur « Coelophysis » à l’aide de la <xref:System.Collections.Generic.List%601.Item%2A> propriété (l’indexeur en c#) et le contenu de la liste en lecture seule s’affichent de nouveau pour montrer qu’il est simplement un wrapper pour la liste d’origine.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Utilise un algorithme de recherche binaire pour trouver un élément spécifique dans le <see cref="T:System.Collections.Generic.List`1" /> trié ou une partie de celui-ci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T -&gt; int" Usage="list.BinarySearch item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objet à trouver. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <summary>Recherche un élément utilisant le comparateur par défaut dans le <see cref="T:System.Collections.Generic.List`1" /> entièrement trié et retourne l'index de base zéro de l'élément.</summary>
        <returns>Index de base zéro de <paramref name="item" /> dans le <see cref="T:System.Collections.Generic.List`1" /> trié, si <paramref name="item" /> existe ; sinon, un nombre négatif qui est le complément de bits de l'index de l'élément suivant supérieur à <paramref name="item" /> ou, s'il n'existe aucun élément supérieur, le complément de bits de <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise le comparateur par défaut <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> pour le type `T` pour déterminer l’ordre des éléments de liste. Le <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> propriété vérifie si le type `T` implémente le <xref:System.IComparable%601> interface générique et utilise cette implémentation, le cas échéant.  Si ce n’est pas le cas, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type `T` implémente le <xref:System.IComparable> interface.  Si type `T` n’implémente pas ces deux interfaces, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lève une <xref:System.InvalidOperationException>.  
  
 Le <xref:System.Collections.Generic.List%601> doit déjà être triée selon l’implémentation du comparateur ; sinon, le résultat est incorrect.  
  
 Comparaison `null` avec toute référence de type est autorisé et ne génère pas d’exception lorsque vous utilisez le <xref:System.IComparable%601> interface générique. Lors du tri, `null` est considéré comme étant inférieure à n’importe quel autre objet.  
  
 Si le <xref:System.Collections.Generic.List%601> contient plusieurs éléments avec la même valeur, la méthode retourne uniquement les occurrences, et il peut retourner l’une des occurrences, pas nécessairement le.  
  
 Si le <xref:System.Collections.Generic.List%601> ne contient pas la valeur spécifiée, la méthode retourne un entier négatif. Vous pouvez appliquer l’opération de complément de bits (~) à cet entier négatif pour obtenir l’index du premier élément qui est supérieure à la valeur de recherche. Lors de l’insertion de la valeur dans la <xref:System.Collections.Generic.List%601>, cet index doit être utilisé en tant que le point d’insertion pour conserver l’ordre de tri.  
  
 Cette méthode est un O (log *n*) opération, où *n* est le nombre d’éléments dans la plage.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.Sort> surcharge de méthode et la <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> surcharge de méthode. Un <xref:System.Collections.Generic.List%601> de chaînes est créé et rempli avec quatre chaînes, dans aucun ordre particulier. La liste est affichée, triée et affiche à nouveau.  
  
 Le <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> surcharge de méthode est ensuite utilisée pour rechercher des deux chaînes qui ne sont pas dans la liste, et le <xref:System.Collections.Generic.List%601.Insert%2A> méthode est utilisée pour les insérer. La valeur de retour de la <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> méthode est négative dans chaque cas, étant donné que les chaînes ne sont pas dans la liste. En prenant le complément de bits (le ~ opérateur en c# et Visual C++, `Xor` -1 en Visual Basic) de ce nombre négatif génère l’index du premier élément dans la liste qui est supérieure à la chaîne de recherche et l’insertion à cet emplacement conserve l’ordre de tri ordre. La deuxième chaîne de recherche est supérieure à n’importe quel élément dans la liste, par conséquent, la position d’insertion est à la fin de la liste.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le comparateur par défaut <see cref="P:System.Collections.Generic.Comparer`1.Default" /> ne peut pas trouver une implémentation de l’interface générique <see cref="T:System.IComparable`1" /> ou de l’interface <see cref="T:System.IComparable" /> pour le type <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Objet à trouver. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.Generic.IComparer`1" /> à utiliser pendant la comparaison d'éléments.  
  
- ou - 
 <see langword="null" /> pour utiliser le comparateur par défaut <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Recherche un élément utilisant le comparateur spécifié dans le <see cref="T:System.Collections.Generic.List`1" /> entièrement trié et retourne l'index de base zéro de l'élément.</summary>
        <returns>Index de base zéro de <paramref name="item" /> dans le <see cref="T:System.Collections.Generic.List`1" /> trié, si <paramref name="item" /> existe ; sinon, un nombre négatif qui est le complément de bits de l'index de l'élément suivant supérieur à <paramref name="item" /> ou, s'il n'existe aucun élément supérieur, le complément de bits de <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comparateur personnalise la manière dont les éléments sont comparés. Par exemple, vous pouvez utiliser un <xref:System.Collections.CaseInsensitiveComparer> instance en tant que comparateur pour effectuer des recherches de chaîne de non-respect de la casse.  
  
 Si `comparer` est fourni, les éléments de la <xref:System.Collections.Generic.List%601> sont comparées à la valeur spécifiée à l’aide de la <xref:System.Collections.Generic.IComparer%601> implémentation.  
  
 Si `comparer` est `null`, le comparateur par défaut <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type `T` implémente le <xref:System.IComparable%601> interface générique et utilise cette implémentation, le cas échéant.  Si ce n’est pas le cas, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type `T` implémente le <xref:System.IComparable> interface.  Si type `T` n’implémente pas ces deux interfaces, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lève <xref:System.InvalidOperationException>.  
  
 Le <xref:System.Collections.Generic.List%601> doit déjà être triée selon l’implémentation du comparateur ; sinon, le résultat est incorrect.  
  
 Comparaison `null` avec toute référence de type est autorisé et ne génère pas d’exception lorsque vous utilisez le <xref:System.IComparable%601> interface générique. Lors du tri, `null` est considéré comme étant inférieure à n’importe quel autre objet.  
  
 Si le <xref:System.Collections.Generic.List%601> contient plusieurs éléments avec la même valeur, la méthode retourne uniquement les occurrences, et il peut retourner l’une des occurrences, pas nécessairement le.  
  
 Si le <xref:System.Collections.Generic.List%601> ne contient pas la valeur spécifiée, la méthode retourne un entier négatif. Vous pouvez appliquer l’opération de complément de bits (~) à cet entier négatif pour obtenir l’index du premier élément qui est supérieure à la valeur de recherche. Lors de l’insertion de la valeur dans la <xref:System.Collections.Generic.List%601>, cet index doit être utilisé en tant que le point d’insertion pour conserver l’ordre de tri.  
  
 Cette méthode est un O (log *n*) opération, où *n* est le nombre d’éléments dans la plage.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> surcharge de méthode et la <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> surcharge de méthode.  
  
 L’exemple définit un autre comparateur pour les chaînes nommées DinoCompare, qui implémente le `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` dans Visual C++) interface générique. Le comparateur fonctionne comme suit : tout d’abord, les comparateurs sont testés pour `null`, et une référence null est considérée comme inférieure à une valeur non null. Deuxièmement, les longueurs de chaîne sont comparées, et la plus longue chaîne est jugée supérieure. Troisièmement, si les longueurs sont égales, la comparaison de chaînes ordinaire est utilisée.  
  
 Un <xref:System.Collections.Generic.List%601> de chaînes est créé et rempli avec quatre chaînes, dans aucun ordre particulier. La liste est affichée, triée à l’aide de l’autre comparateur et s’affichent à nouveau.  
  
 Le <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> surcharge de méthode est ensuite utilisée pour rechercher de nombreuses chaînes qui ne figurent pas dans la liste, par le biais de l’autre comparateur. Le <xref:System.Collections.Generic.List%601.Insert%2A> méthode est utilisée pour insérer les chaînes. Ces deux méthodes sont situés dans la fonction nommée `SearchAndInsert`, ainsi que du code pour prendre le complément au niveau du bit (le ~ opérateur en c# et Visual C++, `Xor` -1 en Visual Basic) du nombre négatif retourné par <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> et utilisez-la en tant qu’index pour Insérer la nouvelle chaîne.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> est <see langword="null" />, et le comparateur par défaut <see cref="P:System.Collections.Generic.Comparer`1.Default" /> ne peut pas trouver une implémentation de l’interface générique <see cref="T:System.IComparable`1" /> ou de l’interface <see cref="T:System.IComparable" /> pour le type <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (index, count, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Index de début de base zéro de la plage dans laquelle effectuer la recherche.</param>
        <param name="count">Longueur de la plage dans laquelle effectuer la recherche.</param>
        <param name="item">Objet à trouver. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.Generic.IComparer`1" /> à utiliser pendant la comparaison d'éléments, ou <see langword="null" /> pour utiliser le comparateur par défaut <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Recherche un élément utilisant le comparateur spécifié dans une plage d'éléments du <see cref="T:System.Collections.Generic.List`1" /> trié et retourne l'index de base zéro de l'élément.</summary>
        <returns>Index de base zéro de <paramref name="item" /> dans le <see cref="T:System.Collections.Generic.List`1" /> trié, si <paramref name="item" /> existe ; sinon, un nombre négatif qui est le complément de bits de l'index de l'élément suivant supérieur à <paramref name="item" /> ou, s'il n'existe aucun élément supérieur, le complément de bits de <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comparateur personnalise la manière dont les éléments sont comparés. Par exemple, vous pouvez utiliser un <xref:System.Collections.CaseInsensitiveComparer> instance en tant que comparateur pour effectuer des recherches de chaîne de non-respect de la casse.  
  
 Si `comparer` est fourni, les éléments de la <xref:System.Collections.Generic.List%601> sont comparées à la valeur spécifiée à l’aide de la <xref:System.Collections.Generic.IComparer%601> implémentation.  
  
 Si `comparer` est `null`, le comparateur par défaut <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type `T` implémente le <xref:System.IComparable%601> interface générique et utilise cette implémentation, le cas échéant.  Si ce n’est pas le cas, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type `T` implémente le <xref:System.IComparable> interface.  Si type `T` n’implémente pas ces deux interfaces, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lève <xref:System.InvalidOperationException>.  
  
 Le <xref:System.Collections.Generic.List%601> doit déjà être triée selon l’implémentation du comparateur ; sinon, le résultat est incorrect.  
  
 Comparaison `null` avec toute référence de type est autorisé et ne génère pas d’exception lorsque vous utilisez le <xref:System.IComparable%601> interface générique. Lors du tri, `null` est considéré comme étant inférieure à n’importe quel autre objet.  
  
 Si le <xref:System.Collections.Generic.List%601> contient plusieurs éléments avec la même valeur, la méthode retourne uniquement les occurrences, et il peut retourner l’une des occurrences, pas nécessairement le.  
  
 Si le <xref:System.Collections.Generic.List%601> ne contient pas la valeur spécifiée, la méthode retourne un entier négatif. Vous pouvez appliquer l’opération de complément de bits (~) à cet entier négatif pour obtenir l’index du premier élément qui est supérieure à la valeur de recherche. Lors de l’insertion de la valeur dans la <xref:System.Collections.Generic.List%601>, cet index doit être utilisé en tant que le point d’insertion pour conserver l’ordre de tri.  
  
 Cette méthode est un O (log *n*) opération, où *n* est le nombre d’éléments dans la plage.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> surcharge de méthode et la <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> surcharge de méthode.  
  
 L’exemple définit un autre comparateur pour les chaînes nommées DinoCompare, qui implémente le `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` dans Visual C++) interface générique. Le comparateur fonctionne comme suit : tout d’abord, les comparateurs sont testés pour `null`, et une référence null est considérée comme inférieure à une valeur non null. Deuxièmement, les longueurs de chaîne sont comparées, et la plus longue chaîne est jugée supérieure. Troisièmement, si les longueurs sont égales, la comparaison de chaînes ordinaire est utilisée.  
  
 Un <xref:System.Collections.Generic.List%601> de chaînes est créé et rempli avec les noms des cinq dinosaures et trois dinosaures carnivores. Dans chacun des deux groupes, les noms ne sont pas dans n’importe quel ordre de tri particulier. La liste est affichée, la plage d’herbivores est triée à l’aide de l’autre comparateur, et la liste s’affiche à nouveau.  
  
 Le <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> surcharge de méthode est ensuite utilisée pour rechercher uniquement la plage d’herbivores correspondant à « Brachiosaure ». La chaîne est introuvable et le complément de bits (le ~ opérateur en c# et Visual C++, `Xor` -1 en Visual Basic) du nombre négatif retourné par la <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> méthode est utilisée en tant qu’index pour insérer la nouvelle chaîne.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à 0.  
  
- ou - 
 <paramref name="count" /> est inférieur à 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> est <see langword="null" />, et le comparateur par défaut <see cref="P:System.Collections.Generic.Comparer`1.Default" /> ne peut pas trouver une implémentation de l’interface générique <see cref="T:System.IComparable`1" /> ou de l’interface <see cref="T:System.IComparable" /> pour le type <paramref name="T" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre total des éléments que la structure de données interne peut contenir sans redimensionnement.</summary>
        <value>Nombre d'éléments que <see cref="T:System.Collections.Generic.List`1" /> peut contenir avant que le redimensionnement soit nécessaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> est le nombre d’éléments qui le <xref:System.Collections.Generic.List%601> peut stocker avant que le redimensionnement soit nécessaire, alors que <xref:System.Collections.Generic.List%601.Count%2A> est le nombre d’éléments réellement contenus dans le <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> est toujours supérieur ou égal à <xref:System.Collections.Generic.List%601.Count%2A>. Si <xref:System.Collections.Generic.List%601.Count%2A> dépasse <xref:System.Collections.Generic.List%601.Capacity%2A> lors de l’ajout d’éléments, la capacité est augmentée en réallouant automatiquement le tableau interne avant de copier les anciens éléments et d’ajouter les nouveaux éléments.  
  
 Si la capacité est beaucoup plus important que le nombre et que vous souhaitez réduire la mémoire utilisée par le <xref:System.Collections.Generic.List%601>, vous pouvez diminuer la capacité en appelant le <xref:System.Collections.Generic.List%601.TrimExcess%2A> méthode ou en définissant le <xref:System.Collections.Generic.List%601.Capacity%2A> propriété explicitement à une valeur inférieure. Lorsque la valeur de <xref:System.Collections.Generic.List%601.Capacity%2A> est défini explicitement, le tableau interne est également réalloué pour prendre en charge de la capacité spécifiée et tous les éléments sont copiés.  
  
 Récupération de la valeur de cette propriété est une opération o (1) ; définition de la propriété est un O (*n*) opération, où *n* est la nouvelle capacité.  
  
   
  
## Examples  
 L’exemple suivant montre comment vérifier la capacité et le nombre d’un <xref:System.Collections.Generic.List%601> qui contient un objet métier simple et illustre l’utilisation de la <xref:System.Collections.Generic.List%601.TrimExcess%2A> méthode pour supprimer une capacité supplémentaire.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.Capacity%2A> propriété à différents points dans la durée de vie d’une liste. Le constructeur par défaut est utilisé pour créer une liste de chaînes avec une capacité de 0 et le <xref:System.Collections.Generic.List%601.Capacity%2A> propriété s’affiche pour illustrer ce point. Après le <xref:System.Collections.Generic.List%601.Add%2A> méthode a été utilisée pour ajouter plusieurs éléments, les éléments sont répertoriés, puis le <xref:System.Collections.Generic.List%601.Capacity%2A> propriété s’affiche à nouveau, avec le <xref:System.Collections.Generic.List%601.Count%2A> propriété, pour indiquer que la capacité a été augmentée en fonction des besoins.  
  
 Le <xref:System.Collections.Generic.List%601.Capacity%2A> propriété s’affiche à nouveau une fois la <xref:System.Collections.Generic.List%601.TrimExcess%2A> méthode est utilisée pour réduire la capacité à correspondre au nombre. Enfin, le <xref:System.Collections.Generic.List%601.Clear%2A> méthode est utilisée pour supprimer tous les éléments dans la liste et le <xref:System.Collections.Generic.List%601.Capacity%2A> et <xref:System.Collections.Generic.List%601.Count%2A> propriétés s’affichent à nouveau.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur affectée à <see cref="P:System.Collections.Generic.List`1.Capacity" /> est inférieure à <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n’y a pas assez de mémoire disponible sur le système.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="list.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les éléments de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> est définie sur 0, et les références à d’autres objets à partir des éléments de la collection sont également libérées.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> reste inchangé. Pour rétablir la capacité de la <xref:System.Collections.Generic.List%601>, appelez le <xref:System.Collections.Generic.List%601.TrimExcess%2A> méthode ou un ensemble la <xref:System.Collections.Generic.List%601.Capacity%2A> propriété directement. Réduction de la capacité réalloue la mémoire et copie tous les éléments dans le <xref:System.Collections.Generic.List%601>. Suppression vide <xref:System.Collections.Generic.List%601> définit la capacité de la <xref:System.Collections.Generic.List%601> à la capacité par défaut.  
  
 Cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.Clear%2A> (méthode) et diverses autres propriétés et méthodes de la <xref:System.Collections.Generic.List%601> classe générique. Le <xref:System.Collections.Generic.List%601.Clear%2A> méthode est utilisée à la fin du programme, pour supprimer tous les éléments dans la liste et le <xref:System.Collections.Generic.List%601.Capacity%2A> et <xref:System.Collections.Generic.List%601.Count%2A> propriétés sont ensuite affichées.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="list.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objet à rechercher dans <see cref="T:System.Collections.Generic.List`1" />. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <summary>Détermine si le <see cref="T:System.Collections.Generic.List`1" /> contient un élément.</summary>
        <returns>
          <see langword="true" /> si <paramref name="item" /> existe dans <see cref="T:System.Collections.Generic.List`1" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine l’égalité à l’aide du comparateur d’égalité par défaut, comme défini par l’implémentation de l’objet de la <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> méthode pour `T` (le type de valeurs dans la liste).  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.Contains%2A> et <xref:System.Collections.Generic.List%601.Exists%2A> méthodes sur un <xref:System.Collections.Generic.List%601> qui contient un objet métier simple qui implémente <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 L’exemple suivant contient une liste d’objets complexes de type `Cube`. Le `Cube` la classe implémente la <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> méthode afin que les deux cubes sont considérées comme égales si leurs dimensions sont les mêmes. Dans cet exemple, le <xref:System.Collections.Generic.List%601.Contains%2A> méthode retourne `true`, car un cube qui possède les dimensions spécifiées est déjà dans la collection.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="member this.ConvertAll : Converter&lt;'T, 'Output&gt; -&gt; System.Collections.Generic.List&lt;'Output&gt;" Usage="list.ConvertAll converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Type des éléments du tableau cible.</typeparam>
        <param name="converter">Délégué <see cref="T:System.Converter`2" /> qui convertit chaque élément d'un type vers un autre.</param>
        <summary>Convertit les éléments du <see cref="T:System.Collections.Generic.List`1" /> actuel dans un autre type et retourne une liste qui contient les éléments convertis.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.List`1" /> du type cible contenant les éléments convertis du <see cref="T:System.Collections.Generic.List`1" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Converter%602> est un délégué à une méthode qui convertit un objet vers le type cible.  Les éléments de l’actuel <xref:System.Collections.Generic.List%601> sont passés à la <xref:System.Converter%602> délégué et les éléments convertis sont enregistrés dans le nouveau <xref:System.Collections.Generic.List%601>.  
  
 Actuel <xref:System.Collections.Generic.List%601> reste inchangé.  
  
 Cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant définit une méthode nommée `PointFToPoint` qui convertit un <xref:System.Drawing.PointF> structure un <xref:System.Drawing.Point> structure. L’exemple crée ensuite un <xref:System.Collections.Generic.List%601> de <xref:System.Drawing.PointF> structures, crée un `Converter\<PointF, Point>` déléguer (`Converter(Of PointF, Point)` en Visual Basic) pour représenter le `PointFToPoint` (méthode) et passe le délégué à la <xref:System.Collections.Generic.List%601.ConvertAll%2A> (méthode). Le <xref:System.Collections.Generic.List%601.ConvertAll%2A> méthode passe chaque élément de la liste d’entrée à la `PointFToPoint` (méthode) et met les éléments convertis dans une nouvelle liste de <xref:System.Drawing.Point> structures. Les deux listes sont affichées.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="converter" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie <see cref="T:System.Collections.Generic.List`1" /> ou une partie de celui-ci dans un tableau.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="list.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Collections.Generic.List`1" />. <see cref="T:System.Array" /> doit avoir une indexation de base zéro.</param>
        <summary>Copie l'ensemble du <see cref="T:System.Collections.Generic.List`1" /> dans un tableau compatible unidimensionnel en partant du début du tableau cible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise <xref:System.Array.Copy%2A?displayProperty=nameWithType> pour copier les éléments.  
  
 Les éléments sont copiés dans le <xref:System.Array> dans le même ordre que celui dans lequel l’énumérateur itère au sein du <xref:System.Collections.Generic.List%601>.  
  
 Cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant illustre les trois surcharges de la <xref:System.Collections.Generic.List%601.CopyTo%2A> (méthode). Un <xref:System.Collections.Generic.List%601> de chaînes est créé et rempli avec 5 chaînes. Un tableau de chaînes vide de 15 éléments est créé et le <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> surcharge de méthode est utilisée pour copier tous les éléments de la liste dans le tableau en commençant au premier élément du tableau. Le <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> surcharge de méthode est utilisée pour copier tous les éléments de la liste dans le tableau en commençant à l’index de tableau 6 (laissant l’index 5 vide). Enfin, le <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour copier 3 éléments dans la liste, en commençant par l’index 2, dans le tableau en commençant à l’index 12 (laissant l’index 11 vide). Le contenu du tableau est ensuite affiché.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nombre d’éléments du <see cref="T:System.Collections.Generic.List`1" /> source est supérieur au nombre d’éléments que la destination <paramref name="array" /> peut contenir.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="list.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Collections.Generic.List`1" />. Le <see cref="T:System.Array" /> doit avoir une indexation de base zéro.</param>
        <param name="arrayIndex">Index de base zéro dans l'<paramref name="array" /> à partir duquel la copie commence.</param>
        <summary>Copie l'ensemble du <see cref="T:System.Collections.Generic.List`1" /> dans un tableau compatible unidimensionnel en partant de l'index spécifié du tableau cible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise <xref:System.Array.Copy%2A?displayProperty=nameWithType> pour copier les éléments.  
  
 Les éléments sont copiés dans le <xref:System.Array> dans le même ordre que celui dans lequel l’énumérateur itère au sein du <xref:System.Collections.Generic.List%601>.  
  
 Cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant illustre les trois surcharges de la <xref:System.Collections.Generic.List%601.CopyTo%2A> (méthode). Un <xref:System.Collections.Generic.List%601> de chaînes est créé et rempli avec 5 chaînes. Un tableau de chaînes vide de 15 éléments est créé et le <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> surcharge de méthode est utilisée pour copier tous les éléments de la liste dans le tableau en commençant au premier élément du tableau. Le <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> surcharge de méthode est utilisée pour copier tous les éléments de la liste dans le tableau en commençant à l’index de tableau 6 (laissant l’index 5 vide). Enfin, le <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour copier 3 éléments dans la liste, en commençant par l’index 2, dans le tableau en commençant à l’index 12 (laissant l’index 11 vide). Le contenu du tableau est ensuite affiché.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> est inférieur à 0.</exception>
        <exception cref="T:System.ArgumentException">Le nombre d’éléments dans le <see cref="T:System.Collections.Generic.List`1" /> source est supérieur à la quantité d’espace disponible entre <paramref name="arrayIndex" /> et la fin du <paramref name="array" /> de destination.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * 'T[] * int * int -&gt; unit" Usage="list.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro dans le <see cref="T:System.Collections.Generic.List`1" /> source au niveau duquel la copie commence.</param>
        <param name="array">
          <see cref="T:System.Array" /> unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Collections.Generic.List`1" />. Le <see cref="T:System.Array" /> doit avoir une indexation de base zéro.</param>
        <param name="arrayIndex">Index de base zéro dans l'<paramref name="array" /> à partir duquel la copie commence.</param>
        <param name="count">Nombre d'éléments à copier.</param>
        <summary>Copie une plage d'éléments de <see cref="T:System.Collections.Generic.List`1" /> dans un tableau compatible unidimensionnel en partant de l'index spécifié du tableau cible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise <xref:System.Array.Copy%2A?displayProperty=nameWithType> pour copier les éléments.  
  
 Les éléments sont copiés dans le <xref:System.Array> dans le même ordre que celui dans lequel l’énumérateur itère au sein du <xref:System.Collections.Generic.List%601>.  
  
 Cette méthode est un O (*n*) opération, où *n* est `count`.  
  
   
  
## Examples  
 L’exemple suivant illustre les trois surcharges de la <xref:System.Collections.Generic.List%601.CopyTo%2A> (méthode). Un <xref:System.Collections.Generic.List%601> de chaînes est créé et rempli avec 5 chaînes. Un tableau de chaînes vide de 15 éléments est créé et le <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> surcharge de méthode est utilisée pour copier tous les éléments de la liste dans le tableau en commençant au premier élément du tableau. Le <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> surcharge de méthode est utilisée pour copier tous les éléments de la liste dans le tableau en commençant à l’index de tableau 6 (laissant l’index 5 vide). Enfin, le <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour copier 3 éléments dans la liste, en commençant par l’index 2, dans le tableau en commençant à l’index 12 (laissant l’index 11 vide). Le contenu du tableau est ensuite affiché.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à 0.  
  
- ou - 
 <paramref name="arrayIndex" /> est inférieur à 0.  
  
- ou - 
 <paramref name="count" /> est inférieur à 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> est égal ou supérieur au <see cref="P:System.Collections.Generic.List`1.Count" /> de la source <see cref="T:System.Collections.Generic.List`1" />.  
  
- ou - 
Le nombre d’éléments entre <paramref name="index" /> et la fin du <see cref="T:System.Collections.Generic.List`1" /> source est supérieur à l’espace disponible entre <paramref name="arrayIndex" /> et la fin du <paramref name="array" /> de destination.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.List&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d'éléments contenus dans le <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <value>Nombre d'éléments contenus dans <see cref="T:System.Collections.Generic.List`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> est le nombre d’éléments qui le <xref:System.Collections.Generic.List%601> peut stocker avant que le redimensionnement soit nécessaire. <xref:System.Collections.Generic.List%601.Count%2A> est le nombre d’éléments réellement contenus dans le <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> est toujours supérieur ou égal à <xref:System.Collections.Generic.List%601.Count%2A>. Si <xref:System.Collections.Generic.List%601.Count%2A> dépasse <xref:System.Collections.Generic.List%601.Capacity%2A> lors de l’ajout d’éléments, la capacité est augmentée en réallouant automatiquement le tableau interne avant de copier les anciens éléments et d’ajouter les nouveaux éléments.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
   
  
## Examples  
 L’exemple suivant montre comment vérifier la capacité et le nombre d’un <xref:System.Collections.Generic.List%601> qui contient un objet métier simple et illustre l’utilisation de la <xref:System.Collections.Generic.List%601.TrimExcess%2A> méthode pour supprimer une capacité supplémentaire.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 L’exemple suivant affiche la valeur de la <xref:System.Collections.Generic.List%601.Count%2A> propriété à différents points dans la vie d’une liste. Une fois que la liste a été créée et remplie et ses éléments affichés, le <xref:System.Collections.Generic.List%601.Capacity%2A> et <xref:System.Collections.Generic.List%601.Count%2A> propriétés sont affichées. Ces propriétés sont affichées après la <xref:System.Collections.Generic.List%601.TrimExcess%2A> méthode a été appelée et à nouveau après le contenu de la liste est effacé.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Exists : Predicate&lt;'T&gt; -&gt; bool" Usage="list.Exists match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Délégué <see cref="T:System.Predicate`1" /> qui définit les conditions des éléments à rechercher.</param>
        <summary>Détermine si <see cref="T:System.Collections.Generic.List`1" /> contient des éléments qui correspondent aux conditions définies par le prédicat spécifié.</summary>
        <returns>
          <see langword="true" /> si <see cref="T:System.Collections.Generic.List`1" /> contient un ou plusieurs éléments qui correspondent aux conditions définies par le prédicat spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de l’actuel <xref:System.Collections.Generic.List%601> sont passés à la <xref:System.Predicate%601> délégué et le traitement s’arrête lorsqu’une correspondance est trouvée.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.Contains%2A> et <xref:System.Collections.Generic.List%601.Exists%2A> méthodes sur un <xref:System.Collections.Generic.List%601> qui contient un objet métier simple qui implémente <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.Exists%2A> (méthode) et plusieurs autres méthodes qui utilisent la <xref:System.Predicate%601> délégué générique.  
  
 Un <xref:System.Collections.Generic.List%601> de chaînes est créé, contenant des noms de dinosaure 8, deux d'entre eux (positions 1 et 5) se terminent par « saurus ». L’exemple définit également une méthode de prédicat de recherche nommée `EndsWithSaurus`, qui accepte un paramètre de chaîne et retourne une valeur Boolean indiquant si la chaîne d’entrée se termine par « saurus ».  
  
 Le <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, et <xref:System.Collections.Generic.List%601.FindAll%2A> méthodes sont utilisées pour rechercher la liste avec la méthode de prédicat de recherche, puis le <xref:System.Collections.Generic.List%601.RemoveAll%2A> méthode est utilisée pour supprimer toutes les entrées se terminant par « saurus ».  
  
 Enfin, le <xref:System.Collections.Generic.List%601.Exists%2A> méthode est appelée. Il parcourt la liste à partir du début, chaque élément en passant à la `EndsWithSaurus` (méthode). La recherche s’arrête et la méthode retourne `true` si le `EndsWithSaurus` retourne de la méthode `true` pour n’importe quel élément. Le <xref:System.Collections.Generic.List%601.Exists%2A> méthode retourne `false` , car tous ces éléments ont été supprimés.  
  
> [!NOTE]
>  En c# et Visual Basic, il n’est pas nécessaire de créer le `Predicate<string>` déléguer (`Predicate(Of String)` en Visual Basic) explicitement. Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Find : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.Find match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Délégué <see cref="T:System.Predicate`1" /> qui définit les conditions de l'élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne la première occurrence dans le <see cref="T:System.Collections.Generic.List`1" /> entier.</summary>
        <returns>Premier élément qui correspond aux conditions définies par le prédicat spécifié, s’il est trouvé ; sinon, valeur par défaut du type <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de l’actuel <xref:System.Collections.Generic.List%601> sont passés à la <xref:System.Predicate%601> délégué, en avançant vers le <xref:System.Collections.Generic.List%601>, en commençant par le premier élément et se terminant par le dernier élément.  Traitement s’arrête lorsqu’une correspondance est trouvée.  
  
> [!IMPORTANT]
>  Lorsque vous recherchez une liste contenant des types valeur, assurez-vous que la valeur par défaut pour le type ne satisfait pas le prédicat de recherche. Sinon, il n’existe aucun moyen de faire la distinction entre une valeur par défaut indiquant qu’aucune correspondance n’a été trouvé et un élément de liste qui possède la valeur par défaut pour le type. Si la valeur par défaut satisfait le prédicat de recherche, utilisez la <xref:System.Collections.Generic.List%601.FindIndex%2A> méthode à la place.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.Find%2A> méthode sur un <xref:System.Collections.Generic.List%601> qui contient un objet complexe simple.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 L’exemple suivant illustre les méthodes de recherche pour la <xref:System.Collections.Generic.List%601> classe. L’exemple pour le <xref:System.Collections.Generic.List%601> contient de la classe `book` objets, de la classe `Book`, en utilisant les données à partir de la [exemple de fichier XML : livres (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Le `FillList` méthode dans l’exemple utilise [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) pour analyser les valeurs à partir du XML aux valeurs de propriété de la `book` objets.  
  
 Le tableau suivant décrit les exemples fournis pour les méthodes find.  
  
|Méthode|Exemple|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Recherche un livre par un ID à l’aide de la `IDToFind` délégué de prédicat.<br /><br /> Exemple c# utilise un délégué anonyme.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Rechercher tous les livres dont `Genre` propriété est « Computer » à l’aide de la `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Recherche le dernier livre dans la collection qui a une date de publication avant 2001, à l’aide de la `PubBefore2001` délégué de prédicat.<br /><br /> Exemple c# utilise un délégué anonyme.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Recherche l’index du premier livre d’ordinateur à l’aide du `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Recherche l’index du dernier ordinateur livre en utilisant le `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Recherche l’index du premier livre d’ordinateur dans la seconde moitié de la collection, à l’aide de la `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Recherche l’index du dernier livre d’ordinateur dans la seconde moitié de la collection, à l’aide de la `FindComputer` délégué de prédicat.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindAll : Predicate&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.FindAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Délégué <see cref="T:System.Predicate`1" /> qui définit les conditions des éléments à rechercher.</param>
        <summary>Récupère tous les éléments qui correspondent aux conditions définies par le prédicat spécifié.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.List`1" /> contenant tous les éléments qui correspondent aux conditions définies par le prédicat spécifié, le cas échéant ; sinon, <see cref="T:System.Collections.Generic.List`1" /> vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de l’actuel <xref:System.Collections.Generic.List%601> sont passés individuellement à la <xref:System.Predicate%601> délégué et les éléments qui correspondent aux conditions sont enregistrés dans le texte retourné <xref:System.Collections.Generic.List%601>.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant illustre les méthodes de recherche pour la <xref:System.Collections.Generic.List%601> classe. L’exemple pour le <xref:System.Collections.Generic.List%601> contient de la classe `book` objets, de la classe `Book`, en utilisant les données à partir de la [exemple de fichier XML : livres (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Le `FillList` méthode dans l’exemple utilise [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) pour analyser les valeurs à partir du XML aux valeurs de propriété de la `book` objets.  
  
 Le tableau suivant décrit les exemples fournis pour les méthodes find.  
  
|Méthode|Exemple|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Recherche un livre par un ID à l’aide de la `IDToFind` délégué de prédicat.<br /><br /> Exemple c# utilise un délégué anonyme.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Rechercher tous les livres dont `Genre` propriété est « Computer » à l’aide de la `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Recherche le dernier livre dans la collection qui a une date de publication avant 2001, à l’aide de la `PubBefore2001` délégué de prédicat.<br /><br /> Exemple c# utilise un délégué anonyme.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Recherche l’index du premier livre d’ordinateur à l’aide du `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Recherche l’index du dernier ordinateur livre en utilisant le `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Recherche l’index du premier livre d’ordinateur dans la seconde moitié de la collection, à l’aide de la `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Recherche l’index du dernier livre d’ordinateur dans la seconde moitié de la collection, à l’aide de la `FindComputer` délégué de prédicat.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche un élément qui correspond aux conditions définies par un prédicat spécifié et retourne l’index de base zéro de la première occurrence trouvée dans le <see cref="T:System.Collections.Generic.List`1" /> ou une partie de celui-ci. Cette méthode retourne -1 si un élément correspondant aux conditions est introuvable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Délégué <see cref="T:System.Predicate`1" /> qui définit les conditions de l'élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l'index de base zéro de la première occurrence trouvée dans le <see cref="T:System.Collections.Generic.List`1" /> entier.</summary>
        <returns>Index de base zéro de la première occurrence d’un élément qui répond aux conditions définies par <paramref name="match" />, si cette occurrence est trouvée ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.List%601> recherche est effectuée vers l’avant à partir du premier élément au dernier élément.  
  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de l’actuel <xref:System.Collections.Generic.List%601> sont passés à la <xref:System.Predicate%601> déléguer. Le délégué a la signature :  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant définit un `Employee` classe avec deux champs, `Name` et `Id`. Il définit également un `EmployeeSearch` classe avec une méthode unique, `StartsWith`, qui indique si le `Employee.Name` champ commence par une sous-chaîne spécifiée qui est fournie à la `EmployeeSearch` constructeur de classe. Notez la signature de cette méthode  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 correspond à la signature du délégué qui peut être passé à la <xref:System.Collections.Generic.List%601.FindIndex%2A> (méthode). L’exemple instancie un `List<Employee>` d’objet, ajoute un nombre de `Employee` objets à elle, puis appelle la <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> méthode à deux reprises pour rechercher la collection entière, la première fois pour la première `Employee` de l’objet dont la propriété `Name` champ commence avec « J » et la deuxième fois pour la première `Employee` de l’objet dont la propriété `Name` champ commence par « Ju ».  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Index de début de base zéro de la recherche.</param>
        <param name="match">Délégué <see cref="T:System.Predicate`1" /> qui définit les conditions de l'élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l'index de base zéro de la première occurrence trouvée dans la plage d'éléments de <see cref="T:System.Collections.Generic.List`1" /> qui s'étend de l'index spécifié au dernier élément.</summary>
        <returns>Index de base zéro de la première occurrence d’un élément qui répond aux conditions définies par <paramref name="match" />, si cette occurrence est trouvée ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.List%601> recherche est effectuée vers l’avant `startIndex` et jusqu’au dernier élément.  
  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de l’actuel <xref:System.Collections.Generic.List%601> sont passés à la <xref:System.Predicate%601> déléguer. Le délégué a la signature :  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est le nombre d’éléments à partir de `startIndex` à la fin de la <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 L’exemple suivant définit un `Employee` classe avec deux champs, `Name` et `Id`. Il définit également un `EmployeeSearch` classe avec une méthode unique, `StartsWith`, qui indique si le `Employee.Name` champ commence par une sous-chaîne spécifiée qui est fournie à la `EmployeeSearch` constructeur de classe. Notez la signature de cette méthode  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 correspond à la signature du délégué qui peut être passé à la <xref:System.Collections.Generic.List%601.FindIndex%2A> (méthode). L’exemple instancie un `List<Employee>` d’objet, ajoute un nombre de `Employee` objets à elle, puis appelle la <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> méthode deux fois à rechercher dans la collection en commençant par son membre cinquième (autrement dit, le membre à l’index 4). La première fois, il recherche le premier `Employee` de l’objet dont la propriété `Name` champ commence par « J » ; la deuxième fois, il recherche le premier `Employee` de l’objet dont la propriété `Name` champ commence par « Ju ».  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> est en dehors de la plage d’index valides pour <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Index de début de base zéro de la recherche.</param>
        <param name="count">Nombre d'éléments contenus dans la section où la recherche doit être effectuée.</param>
        <param name="match">Délégué <see cref="T:System.Predicate`1" /> qui définit les conditions de l'élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l'index de base zéro de la première occurrence trouvée dans la plage d'éléments de <see cref="T:System.Collections.Generic.List`1" /> qui commence à l'index spécifié et contient le nombre d'éléments spécifié.</summary>
        <returns>Index de base zéro de la première occurrence d’un élément qui répond aux conditions définies par <paramref name="match" />, si cette occurrence est trouvée ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.List%601> recherche est effectuée vers l’avant `startIndex` et en terminant à `startIndex` plus `count` -1, si `count` est supérieur à 0.  
  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de l’actuel <xref:System.Collections.Generic.List%601> sont passés à la <xref:System.Predicate%601> déléguer. Le délégué a la signature :  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est `count`.  
  
   
  
## Examples  
 L’exemple suivant définit un `Employee` classe avec deux champs, `Name` et `Id`. Il définit également un `EmployeeSearch` classe avec une méthode unique, `StartsWith`, qui indique si le `Employee.Name` champ commence par une sous-chaîne spécifiée qui est fournie à la `EmployeeSearch` constructeur de classe. Notez la signature de cette méthode  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 correspond à la signature du délégué qui peut être passé à la <xref:System.Collections.Generic.List%601.FindIndex%2A> (méthode). L’exemple instancie un `List<Employee>` d’objet, ajoute un nombre de `Employee` objets à elle, puis appelle la <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> à deux reprises pour rechercher la collection entière (méthode) (autrement dit, les membres de l’index 0 à l’index <xref:System.Collections.Generic.List%601.Count%2A> - 1). La première fois, il recherche le premier `Employee` de l’objet dont la propriété `Name` champ commence par « J » ; la deuxième fois, il recherche le premier `Employee` de l’objet dont la propriété `Name` champ commence par « Ju ».  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> n’est pas compris dans la plage d’index valides pour <see cref="T:System.Collections.Generic.List`1" />.  
  
- ou - 
 <paramref name="count" /> est inférieur à 0.  
  
- ou - 
 <paramref name="startIndex" /> et <paramref name="count" /> ne spécifient pas une section valide dans <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLast : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.FindLast match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Délégué <see cref="T:System.Predicate`1" /> qui définit les conditions de l'élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne la dernière occurrence dans le <see cref="T:System.Collections.Generic.List`1" /> entier.</summary>
        <returns>Dernier élément qui correspond aux conditions définies par le prédicat spécifié, le cas échéant ; sinon, valeur par défaut du type <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de l’actuel <xref:System.Collections.Generic.List%601> sont passés à la <xref:System.Predicate%601> délégué, déplacement vers l’arrière le <xref:System.Collections.Generic.List%601>, en commençant par le dernier élément et se terminant par le premier élément.  Traitement s’arrête lorsqu’une correspondance est trouvée.  
  
> [!IMPORTANT]
>  Lorsque vous recherchez une liste contenant des types valeur, assurez-vous que la valeur par défaut pour le type ne satisfait pas le prédicat de recherche. Sinon, il n’existe aucun moyen de faire la distinction entre une valeur par défaut indiquant qu’aucune correspondance n’a été trouvé et un élément de liste qui possède la valeur par défaut pour le type. Si la valeur par défaut satisfait le prédicat de recherche, utilisez la <xref:System.Collections.Generic.List%601.FindLastIndex%2A> méthode à la place.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant illustre les méthodes de recherche pour la <xref:System.Collections.Generic.List%601> classe. L’exemple pour le <xref:System.Collections.Generic.List%601> contient de la classe `book` objets, de la classe `Book`, en utilisant les données à partir de la [exemple de fichier XML : livres (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Le `FillList` méthode dans l’exemple utilise [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) pour analyser les valeurs à partir du XML aux valeurs de propriété de la `book` objets.  
  
 Le tableau suivant décrit les exemples fournis pour les méthodes find.  
  
|Méthode|Exemple|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Recherche un livre par un ID à l’aide de la `IDToFind` délégué de prédicat.<br /><br /> Exemple c# utilise un délégué anonyme.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Rechercher tous les livres dont `Genre` propriété est « Computer » à l’aide de la `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Recherche le dernier livre dans la collection qui a une date de publication avant 2001, à l’aide de la `PubBefore2001` délégué de prédicat.<br /><br /> Exemple c# utilise un délégué anonyme.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Recherche l’index du premier livre d’ordinateur à l’aide du `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Recherche l’index du dernier ordinateur livre en utilisant le `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Recherche l’index du premier livre d’ordinateur dans la seconde moitié de la collection, à l’aide de la `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Recherche l’index du dernier livre d’ordinateur dans la seconde moitié de la collection, à l’aide de la `FindComputer` délégué de prédicat.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche un élément qui correspond aux conditions définies par un prédicat spécifié et retourne l’index de base zéro de la dernière occurrence trouvée dans <see cref="T:System.Collections.Generic.List`1" /> ou une partie de celui-ci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Délégué <see cref="T:System.Predicate`1" /> qui définit les conditions de l'élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l’index de base zéro de la dernière occurrence trouvée dans le <see cref="T:System.Collections.Generic.List`1" /> entier.</summary>
        <returns>Index de base zéro de la dernière occurrence d’un élément qui correspond aux conditions définies par <paramref name="match" />, si cette occurrence est trouvée ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.List%601> recherche est effectuée vers l’arrière à partir du dernier élément vers le premier élément.  
  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de l’actuel <xref:System.Collections.Generic.List%601> sont passés à la <xref:System.Predicate%601> déléguer.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant illustre les méthodes de recherche pour la <xref:System.Collections.Generic.List%601> classe. L’exemple pour le <xref:System.Collections.Generic.List%601> contient de la classe `book` objets, de la classe `Book`, en utilisant les données à partir de la [exemple de fichier XML : livres (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Le `FillList` méthode dans l’exemple utilise [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) pour analyser les valeurs à partir du XML aux valeurs de propriété de la `book` objets.  
  
 Le tableau suivant décrit les exemples fournis pour les méthodes find.  
  
|Méthode|Exemple|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Recherche un livre par un ID à l’aide de la `IDToFind` délégué de prédicat.<br /><br /> Exemple c# utilise un délégué anonyme.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Rechercher tous les livres dont `Genre` propriété est « Computer » à l’aide de la `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Recherche le dernier livre dans la collection qui a une date de publication avant 2001, à l’aide de la `PubBefore2001` délégué de prédicat.<br /><br /> Exemple c# utilise un délégué anonyme.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Recherche l’index du premier livre d’ordinateur à l’aide du `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Recherche l’index du dernier ordinateur livre en utilisant le `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Recherche l’index du premier livre d’ordinateur dans la seconde moitié de la collection, à l’aide de la `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Recherche l’index du dernier livre d’ordinateur dans la seconde moitié de la collection, à l’aide de la `FindComputer` délégué de prédicat.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Index de début de base zéro de la recherche vers le haut.</param>
        <param name="match">Délégué <see cref="T:System.Predicate`1" /> qui définit les conditions de l'élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l'index de base zéro de la dernière occurrence trouvée dans la plage d'éléments du <see cref="T:System.Collections.Generic.List`1" /> qui s'étend du premier élément à l'index spécifié.</summary>
        <returns>Index de base zéro de la dernière occurrence d’un élément qui correspond aux conditions définies par <paramref name="match" />, si cette occurrence est trouvée ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.List%601> est effectuée vers l’arrière commençant à `startIndex` et jusqu’au premier élément.  
  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de l’actuel <xref:System.Collections.Generic.List%601> sont passés à la <xref:System.Predicate%601> déléguer.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est le nombre d’éléments à partir du début de la <xref:System.Collections.Generic.List%601> à `startIndex`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> est en dehors de la plage d’index valides pour <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Index de début de base zéro de la recherche vers le haut.</param>
        <param name="count">Nombre d'éléments contenus dans la section où la recherche doit être effectuée.</param>
        <param name="match">Délégué <see cref="T:System.Predicate`1" /> qui définit les conditions de l'élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l’index de base zéro de la dernière occurrence trouvée dans la plage d’éléments du <see cref="T:System.Collections.Generic.List`1" /> qui contient le nombre d’éléments spécifié et se termine à l’index spécifié.</summary>
        <returns>Index de base zéro de la dernière occurrence d’un élément qui correspond aux conditions définies par <paramref name="match" />, si cette occurrence est trouvée ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.List%601> est effectuée vers l’arrière commençant à `startIndex` et en terminant à `startIndex` moins `count` + 1, si `count` est supérieur à 0.  
  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de l’actuel <xref:System.Collections.Generic.List%601> sont passés à la <xref:System.Predicate%601> déléguer.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est `count`.  
  
   
  
## Examples  
 L’exemple suivant illustre les méthodes de recherche pour la <xref:System.Collections.Generic.List%601> classe. L’exemple pour le <xref:System.Collections.Generic.List%601> contient de la classe `book` objets, de la classe `Book`, en utilisant les données à partir de la [exemple de fichier XML : livres (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Le `FillList` méthode dans l’exemple utilise [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) pour analyser les valeurs à partir du XML aux valeurs de propriété de la `book` objets.  
  
 Le tableau suivant décrit les exemples fournis pour les méthodes find.  
  
|Méthode|Exemple|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Recherche un livre par un ID à l’aide de la `IDToFind` délégué de prédicat.<br /><br /> Exemple c# utilise un délégué anonyme.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Rechercher tous les livres dont `Genre` propriété est « Computer » à l’aide de la `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Recherche le dernier livre dans la collection qui a une date de publication avant 2001, à l’aide de la `PubBefore2001` délégué de prédicat.<br /><br /> Exemple c# utilise un délégué anonyme.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Recherche l’index du premier livre d’ordinateur à l’aide du `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Recherche l’index du dernier ordinateur livre en utilisant le `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Recherche l’index du premier livre d’ordinateur dans la seconde moitié de la collection, à l’aide de la `FindComputer` délégué de prédicat.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Recherche l’index du dernier livre d’ordinateur dans la seconde moitié de la collection, à l’aide de la `FindComputer` délégué de prédicat.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> n’est pas compris dans la plage d’index valides pour <see cref="T:System.Collections.Generic.List`1" />.  
  
- ou - 
 <paramref name="count" /> est inférieur à 0.  
  
- ou - 
 <paramref name="startIndex" /> et <paramref name="count" /> ne spécifient pas une section valide dans <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="member this.ForEach : Action&lt;'T&gt; -&gt; unit" Usage="list.ForEach action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="action">Délégué <see cref="T:System.Action`1" /> à exécuter sur chaque élément de <see cref="T:System.Collections.Generic.List`1" />.</param>
        <summary>Exécute l'action spécifiée sur chaque élément de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Action%601> est un délégué à une méthode qui effectue une action sur l’objet passé.  Les éléments de l’actuel <xref:System.Collections.Generic.List%601> sont passés à la <xref:System.Action%601> déléguer.  
  
 Cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Modification de la collection sous-jacente dans le corps de la <xref:System.Action%601> délégué n’est pas pris en charge et provoque un comportement indéfini.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Action%601> délégué pour imprimer le contenu d’un <xref:System.Collections.Generic.List%601> objet. Dans cet exemple la `Print` méthode est utilisée pour afficher le contenu de la liste dans la console.  
  
> [!NOTE]
>  En plus de l’affichage du contenu à l’aide de la `Print` (méthode), l’exemple c# illustre l’utilisation de pour afficher les résultats dans la console.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Un élément a été modifié dans la collection.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.List&lt;'T&gt;.Enumerator" Usage="list.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.List`1.Enumerator" /> pour l'objet <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs. Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. À cette position, la <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> propriété n’est pas définie. Par conséquent, vous devez appeler la <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> méthode pour avancer l’énumérateur vers le premier élément de la collection avant de lire la valeur de <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>.  
  
 Le <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> propriété retourne le même objet jusqu'à ce que <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> est appelée. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>.  
  
 Si <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> n’est pas défini. Vous ne pouvez pas attribuer de nouveau <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> au premier élément de la collection ; vous devez créer une nouvelle instance de l'énumérateur à la place.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> ou <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> lève une <xref:System.InvalidOperationException>.  
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe. Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Les implémentations par défaut de collections dans l’espace de noms <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetRange : int * int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro <see cref="T:System.Collections.Generic.List`1" /> où débute la plage.</param>
        <param name="count">Nombre d'éléments dans la plage.</param>
        <summary>Crée une copie superficielle d'une plage d'éléments de la source <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Copie superficielle d'une plage d'éléments de la source <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une copie superficielle d’une collection de types référence, ou un sous-ensemble de cette collection, contient uniquement les références aux éléments de la collection. Les objets eux-mêmes ne sont pas copiés. Les références dans la nouvelle liste pointent vers les mêmes objets que les références dans la liste d’origine.  
  
 Une copie superficielle d’une collection de types valeur, ou un sous-ensemble de cette collection, contient les éléments de la collection. Toutefois, si les éléments de la collection contiennent des références à d’autres objets, ces objets ne sont pas copiés. Les références dans les éléments de la nouvelle collection pointent vers les mêmes objets que les références dans les éléments de la collection d’origine.  
  
 En revanche, une copie complète d’une collection copie les éléments et tous les éléments référencés directement ou indirectement par les éléments.  
  
 Cette méthode est un O (*n*) opération, où *n* est `count`.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.GetRange%2A> (méthode) et autres méthodes de la <xref:System.Collections.Generic.List%601> classe qui agissent sur les plages. À la fin de l’exemple, le <xref:System.Collections.Generic.List%601.GetRange%2A> méthode est utilisée pour obtenir trois éléments dans la liste, en commençant par l’emplacement d’index 2. Le <xref:System.Collections.Generic.List%601.ToArray%2A> méthode est appelée sur résultant <xref:System.Collections.Generic.List%601>, création d’un tableau de trois éléments. Les éléments du tableau sont affichés.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à 0.  
  
- ou - 
 <paramref name="count" /> est inférieur à 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage d’éléments valide du <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne l'index de base zéro de la première occurrence d'une valeur trouvée dans <see cref="T:System.Collections.Generic.List`1" /> ou dans une partie de celui-ci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="list.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objet à rechercher dans <see cref="T:System.Collections.Generic.List`1" />. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <summary>Recherche l'objet spécifié et retourne l'index de base zéro de la première occurrence trouvée dans l'ensemble du <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Index de base zéro de la première occurrence de <paramref name="item" /> dans l'ensemble du <see cref="T:System.Collections.Generic.List`1" />, s'il existe ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.List%601> recherche est effectuée vers l’avant à partir du premier élément au dernier élément.  
  
 Cette méthode détermine l’égalité à l’aide du comparateur d’égalité par défaut <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> pour `T`, le type des valeurs dans la liste.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant illustre les trois surcharges de la <xref:System.Collections.Generic.List%601.IndexOf%2A> (méthode). Un <xref:System.Collections.Generic.List%601> de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et emplacement d’index 5. Le <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> surcharge de méthode de recherche dans la liste à partir du début et de la première occurrence de la chaîne. Le <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher la liste en commençant par l’emplacement d’index 3 et en continuant à la fin de la liste et la deuxième occurrence de la chaîne. Enfin, le <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher une plage de deux entrées, en commençant à l’emplacement d’index deux ; elle retourne -1, car aucune instance de la chaîne de recherche dans cette plage.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int -&gt; int" Usage="list.IndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Objet à rechercher dans <see cref="T:System.Collections.Generic.List`1" />. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <param name="index">Index de début de base zéro de la recherche. 0 (zéro) est valide dans une liste vide.</param>
        <summary>Recherche l'objet spécifié et retourne l'index de base zéro de la première occurrence trouvée dans la plage d'éléments de <see cref="T:System.Collections.Generic.List`1" /> qui s'étend de l'index spécifié au dernier élément.</summary>
        <returns>Index de base zéro de la première occurrence de <paramref name="item" /> trouvée dans la plage d’éléments de <see cref="T:System.Collections.Generic.List`1" /> qui s’étend de <paramref name="index" /> jusqu’au dernier élément, le cas échéant ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.List%601> recherche est effectuée vers l’avant `index` et jusqu’au dernier élément.  
  
 Cette méthode détermine l’égalité à l’aide du comparateur d’égalité par défaut <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> pour `T`, le type des valeurs dans la liste.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est le nombre d’éléments à partir de `index` à la fin de la <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 L’exemple suivant illustre les trois surcharges de la <xref:System.Collections.Generic.List%601.IndexOf%2A> (méthode). Un <xref:System.Collections.Generic.List%601> de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et emplacement d’index 5. Le <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> surcharge de méthode de recherche dans la liste à partir du début et de la première occurrence de la chaîne. Le <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher la liste en commençant par l’emplacement d’index 3 et en continuant à la fin de la liste et la deuxième occurrence de la chaîne. Enfin, le <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher une plage de deux entrées, en commençant à l’emplacement d’index deux ; elle retourne -1, car aucune instance de la chaîne de recherche dans cette plage.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est en dehors de la plage d’index valides pour <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int * int -&gt; int" Usage="list.IndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Objet à rechercher dans <see cref="T:System.Collections.Generic.List`1" />. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <param name="index">Index de début de base zéro de la recherche. 0 (zéro) est valide dans une liste vide.</param>
        <param name="count">Nombre d'éléments contenus dans la section où la recherche doit être effectuée.</param>
        <summary>Recherche l'objet spécifié et retourne l'index de base zéro de la première occurrence trouvée dans la plage d'éléments de <see cref="T:System.Collections.Generic.List`1" /> qui commence à l'index spécifié et qui contient le nombre d'éléments spécifié.</summary>
        <returns>Index de base zéro de la première occurrence de <paramref name="item" /> trouvée dans la plage d’éléments de <see cref="T:System.Collections.Generic.List`1" /> qui commence à <paramref name="index" /> et contient le nombre <paramref name="count" /> d’éléments, le cas échéant ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.List%601> recherche est effectuée vers l’avant `index` et en terminant à `index` plus `count` -1, si `count` est supérieur à 0.  
  
 Cette méthode détermine l’égalité à l’aide du comparateur d’égalité par défaut <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> pour `T`, le type des valeurs dans la liste.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est `count`.  
  
   
  
## Examples  
 L’exemple suivant illustre les trois surcharges de la <xref:System.Collections.Generic.List%601.IndexOf%2A> (méthode). Un <xref:System.Collections.Generic.List%601> de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et emplacement d’index 5. Le <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> surcharge de méthode de recherche dans la liste à partir du début et de la première occurrence de la chaîne. Le <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher la liste en commençant par l’emplacement d’index 3 et en continuant à la fin de la liste et la deuxième occurrence de la chaîne. Enfin, le <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher une plage de deux entrées, en commençant à l’emplacement d’index deux ; elle retourne -1, car aucune instance de la chaîne de recherche dans cette plage.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est en dehors de la plage d’index valides pour <see cref="T:System.Collections.Generic.List`1" />.  
  
- ou - 
 <paramref name="count" /> est inférieur à 0.  
  
- ou - 
 <paramref name="index" /> et <paramref name="count" /> ne spécifient pas une section valide dans <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="list.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro au niveau duquel <paramref name="item" /> doit être inséré.</param>
        <param name="item">Objet à insérer. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <summary>Insère un élément dans la classe <see cref="T:System.Collections.Generic.List`1" /> au niveau de l'index spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accepte `null` comme une valeur valide pour la référence de types et autorise les éléments en double.  
  
 Si <xref:System.Collections.Generic.List%601.Count%2A> est déjà égale à <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacité de la <xref:System.Collections.Generic.List%601> est augmentée en réallouant automatiquement le tableau interne, et les éléments existants sont copiés vers le nouveau tableau avant le nouvel élément est ajouté.  
  
 Si `index` est égal à <xref:System.Collections.Generic.List%601.Count%2A>, `item` est ajouté à la fin de <xref:System.Collections.Generic.List%601>.  
  
 Cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter, supprimer et insérer un objet métier simple dans un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.Insert%2A> (méthode), ainsi que de nombreuses autres propriétés et méthodes de la <xref:System.Collections.Generic.List%601> classe générique. Une fois que la liste est créée, les éléments sont ajoutés. Le <xref:System.Collections.Generic.List%601.Insert%2A> méthode est utilisée pour insérer un élément au milieu de la liste. L’élément inséré est un doublon, qui est supprimé ultérieurement à l’aide de la <xref:System.Collections.Generic.List%601.Remove%2A> (méthode).  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à 0.  
  
- ou - 
 <paramref name="index" /> est supérieur à <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;'T&gt; -&gt; unit" Usage="list.InsertRange (index, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro au niveau duquel les nouveaux éléments devraient être insérés.</param>
        <param name="collection">Collection dont les éléments doivent être insérés dans <see cref="T:System.Collections.Generic.List`1" />. La collection elle-même ne peut pas avoir la valeur <see langword="null" />, mais elle peut contenir des éléments qui sont <see langword="null" />, si le type <paramref name="T" /> est un type référence.</param>
        <summary>Insère les éléments d’une collection dans <see cref="T:System.Collections.Generic.List`1" /> au niveau de l’index spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accepte `null` comme une valeur valide pour la référence de types et autorise les éléments en double.  
  
 Si la nouvelle <xref:System.Collections.Generic.List%601.Count%2A> (actuel <xref:System.Collections.Generic.List%601.Count%2A> plus la taille de la collection) sera supérieur à <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacité de la <xref:System.Collections.Generic.List%601> est augmentée en réallouant automatiquement le tableau interne pour prendre en compte les nouveaux éléments et le éléments existants sont copiés vers le nouveau tableau avant que les nouveaux éléments sont ajoutés.  
  
 Si `index` est égal à <xref:System.Collections.Generic.List%601.Count%2A>, les éléments sont ajoutés à la fin de <xref:System.Collections.Generic.List%601>.  
  
 L’ordre des éléments dans la collection est conservé dans le <xref:System.Collections.Generic.List%601>.  
  
 Cette méthode est un O (*n* * *m*) opération, où *n* est le nombre d’éléments à ajouter et *m* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre <xref:System.Collections.Generic.List%601.InsertRange%2A> (méthode) et diverses autres méthodes de la <xref:System.Collections.Generic.List%601> classe qui agissent sur les plages. Une fois que la liste a été créée et remplie avec les noms de plusieurs pacifiques plant dinosaures, le <xref:System.Collections.Generic.List%601.InsertRange%2A> méthode est utilisée pour insérer un tableau de trois dinosaures féroces dans la liste, en commençant à l’emplacement d’index 3.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à 0.  
  
- ou - 
 <paramref name="index" /> est supérieur à <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro de l'élément à obtenir ou à définir.</param>
        <summary>Obtient ou définit l'élément au niveau de l'index spécifié.</summary>
        <value>Élément au niveau de l'index spécifié.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accepte `null` comme une valeur valide pour la référence de types et autorise les éléments en double.  
  
 Cette propriété permet d’accéder à un élément spécifique de la collection à l’aide de la syntaxe suivante : `myCollection[index]`.  
  
 Récupération de la valeur de cette propriété est une opération o (1) ; définition de la propriété est également une opération o (1).  
  
   
  
## Examples  
 L’exemple de cette section montre les <xref:System.Collections.Generic.List%601.Item%2A> propriété (l’indexeur en c#) et diverses autres propriétés et méthodes de la <xref:System.Collections.Generic.List%601> classe générique. Une fois que la liste a été créée et remplie à l’aide de la <xref:System.Collections.Generic.List%601.Add%2A> (méthode), un élément est récupéré et affiché à l’aide de la <xref:System.Collections.Generic.List%601.Item%2A> propriété. (Pour obtenir un exemple qui utilise le <xref:System.Collections.Generic.List%601.Item%2A> propriété pour définir la valeur d’un élément de liste, consultez <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, c# et C++ tous ont la syntaxe permettant d’accéder à la <xref:System.Collections.Generic.List%601.Item%2A> propriété sans utiliser son nom. Au lieu de cela, la variable contenant le <xref:System.Collections.Generic.List%601> est utilisée comme s’il s’agissait d’un tableau.  
  
 Le langage c# utilise le mot clé pour définir les indexeurs au lieu d’implémenter le <xref:System.Collections.Generic.List%601.Item%2A> propriété. Visual Basic implémente <xref:System.Collections.Generic.List%601.Item%2A> comme propriété par défaut, ce qui fournit les mêmes fonctionnalités d'indexation.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à 0.  
  
- ou - 
 <paramref name="index" /> est supérieur ou égal à <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne l'index de base zéro de la dernière occurrence d'une valeur trouvée dans <see cref="T:System.Collections.Generic.List`1" /> ou une partie de celui-ci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T -&gt; int" Usage="list.LastIndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objet à rechercher dans <see cref="T:System.Collections.Generic.List`1" />. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <summary>Recherche l'objet spécifié et retourne l'index de base zéro de la dernière occurrence trouvée dans l'ensemble de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Index de base zéro de la dernière occurrence de <paramref name="item" /> trouvée dans l’ensemble de <see cref="T:System.Collections.Generic.List`1" />, le cas échéant ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.List%601> recherche est effectuée vers l’arrière à partir du dernier élément vers le premier élément.  
  
 Cette méthode détermine l’égalité à l’aide du comparateur d’égalité par défaut <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> pour `T`, le type des valeurs dans la liste.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant illustre les trois surcharges de la <xref:System.Collections.Generic.List%601.LastIndexOf%2A> (méthode). Un <xref:System.Collections.Generic.List%601> de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et emplacement d’index 5. Le <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> surcharge de méthode recherche toute la liste à partir de la fin et la deuxième occurrence de la chaîne. Le <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher la liste en commençant par l’emplacement d’index 3 et en remontant vers le début de la liste, afin que la première occurrence de la chaîne dans la liste. Enfin, le <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher une plage de quatre entrées, en commençant à l’emplacement d’index 4 et l’extension vers l’arrière (autrement dit, il recherche les éléments aux emplacements 4, 3, 2 et 1) ; cette recherche retourne -1, car aucune instance de la recherche chaîne dans cette plage.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int -&gt; int" Usage="list.LastIndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Objet à rechercher dans <see cref="T:System.Collections.Generic.List`1" />. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <param name="index">Index de début de base zéro de la recherche vers le haut.</param>
        <summary>Recherche l'objet spécifié et retourne l'index de base zéro de la dernière occurrence trouvée dans la plage d'éléments de <see cref="T:System.Collections.Generic.List`1" /> qui s'étend du premier élément à l'index spécifié.</summary>
        <returns>Index de base zéro de la dernière occurrence de <paramref name="item" /> trouvée dans la plage d’éléments d’<see cref="T:System.Collections.Generic.List`1" /> qui s’étend du premier élément à <paramref name="index" />, le cas échéant ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.List%601> est effectuée vers l’arrière commençant à `index` et jusqu’au premier élément.  
  
 Cette méthode détermine l’égalité à l’aide du comparateur d’égalité par défaut <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> pour `T`, le type des valeurs dans la liste.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est le nombre d’éléments à partir du début de la <xref:System.Collections.Generic.List%601> à `index`.  
  
   
  
## Examples  
 L’exemple suivant illustre les trois surcharges de la <xref:System.Collections.Generic.List%601.LastIndexOf%2A> (méthode). Un <xref:System.Collections.Generic.List%601> de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et emplacement d’index 5. Le <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> surcharge de méthode recherche toute la liste à partir de la fin et la deuxième occurrence de la chaîne. Le <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher la liste en commençant par l’emplacement d’index 3 et en remontant vers le début de la liste, afin que la première occurrence de la chaîne dans la liste. Enfin, le <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher une plage de quatre entrées, en commençant à l’emplacement d’index 4 et l’extension vers l’arrière (autrement dit, il recherche les éléments aux emplacements 4, 3, 2 et 1) ; cette recherche retourne -1, car aucune instance de la recherche chaîne dans cette plage.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est en dehors de la plage d’index valides pour <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int * int -&gt; int" Usage="list.LastIndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Objet à rechercher dans <see cref="T:System.Collections.Generic.List`1" />. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <param name="index">Index de début de base zéro de la recherche vers le haut.</param>
        <param name="count">Nombre d'éléments contenus dans la section où la recherche doit être effectuée.</param>
        <summary>Recherche l'objet spécifié et retourne l'index de base zéro de la dernière occurrence trouvée dans la plage d'éléments de <see cref="T:System.Collections.Generic.List`1" /> qui contient le nombre spécifié d'éléments et se termine à l'index spécifié.</summary>
        <returns>Index de base zéro de la dernière occurrence de <paramref name="item" /> trouvée dans la plage d’éléments de <see cref="T:System.Collections.Generic.List`1" /> qui contient le nombre <paramref name="count" /> d’éléments et se termine à <paramref name="index" />, le cas échéant ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.Generic.List%601> est effectuée vers l’arrière commençant à `index` et en terminant à `index` moins `count` + 1, si `count` est supérieur à 0.  
  
 Cette méthode détermine l’égalité à l’aide du comparateur d’égalité par défaut <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> pour `T`, le type des valeurs dans la liste.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est `count`.  
  
   
  
## Examples  
 L’exemple suivant illustre les trois surcharges de la <xref:System.Collections.Generic.List%601.LastIndexOf%2A> (méthode). Un <xref:System.Collections.Generic.List%601> de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et emplacement d’index 5. Le <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> surcharge de méthode recherche toute la liste à partir de la fin et la deuxième occurrence de la chaîne. Le <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher la liste en commençant par l’emplacement d’index 3 et en remontant vers le début de la liste, afin que la première occurrence de la chaîne dans la liste. Enfin, le <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher une plage de 4 entrées, en commençant à l’emplacement d’index 4 et l’extension vers l’arrière (autrement dit, il recherche les éléments aux emplacements 4, 3, 2 et 1) ; cette recherche retourne -1, car aucune instance de la recherche chaîne dans cette plage.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est en dehors de la plage d’index valides pour <see cref="T:System.Collections.Generic.List`1" />.  
  
- ou - 
 <paramref name="count" /> est inférieur à 0.  
  
- ou - 
 <paramref name="index" /> et <paramref name="count" /> ne spécifient pas une section valide dans <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="list.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objet à supprimer de <see cref="T:System.Collections.Generic.List`1" />. La valeur peut être <see langword="null" /> pour les types référence.</param>
        <summary>Supprime la première occurrence d'un objet spécifique de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="item" /> est bien supprimé ; sinon, <see langword="false" />.  Cette méthode retourne également <see langword="false" /> si <paramref name="item" /> est introuvable dans <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si type `T` implémente le <xref:System.IEquatable%601> interface générique, le comparateur d’égalité est la <xref:System.IEquatable%601.Equals%2A> méthode de cette interface ; sinon, le comparateur d’égalité par défaut est <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter, supprimer et insérer un objet métier simple dans un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 L’exemple suivant montre <xref:System.Collections.Generic.List%601.Remove%2A> (méthode). Plusieurs propriétés et méthodes de la <xref:System.Collections.Generic.List%601> classe générique sont utilisées pour ajouter, insérer et recherche dans la liste. Après ces opérations, la liste contient un doublon. Le <xref:System.Collections.Generic.List%601.Remove%2A> méthode est utilisée pour supprimer la première instance de l’élément en double, et le contenu est affiché. Le <xref:System.Collections.Generic.List%601.Remove%2A> méthode supprime toujours la première instance qu’il rencontre.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : Predicate&lt;'T&gt; -&gt; int" Usage="list.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Délégué <see cref="T:System.Predicate`1" /> qui définit les conditions des éléments à supprimer.</param>
        <summary>Supprime tous les éléments qui correspondent aux conditions définies par le prédicat spécifié.</summary>
        <returns>Nombre d'éléments supprimés de <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de l’actuel <xref:System.Collections.Generic.List%601> sont passés à la <xref:System.Predicate%601> délégué et les éléments qui correspondent aux conditions sont supprimés de la <xref:System.Collections.Generic.List%601>.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.RemoveAll%2A> (méthode) et plusieurs autres méthodes qui utilisent la <xref:System.Predicate%601> délégué générique.  
  
 Un <xref:System.Collections.Generic.List%601> de chaînes est créé, contenant des noms de dinosaure 8, deux d'entre eux (positions 1 et 5) se terminent par « saurus ». L’exemple définit également une méthode de prédicat de recherche nommée `EndsWithSaurus`, qui accepte un paramètre de chaîne et retourne une valeur Boolean indiquant si la chaîne d’entrée se termine par « saurus ».  
  
 Le <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, et <xref:System.Collections.Generic.List%601.FindAll%2A> méthodes sont utilisées pour rechercher la liste avec la méthode de prédicat de recherche.  
  
 Le <xref:System.Collections.Generic.List%601.RemoveAll%2A> méthode est utilisée pour supprimer toutes les entrées se terminant par « saurus ». Il parcourt la liste à partir du début, chaque élément en passant à la `EndsWithSaurus` (méthode). L’élément est supprimé si le `EndsWithSaurus` retourne de la méthode `true`.  
  
> [!NOTE]
>  En c# et Visual Basic, il n’est pas nécessaire de créer le `Predicate<string>` déléguer (`Predicate(Of String)` en Visual Basic) explicitement. Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.  
  
 Enfin, le <xref:System.Collections.Generic.List%601.Exists%2A> méthode vérifie qu’il n’y a aucune chaîne de la liste qui se termine par « saurus ».  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="list.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro de l'élément à supprimer.</param>
        <summary>Supprime l'élément au niveau de l'index spécifié de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous appelez <xref:System.Collections.Generic.List%601.RemoveAt%2A> pour supprimer un élément, les éléments restants dans la liste sont alors renumérotés pour remplacer l’élément supprimé. Par exemple, si vous supprimez l’élément à l’index 3, l’élément à l’index 4 est déplacé vers la position 3. En outre, le nombre d’éléments dans la liste (telle que représentée par le <xref:System.Collections.Generic.List%601.Count%2A> propriété) est diminuée de 1.  
  
 Cette méthode est un O (*n*) opération, où *n* est (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter, supprimer et insérer un objet métier simple dans un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à 0.  
  
- ou - 
 <paramref name="index" /> est supérieur ou égal à <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="list.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de début de base zéro de la plage d'éléments à supprimer.</param>
        <param name="count">Nombre d'éléments à supprimer.</param>
        <summary>Supprime une plage d'éléments de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments sont supprimés et tous les éléments suivant dans le <xref:System.Collections.Generic.List%601> ont leurs index réduit de `count`.  
  
 Cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.RemoveRange%2A> (méthode) et diverses autres méthodes de la <xref:System.Collections.Generic.List%601> classe qui agissent sur les plages. Une fois que la liste a été créée et modifiée, le <xref:System.Collections.Generic.List%601.RemoveRange%2A> méthode est utilisée pour supprimer les deux éléments dans la liste, en commençant à l’emplacement d’index 2.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à 0.  
  
- ou - 
 <paramref name="count" /> est inférieur à 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage d’éléments valide du <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inverse l'ordre des éléments dans <see cref="T:System.Collections.Generic.List`1" /> ou une partie de celui-ci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="list.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inverse l'ordre des éléments dans l'ensemble de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise <xref:System.Array.Reverse%2A?displayProperty=nameWithType> pour inverser l’ordre des éléments.  
  
 Cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant illustre les deux surcharges de la <xref:System.Collections.Generic.List%601.Reverse%2A> (méthode). L’exemple crée un <xref:System.Collections.Generic.List%601> de chaînes et ajoute six chaînes. Le <xref:System.Collections.Generic.List%601.Reverse> surcharge de méthode est utilisée pour inverser la liste, puis le <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour inverser le milieu de la liste, en commençant par l’élément 1 et en englobant quatre éléments.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Reverse : int * int -&gt; unit" Usage="list.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de début de base zéro de la plage à inverser.</param>
        <param name="count">Nombre d'éléments à inverser dans la plage.</param>
        <summary>Inverse l'ordre des éléments dans la plage spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise <xref:System.Array.Reverse%2A?displayProperty=nameWithType> pour inverser l’ordre des éléments.  
  
 Cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant illustre les deux surcharges de la <xref:System.Collections.Generic.List%601.Reverse%2A> (méthode). L’exemple crée un <xref:System.Collections.Generic.List%601> de chaînes et ajoute six chaînes. Le <xref:System.Collections.Generic.List%601.Reverse> surcharge de méthode est utilisée pour inverser la liste, puis le <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour inverser le milieu de la liste, en commençant par l’élément 1 et en englobant quatre éléments.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à 0.  
  
- ou - 
 <paramref name="count" /> est inférieur à 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage d’éléments valide du <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Trie les éléments ou une partie des éléments dans <see cref="T:System.Collections.Generic.List`1" /> à l’aide de l’implémentation <see cref="T:System.Collections.Generic.IComparer`1" /> spécifiée ou par défaut ou un délégué <see cref="T:System.Comparison`1" /> fourni pour comparer les éléments de la liste.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberSignature Language="F#" Value="member this.Sort : unit -&gt; unit" Usage="list.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Trie les éléments dans l'ensemble de <see cref="T:System.Collections.Generic.List`1" /> à l'aide du comparateur par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise le comparateur par défaut <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> pour le type `T` pour déterminer l’ordre des éléments de liste. Le <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> propriété vérifie si le type `T` implémente le <xref:System.IComparable%601> interface générique et utilise cette implémentation, le cas échéant.  Si ce n’est pas le cas, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type `T` implémente le <xref:System.IComparable> interface.  Si type `T` n’implémente pas ces deux interfaces, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lève une <xref:System.InvalidOperationException>.  
  
 Cette méthode utilise le <xref:System.Array.Sort%2A?displayProperty=nameWithType> (méthode), qui s’applique le tri approfondi comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un algorithme de tri d’insertion.  
  
-   Si le nombre de partitions dépasse 2 journal *n*, où *n* correspond à la plage du tableau d’entrée, il utilise un algorithme de Heapsort.  
  
-   Sinon, il utilise un algorithme de tri rapide.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 En moyenne, cette méthode est un O (*n* journal *n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>; dans le pire des cas il est un O (*n* <sup>2</sup>) opération.  
  
   
  
## Examples  
 L’exemple suivant ajoute des noms à un `List<String>` object, affiche la liste dans un ordre aléatoire, appelle le <xref:System.Collections.Generic.List%601.Sort%2A> (méthode), puis affiche la liste triée.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 Le code suivant illustre la <xref:System.Collections.Generic.List%601.Sort> et <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> des surcharges de méthode sur un objet métier simple. Appel de la <xref:System.Collections.Generic.List%601.Sort> méthode se traduit par l’utilisation du comparateur par défaut pour le type de composant et le <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> méthode est implémentée à l’aide d’une méthode anonyme.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.Sort> surcharge de méthode et la <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> surcharge de méthode. Un <xref:System.Collections.Generic.List%601> de chaînes est créé et rempli avec quatre chaînes, dans aucun ordre particulier. La liste est affichée, triée et affiche à nouveau.  
  
 Le <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> surcharge de méthode est ensuite utilisée pour rechercher des deux chaînes qui ne sont pas dans la liste, et le <xref:System.Collections.Generic.List%601.Insert%2A> méthode est utilisée pour les insérer. La valeur de retour de la <xref:System.Collections.Generic.List%601.BinarySearch%2A> méthode est négative dans chaque cas, étant donné que les chaînes ne sont pas dans la liste. En prenant le complément de bits (le ~ opérateur en c# et Visual C++, `Xor` -1 en Visual Basic) de ce nombre négatif génère l’index du premier élément dans la liste qui est supérieure à la chaîne de recherche et l’insertion à cet emplacement conserve l’ordre de tri ordre. La deuxième chaîne de recherche est supérieure à n’importe quel élément dans la liste, par conséquent, la position d’insertion est à la fin de la liste.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le comparateur par défaut <see cref="P:System.Collections.Generic.Comparer`1.Default" /> ne peut pas trouver une implémentation de l’interface générique <see cref="T:System.IComparable`1" /> ou de l’interface <see cref="T:System.IComparable" /> pour le type <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.Generic.IComparer`1" /> à utiliser pendant la comparaison d'éléments, ou <see langword="null" /> pour utiliser le comparateur par défaut <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Trie les éléments dans l'ensemble de <see cref="T:System.Collections.Generic.List`1" /> à l'aide du comparateur spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparer` est fourni, les éléments de la <xref:System.Collections.Generic.List%601> sont triés à l’aide de la <xref:System.Collections.Generic.IComparer%601> implémentation.  
  
 Si `comparer` est `null`, le comparateur par défaut <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type `T` implémente le <xref:System.IComparable%601> interface générique et utilise cette implémentation, le cas échéant.  Si ce n’est pas le cas, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type `T` implémente le <xref:System.IComparable> interface.  Si type `T` n’implémente pas ces deux interfaces, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lève une <xref:System.InvalidOperationException>.  
  
 Cette méthode utilise le <xref:System.Array.Sort%2A?displayProperty=nameWithType> (méthode), qui s’applique le tri approfondi comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un algorithme de tri d’insertion.  
  
-   Si le nombre de partitions dépasse 2 journal *n*, où *n* correspond à la plage du tableau d’entrée, il utilise un algorithme de Heapsort.  
  
-   Sinon, il utilise un algorithme de tri rapide.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 En moyenne, cette méthode est un O (*n* journal *n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>; dans le pire des cas il est un O (*n* <sup>2</sup>) opération.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> surcharge de méthode et la <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> surcharge de méthode.  
  
 L’exemple définit un autre comparateur pour les chaînes nommées DinoCompare, qui implémente le `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` dans Visual C++) interface générique. Le comparateur fonctionne comme suit : tout d’abord, les comparateurs sont testés pour `null`, et une référence null est considérée comme inférieure à une valeur non null. Deuxièmement, les longueurs de chaîne sont comparées, et la plus longue chaîne est jugée supérieure. Troisièmement, si les longueurs sont égales, la comparaison de chaînes ordinaire est utilisée.  
  
 Un <xref:System.Collections.Generic.List%601> de chaînes est créé et rempli avec quatre chaînes, dans aucun ordre particulier. La liste est affichée, triée à l’aide de l’autre comparateur et s’affichent à nouveau.  
  
 Le <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> surcharge de méthode est ensuite utilisée pour rechercher de nombreuses chaînes qui ne figurent pas dans la liste, par le biais de l’autre comparateur. Le <xref:System.Collections.Generic.List%601.Insert%2A> méthode est utilisée pour insérer les chaînes. Ces deux méthodes sont situés dans la fonction nommée `SearchAndInsert`, ainsi que du code pour prendre le complément au niveau du bit (le ~ opérateur en c# et Visual C++, `Xor` -1 en Visual Basic) du nombre négatif retourné par <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> et utilisez-la en tant qu’index pour Insérer la nouvelle chaîne.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> a la valeur <see langword="null" />, et le comparateur par défaut <see cref="P:System.Collections.Generic.Comparer`1.Default" /> ne peut pas trouver d’implémentation de l’interface générique <see cref="T:System.IComparable`1" /> ou de l’interface <see cref="T:System.IComparable" /> pour le type <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentException">L’implémentation de <paramref name="comparer" /> a provoqué une erreur pendant le tri. Par exemple, <paramref name="comparer" /> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="member this.Sort : Comparison&lt;'T&gt; -&gt; unit" Usage="list.Sort comparison" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">
          <see cref="T:System.Comparison`1" /> à utiliser pendant la comparaison d'éléments.</param>
        <summary>Trie les éléments dans l'ensemble de <see cref="T:System.Collections.Generic.List`1" /> à l'aide du <see cref="T:System.Comparison`1" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparison` est fourni, les éléments de la <xref:System.Collections.Generic.List%601> sont triés à l’aide de la méthode représentée par le délégué.  
  
 Si `comparison` est `null`, un <xref:System.ArgumentNullException> est levée.  
  
 Cette méthode utilise <xref:System.Array.Sort%2A?displayProperty=nameWithType>, auquel s’applique le tri approfondi comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un algorithme de tri d’insertion  
  
-   Si le nombre de partitions dépasse 2 journal *n*, où *n* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un algorithme de tri rapide.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 En moyenne, cette méthode est un O (*n* journal *n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>; dans le pire des cas il est un O (*n* <sup>2</sup>) opération.  
  
   
  
## Examples  
 Le code suivant illustre la <xref:System.Collections.Generic.List%601.Sort%2A> et <xref:System.Collections.Generic.List%601.Sort%2A> des surcharges de méthode sur un objet métier simple. Appel de la <xref:System.Collections.Generic.List%601.Sort%2A> méthode se traduit par l’utilisation du comparateur par défaut pour le type de composant et le <xref:System.Collections.Generic.List%601.Sort%2A> méthode est implémentée à l’aide d’une méthode anonyme.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> surcharge de méthode.  
  
 L’exemple définit une autre méthode de comparaison des chaînes, nommée `CompareDinosByLength`. Cette méthode fonctionne comme suit : tout d’abord, les comparateurs sont testés pour `null`, et une référence null est considérée comme inférieure à une valeur non null. Deuxièmement, les longueurs de chaîne sont comparées, et la plus longue chaîne est jugée supérieure. Troisièmement, si les longueurs sont égales, la comparaison de chaînes ordinaire est utilisée.  
  
 Un <xref:System.Collections.Generic.List%601> de chaînes est créé et rempli avec quatre chaînes, dans aucun ordre particulier. La liste inclut également une chaîne vide et une référence null. La liste s’affiche, trié à l’aide un <xref:System.Comparison%601> délégué générique représentant le `CompareDinosByLength` (méthode) et affiche à nouveau.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="comparison" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L’implémentation de <paramref name="comparison" /> a provoqué une erreur pendant le tri. Par exemple, <paramref name="comparison" /> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</exception>
        <altmember cref="T:System.Comparison`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Index de début de base zéro de la plage à trier.</param>
        <param name="count">Longueur de la plage à trier.</param>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.Generic.IComparer`1" /> à utiliser pendant la comparaison d'éléments, ou <see langword="null" /> pour utiliser le comparateur par défaut <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Trie les éléments dans une plage d'éléments de <see cref="T:System.Collections.Generic.List`1" /> à l'aide du comparateur spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparer` est fourni, les éléments de la <xref:System.Collections.Generic.List%601> sont triés à l’aide de la <xref:System.Collections.Generic.IComparer%601> implémentation.  
  
 Si `comparer` est `null`, le comparateur par défaut <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type `T` implémente le <xref:System.IComparable%601> interface générique et utilise cette implémentation, le cas échéant.  Si ce n’est pas le cas, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> vérifie si le type `T` implémente le <xref:System.IComparable> interface.  Si type `T` n’implémente pas ces deux interfaces, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lève une <xref:System.InvalidOperationException>.  
  
 Cette méthode utilise <xref:System.Array.Sort%2A?displayProperty=nameWithType>, auquel s’applique le tri approfondi comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un algorithme de tri d’insertion  
  
-   Si le nombre de partitions dépasse 2 journal *n*, où *n* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un algorithme de tri rapide.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 En moyenne, cette méthode est un O (*n* journal *n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>; dans le pire des cas il est un O (*n* <sup>2</sup>) opération.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> surcharge de méthode et la <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> surcharge de méthode.  
  
 L’exemple définit un autre comparateur pour les chaînes nommées DinoCompare, qui implémente le `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` dans Visual C++) interface générique. Le comparateur fonctionne comme suit : tout d’abord, les comparateurs sont testés pour `null`, et une référence null est considérée comme inférieure à une valeur non null. Deuxièmement, les longueurs de chaîne sont comparées, et la plus longue chaîne est jugée supérieure. Troisièmement, si les longueurs sont égales, la comparaison de chaînes ordinaire est utilisée.  
  
 Un <xref:System.Collections.Generic.List%601> de chaînes est créé et rempli avec les noms des cinq dinosaures et trois dinosaures carnivores. Dans chacun des deux groupes, les noms ne sont pas dans n’importe quel ordre de tri particulier. La liste est affichée, la plage d’herbivores est triée à l’aide de l’autre comparateur, et la liste s’affiche à nouveau.  
  
 Le <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> surcharge de méthode est ensuite utilisée pour rechercher uniquement la plage d’herbivores correspondant à « Brachiosaure ». La chaîne est introuvable et le complément de bits (le ~ opérateur en c# et Visual C++, `Xor` -1 en Visual Basic) du nombre négatif retourné par la <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> méthode est utilisée en tant qu’index pour insérer la nouvelle chaîne.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à 0.  
  
- ou - 
 <paramref name="count" /> est inférieur à 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> et <paramref name="count" /> ne spécifient pas une plage valide dans le <see cref="T:System.Collections.Generic.List`1" />.  
  
- ou - 
L’implémentation de <paramref name="comparer" /> a provoqué une erreur pendant le tri. Par exemple, <paramref name="comparer" /> peut ne pas retourner 0 lors de la comparaison d’un élément à lui-même.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> a la valeur <see langword="null" />, et le comparateur par défaut <see cref="P:System.Collections.Generic.Comparer`1.Default" /> ne peut pas trouver d’implémentation de l’interface générique <see cref="T:System.IComparable`1" /> ou de l’interface <see cref="T:System.IComparable" /> pour le type <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Exécution d’opérations de chaînes indépendantes de la culture dans des collections</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Collections.Generic.ICollection`1" /> est en lecture seule.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Collections.Generic.ICollection`1" /> est en lecture seule ; sinon, <see langword="false" />.  Dans l'implémentation par défaut de <see cref="T:System.Collections.Generic.List`1" />, cette propriété retourne toujours <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection en lecture seule n’autorise pas l’ajout, la suppression ou la modification d’éléments après sa création.  
  
 Une collection est en lecture seule est simplement une collection avec un wrapper qui empêche la modification de la collection ; Par conséquent, si des modifications sont apportées à la collection sous-jacente, la collection en lecture seule reflète ces modifications.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein d'une collection.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" /> qui peut être utilisé pour itérer au sein de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs. Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. À cette position, la <xref:System.Collections.Generic.IEnumerator%601.Current%2A> propriété n’est pas définie. Par conséquent, vous devez appeler la <xref:System.Collections.IEnumerator.MoveNext%2A> méthode pour avancer l’énumérateur vers le premier élément de la collection avant de lire la valeur de <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 Le <xref:System.Collections.Generic.IEnumerator%601.Current%2A> propriété retourne le même objet jusqu'à ce que <xref:System.Collections.IEnumerator.MoveNext%2A> est appelée. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> n’est pas défini. Vous ne pouvez pas attribuer de nouveau <xref:System.Collections.Generic.IEnumerator%601.Current%2A> au premier élément de la collection ; vous devez créer une nouvelle instance de l'énumérateur à la place.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> lève une <xref:System.InvalidOperationException>.  
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe. Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Les implémentations par défaut de collections dans l’espace de noms <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensionnel qui constitue la destination des éléments copiés à partir de <see cref="T:System.Collections.ICollection" />. Le <see cref="T:System.Array" /> doit avoir une indexation de base zéro.</param>
        <param name="arrayIndex">Index de base zéro dans l'<paramref name="array" /> à partir duquel la copie commence.</param>
        <summary>Copie les éléments de <see cref="T:System.Collections.ICollection" /> dans <see cref="T:System.Array" />, à partir d'un index particulier de <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si le type de la source <xref:System.Collections.ICollection> ne peut pas être casté automatiquement au type de la destination `array`, les implémentations non génériques de <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> lever <xref:System.InvalidCastException>, tandis que les implémentations génériques lèvent <xref:System.ArgumentException>.  
  
 Cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> est inférieur à 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> est multidimensionnel.  
  
- ou - 
 <paramref name="array" /> n’a pas d’indexation de base zéro.  
  
- ou - 
Le nombre d’éléments dans la <see cref="T:System.Collections.ICollection" /> source est supérieur à la quantité d’espace disponible entre <paramref name="arrayIndex" /> et la fin du <paramref name="array" /> de destination.  
  
- ou - 
Le type du <see cref="T:System.Collections.ICollection" /> source ne peut pas être converti automatiquement en type du <paramref name="array" /> de destination.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'accès à <see cref="T:System.Collections.ICollection" /> est synchronisé (thread-safe).</summary>
        <value>
          <see langword="true" /> si l'accès à <see cref="T:System.Collections.ICollection" /> est synchronisé (thread-safe) ; sinon <see langword="false" />.  Dans l'implémentation par défaut de <see cref="T:System.Collections.Generic.List`1" />, cette propriété retourne toujours <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les implémentations par défaut de collections dans l’espace de noms <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.  Dans les rares cas où l’énumération gère accès en écriture, vous pouvez verrouiller la collection pendant toute l’énumération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Retourne un objet qui peut être utilisé pour synchroniser l’accès à la <xref:System.Collections.ICollection>. La synchronisation est effective uniquement si tous les threads de verrouillent de cet objet avant d’accéder à la collection.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.ICollection" />.  Dans l'implémentation par défaut de <see cref="T:System.Collections.Generic.List`1" />, cette propriété retourne toujours l'instance actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les implémentations par défaut de collections dans l’espace de noms <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 L’énumération d’une collection n’est intrinsèquement pas une procédure thread-safe.  Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Retourne un objet qui peut être utilisé pour synchroniser l’accès à la <xref:System.Collections.ICollection>. La synchronisation est effective uniquement si tous les threads de verrouillent de cet objet avant d’accéder à la collection. Le code suivant illustre l’utilisation de la <xref:System.Collections.ICollection.SyncRoot%2A> propriété pour c#, C++ et Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein d'une collection.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> qui peut être utilisé pour itérer au sein de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs. Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l’énumérateur est positionné avant le premier élément de la collection. <xref:System.Collections.IEnumerator.Reset%2A> replace également l'énumérateur à cette position.  À cette position, la <xref:System.Collections.IEnumerator.Current%2A> propriété n’est pas définie. Par conséquent, vous devez appeler la <xref:System.Collections.IEnumerator.MoveNext%2A> méthode pour avancer l’énumérateur vers le premier élément de la collection avant de lire la valeur de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Le <xref:System.Collections.IEnumerator.Current%2A> propriété retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> est appelée. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.IEnumerator.Current%2A> n’est pas défini. Pour attribuer une nouvelle fois <xref:System.Collections.IEnumerator.Current%2A> au premier élément de la collection, vous pouvez appeler <xref:System.Collections.IEnumerator.Reset%2A> suivi de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, modification, ou la suppression d’éléments, l’énumérateur est définitivement invalidé et l’appel suivant à <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> lève une <xref:System.InvalidOperationException>.  
  
 Comme l’énumérateur ne dispose pas d’un accès exclusif à la collection, l’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe.  Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Les implémentations par défaut de collections dans l’espace de noms <xref:System.Collections.Generic?displayProperty=nameWithType> ne sont pas synchronisées.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Object" /> à ajouter à <see cref="T:System.Collections.IList" />.</param>
        <summary>Ajoute un élément à <see cref="T:System.Collections.IList" />.</summary>
        <returns>Position à laquelle le nouvel élément est inséré.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Collections.Generic.List%601.Count%2A> est inférieure à <xref:System.Collections.Generic.List%601.Capacity%2A>, cette méthode est une opération o (1). Si la capacité doit être augmentée pour intégrer un nouvel élément, cette méthode devient un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> est d’un type qui ne peut pas être assigné à <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Object" /> à rechercher dans <see cref="T:System.Collections.IList" />.</param>
        <summary>Détermine si <see cref="T:System.Collections.IList" /> contient une valeur spécifique.</summary>
        <returns>
          <see langword="true" /> si <paramref name="item" /> existe dans <see cref="T:System.Collections.IList" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine l’égalité à l’aide du comparateur d’égalité par défaut <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> pour `T`, le type des valeurs dans la liste.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Objet à rechercher dans <see cref="T:System.Collections.IList" />.</param>
        <summary>Détermine l'index d'un élément spécifique d'<see cref="T:System.Collections.IList" />.</summary>
        <returns>Index de <paramref name="item" /> s'il figure dans la liste ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine l’égalité à l’aide du comparateur d’égalité par défaut <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> pour `T`, le type des valeurs dans la liste.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> est d’un type qui ne peut pas être assigné à <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro au niveau duquel <paramref name="item" /> doit être inséré.</param>
        <param name="item">Objet à insérer dans <see cref="T:System.Collections.IList" />.</param>
        <summary>Insère un élément dans <see cref="T:System.Collections.IList" /> à l'index spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `index` est égal au nombre d'éléments dans <xref:System.Collections.IList>, `item` est ajouté à la fin.  
  
 Cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> n'est pas un index valide dans <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> est d’un type qui ne peut pas être assigné à <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Collections.IList" /> est de taille fixe.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Collections.IList" /> est de taille fixe ; sinon, <see langword="false" />.  Dans l'implémentation par défaut de <see cref="T:System.Collections.Generic.List`1" />, cette propriété retourne toujours <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection de taille fixe ne permet pas l’ajout ou la suppression d’éléments après sa création, mais permet la modification des éléments existants.  
  
 Une collection avec une taille fixe est simplement une collection avec un wrapper qui empêche l’ajout et suppression d’éléments. Par conséquent, si des modifications sont apportées à la collection sous-jacente, y compris l’ajout ou la suppression d’éléments, la collection de taille fixe reflète ces modifications.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Collections.IList" /> est en lecture seule.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Collections.IList" /> est en lecture seule ; sinon, <see langword="false" />.  Dans l'implémentation par défaut de <see cref="T:System.Collections.Generic.List`1" />, cette propriété retourne toujours <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection en lecture seule n’autorise pas l’ajout, la suppression ou la modification d’éléments après sa création.  
  
 Une collection est en lecture seule est simplement une collection avec un wrapper qui empêche la modification de la collection ; Par conséquent, si des modifications sont apportées à la collection sous-jacente, la collection en lecture seule reflète ces modifications.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro de l'élément à obtenir ou à définir.</param>
        <summary>Obtient ou définit l'élément au niveau de l'index spécifié.</summary>
        <value>Élément au niveau de l'index spécifié.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le langage c# utilise le [cela](~/docs/csharp/language-reference/keywords/this.md) mot clé pour définir les indexeurs au lieu d’implémenter le <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> propriété. Visual Basic implémente <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> comme propriété par défaut, ce qui fournit les mêmes fonctionnalités d'indexation.  
  
 Récupération de la valeur de cette propriété est une opération o (1) ; définition de la propriété est également une opération o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> n'est pas un index valide dans <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété est définie et <paramref name="value" /> a un type qui ne peut pas être assigné à <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Objet à supprimer de <see cref="T:System.Collections.IList" />.</param>
        <summary>Supprime la première occurrence d'un objet spécifique de <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode détermine l’égalité à l’aide du comparateur d’égalité par défaut <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> pour `T`, le type des valeurs dans la liste.  
  
 Cette méthode effectue une recherche linéaire ; Par conséquent, cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> est d’un type qui ne peut pas être assigné à <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="list.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copie les éléments de <see cref="T:System.Collections.Generic.List`1" /> dans un nouveau tableau.</summary>
        <returns>Tableau contenant les copies des éléments de <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments sont copiés à l’aide de <xref:System.Array.Copy%2A?displayProperty=nameWithType>, qui est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.ToArray%2A> (méthode) et autres méthodes de la <xref:System.Collections.Generic.List%601> classe qui agissent sur les plages. À la fin de l’exemple, le <xref:System.Collections.Generic.List%601.GetRange%2A> méthode est utilisée pour obtenir trois éléments dans la liste, en commençant par l’emplacement d’index 2. Le <xref:System.Collections.Generic.List%601.ToArray%2A> méthode est appelée sur résultant <xref:System.Collections.Generic.List%601>, création d’un tableau de trois éléments. Les éléments du tableau sont affichés.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="list.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Définit la capacité en fonction du nombre effectif d'éléments situés dans <see cref="T:System.Collections.Generic.List`1" />, si ce nombre est inférieur à une valeur de seuil.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour réduire une surcharge de mémoire d’une collection si aucun nouvel élément ne doit être ajouté à la collection. Le coût de réallocation et de copie d’un grand <xref:System.Collections.Generic.List%601> peut être considérable, toutefois, par conséquent, le <xref:System.Collections.Generic.List%601.TrimExcess%2A> méthode ne fait rien si la liste est à plus de 90 pour cent de la capacité. Cela évite de devoir engager un coût de réallocation élevé pour un gain relativement faible.  
  
> [!NOTE]
>  Le seuil actuel de 90 pour cent peut-être changer dans les futures versions.  
  
 Cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Pour réinitialiser un <xref:System.Collections.Generic.List%601> à son état initial, appelez le <xref:System.Collections.Generic.List%601.Clear%2A> méthode avant d’appeler le <xref:System.Collections.Generic.List%601.TrimExcess%2A> (méthode). Suppression vide <xref:System.Collections.Generic.List%601> définit la capacité de la <xref:System.Collections.Generic.List%601> à la capacité par défaut.  
  
 La capacité peut également être définie à l’aide de la <xref:System.Collections.Generic.List%601.Capacity%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant montre comment vérifier la capacité et le nombre d’un <xref:System.Collections.Generic.List%601> qui contient un objet métier simple et illustre l’utilisation de la <xref:System.Collections.Generic.List%601.TrimExcess%2A> méthode pour supprimer une capacité supplémentaire.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.TrimExcess%2A> (méthode). Plusieurs propriétés et méthodes de la <xref:System.Collections.Generic.List%601> classe sont utilisés pour ajouter, insérer et supprimer des éléments à partir d’une liste de chaînes. Le <xref:System.Collections.Generic.List%601.TrimExcess%2A> méthode est utilisée pour réduire la capacité à correspondre au nombre et le <xref:System.Collections.Generic.List%601.Capacity%2A> et <xref:System.Collections.Generic.List%601.Count%2A> propriétés sont affichées. Si la capacité inutilisée avait été inférieure à 10 % de la capacité totale, la liste n’aurait pas été redimensionnée. Enfin, le contenu de la liste est effacé.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.TrueForAll : Predicate&lt;'T&gt; -&gt; bool" Usage="list.TrueForAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Délégué <see cref="T:System.Predicate`1" /> qui définit les conditions à vérifier par rapport aux éléments.</param>
        <summary>Détermine si chaque élément de <see cref="T:System.Collections.Generic.List`1" /> correspond aux conditions définies par le prédicat spécifié.</summary>
        <returns>
          <see langword="true" /> si chaque élément de <see cref="T:System.Collections.Generic.List`1" /> correspond aux conditions définies par le prédicat spécifié ; sinon, <see langword="false" />. Si la liste ne comporte pas d'éléments, la valeur de retour est <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de l’actuel <xref:System.Collections.Generic.List%601> sont passés à la <xref:System.Predicate%601> délégué et le traitement s’arrête lorsque le délégué retourne `false` pour n’importe quel élément. Les éléments sont traités dans l’ordre, et tous les appels sont effectués sur un seul thread.  
  
 Cette méthode est un O (*n*) opération, où *n* est <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Collections.Generic.List%601.TrueForAll%2A> (méthode) et plusieurs autres méthodes qui utilisent <xref:System.Predicate%601> délégué générique.  
  
 Un <xref:System.Collections.Generic.List%601> de chaînes est créé, contenant des noms de dinosaure 8, deux d'entre eux (positions 1 et 5) se terminent par « saurus ». L’exemple définit également une méthode de prédicat de recherche nommée `EndsWithSaurus`, qui accepte un paramètre de chaîne et retourne une valeur Boolean indiquant si la chaîne d’entrée se termine par « saurus ».  
  
 Le <xref:System.Collections.Generic.List%601.TrueForAll%2A> méthode parcourt la liste à partir du début, chaque élément en passant à la `EndsWithSaurus` (méthode). La recherche s’arrête lorsque la `EndsWithSaurus` retourne de la méthode `false`.  
  
> [!NOTE]
>  En c# et Visual Basic, il n’est pas nécessaire de créer le `Predicate<string>` déléguer (`Predicate(Of String)` en Visual Basic) explicitement. Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>