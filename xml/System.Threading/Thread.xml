<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="364f25c7d0e105a33705e6a6d8354e4f5159d93d" /><Meta Name="ms.sourcegitcommit" Value="75eca440f8f4d595506405f48961f38649e160d7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="06/01/2019" /><Meta Name="ms.locfileid" Value="66457902" /></Metadata><TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="30c12-101">Crée et contrôle un thread, définit sa priorité et obtient son état.</span><span class="sxs-lookup"><span data-stu-id="30c12-101">Creates and controls a thread, sets its priority, and gets its status.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-102">Quand un processus démarre, le common language runtime crée automatiquement un thread de premier plan pour exécuter le code d’application.</span><span class="sxs-lookup"><span data-stu-id="30c12-102">When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</span></span> <span data-ttu-id="30c12-103">En même temps que ce thread de premier plan principal, un processus peut créer un ou plusieurs threads pour exécuter une partie du code du programme associé au processus.</span><span class="sxs-lookup"><span data-stu-id="30c12-103">Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</span></span> <span data-ttu-id="30c12-104">Ces threads peuvent exécuter au premier plan ou en arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="30c12-104">These threads can execute either in the foreground or in the background.</span></span> <span data-ttu-id="30c12-105">En outre, vous pouvez utiliser la <xref:System.Threading.ThreadPool> classe pour exécuter du code sur les threads de travail qui sont gérés par le common language runtime.</span><span class="sxs-lookup"><span data-stu-id="30c12-105">In addition, you can use the <xref:System.Threading.ThreadPool> class to execute code on worker threads that are managed by the common language runtime.</span></span>  
  
 <span data-ttu-id="30c12-106">Dans cette section</span><span class="sxs-lookup"><span data-stu-id="30c12-106">In this section</span></span>  
  
 <span data-ttu-id="30c12-107">[À partir d’un thread](#Starting) </span><span class="sxs-lookup"><span data-stu-id="30c12-107">[Starting a thread](#Starting) </span></span>  
 <span data-ttu-id="30c12-108">[Récupération d’objets de Thread](#Retrieving) </span><span class="sxs-lookup"><span data-stu-id="30c12-108">[Retrieving Thread objects](#Retrieving) </span></span>  
 <span data-ttu-id="30c12-109">[Threads de premier plan et d’arrière-plan](#Foreground) </span><span class="sxs-lookup"><span data-stu-id="30c12-109">[Foreground and background threads](#Foreground) </span></span>  
 <span data-ttu-id="30c12-110">[Culture et des threads](#Culture) </span><span class="sxs-lookup"><span data-stu-id="30c12-110">[Culture and threads](#Culture) </span></span>  
 [<span data-ttu-id="30c12-111">Obtenir des informations sur et contrôler les threads</span><span class="sxs-lookup"><span data-stu-id="30c12-111">Getting information about and controlling threads</span></span>](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a><span data-ttu-id="30c12-112">À partir d’un thread</span><span class="sxs-lookup"><span data-stu-id="30c12-112">Starting a thread</span></span>  
 <span data-ttu-id="30c12-113">Démarrer un thread en fournissant un délégué qui représente la méthode que le thread consiste à exécuter dans son constructeur de classe.</span><span class="sxs-lookup"><span data-stu-id="30c12-113">You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</span></span> <span data-ttu-id="30c12-114">Vous appelez ensuite la <xref:System.Threading.Thread.Start%2A> méthode pour commencer l’exécution.</span><span class="sxs-lookup"><span data-stu-id="30c12-114">You then call the <xref:System.Threading.Thread.Start%2A> method to begin execution.</span></span>  
  
 <span data-ttu-id="30c12-115">Le <xref:System.Threading.Thread> constructeurs peuvent prendre un des types de délégué deux, selon que vous pouvez passer un argument à la méthode à exécuter :</span><span class="sxs-lookup"><span data-stu-id="30c12-115">The <xref:System.Threading.Thread> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</span></span>  
  
-   <span data-ttu-id="30c12-116">Si la méthode n’a aucun argument, vous passez un <xref:System.Threading.ThreadStart> déléguer au constructeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-116">If the method has no arguments, you pass a <xref:System.Threading.ThreadStart> delegate to  the constructor.</span></span> <span data-ttu-id="30c12-117">Il a la signature :</span><span class="sxs-lookup"><span data-stu-id="30c12-117">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     <span data-ttu-id="30c12-118">L’exemple suivant crée et démarre un thread qui exécute le `ExecuteInForeground` (méthode).</span><span class="sxs-lookup"><span data-stu-id="30c12-118">The following example creates and starts a thread that executes the `ExecuteInForeground` method.</span></span> <span data-ttu-id="30c12-119">La méthode affiche des informations sur certaines propriétés de thread, puis exécute une boucle dans laquelle elle s’interrompt pendant une demi-seconde et affiche le nombre de secondes écoulé.</span><span class="sxs-lookup"><span data-stu-id="30c12-119">The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</span></span> <span data-ttu-id="30c12-120">Lorsque le thread a été exécutée pendant au moins cinq secondes, fin de la boucle et le thread se termine l’exécution.</span><span class="sxs-lookup"><span data-stu-id="30c12-120">When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</span></span>  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   <span data-ttu-id="30c12-121">Si la méthode possède un argument, vous passez un <xref:System.Threading.ParameterizedThreadStart> déléguer au constructeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-121">If the method has an argument, you pass a <xref:System.Threading.ParameterizedThreadStart> delegate to the constructor.</span></span> <span data-ttu-id="30c12-122">Il a la signature :</span><span class="sxs-lookup"><span data-stu-id="30c12-122">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     <span data-ttu-id="30c12-123">La méthode exécutée par le délégué peut ensuite effectuer un cast (en c#) ou convertir (en Visual Basic) le paramètre du type approprié.</span><span class="sxs-lookup"><span data-stu-id="30c12-123">The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</span></span>  
  
     <span data-ttu-id="30c12-124">L’exemple suivant est identique au précédent, excepté qu’il appelle le <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-124">The following example is identical to the previous one, except that it calls the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor.</span></span> <span data-ttu-id="30c12-125">Cette version de la `ExecuteInForeground` méthode possède un paramètre unique qui représente le nombre approximatif de millisecondes de la boucle doit s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="30c12-125">This version of the `ExecuteInForeground` method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</span></span>  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 <span data-ttu-id="30c12-126">Il n’est pas nécessaire de conserver une référence à un <xref:System.Threading.Thread> une fois que vous avez démarré le thread de l’objet.</span><span class="sxs-lookup"><span data-stu-id="30c12-126">It is not necessary to retain a reference to a <xref:System.Threading.Thread> object once you have started the thread.</span></span> <span data-ttu-id="30c12-127">Le thread continue à s’exécuter jusqu'à la fin de la procédure de thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-127">The thread continues to execute until the thread procedure is complete.</span></span>  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a><span data-ttu-id="30c12-128">Récupération d’objets de Thread</span><span class="sxs-lookup"><span data-stu-id="30c12-128">Retrieving Thread objects</span></span>  
 <span data-ttu-id="30c12-129">Vous pouvez utiliser la méthode statique (`Shared` en Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> propriété à récupérer une référence au thread en cours d’exécution à partir du code que le thread s’exécute.</span><span class="sxs-lookup"><span data-stu-id="30c12-129">You can use the static (`Shared` in Visual Basic)  <xref:System.Threading.Thread.CurrentThread%2A> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</span></span> <span data-ttu-id="30c12-130">L’exemple suivant utilise le <xref:System.Threading.Thread.CurrentThread%2A> propriété pour afficher des informations sur le thread principal de l’application, un autre thread de premier plan, un thread d’arrière-plan et un thread de pool de threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-130">The following example uses the <xref:System.Threading.Thread.CurrentThread%2A> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</span></span>  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a><span data-ttu-id="30c12-131">Threads de premier plan et d’arrière-plan</span><span class="sxs-lookup"><span data-stu-id="30c12-131">Foreground and background threads</span></span>  
 <span data-ttu-id="30c12-132">Instances de la <xref:System.Threading.Thread> classe représentent les threads de premier plan ou de threads d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="30c12-132">Instances of the <xref:System.Threading.Thread> class represent either foreground threads or background threads.</span></span> <span data-ttu-id="30c12-133">Threads d’arrière-plan sont identiques aux threads de premier plan à une exception près : un thread d’arrière-plan ne conserve pas un processus exécuté si tous les threads de premier plan sont terminés.</span><span class="sxs-lookup"><span data-stu-id="30c12-133">Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</span></span> <span data-ttu-id="30c12-134">Une fois que tous les threads de premier plan ont été arrêtés, le runtime arrête tous les threads d’arrière-plan et s’arrête.</span><span class="sxs-lookup"><span data-stu-id="30c12-134">Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</span></span>  
  
 <span data-ttu-id="30c12-135">Par défaut, les threads suivants s’exécutent au premier plan :</span><span class="sxs-lookup"><span data-stu-id="30c12-135">By default, the following threads execute in the foreground:</span></span>  
  
-   <span data-ttu-id="30c12-136">Le thread principal de l’application.</span><span class="sxs-lookup"><span data-stu-id="30c12-136">The main application thread.</span></span>  
  
-   <span data-ttu-id="30c12-137">Tous les threads créés en appelant un <xref:System.Threading.Thread> constructeur de classe.</span><span class="sxs-lookup"><span data-stu-id="30c12-137">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="30c12-138">Les threads suivants s’exécutent en arrière-plan par défaut :</span><span class="sxs-lookup"><span data-stu-id="30c12-138">The following threads execute in the background by default:</span></span>  
  
-   <span data-ttu-id="30c12-139">Thread du pool de threads, qui constituent un pool de threads de travail géré par le runtime.</span><span class="sxs-lookup"><span data-stu-id="30c12-139">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span>  <span data-ttu-id="30c12-140">Vous pouvez configurer le travail de pool et de planification de thread sur les threads du pool à l’aide de la <xref:System.Threading.ThreadPool> classe.</span><span class="sxs-lookup"><span data-stu-id="30c12-140">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="30c12-141">Opérations asynchrones basées sur la tâche s’exécute automatiquement sur les threads du pool.</span><span class="sxs-lookup"><span data-stu-id="30c12-141">Task-based asynchronous operations automatically execute on thread pool threads.</span></span> <span data-ttu-id="30c12-142">Utilisent des opérations asynchrones basées sur une tâche le <xref:System.Threading.Tasks.Task> et <xref:System.Threading.Tasks.Task%601> classes pour implémenter le [modèle asynchrone basé sur les tâches](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span><span class="sxs-lookup"><span data-stu-id="30c12-142">Task-based asynchronous operations use the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes to implement the [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span></span>  
  
-   <span data-ttu-id="30c12-143">Tous les threads qui entrent dans l’environnement d’exécution managé à partir de code non managé.</span><span class="sxs-lookup"><span data-stu-id="30c12-143">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
 <span data-ttu-id="30c12-144">Vous pouvez modifier un thread d’exécuter en arrière-plan en définissant le <xref:System.Threading.Thread.IsBackground%2A> propriété à tout moment.</span><span class="sxs-lookup"><span data-stu-id="30c12-144">You can change a thread to execute in the background by setting the <xref:System.Threading.Thread.IsBackground%2A> property at any time.</span></span>  <span data-ttu-id="30c12-145">Threads d’arrière-plan sont utiles pour toute opération qui doit se poursuivre tant qu’une application est en cours d’exécution mais ne doit pas empêcher l’application à partir de la fin d’exécution, comme la surveillance des modifications de système de fichiers ou les connexions de socket entrante.</span><span class="sxs-lookup"><span data-stu-id="30c12-145">Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</span></span>  
  
 <span data-ttu-id="30c12-146">L’exemple suivant illustre la différence entre les threads de premier plan et d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="30c12-146">The following example illustrates the difference between foreground and background threads.</span></span> <span data-ttu-id="30c12-147">C’est comme le premier exemple dans le [à partir d’un thread](#Starting) section, sauf qu’il définit le thread de s’exécuter en arrière-plan avant de le démarrer.</span><span class="sxs-lookup"><span data-stu-id="30c12-147">It is like the first example in the [Starting a thread](#Starting) section, except that it sets the thread to execute in the background before starting it.</span></span> <span data-ttu-id="30c12-148">Comme le montre la sortie, la boucle est interrompue avant de s’exécuter pendant cinq secondes.</span><span class="sxs-lookup"><span data-stu-id="30c12-148">As the output shows, the loop is interrupted before it executes for five seconds.</span></span>  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a><span data-ttu-id="30c12-149">Culture et des threads</span><span class="sxs-lookup"><span data-stu-id="30c12-149">Culture and threads</span></span>  
 <span data-ttu-id="30c12-150">Chaque thread possède une culture, représentée par le <xref:System.Threading.Thread.CurrentCulture%2A> propriété et une culture d’interface utilisateur, représentée par le <xref:System.Threading.Thread.CurrentUICulture%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="30c12-150">Each thread has a culture, represented by the <xref:System.Threading.Thread.CurrentCulture%2A> property, and a UI culture, represented by the <xref:System.Threading.Thread.CurrentUICulture%2A> property.</span></span>  <span data-ttu-id="30c12-151">La culture actuelle prend en charge ces opérations dépendantes de la culture en tant que l’analyse et mise en forme, comparaison de chaînes et le tri et contrôle également le système d’écriture et le calendrier utilisé par un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-151">The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</span></span> <span data-ttu-id="30c12-152">La culture d’interface utilisateur actuelle fournit pour la récupération de la culture des ressources dans les fichiers de ressources.</span><span class="sxs-lookup"><span data-stu-id="30c12-152">The current UI culture provides for culture-sensitive retrieval of resources in resource files.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="30c12-153">Le <xref:System.Threading.Thread.CurrentCulture> et <xref:System.Threading.Thread.CurrentUICulture> propriétés ne fonctionnent de façon fiable lorsqu’il est utilisé avec n’importe quel thread autre que le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-153">The <xref:System.Threading.Thread.CurrentCulture> and <xref:System.Threading.Thread.CurrentUICulture> properties don't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="30c12-154">Dans .NET Framework, la lecture de ces propriétés est fiable, bien que la définition de ces propriétés pour un thread autre que le thread actuel n’est pas.</span><span class="sxs-lookup"><span data-stu-id="30c12-154">In .NET Framework, reading these properties is reliable, although setting these properties for a thread other than the current thread is not.</span></span> <span data-ttu-id="30c12-155">Sur .NET Core, un <xref:System.InvalidOperationException> est levée si un thread tente de lire ou écrire ces propriétés sur un thread différent.</span><span class="sxs-lookup"><span data-stu-id="30c12-155">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write these properties on a different thread.</span></span>
> <span data-ttu-id="30c12-156">Nous vous recommandons d’utiliser le <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> et <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> propriétés à récupérer et définir la culture actuelle.</span><span class="sxs-lookup"><span data-stu-id="30c12-156">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> properties to retrieve and set the current culture.</span></span>

 <span data-ttu-id="30c12-157">Quand un nouveau thread est instancié, sa culture et la culture d’interface utilisateur sont définis par la culture système actuelle et la culture d’interface utilisateur et non par la culture et la culture d’interface utilisateur du thread à partir duquel le nouveau thread est créé.</span><span class="sxs-lookup"><span data-stu-id="30c12-157">When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</span></span> <span data-ttu-id="30c12-158">Cela signifie, par exemple, que si la culture système actuelle est anglais (États-Unis) et la culture actuelle du thread d’application principal est le Français (France), la culture d’un nouveau thread créé en appelant le <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructeur à partir du thread principal est anglais (États-Unis) et pas Français (France).</span><span class="sxs-lookup"><span data-stu-id="30c12-158">This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor from the primary thread is English (United States), and not French (France).</span></span> <span data-ttu-id="30c12-159">Pour plus d’informations, consultez la section « Culture et threads » de la <xref:System.Globalization.CultureInfo> rubrique de la classe.</span><span class="sxs-lookup"><span data-stu-id="30c12-159">For more information, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="30c12-160">Cela n’est pas vrai pour les threads qui exécutent des opérations asynchrones pour les applications qui ciblent le [!INCLUDE[net_v46](~/includes/net-v46-md.md)] et versions ultérieures, dans ce cas, la culture et la culture d’interface utilisateur fait partie d’une commande asynchrone contexte des opérations ; le thread sur lequel une opération asynchrone s’exécute par défaut hérite de la culture et la culture d’interface utilisateur du thread à partir duquel l’opération asynchrone a été lancée.</span><span class="sxs-lookup"><span data-stu-id="30c12-160">This is not true of threads that execute asynchronous operations for apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)] and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</span></span> <span data-ttu-id="30c12-161">Pour plus d'informations, consultez la section « Culture et opérations asynchrones basées sur les tâches » de la rubrique relative à la classe <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="30c12-161">For more information, see the "Culture and task-based asynchronous operations" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
 <span data-ttu-id="30c12-162">Vous pouvez effectuer l’une des opérations suivantes pour vous assurer que tous les threads de l’exécution dans une application partagent la même culture et la culture d’interface utilisateur :</span><span class="sxs-lookup"><span data-stu-id="30c12-162">You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</span></span>  
  
-   <span data-ttu-id="30c12-163">Vous pouvez passer un <xref:System.Globalization.CultureInfo> objet qui représente cette culture pour le <xref:System.Threading.ParameterizedThreadStart> déléguer ou <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="30c12-163">You can pass a <xref:System.Globalization.CultureInfo> object that represents that culture to the <xref:System.Threading.ParameterizedThreadStart> delegate or the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="30c12-164">Pour les applications exécutées le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] et versions ultérieures, vous pouvez définir la culture et la culture d’interface utilisateur qui doit être affecté à tous les threads créés dans un domaine d’application en définissant la valeur de la <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> et <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> propriétés.</span><span class="sxs-lookup"><span data-stu-id="30c12-164">For apps running on the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="30c12-165">Notez qu’il s’agit d’un paramètre par domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="30c12-165">Note that this is a per-application domain setting.</span></span>  

 <span data-ttu-id="30c12-166">Pour plus d’informations et des exemples, consultez la section « Culture et threads » de la <xref:System.Globalization.CultureInfo> rubrique de la classe.</span><span class="sxs-lookup"><span data-stu-id="30c12-166">For more information and examples, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a><span data-ttu-id="30c12-167">Obtenir des informations sur et contrôler les threads</span><span class="sxs-lookup"><span data-stu-id="30c12-167">Getting information about and controlling threads</span></span>  
 <span data-ttu-id="30c12-168">Vous pouvez récupérer un nombre de valeurs de propriétés qui fournissent des informations sur un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-168">You can retrieve a number of property values that provide information about a thread.</span></span> <span data-ttu-id="30c12-169">Dans certains cas, vous pouvez également définir ces valeurs de propriété pour contrôler le fonctionnement du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-169">In some cases, you can also set these property values to control the operation of the thread.</span></span> <span data-ttu-id="30c12-170">Ces propriétés de thread sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="30c12-170">These thread properties include:</span></span>  
  
-   <span data-ttu-id="30c12-171">Nom.</span><span class="sxs-lookup"><span data-stu-id="30c12-171">A name.</span></span> <span data-ttu-id="30c12-172"><xref:System.Threading.Thread.Name%2A> est une écriture-propriété une fois que vous pouvez utiliser pour identifier un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-172"><xref:System.Threading.Thread.Name%2A> is a write-once property that you can use to identify a thread.</span></span>  <span data-ttu-id="30c12-173">Sa valeur par défaut est `null`.</span><span class="sxs-lookup"><span data-stu-id="30c12-173">Its default value is `null`.</span></span>  
  
-   <span data-ttu-id="30c12-174">Un code de hachage, vous pouvez récupérer en appelant le <xref:System.Threading.Thread.GetHashCode%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="30c12-174">A hash code, which you can retrieve by calling the <xref:System.Threading.Thread.GetHashCode%2A> method.</span></span> <span data-ttu-id="30c12-175">Le code de hachage peut être utilisé pour identifier de façon unique un thread ; pour la durée de vie de votre thread, son code de hachage ne sera pas entrer en conflit avec la valeur à partir de n’importe quel autre thread, quel que soit le domaine d’application à partir de laquelle vous obtenez la valeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-175">The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</span></span>  
  
-   <span data-ttu-id="30c12-176">Un ID de thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-176">A thread ID.</span></span> <span data-ttu-id="30c12-177">La valeur de la lecture seule <xref:System.Threading.Thread.ManagedThreadId%2A> propriété est attribuée par le runtime et identifie de façon unique un thread au sein de son processus.</span><span class="sxs-lookup"><span data-stu-id="30c12-177">The value of the read-only <xref:System.Threading.Thread.ManagedThreadId%2A> property is assigned by the runtime and uniquely identifies a thread within its process.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="30c12-178">Un [ID de thread](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) de système d'exploitation n'est pas lié de manière fixe à un thread managé, car un hôte non managé peut contrôler la relation entre les threads managés et les threads non managés.</span><span class="sxs-lookup"><span data-stu-id="30c12-178">An operating-system [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="30c12-179">Plus précisément, un hôte élaboré peut utiliser le [API d’hébergement CLR](https://msdn.microsoft.com/library/ms404385.aspx) pour planifier de nombreux threads managés sur le même thread de système d’exploitation, ou pour déplacer un thread managé entre les threads de système d’exploitation différent.</span><span class="sxs-lookup"><span data-stu-id="30c12-179">Specifically, a sophisticated host can use the [CLR Hosting API](https://msdn.microsoft.com/library/ms404385.aspx) to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</span></span>  
  
-   <span data-ttu-id="30c12-180">L’état du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-180">The thread's current state.</span></span> <span data-ttu-id="30c12-181">Pendant la durée de son existence, un thread se trouve toujours dans un ou plusieurs des états définis par le <xref:System.Threading.ThreadState> propriété.</span><span class="sxs-lookup"><span data-stu-id="30c12-181">For the duration of its existence, a thread is always in one or more of the states defined by the <xref:System.Threading.ThreadState> property.</span></span>  
  
-   <span data-ttu-id="30c12-182">Un niveau de priorité de planification est défini par le <xref:System.Threading.ThreadPriority> propriété.</span><span class="sxs-lookup"><span data-stu-id="30c12-182">A scheduling priority level, which is defined by the <xref:System.Threading.ThreadPriority> property.</span></span> <span data-ttu-id="30c12-183">Bien que vous pouvez définir cette valeur pour demander une priorité de thread, il n’est pas garanti à être respectées par le système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="30c12-183">Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</span></span>  
  
-   <span data-ttu-id="30c12-184">En lecture seule <xref:System.Threading.Thread.IsThreadPoolThread%2A> propriété, qui indique si un thread est un thread de pool de threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-184">The read-only <xref:System.Threading.Thread.IsThreadPoolThread%2A> property, which indicates whether a thread is  a thread pool thread.</span></span>  
  
-   <span data-ttu-id="30c12-185">La propriété <xref:System.Threading.Thread.IsBackground%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-185">The <xref:System.Threading.Thread.IsBackground%2A> property.</span></span> <span data-ttu-id="30c12-186">Pour plus d’informations, consultez le [les threads de premier plan et arrière-plan](#Foreground) section.</span><span class="sxs-lookup"><span data-stu-id="30c12-186">For more information, see the [Foreground and background threads](#Foreground) section.</span></span>  
  
## Examples  
 <span data-ttu-id="30c12-187">L’exemple suivant illustre la fonctionnalité de thread simple.</span><span class="sxs-lookup"><span data-stu-id="30c12-187">The following example demonstrates simple threading functionality.</span></span>  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 <span data-ttu-id="30c12-188">Ce code produit une sortie similaire à ce qui suit :</span><span class="sxs-lookup"><span data-stu-id="30c12-188">This code produces output similar to the following:</span></span>  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="30c12-189">Ce type est thread-safe.</span><span class="sxs-lookup"><span data-stu-id="30c12-189">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="30c12-190">Threads et threading</span><span class="sxs-lookup"><span data-stu-id="30c12-190">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="30c12-191">Utilisation des threads et du threading</span><span class="sxs-lookup"><span data-stu-id="30c12-191">Using Threads and Threading</span></span></related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96"><span data-ttu-id="30c12-192">Source de référence pour la classe de Thread</span><span class="sxs-lookup"><span data-stu-id="30c12-192">Reference Source for the Thread Class</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="30c12-193">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Thread" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-193">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="30c12-194">Délégué qui représente les méthodes à appeler au début de l'exécution de ce thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-194">A delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="30c12-195">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Thread" />, en spécifiant un délégué qui permet à un objet d'être passé au thread quand le thread est démarré.</span><span class="sxs-lookup"><span data-stu-id="30c12-195">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-196">Un thread d’exécution ne commence pas lors de sa création.</span><span class="sxs-lookup"><span data-stu-id="30c12-196">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="30c12-197">Pour planifier l’exécution du thread, appelez le <xref:System.Threading.Thread.Start%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="30c12-197">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span> <span data-ttu-id="30c12-198">Pour passer un objet de données au thread, utilisez la <xref:System.Threading.Thread.Start%28System.Object%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="30c12-198">To pass a data object to the thread, use the <xref:System.Threading.Thread.Start%28System.Object%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-199">Les utilisateurs de Visual Basic peuvent omettre le <xref:System.Threading.ThreadStart> constructeur lors de la création d’un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-199">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="30c12-200">Utilisez le `AddressOf` opérateur lorsque vous passez votre méthode, par exemple `Dim t As New Thread(AddressOf ThreadProc)`.</span><span class="sxs-lookup"><span data-stu-id="30c12-200">Use the `AddressOf` operator when passing your method, for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="30c12-201">Visual Basic appelle automatiquement la <xref:System.Threading.ThreadStart> constructeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-201">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-202">L’exemple suivant illustre la syntaxe pour créer et utiliser un <xref:System.Threading.ParameterizedThreadStart> délégué avec une méthode statique et une méthode d’instance.</span><span class="sxs-lookup"><span data-stu-id="30c12-202">The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="30c12-203"><paramref name="start" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-203"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="30c12-204">Création de Threads</span><span class="sxs-lookup"><span data-stu-id="30c12-204">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="30c12-205">Délégué <see cref="T:System.Threading.ThreadStart" /> qui représente les méthodes à appeler au début de l'exécution de ce thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-205">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="30c12-206">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Thread" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-206">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-207">Un thread d’exécution ne commence pas lors de sa création.</span><span class="sxs-lookup"><span data-stu-id="30c12-207">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="30c12-208">Pour planifier l’exécution du thread, appelez le <xref:System.Threading.Thread.Start%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="30c12-208">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-209">Les utilisateurs de Visual Basic peuvent omettre le <xref:System.Threading.ThreadStart> constructeur lors de la création d’un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-209">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="30c12-210">Utilisez le `AddressOf` opérateur lorsque vous passez votre méthode par exemple `Dim t As New Thread(AddressOf ThreadProc)`.</span><span class="sxs-lookup"><span data-stu-id="30c12-210">Use the `AddressOf` operator when passing your method for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="30c12-211">Visual Basic appelle automatiquement la <xref:System.Threading.ThreadStart> constructeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-211">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-212">L’exemple de code suivant montre comment créer un thread qui exécute une méthode statique.</span><span class="sxs-lookup"><span data-stu-id="30c12-212">The following code example shows how to create a thread that executes a static method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 <span data-ttu-id="30c12-213">L’exemple de code suivant montre comment créer un thread qui exécute une méthode d’instance.</span><span class="sxs-lookup"><span data-stu-id="30c12-213">The following code example shows how to create a thread that executes an instance method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="30c12-214">Le paramètre <paramref name="start" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-214">The <paramref name="start" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="30c12-215">Création de Threads</span><span class="sxs-lookup"><span data-stu-id="30c12-215">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="30c12-216">Délégué <see cref="T:System.Threading.ParameterizedThreadStart" /> qui représente les méthodes à appeler au début de l'exécution de ce thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-216">A <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="30c12-217">Taille de pile maximale, en octets, à utiliser par le thread, ou 0 pour utiliser la taille de pile maximale par défaut spécifiée dans l'en-tête pour le fichier exécutable.</span><span class="sxs-lookup"><span data-stu-id="30c12-217">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="30c12-218">Important   Pour le code partiellement fiable, <paramref name="maxStackSize" /> est ignoré s’il est supérieur à la taille de la pile par défaut.</span><span class="sxs-lookup"><span data-stu-id="30c12-218">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="30c12-219">Aucune exception n'est levée.</span><span class="sxs-lookup"><span data-stu-id="30c12-219">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="30c12-220">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Thread" />, en spécifiant un délégué qui permet à un objet d'être passé au thread quand le thread est démarré et en spécifiant la taille de pile maximale pour le thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-220">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-221">Évitez d’utiliser cette surcharge de constructeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-221">Avoid using this constructor overload.</span></span> <span data-ttu-id="30c12-222">La taille de pile par défaut utilisée par le <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> surcharge de constructeur est la taille de pile recommandée pour les threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-222">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="30c12-223">Si un thread a des problèmes de mémoire, la cause la plus probable est la programmation erreur, telle qu’une récurrence infinie.</span><span class="sxs-lookup"><span data-stu-id="30c12-223">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="30c12-224">Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]uniquement de confiance suffisant pour le code peut définir `maxStackSize` sur une valeur supérieure à celle de la taille de pile par défaut (1 Mo).</span><span class="sxs-lookup"><span data-stu-id="30c12-224">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="30c12-225">Si une valeur supérieure est spécifiée pour `maxStackSize` lorsque le code s’exécute avec une confiance partielle, `maxStackSize` est ignoré et la taille de pile par défaut est utilisée.</span><span class="sxs-lookup"><span data-stu-id="30c12-225">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="30c12-226">Aucune exception n'est levée.</span><span class="sxs-lookup"><span data-stu-id="30c12-226">No exception is thrown.</span></span> <span data-ttu-id="30c12-227">Le code à tout niveau de confiance peut définir `maxStackSize` sur une valeur inférieure à la taille de pile par défaut.</span><span class="sxs-lookup"><span data-stu-id="30c12-227">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-228">Si vous développez une bibliothèque totalement approuvée qui sera utilisée par du code partiellement fiable, et que vous avez besoin démarrer un thread qui nécessite une importante pile, vous devez déclarer la confiance totale avant de créer le thread ou la taille de pile par défaut sera utilisée.</span><span class="sxs-lookup"><span data-stu-id="30c12-228">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="30c12-229">Ne le faites pas, sauf si vous contrôlez entièrement le code qui s’exécute sur le thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-229">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="30c12-230">Si `maxStackSize` est inférieure à la taille minimale de pile, la taille de pile minimale est utilisée.</span><span class="sxs-lookup"><span data-stu-id="30c12-230">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="30c12-231">Si `maxStackSize` n’est pas un multiple de la taille de page, il est arrondi au prochain multiple de la taille de page.</span><span class="sxs-lookup"><span data-stu-id="30c12-231">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="30c12-232">Par exemple, si vous utilisez la version 2.0 du .NET Framework sur Windows Vista, 256 Ko (262 144 octets) est la taille de pile minimale et la taille de page est de 64 Ko (65 536 octets).</span><span class="sxs-lookup"><span data-stu-id="30c12-232">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-233">Sur les versions de Windows Microsoft antérieurs à Windows XP et Windows Server 2003, `maxStackSize` est ignoré, et la taille de pile spécifiée dans l’en-tête de l’exécutable est utilisée.</span><span class="sxs-lookup"><span data-stu-id="30c12-233">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="30c12-234">Si vous spécifiez une très petite taille de pile, vous devrez peut-être désactiver la détection de débordement de pile.</span><span class="sxs-lookup"><span data-stu-id="30c12-234">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="30c12-235">Lors de la pile est sévèrement limitée, la détection peut elle-même provoquer un débordement de pile.</span><span class="sxs-lookup"><span data-stu-id="30c12-235">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="30c12-236">Pour désactiver la détection de dépassement de capacité de pile, ajoutez le code suivant au fichier de configuration de votre application.</span><span class="sxs-lookup"><span data-stu-id="30c12-236">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="30c12-237"><paramref name="start" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-237"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="30c12-238"><paramref name="maxStackSize" /> est inférieur à zéro.</span><span class="sxs-lookup"><span data-stu-id="30c12-238"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="30c12-239">Délégué <see cref="T:System.Threading.ThreadStart" /> qui représente les méthodes à appeler au début de l'exécution de ce thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-239">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="30c12-240">Taille de pile maximale, en octets, à utiliser par le thread, ou 0 pour utiliser la taille de pile maximale par défaut spécifiée dans l'en-tête pour le fichier exécutable.</span><span class="sxs-lookup"><span data-stu-id="30c12-240">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="30c12-241">Important   Pour le code partiellement fiable, <paramref name="maxStackSize" /> est ignoré s’il est supérieur à la taille de la pile par défaut.</span><span class="sxs-lookup"><span data-stu-id="30c12-241">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="30c12-242">Aucune exception n'est levée.</span><span class="sxs-lookup"><span data-stu-id="30c12-242">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="30c12-243">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Thread" />, en spécifiant la taille de pile maximale pour le thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-243">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-244">Évitez d’utiliser cette surcharge de constructeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-244">Avoid using this constructor overload.</span></span> <span data-ttu-id="30c12-245">La taille de pile par défaut utilisée par le <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> surcharge de constructeur est la taille de pile recommandée pour les threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-245">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="30c12-246">Si un thread a des problèmes de mémoire, la cause la plus probable est la programmation erreur, telle qu’une récurrence infinie.</span><span class="sxs-lookup"><span data-stu-id="30c12-246">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="30c12-247">Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]uniquement de confiance suffisant pour le code peut définir `maxStackSize` sur une valeur supérieure à celle de la taille de pile par défaut (1 Mo).</span><span class="sxs-lookup"><span data-stu-id="30c12-247">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="30c12-248">Si une valeur supérieure est spécifiée pour `maxStackSize` lorsque le code s’exécute avec une confiance partielle, `maxStackSize` est ignoré et la taille de pile par défaut est utilisée.</span><span class="sxs-lookup"><span data-stu-id="30c12-248">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="30c12-249">Aucune exception n'est levée.</span><span class="sxs-lookup"><span data-stu-id="30c12-249">No exception is thrown.</span></span> <span data-ttu-id="30c12-250">Le code à tout niveau de confiance peut définir `maxStackSize` sur une valeur inférieure à la taille de pile par défaut.</span><span class="sxs-lookup"><span data-stu-id="30c12-250">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-251">Si vous développez une bibliothèque totalement approuvée qui sera utilisée par du code partiellement fiable, et que vous avez besoin démarrer un thread qui nécessite une importante pile, vous devez déclarer la confiance totale avant de créer le thread ou la taille de pile par défaut sera utilisée.</span><span class="sxs-lookup"><span data-stu-id="30c12-251">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="30c12-252">Ne le faites pas, sauf si vous contrôlez entièrement le code qui s’exécute sur le thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-252">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="30c12-253">Si `maxStackSize` est inférieure à la taille minimale de pile, la taille de pile minimale est utilisée.</span><span class="sxs-lookup"><span data-stu-id="30c12-253">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="30c12-254">Si `maxStackSize` n’est pas un multiple de la taille de page, il est arrondi au prochain multiple de la taille de page.</span><span class="sxs-lookup"><span data-stu-id="30c12-254">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="30c12-255">Par exemple, si vous utilisez la version 2.0 du .NET Framework sur Windows Vista, 256 Ko (262 144 octets) est la taille de pile minimale et la taille de page est de 64 Ko (65 536 octets).</span><span class="sxs-lookup"><span data-stu-id="30c12-255">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-256">Sur les versions de Windows Microsoft antérieurs à Windows XP et Windows Server 2003, `maxStackSize` est ignoré, et la taille de pile spécifiée dans l’en-tête de l’exécutable est utilisée.</span><span class="sxs-lookup"><span data-stu-id="30c12-256">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="30c12-257">Si vous spécifiez une très petite taille de pile, vous devrez peut-être désactiver la détection de débordement de pile.</span><span class="sxs-lookup"><span data-stu-id="30c12-257">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="30c12-258">Lors de la pile est sévèrement limitée, la détection peut elle-même provoquer un débordement de pile.</span><span class="sxs-lookup"><span data-stu-id="30c12-258">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="30c12-259">Pour désactiver la détection de dépassement de capacité de pile, ajoutez le code suivant au fichier de configuration de votre application.</span><span class="sxs-lookup"><span data-stu-id="30c12-259">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="30c12-260"><paramref name="start" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-260"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="30c12-261"><paramref name="maxStackSize" /> est inférieur à zéro.</span><span class="sxs-lookup"><span data-stu-id="30c12-261"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="30c12-262">Déclenche <see cref="T:System.Threading.ThreadAbortException" /> dans le thread sur lequel l'appel a lieu pour commencer le processus d'arrêt du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-262">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="30c12-263">L'appel de cette méthode arrête généralement le thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-263">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> <span data-ttu-id="30c12-264">Le `Thread.Abort` méthode doit être utilisée avec précaution.</span><span class="sxs-lookup"><span data-stu-id="30c12-264">The `Thread.Abort` method should be used with caution.</span></span> <span data-ttu-id="30c12-265">En particulier lorsque vous appelez l’abandon d’un thread autre que le thread actuel, vous ne connaissez pas ce que le code est exécuté ou a échoué à exécuter lorsque le <xref:System.Threading.ThreadAbortException> est levée, ni vous pouvez être certain de l’état de votre application ou n’importe quel état utilisateur et d’applications qu’il est responsable de la conservation.</span><span class="sxs-lookup"><span data-stu-id="30c12-265">Particularly when you call it to abort a thread other than the current thread, you do not know what code has executed or failed to execute when the <xref:System.Threading.ThreadAbortException> is thrown, nor can you be certain of the state of your application or any application and user state that it is responsible for preserving.</span></span> <span data-ttu-id="30c12-266">Par exemple, l’appel `Thread.Abort` peut empêcher l’exécution des constructeurs statiques ou empêcher la libération des ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="30c12-266">For example, calling `Thread.Abort` may prevent static constructors from executing or prevent the release of unmanaged resources.</span></span> 
>
> <span data-ttu-id="30c12-267">Notez que le `Thread.Abort` méthode n’est pas prise en charge sur .NET Core.</span><span class="sxs-lookup"><span data-stu-id="30c12-267">Note that the `Thread.Abort` method is not supported on .NET Core.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-268">Déclenche <see cref="T:System.Threading.ThreadAbortException" /> dans le thread sur lequel l'appel a lieu pour commencer le processus d'arrêt du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-268">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="30c12-269">L'appel de cette méthode arrête généralement le thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-269">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-270">Lorsque cette méthode est appelée sur un thread, le système lève une <xref:System.Threading.ThreadAbortException> dans le thread pour l’abandonner.</span><span class="sxs-lookup"><span data-stu-id="30c12-270">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="30c12-271">`ThreadAbortException` est une exception spéciale qui peut être interceptée par le code d’application, mais est à nouveau levée à la fin de la `catch` bloquer, sauf si <xref:System.Threading.Thread.ResetAbort%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="30c12-271">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="30c12-272">`ResetAbort` Annule la demande d’abandon et empêche le `ThreadAbortException` à partir de l’arrêt du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-272">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="30c12-273">Non `finally` blocs sont exécutés avant l’abandon du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-273">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-274">Lorsqu’un thread appelle `Abort` sur lui-même, l’effet est similaire à la levée d’une exception ; le <xref:System.Threading.ThreadAbortException> se produit immédiatement, et le résultat est prévisible.</span><span class="sxs-lookup"><span data-stu-id="30c12-274">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="30c12-275">Toutefois, si un thread appelle `Abort` sur un autre thread, l’abandon interrompt le code est en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="30c12-275">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="30c12-276">Il est également probable qu’un constructeur statique soit abandonné.</span><span class="sxs-lookup"><span data-stu-id="30c12-276">There is also a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="30c12-277">Dans de rares cas, ceci peut empêcher des instances de cette classe d’être créées dans ce domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="30c12-277">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="30c12-278">Dans les versions 1.0 et 1.1 du .NET Framework, il existe un risque le thread abandonné pendant un `finally` bloc est en cours d’exécution, auquel cas la `finally` bloc est abandonné.</span><span class="sxs-lookup"><span data-stu-id="30c12-278">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="30c12-279">Le thread n’est pas garanti pour abandonner immédiatement, ou du tout.</span><span class="sxs-lookup"><span data-stu-id="30c12-279">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="30c12-280">Cette situation peut se produire si un thread effectue un nombre illimité de calcul dans le `finally` blocs qui sont appelées dans le cadre de la procédure d’abandon, ce qui retarde indéfiniment l’abandon.</span><span class="sxs-lookup"><span data-stu-id="30c12-280">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="30c12-281">Pour attendre qu’un thread a abandonné, vous pouvez appeler la <xref:System.Threading.Thread.Join%2A> méthode sur le thread après avoir appelé la <xref:System.Threading.Thread.Abort%2A> (méthode), mais il n’existe aucune garantie que l’attente se termine.</span><span class="sxs-lookup"><span data-stu-id="30c12-281">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-282">Le thread qui appelle <xref:System.Threading.Thread.Abort%2A> peut se bloquer si le thread qui est en cours d’abandon est dans une zone protégée du code, comme un `catch` bloc, `finally` bloc ou la région d’exécution limitée.</span><span class="sxs-lookup"><span data-stu-id="30c12-282">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="30c12-283">Si le thread qui appelle <xref:System.Threading.Thread.Abort%2A> maintient un verrouillage que le thread interrompu requiert, un interblocage peut se produire.</span><span class="sxs-lookup"><span data-stu-id="30c12-283">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="30c12-284">Si `Abort` est appelée sur un thread qui n’a pas été démarré, le thread sera abandonnée lorsque <xref:System.Threading.Thread.Start%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="30c12-284">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="30c12-285">Si `Abort` est appelée sur un thread qui est bloqué ou en état de veille, le thread est interrompu et puis abandonné.</span><span class="sxs-lookup"><span data-stu-id="30c12-285">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="30c12-286">Si `Abort` est appelée sur un thread qui a été suspendu, un <xref:System.Threading.ThreadStateException> est levée dans le thread qui a appelé <xref:System.Threading.Thread.Abort%2A>, et <xref:System.Threading.ThreadState.AbortRequested> est ajouté à la <xref:System.Threading.Thread.ThreadState%2A> propriété du thread en cours d’abandon.</span><span class="sxs-lookup"><span data-stu-id="30c12-286">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="30c12-287">Un <xref:System.Threading.ThreadAbortException> n’est pas levée dans le thread suspendu jusqu'à ce que <xref:System.Threading.Thread.Resume%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="30c12-287">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="30c12-288">Si `Abort` est appelée sur un thread managé, tandis que l’exécution de code non managé, un `ThreadAbortException` n’est pas levée jusqu'à ce que le thread retourne au code managé.</span><span class="sxs-lookup"><span data-stu-id="30c12-288">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="30c12-289">Si deux appels à `Abort` sont fournis en même temps, il est possible qu’un seul appel à définir les informations d’état et l’autre appel pour exécuter le `Abort`.</span><span class="sxs-lookup"><span data-stu-id="30c12-289">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="30c12-290">Toutefois, une application ne peut pas détecter cette situation.</span><span class="sxs-lookup"><span data-stu-id="30c12-290">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="30c12-291">Après avoir `Abort` est appelé sur un thread, l’état du thread inclut <xref:System.Threading.ThreadState.AbortRequested>.</span><span class="sxs-lookup"><span data-stu-id="30c12-291">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="30c12-292">Une fois que le thread s’est arrêté suite à un appel réussi à `Abort`, l’état du thread est passé à <xref:System.Threading.ThreadState.Stopped>.</span><span class="sxs-lookup"><span data-stu-id="30c12-292">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="30c12-293">Avec des autorisations suffisantes, un thread qui est la cible d’une `Abort` peut annuler l’abandon à l’aide de la `ResetAbort` (méthode).</span><span class="sxs-lookup"><span data-stu-id="30c12-293">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="30c12-294">Pour obtenir un exemple qui montre comment appeler le `ResetAbort` (méthode), consultez la `ThreadAbortException` classe.</span><span class="sxs-lookup"><span data-stu-id="30c12-294">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="30c12-295">.NET Core uniquement : ce membre n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="30c12-295">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="30c12-296">L'appelant n'a pas l'autorisation requise.</span><span class="sxs-lookup"><span data-stu-id="30c12-296">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="30c12-297">Le thread en cours d’abandon est actuellement suspendu.</span><span class="sxs-lookup"><span data-stu-id="30c12-297">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="30c12-298">pour les opérations avancées sur les threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-298">for advanced operations on threads.</span></span> <span data-ttu-id="30c12-299">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-299">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="30c12-300">Threads et threading</span><span class="sxs-lookup"><span data-stu-id="30c12-300">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="30c12-301">Utilisation des threads et du threading</span><span class="sxs-lookup"><span data-stu-id="30c12-301">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="30c12-302">Détruire des threads</span><span class="sxs-lookup"><span data-stu-id="30c12-302">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="stateInfo"><span data-ttu-id="30c12-303">Objet contenant des informations spécifiques à l'application, telles que l'état, qui peuvent être utilisées par le thread en cours d'abandon.</span><span class="sxs-lookup"><span data-stu-id="30c12-303">An object that contains application-specific information, such as state, which can be used by the thread being aborted.</span></span></param>
        <summary><span data-ttu-id="30c12-304">Déclenche une <see cref="T:System.Threading.ThreadAbortException" /> dans le thread sur lequel l'appel a lieu pour commencer le processus d'arrêt du thread, tout en fournissant des informations sur les exceptions relatives à l'arrêt du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-304">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</span></span> <span data-ttu-id="30c12-305">L'appel de cette méthode arrête généralement le thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-305">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-306">Lorsque cette méthode est appelée sur un thread, le système lève une <xref:System.Threading.ThreadAbortException> dans le thread pour l’abandonner.</span><span class="sxs-lookup"><span data-stu-id="30c12-306">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="30c12-307">`ThreadAbortException` est une exception spéciale qui peut être interceptée par le code d’application, mais est à nouveau levée à la fin de la `catch` bloquer, sauf si <xref:System.Threading.Thread.ResetAbort%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="30c12-307">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="30c12-308">`ResetAbort` Annule la demande d’abandon et empêche le `ThreadAbortException` à partir de l’arrêt du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-308">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="30c12-309">Non `finally` blocs sont exécutés avant l’abandon du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-309">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-310">Lorsqu’un thread appelle `Abort` sur lui-même, l’effet est similaire à la levée d’une exception ; le <xref:System.Threading.ThreadAbortException> se produit immédiatement, et le résultat est prévisible.</span><span class="sxs-lookup"><span data-stu-id="30c12-310">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="30c12-311">Toutefois, si un thread appelle `Abort` sur un autre thread, l’abandon interrompt le code est en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="30c12-311">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="30c12-312">Il est probable qu’un constructeur statique soit abandonné.</span><span class="sxs-lookup"><span data-stu-id="30c12-312">There is a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="30c12-313">Dans de rares cas, ceci peut empêcher des instances de cette classe d’être créées dans ce domaine d’application.</span><span class="sxs-lookup"><span data-stu-id="30c12-313">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="30c12-314">Dans les versions 1.0 et 1.1 du .NET Framework, il existe un risque le thread abandonné pendant un `finally` bloc est en cours d’exécution, auquel cas la `finally` bloc est abandonné.</span><span class="sxs-lookup"><span data-stu-id="30c12-314">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="30c12-315">Le thread n’est pas garanti pour abandonner immédiatement, ou du tout.</span><span class="sxs-lookup"><span data-stu-id="30c12-315">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="30c12-316">Cette situation peut se produire si un thread effectue un nombre illimité de calcul dans le `finally` blocs qui sont appelées dans le cadre de la procédure d’abandon, ce qui retarde indéfiniment l’abandon.</span><span class="sxs-lookup"><span data-stu-id="30c12-316">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="30c12-317">Pour attendre qu’un thread a abandonné, vous pouvez appeler la <xref:System.Threading.Thread.Join%2A> méthode sur le thread après avoir appelé la <xref:System.Threading.Thread.Abort%2A> (méthode), mais il n’existe aucune garantie que l’attente se termine.</span><span class="sxs-lookup"><span data-stu-id="30c12-317">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee that the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-318">Le thread qui appelle <xref:System.Threading.Thread.Abort%2A> peut se bloquer si le thread qui est en cours d’abandon est dans une zone protégée du code, comme un `catch` bloc, `finally` bloc ou la région d’exécution limitée.</span><span class="sxs-lookup"><span data-stu-id="30c12-318">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="30c12-319">Si le thread qui appelle <xref:System.Threading.Thread.Abort%2A> maintient un verrouillage que le thread interrompu requiert, un interblocage peut se produire.</span><span class="sxs-lookup"><span data-stu-id="30c12-319">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="30c12-320">Si `Abort` est appelée sur un thread qui n’a pas été démarré, le thread sera abandonnée lorsque <xref:System.Threading.Thread.Start%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="30c12-320">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="30c12-321">Si `Abort` est appelée sur un thread qui est bloqué ou en état de veille, le thread est interrompu et puis abandonné.</span><span class="sxs-lookup"><span data-stu-id="30c12-321">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="30c12-322">Si `Abort` est appelée sur un thread qui a été suspendu, un <xref:System.Threading.ThreadStateException> est levée dans le thread qui a appelé <xref:System.Threading.Thread.Abort%2A>, et <xref:System.Threading.ThreadState.AbortRequested> est ajouté à la <xref:System.Threading.Thread.ThreadState%2A> propriété du thread en cours d’abandon.</span><span class="sxs-lookup"><span data-stu-id="30c12-322">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="30c12-323">Un <xref:System.Threading.ThreadAbortException> n’est pas levée dans le thread suspendu jusqu'à ce que <xref:System.Threading.Thread.Resume%2A> est appelée.</span><span class="sxs-lookup"><span data-stu-id="30c12-323">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="30c12-324">Si `Abort` est appelée sur un thread managé, tandis que l’exécution de code non managé, un `ThreadAbortException` n’est pas levée jusqu'à ce que le thread retourne au code managé.</span><span class="sxs-lookup"><span data-stu-id="30c12-324">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="30c12-325">Si deux appels à `Abort` sont fournis en même temps, il est possible qu’un seul appel à définir les informations d’état et l’autre appel pour exécuter le `Abort`.</span><span class="sxs-lookup"><span data-stu-id="30c12-325">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="30c12-326">Toutefois, une application ne peut pas détecter cette situation.</span><span class="sxs-lookup"><span data-stu-id="30c12-326">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="30c12-327">Après avoir `Abort` est appelé sur un thread, l’état du thread inclut <xref:System.Threading.ThreadState.AbortRequested>.</span><span class="sxs-lookup"><span data-stu-id="30c12-327">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="30c12-328">Une fois que le thread s’est arrêté suite à un appel réussi à `Abort`, l’état du thread est passé à <xref:System.Threading.ThreadState.Stopped>.</span><span class="sxs-lookup"><span data-stu-id="30c12-328">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="30c12-329">Avec des autorisations suffisantes, un thread qui est la cible d’une `Abort` peut annuler l’abandon à l’aide de la `ResetAbort` (méthode).</span><span class="sxs-lookup"><span data-stu-id="30c12-329">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="30c12-330">Pour obtenir un exemple qui montre comment appeler le `ResetAbort` (méthode), consultez la `ThreadAbortException` classe.</span><span class="sxs-lookup"><span data-stu-id="30c12-330">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-331">L’exemple de code suivant montre comment transmettre des informations à un thread qui est en cours d’abandon.</span><span class="sxs-lookup"><span data-stu-id="30c12-331">The following code example shows how to pass information to a thread that is being aborted.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="30c12-332">.NET Core uniquement : ce membre n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="30c12-332">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="30c12-333">L'appelant n'a pas l'autorisation requise.</span><span class="sxs-lookup"><span data-stu-id="30c12-333">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="30c12-334">Le thread en cours d’abandon est actuellement suspendu.</span><span class="sxs-lookup"><span data-stu-id="30c12-334">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="30c12-335">pour les opérations avancées sur les threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-335">for advanced operations on threads.</span></span> <span data-ttu-id="30c12-336">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-336">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="30c12-337">Threads et threading</span><span class="sxs-lookup"><span data-stu-id="30c12-337">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="30c12-338">Utilisation des threads et du threading</span><span class="sxs-lookup"><span data-stu-id="30c12-338">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="30c12-339">Détruire des threads</span><span class="sxs-lookup"><span data-stu-id="30c12-339">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-340">Alloue sur tous les threads un emplacement de données sans nom.</span><span class="sxs-lookup"><span data-stu-id="30c12-340">Allocates an unnamed data slot on all the threads.</span></span> <span data-ttu-id="30c12-341">Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-341">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="30c12-342">Emplacement de données nommé alloué sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-342">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="30c12-343">Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <xref:System.ThreadStaticAttribute> attribut) et emplacements de données.</span><span class="sxs-lookup"><span data-stu-id="30c12-343">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="30c12-344">Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="30c12-344">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="30c12-345">Pour plus d’informations sur l’utilisation de TLS, consultez [stockage Local des threads : Les champs statiques relatifs à un thread et emplacements de données](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="30c12-345">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="30c12-346">L’emplacement est alloué sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-346">The slot is allocated on all threads.</span></span>  
  
 <span data-ttu-id="30c12-347">Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-347">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="30c12-348">Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création.</span><span class="sxs-lookup"><span data-stu-id="30c12-348">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="30c12-349">Le thread peut allouer un emplacement de données dans le magasin de données, stockez et récupérez une données valeur dans l’emplacement et libérer l’emplacement pour une réutilisation après l’expiration du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-349">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="30c12-350">Emplacements de données sont uniques pour chaque thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-350">Data slots are unique per thread.</span></span> <span data-ttu-id="30c12-351">Aucun autre thread (pas même un thread enfant) ne peut obtenir les données.</span><span class="sxs-lookup"><span data-stu-id="30c12-351">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-352">Cette section contient deux exemples de code.</span><span class="sxs-lookup"><span data-stu-id="30c12-352">This section contains two code examples.</span></span> <span data-ttu-id="30c12-353">Le premier exemple montre comment utiliser un champ est marqué avec le <xref:System.ThreadStaticAttribute> attribut devant contenir les informations spécifiques aux threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-353">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="30c12-354">Le deuxième exemple montre comment utiliser un emplacement de données pour faire la même chose.</span><span class="sxs-lookup"><span data-stu-id="30c12-354">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="30c12-355">**Premier exemple**</span><span class="sxs-lookup"><span data-stu-id="30c12-355">**First Example**</span></span>  
  
 <span data-ttu-id="30c12-356">L’exemple suivant montre comment utiliser un champ est marqué avec <xref:System.ThreadStaticAttribute> pour contenir des informations spécifiques au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-356">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="30c12-357">Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.</span><span class="sxs-lookup"><span data-stu-id="30c12-357">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="30c12-358">**Deuxième exemple**</span><span class="sxs-lookup"><span data-stu-id="30c12-358">**Second Example**</span></span>  
  
 <span data-ttu-id="30c12-359">L’exemple de code suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-359">The following code example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="30c12-360">Threads et threading</span><span class="sxs-lookup"><span data-stu-id="30c12-360">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="30c12-361">Stockage local des threads : champs static et emplacements de données relatifs à un thread</span><span class="sxs-lookup"><span data-stu-id="30c12-361">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="30c12-362">Nom de l'emplacement de données à allouer.</span><span class="sxs-lookup"><span data-stu-id="30c12-362">The name of the data slot to be allocated.</span></span></param>
        <summary><span data-ttu-id="30c12-363">Alloue sur tous les threads un emplacement de données nommé.</span><span class="sxs-lookup"><span data-stu-id="30c12-363">Allocates a named data slot on all threads.</span></span> <span data-ttu-id="30c12-364">Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-364">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="30c12-365">Emplacement de données nommé alloué sur tous les threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-365">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="30c12-366">Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <xref:System.ThreadStaticAttribute> attribut) et emplacements de données.</span><span class="sxs-lookup"><span data-stu-id="30c12-366">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="30c12-367">Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="30c12-367">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="30c12-368">Pour plus d’informations sur l’utilisation de TLS, consultez [stockage Local des threads : Les champs statiques relatifs à un thread et emplacements de données](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="30c12-368">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="30c12-369">Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-369">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="30c12-370">Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création.</span><span class="sxs-lookup"><span data-stu-id="30c12-370">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="30c12-371">Le thread peut allouer un emplacement de données dans le magasin de données, stockez et récupérez une données valeur dans l’emplacement et libérer l’emplacement pour une réutilisation après l’expiration du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-371">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="30c12-372">Emplacements de données sont uniques pour chaque thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-372">Data slots are unique per thread.</span></span> <span data-ttu-id="30c12-373">Aucun autre thread (pas même un thread enfant) ne peut obtenir les données.</span><span class="sxs-lookup"><span data-stu-id="30c12-373">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="30c12-374">Il n’est pas nécessaire d’utiliser le <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> (méthode) à allouer un emplacement de données, car le <xref:System.Threading.Thread.GetNamedDataSlot%2A> méthode alloue l’emplacement s’il n’a pas déjà été alloué.</span><span class="sxs-lookup"><span data-stu-id="30c12-374">It is not necessary to use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method to allocate a named data slot, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-375">Si le <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> méthode est utilisée, elle doit être appelée dans le thread principal au démarrage du programme, car elle lève une exception si un emplacement avec le nom spécifié a déjà été alloué.</span><span class="sxs-lookup"><span data-stu-id="30c12-375">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</span></span> <span data-ttu-id="30c12-376">Il n’existe aucun moyen pour déterminer si un emplacement a déjà été alloué.</span><span class="sxs-lookup"><span data-stu-id="30c12-376">There is no way to test whether a slot has already been allocated.</span></span>  
  
 <span data-ttu-id="30c12-377">Emplacements alloués avec cette méthode doivent être libérées avec <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-377">Slots allocated with this method must be freed with <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-378">Cette section contient deux exemples de code.</span><span class="sxs-lookup"><span data-stu-id="30c12-378">This section contains two code examples.</span></span> <span data-ttu-id="30c12-379">Le premier exemple montre comment utiliser un champ est marqué avec le <xref:System.ThreadStaticAttribute> attribut devant contenir les informations spécifiques aux threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-379">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="30c12-380">Le deuxième exemple montre comment utiliser un emplacement de données pour faire la même chose.</span><span class="sxs-lookup"><span data-stu-id="30c12-380">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="30c12-381">**Premier exemple**</span><span class="sxs-lookup"><span data-stu-id="30c12-381">**First Example**</span></span>  
  
 <span data-ttu-id="30c12-382">L’exemple suivant montre comment utiliser un champ est marqué avec <xref:System.ThreadStaticAttribute> pour contenir des informations spécifiques au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-382">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="30c12-383">Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.</span><span class="sxs-lookup"><span data-stu-id="30c12-383">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="30c12-384">**Deuxième exemple**</span><span class="sxs-lookup"><span data-stu-id="30c12-384">**Second Example**</span></span>  
  
 <span data-ttu-id="30c12-385">L’exemple suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-385">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-386">L’exemple de code n’utilise pas le <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> (méthode), car le <xref:System.Threading.Thread.GetNamedDataSlot%2A> méthode alloue l’emplacement s’il n’a pas déjà été alloué.</span><span class="sxs-lookup"><span data-stu-id="30c12-386">The example code does not use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span> <span data-ttu-id="30c12-387">Si le <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> méthode est utilisée, elle doit être appelée dans le thread principal au démarrage du programme.</span><span class="sxs-lookup"><span data-stu-id="30c12-387">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="30c12-388">Un emplacement de données portant le nom spécifié existe déjà.</span><span class="sxs-lookup"><span data-stu-id="30c12-388">A named data slot with the specified name already exists.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="30c12-389">Threads et threading</span><span class="sxs-lookup"><span data-stu-id="30c12-389">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="30c12-390">Stockage local des threads : champs static et emplacements de données relatifs à un thread</span><span class="sxs-lookup"><span data-stu-id="30c12-390">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="30c12-391">Obtient ou définit l'état de cloisonnement de ce thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-391">Gets or sets the apartment state of this thread.</span></span></summary>
        <value><span data-ttu-id="30c12-392">Une des valeurs de <see cref="T:System.Threading.ApartmentState" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-392">One of the <see cref="T:System.Threading.ApartmentState" /> values.</span></span> <span data-ttu-id="30c12-393">La valeur initiale est <see langword="Unknown" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-393">The initial value is <see langword="Unknown" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-394">**Le <xref:System.Threading.Thread.ApartmentState%2A> propriété est obsolète.**</span><span class="sxs-lookup"><span data-stu-id="30c12-394">**The <xref:System.Threading.Thread.ApartmentState%2A> property is obsolete.**</span></span>  <span data-ttu-id="30c12-395">Les alternatives non obsolète sont le <xref:System.Threading.Thread.GetApartmentState%2A> méthode pour récupérer l’état de cloisonnement et le <xref:System.Threading.Thread.SetApartmentState%2A> pour définir l’état de cloisonnement.</span><span class="sxs-lookup"><span data-stu-id="30c12-395">The non-obsolete alternatives are the <xref:System.Threading.Thread.GetApartmentState%2A> method to retrieve the apartment state and the   <xref:System.Threading.Thread.SetApartmentState%2A> method to set the apartment state.</span></span>  
  
 <span data-ttu-id="30c12-396">Dans les versions de .NET Framework 1.0 et 1.1, le `ApartmentState` propriété marque un thread pour indiquer qu’il s’exécute dans un cloisonnement monothread ou multithread.</span><span class="sxs-lookup"><span data-stu-id="30c12-396">In the .NET Framework versions 1.0 and 1.1, the `ApartmentState` property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</span></span> <span data-ttu-id="30c12-397">Cette propriété peut être définie lorsque le thread est dans le `Unstarted` ou `Running` thread état ; Toutefois, elle peut être définie qu’une seule fois pour un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-397">This property can be set when the thread is in the `Unstarted` or `Running` thread state; however, it can be set only once for a thread.</span></span> <span data-ttu-id="30c12-398">Si la propriété n’a pas été définie, elle retourne `Unknown`.</span><span class="sxs-lookup"><span data-stu-id="30c12-398">If the property has not been set, it returns `Unknown`.</span></span>  
  
 <span data-ttu-id="30c12-399">Une tentative d’utilisation le <xref:System.Threading.Thread.ApartmentState%2A> propriété à définir l’état de cloisonnement d’un thread dont l’état de cloisonnement a déjà été défini est ignorée.</span><span class="sxs-lookup"><span data-stu-id="30c12-399">An attempt to use the <xref:System.Threading.Thread.ApartmentState%2A> property to set the apartment state of a thread whose apartment state has already been set is ignored.</span></span> <span data-ttu-id="30c12-400">Toutefois, le <xref:System.Threading.Thread.SetApartmentState%2A> méthode lève un <xref:System.InvalidOperationException> dans ce cas.</span><span class="sxs-lookup"><span data-stu-id="30c12-400">However, the <xref:System.Threading.Thread.SetApartmentState%2A> method throws a <xref:System.InvalidOperationException> in this case.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="30c12-401">Dans le .NET Framework version 2.0, les nouveaux threads sont initialisés en tant que <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> si leur état de cloisonnement n’a pas été défini avant leur démarrage.</span><span class="sxs-lookup"><span data-stu-id="30c12-401">In the .NET Framework version 2.0, new threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="30c12-402">Le thread principal de l’application est initialisé à <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> par défaut.</span><span class="sxs-lookup"><span data-stu-id="30c12-402">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="30c12-403">Vous ne pouvez plus définir le thread principal de l’application <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> en définissant le <xref:System.Threading.ApartmentState?displayProperty=nameWithType> propriété sur la première ligne de code.</span><span class="sxs-lookup"><span data-stu-id="30c12-403">You can no longer set the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> by setting the <xref:System.Threading.ApartmentState?displayProperty=nameWithType> property on the first line of code.</span></span> <span data-ttu-id="30c12-404">Utilisez le <xref:System.STAThreadAttribute> à la place.</span><span class="sxs-lookup"><span data-stu-id="30c12-404">Use the <xref:System.STAThreadAttribute> instead.</span></span>  
  
 <span data-ttu-id="30c12-405">Dans le .NET Framework version 2.0, vous pouvez spécifier le modèle pour une application C++ à l’aide de thread COM le [/CLRTHREADATTRIBUTE (définir l’attribut de Thread CLR)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) option de l’éditeur de liens.</span><span class="sxs-lookup"><span data-stu-id="30c12-405">In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) linker option.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-406">L’exemple de code suivant montre comment définir l’état de cloisonnement d’un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-406">The following code example demonstrates how to set the apartment state of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="30c12-407">Une tentative est effectuée pour définir cette propriété sur un état qui n’est pas un état de cloisonnement valide (un état autre que celui de thread unique cloisonné (<see langword="STA" />) ou de multithread cloisonné (<see langword="MTA" />)).</span><span class="sxs-lookup"><span data-stu-id="30c12-407">An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<see langword="STA" />) or multithreaded apartment (<see langword="MTA" />)).</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-408">Avertit un hôte que l'exécution est sur le point d'entrer dans une zone de code dans laquelle les effets d'un abandon de thread ou d'une exception non gérée peuvent compromettre d'autres tâches dans le domaine d'application.</span><span class="sxs-lookup"><span data-stu-id="30c12-408">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-409">Les hôtes du common language runtime (CLR), tel que Microsoft SQL Server 2005, peuvent établir des stratégies différentes pour les erreurs dans les régions de code critiques et non critiques.</span><span class="sxs-lookup"><span data-stu-id="30c12-409">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="30c12-410">Une zone critique est un dans lesquels les effets d’un abandon de thread ou une exception non gérée ne peuvent pas être limités à la tâche actuelle.</span><span class="sxs-lookup"><span data-stu-id="30c12-410">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="30c12-411">En revanche, un abandon ou une défaillance dans une région de code non critique affecte uniquement la tâche dans laquelle l’erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="30c12-411">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="30c12-412">Par exemple, considérez une tâche qui tente d’allouer de la mémoire tout en maintenant un verrou.</span><span class="sxs-lookup"><span data-stu-id="30c12-412">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="30c12-413">Si l’allocation de mémoire échoue, l’abandon de la tâche en cours n’est pas suffisante pour assurer la stabilité de le <xref:System.AppDomain>, car il peut y avoir des autres tâches dans le domaine en attente pour le même verrou.</span><span class="sxs-lookup"><span data-stu-id="30c12-413">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="30c12-414">Si la tâche en cours est arrêtée, les autres tâches peuvent être bloquées.</span><span class="sxs-lookup"><span data-stu-id="30c12-414">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="30c12-415">En cas de défaillance dans une zone critique, l’hôte peut décider de décharger l’intégralité de <xref:System.AppDomain> plutôt que de prendre le risque de continuer l’exécution dans un état potentiellement instable.</span><span class="sxs-lookup"><span data-stu-id="30c12-415">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="30c12-416">Pour informer l’hôte que votre code entre dans une zone critique, appelez <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-416">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="30c12-417">Appelez <xref:System.Threading.Thread.EndCriticalRegion%2A> lorsque l’exécution retourne dans une région non critique de code.</span><span class="sxs-lookup"><span data-stu-id="30c12-417">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="30c12-418">À l’aide de cette méthode dans le code qui s’exécute sous SQL Server 2005 nécessite le code à exécuter sur le niveau de protection de l’hôte le plus élevé.</span><span class="sxs-lookup"><span data-stu-id="30c12-418">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-419">L’exemple suivant illustre l’utilisation de la <xref:System.Threading.Thread.BeginCriticalRegion%2A> et <xref:System.Threading.Thread.EndCriticalRegion%2A> méthodes pour diviser un bloc de code en régions critiques et non critiques.</span><span class="sxs-lookup"><span data-stu-id="30c12-419">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-420">Avertit un hôte que le code managé est sur le point d'exécuter des instructions qui dépendent de l'identité du thread du système d'exploitation physique actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-420">Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-421">Certains hôtes du common language runtime, tels que Microsoft SQL Server 2005, fournissent leur propre gestion de threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-421">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="30c12-422">Un hôte qui fournit sa propre gestion des threads peut déplacer une tâche en cours d’exécution d’un thread de système d’exploitation physique vers un autre à tout moment.</span><span class="sxs-lookup"><span data-stu-id="30c12-422">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="30c12-423">La plupart des tâches ne sont pas affectées par ce basculement.</span><span class="sxs-lookup"><span data-stu-id="30c12-423">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="30c12-424">Toutefois, certaines tâches ont une affinité de thread : autrement dit, ils dépendent de l’identité d’un thread de système d’exploitation physique.</span><span class="sxs-lookup"><span data-stu-id="30c12-424">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="30c12-425">Ces tâches doivent informer l’hôte lorsqu’elles exécutent du code qui ne doit pas être basculée.</span><span class="sxs-lookup"><span data-stu-id="30c12-425">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="30c12-426">Par exemple, si votre application appelle une API système pour acquérir un système d’exploitation de verrouillage qui possède l’affinité de thread, telles que Win32 CRITICAL_SECTION, vous devez appeler <xref:System.Threading.Thread.BeginThreadAffinity%2A> avant d’acquérir le verrou, et <xref:System.Threading.Thread.EndThreadAffinity%2A> après l’avoir libéré le verrou.</span><span class="sxs-lookup"><span data-stu-id="30c12-426">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="30c12-427">À l’aide de cette méthode dans le code qui s’exécute sous SQL Server 2005 nécessite le code à exécuter sur le niveau de protection de l’hôte le plus élevé.</span><span class="sxs-lookup"><span data-stu-id="30c12-427">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-428">L’exemple suivant illustre l’utilisation de la <xref:System.Threading.Thread.BeginThreadAffinity%2A> et <xref:System.Threading.Thread.EndThreadAffinity%2A> méthodes pour avertir un hôte qu’un bloc de code dépend de l’identité d’un thread de système d’exploitation physique.</span><span class="sxs-lookup"><span data-stu-id="30c12-428">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="30c12-429">L'appelant n'a pas l'autorisation requise.</span><span class="sxs-lookup"><span data-stu-id="30c12-429">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="30c12-430">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="30c12-430">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="30c12-431">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="30c12-431">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="30c12-432">Obtient le contexte actuel dans lequel le thread s'exécute.</span><span class="sxs-lookup"><span data-stu-id="30c12-432">Gets the current context in which the thread is executing.</span></span></summary>
        <value><span data-ttu-id="30c12-433"><see cref="T:System.Runtime.Remoting.Contexts.Context" /> représentant le contexte actuel du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-433">A <see cref="T:System.Runtime.Remoting.Contexts.Context" /> representing the current thread context.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="30c12-434">L'appelant n'a pas l'autorisation requise.</span><span class="sxs-lookup"><span data-stu-id="30c12-434">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="30c12-435">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="30c12-435">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="30c12-436">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="30c12-436">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="30c12-437">Obtient ou définit la culture du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-437">Gets or sets the culture for the current thread.</span></span></summary>
        <value><span data-ttu-id="30c12-438">Objet qui représente la culture du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-438">An object that represents the culture for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-439">Le <xref:System.Globalization.CultureInfo> objet qui est retourné par cette propriété, ainsi que ses objets associés, déterminer le format par défaut pour les dates, heures, nombres, les valeurs de devise, l’ordre de tri du texte, conventions de casse et les comparaisons de chaînes.</span><span class="sxs-lookup"><span data-stu-id="30c12-439">The <xref:System.Globalization.CultureInfo> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</span></span> <span data-ttu-id="30c12-440">Consultez la <xref:System.Globalization.CultureInfo> classe pour en savoir plus sur les noms de culture et les identificateurs, les différences entre les cultures invariants, neutres et spécifiques, ainsi que les façon dont les informations de culture affectent les domaines d’application et les threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-440">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="30c12-441">Consultez le <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriété pour savoir comment est déterminée la culture par défaut d’un thread, et comment les utilisateurs définir les informations de culture pour leurs ordinateurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-441">See the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="30c12-442">Le <xref:System.Threading.Thread.CurrentCulture> propriété ne fonctionne de façon fiable lorsqu’il est utilisé avec n’importe quel thread autre que le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-442">The <xref:System.Threading.Thread.CurrentCulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="30c12-443">Dans .NET Framework, la lecture de la propriété est fiable, bien que la définition pour un thread autre que le thread actuel n’est pas.</span><span class="sxs-lookup"><span data-stu-id="30c12-443">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="30c12-444">Sur .NET Core, une <xref:System.InvalidOperationException> est levée si un thread tente de lire ou écrire le <xref:System.Threading.Thread.CurrentCulture> propriété sur un thread différent.</span><span class="sxs-lookup"><span data-stu-id="30c12-444">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentCulture> property on a different thread.</span></span>
> <span data-ttu-id="30c12-445">Nous vous recommandons d’utiliser le <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> propriété pour récupérer et définir la culture actuelle.</span><span class="sxs-lookup"><span data-stu-id="30c12-445">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="30c12-446">Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], vous pouvez définir le <xref:System.Threading.Thread.CurrentCulture%2A> propriété à une culture neutre.</span><span class="sxs-lookup"><span data-stu-id="30c12-446">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], you can set the <xref:System.Threading.Thread.CurrentCulture%2A> property to a neutral culture.</span></span> <span data-ttu-id="30c12-447">Il s’agit, car le comportement de la <xref:System.Globalization.CultureInfo> classe a été modifiée : Lorsqu’il représente une culture neutre, ses valeurs de propriété (en particulier, le <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, et <xref:System.Globalization.CultureInfo.TextInfo%2A> propriétés) indiquent désormais la culture spécifique associée à la culture neutre.</span><span class="sxs-lookup"><span data-stu-id="30c12-447">This is because the behavior of the <xref:System.Globalization.CultureInfo> class has changed: When it represents a neutral culture, its property values (in particular, the <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, and <xref:System.Globalization.CultureInfo.TextInfo%2A> properties) now reflect the specific culture that is associated with the neutral culture.</span></span> <span data-ttu-id="30c12-448">Dans les versions antérieures du .NET Framework, le <xref:System.Threading.Thread.CurrentCulture%2A> propriété a levé une <xref:System.NotSupportedException> exception lorsqu’une culture neutre a été affectée.</span><span class="sxs-lookup"><span data-stu-id="30c12-448">In earlier versions of the .NET Framework, the <xref:System.Threading.Thread.CurrentCulture%2A> property threw a <xref:System.NotSupportedException> exception when a neutral culture was assigned.</span></span>  
  
## Examples  
 <span data-ttu-id="30c12-449">L’exemple suivant montre l’instruction de thread qui permet à l’interface utilisateur d’une application Windows Forms à afficher dans la culture qui est définie dans le panneau de configuration.</span><span class="sxs-lookup"><span data-stu-id="30c12-449">The following example shows the threading statement that allows the user interface of a Windows Forms application to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="30c12-450">Code supplémentaire est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="30c12-450">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="30c12-451">La propriété est définie sur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-451">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="30c12-452">.NET Core uniquement : la lecture ou l’écriture de la culture d’un thread à partir d’un autre thread n’est pas prise en charge.</span><span class="sxs-lookup"><span data-stu-id="30c12-452">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="30c12-453">Pour définir la propriété.</span><span class="sxs-lookup"><span data-stu-id="30c12-453">for setting the property.</span></span> <span data-ttu-id="30c12-454">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="30c12-454">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="30c12-455">Obtient ou définit le principal actuel du thread (pour une sécurité basée sur les rôles).</span><span class="sxs-lookup"><span data-stu-id="30c12-455">Gets or sets the thread's current principal (for role-based security).</span></span></summary>
        <value><span data-ttu-id="30c12-456">Valeur <see cref="T:System.Security.Principal.IPrincipal" /> représentant le contexte de sécurité.</span><span class="sxs-lookup"><span data-stu-id="30c12-456">An <see cref="T:System.Security.Principal.IPrincipal" /> value representing the security context.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="30c12-457">L’exemple de code suivant montre comment définir et récupérer l’entité de sécurité d’un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-457">The following code example shows how to set and retrieve the principal of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="30c12-458">L’appelant n’a pas l’autorisation nécessaire pour définir le principal.</span><span class="sxs-lookup"><span data-stu-id="30c12-458">The caller does not have the permission required to set the principal.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="30c12-459">pour manipuler l’objet principal.</span><span class="sxs-lookup"><span data-stu-id="30c12-459">to manipulate the principal object.</span></span> <span data-ttu-id="30c12-460">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-460">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="30c12-461">Obtient le thread en cours d'exécution.</span><span class="sxs-lookup"><span data-stu-id="30c12-461">Gets the currently running thread.</span></span></summary>
        <value><span data-ttu-id="30c12-462"><see cref="T:System.Threading.Thread" /> constituant la représentation du thread en cours d'exécution.</span><span class="sxs-lookup"><span data-stu-id="30c12-462">A <see cref="T:System.Threading.Thread" /> that is the representation of the currently running thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="30c12-463">L’exemple suivant crée une tâche qui crée à son tour 20 tâches enfants.</span><span class="sxs-lookup"><span data-stu-id="30c12-463">The following example creates a task that in turn creates 20 child tasks.</span></span> <span data-ttu-id="30c12-464">L’application elle-même, en tant que bien que chaque tâche, appelle le `ShowThreadInformation` (méthode), qui utilise le <xref:System.Threading.Thread.CurrentThread%2A> propriété à afficher des informations sur le thread sur lequel il est en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="30c12-464">The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the <xref:System.Threading.Thread.CurrentThread%2A> property  to display information about the thread on which it is running.</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 <span data-ttu-id="30c12-465">Chaque tâche enfant génère 1 million de nombres aléatoires compris entre 1 et 1 million et retourne leur moyenne.</span><span class="sxs-lookup"><span data-stu-id="30c12-465">Each child task generates 1 million random numbers between 1 and 1 million and returns their mean.</span></span> <span data-ttu-id="30c12-466">Les appels de la tâche parent la <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> méthode pour vous assurer que les tâches enfants terminées avant d’afficher la moyenne retournée par chaque tâche et en calculant la moyenne des moyens.</span><span class="sxs-lookup"><span data-stu-id="30c12-466">The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.</span></span>  
  
 <span data-ttu-id="30c12-467">Notez que pendant que l’application s’exécute sur un thread de premier plan, chaque tâche s’exécute sur un thread de pool de threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-467">Note that while the application runs on a foreground thread, each task runs on a thread pool thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="30c12-468">Obtient ou définit la culture actuelle utilisée par le Gestionnaire de ressources pour rechercher des ressources spécifiques à la culture au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="30c12-468">Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</span></span></summary>
        <value><span data-ttu-id="30c12-469">Objet qui représente la culture actuelle.</span><span class="sxs-lookup"><span data-stu-id="30c12-469">An object that represents the current culture.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-470">La culture d’interface utilisateur spécifie les ressources d’une application doit prendre en charge l’entrée d’utilisateur et de sortie et par défaut est identique à la culture du système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="30c12-470">The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</span></span> <span data-ttu-id="30c12-471">Consultez la <xref:System.Globalization.CultureInfo> classe pour en savoir plus sur les noms de culture et les identificateurs, les différences entre les cultures invariants, neutres et spécifiques, ainsi que les façon dont les informations de culture affectent les domaines d’application et les threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-471">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="30c12-472">Consultez le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété pour en savoir plus de la détermination de la culture d’interface utilisateur d’un thread par défaut.</span><span class="sxs-lookup"><span data-stu-id="30c12-472">See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> property to learn how a thread's default UI culture is determined.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="30c12-473">Le <xref:System.Threading.Thread.CurrentUICulture> propriété ne fonctionne de façon fiable lorsqu’il est utilisé avec n’importe quel thread autre que le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-473">The <xref:System.Threading.Thread.CurrentUICulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="30c12-474">Dans .NET Framework, la lecture de la propriété est fiable, bien que la définition pour un thread autre que le thread actuel n’est pas.</span><span class="sxs-lookup"><span data-stu-id="30c12-474">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="30c12-475">Sur .NET Core, une <xref:System.InvalidOperationException> est levée si un thread tente de lire ou écrire le <xref:System.Threading.Thread.CurrentUICulture> propriété sur un thread différent.</span><span class="sxs-lookup"><span data-stu-id="30c12-475">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentUICulture> property on a different thread.</span></span>
> <span data-ttu-id="30c12-476">Nous vous recommandons d’utiliser le <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> propriété pour récupérer et définir la culture actuelle.</span><span class="sxs-lookup"><span data-stu-id="30c12-476">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="30c12-477">Le <xref:System.Globalization.CultureInfo> retourné par cette propriété peut être une culture neutre.</span><span class="sxs-lookup"><span data-stu-id="30c12-477">The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture.</span></span> <span data-ttu-id="30c12-478">Cultures neutres ne doivent pas être utilisées avec mise en forme de méthodes telles que <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, et <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="30c12-478">Neutral cultures should not be used with formatting methods such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="30c12-479">Utiliser le <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> méthode pour obtenir une culture spécifique, ou utilisez le <xref:System.Threading.Thread.CurrentCulture%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="30c12-479">Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-480">Le <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> méthode lève une exception <xref:System.ArgumentException> pour les cultures neutres « zh-Hant » (« zh-CHT ») et « zh-Hans » (« zh-CHS »).</span><span class="sxs-lookup"><span data-stu-id="30c12-480">The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method throws <xref:System.ArgumentException> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-481">L’exemple suivant détermine si la langue de la culture d’interface utilisateur du thread actuel est le Français.</span><span class="sxs-lookup"><span data-stu-id="30c12-481">The following example determines whether the language of the current thread's UI culture is French.</span></span> <span data-ttu-id="30c12-482">Si elle n’est pas le cas, il définit la culture d’interface utilisateur du thread actuel vers l’anglais (États-Unis).</span><span class="sxs-lookup"><span data-stu-id="30c12-482">If it is not, it sets the UI culture of the current thread to English (United States).</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 <span data-ttu-id="30c12-483">L’exemple de code suivant montre l’instruction de thread qui permet à l’interface utilisateur d’un formulaire Windows à afficher dans la culture qui est définie dans le panneau de configuration.</span><span class="sxs-lookup"><span data-stu-id="30c12-483">The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="30c12-484">Code supplémentaire est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="30c12-484">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="30c12-485">La propriété est définie sur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-485">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="30c12-486">La propriété a la valeur d’un nom de culture qui ne peut pas être utilisé pour localiser un fichier de ressources.</span><span class="sxs-lookup"><span data-stu-id="30c12-486">The property is set to a culture name that cannot be used to locate a resource file.</span></span> <span data-ttu-id="30c12-487">Les noms de fichiers des ressources doivent inclure uniquement des lettres, des chiffres, des traits d’union ou des traits de soulignement.</span><span class="sxs-lookup"><span data-stu-id="30c12-487">Resource filenames must include only letters, numbers, hyphens or underscores.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="30c12-488">.NET Core uniquement : la lecture ou l’écriture de la culture d’un thread à partir d’un autre thread n’est pas prise en charge.</span><span class="sxs-lookup"><span data-stu-id="30c12-488">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-489">Désactive le nettoyage automatique des wrappers RCW (Runtime Callable Wrapper) pour le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-489">Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-490">Par défaut, le common language runtime (CLR) nettoie automatiquement les wrappers RCW.</span><span class="sxs-lookup"><span data-stu-id="30c12-490">By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</span></span> <span data-ttu-id="30c12-491">Les CLR pompe des messages pendant le nettoyage, ce qui peut provoquer des problèmes de réentrance pour quelques applications qui répondent aux critères inhabituels suivants :</span><span class="sxs-lookup"><span data-stu-id="30c12-491">The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</span></span>  
  
-   <span data-ttu-id="30c12-492">L’application effectue son propre pompage des messages.</span><span class="sxs-lookup"><span data-stu-id="30c12-492">The application does its own message pumping.</span></span>  
  
-   <span data-ttu-id="30c12-493">L’application doit contrôler précisément lorsque le pompage de messages se produit.</span><span class="sxs-lookup"><span data-stu-id="30c12-493">The application needs to control precisely when message pumping occurs.</span></span>  
  
 <span data-ttu-id="30c12-494">Ces applications peuvent utiliser le <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> méthode pour empêcher le CLR d’effectuer une récupération automatique du runtime callable wrapper.</span><span class="sxs-lookup"><span data-stu-id="30c12-494">Such applications can use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</span></span>  
  
 <span data-ttu-id="30c12-495">Lorsque cette méthode a été appelée sur un thread, le nettoyage automatique ne peut pas être réactivé pour ce thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-495">When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</span></span> <span data-ttu-id="30c12-496">Lorsque votre application est prête nettoyer les wrappers RCW, utilisez le <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> méthode pour demander au runtime de nettoyer tous les wrappers RCW dans le contexte actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-496">When your application is ready to clean up runtime callable wrappers, use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</span></span> <span data-ttu-id="30c12-497">Pompage de messages se produit pendant que la méthode s’exécute.</span><span class="sxs-lookup"><span data-stu-id="30c12-497">Message pumping occurs while the method executes.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="30c12-498">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="30c12-498">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="30c12-499">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="30c12-499">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-500">Avertit un hôte que l’exécution est sur le point d’entrer dans une zone de code dans laquelle les effets d’un abandon de thread ou d’une exception non gérée sont limités à la tâche actuelle.</span><span class="sxs-lookup"><span data-stu-id="30c12-500">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-501">Les hôtes du common language runtime (CLR), tel que Microsoft SQL Server 2005, peuvent établir des stratégies différentes pour les erreurs dans les régions de code critiques et non critiques.</span><span class="sxs-lookup"><span data-stu-id="30c12-501">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="30c12-502">Une zone critique est un dans lesquels les effets d’un abandon de thread ou une exception non gérée ne peuvent pas être limités à la tâche actuelle.</span><span class="sxs-lookup"><span data-stu-id="30c12-502">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="30c12-503">En revanche, un abandon ou une défaillance dans une région de code non critique affecte uniquement la tâche dans laquelle l’erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="30c12-503">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="30c12-504">Par exemple, considérez une tâche qui tente d’allouer de la mémoire tout en maintenant un verrou.</span><span class="sxs-lookup"><span data-stu-id="30c12-504">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="30c12-505">Si l’allocation de mémoire échoue, l’abandon de la tâche en cours n’est pas suffisante pour assurer la stabilité de le <xref:System.AppDomain>, car il peut y avoir des autres tâches dans le domaine en attente pour le même verrou.</span><span class="sxs-lookup"><span data-stu-id="30c12-505">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="30c12-506">Si la tâche en cours est arrêtée, les autres tâches peuvent être bloquées.</span><span class="sxs-lookup"><span data-stu-id="30c12-506">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="30c12-507">En cas de défaillance dans une zone critique, l’hôte peut décider de décharger l’intégralité de <xref:System.AppDomain> plutôt que de prendre le risque de continuer l’exécution dans un état potentiellement instable.</span><span class="sxs-lookup"><span data-stu-id="30c12-507">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="30c12-508">Pour informer l’hôte que votre code entre dans une zone critique, appelez <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-508">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="30c12-509">Appelez <xref:System.Threading.Thread.EndCriticalRegion%2A> lorsque l’exécution retourne dans une région non critique de code.</span><span class="sxs-lookup"><span data-stu-id="30c12-509">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="30c12-510">À l’aide de cette méthode dans le code qui s’exécute sous SQL Server 2005 nécessite le code à exécuter sur le niveau de protection de l’hôte le plus élevé.</span><span class="sxs-lookup"><span data-stu-id="30c12-510">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-511">L’exemple suivant illustre l’utilisation de la <xref:System.Threading.Thread.BeginCriticalRegion%2A> et <xref:System.Threading.Thread.EndCriticalRegion%2A> méthodes pour diviser un bloc de code en régions critiques et non critiques.</span><span class="sxs-lookup"><span data-stu-id="30c12-511">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-512">Avertit un hôte que le code managé a terminé l'exécution des instructions qui dépendent de l'identité du thread du système d'exploitation physique actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-512">Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-513">Certains hôtes du common language runtime, tels que Microsoft SQL Server 2005, fournissent leur propre gestion de threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-513">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="30c12-514">Un hôte qui fournit sa propre gestion des threads peut déplacer une tâche en cours d’exécution d’un thread de système d’exploitation physique vers un autre à tout moment.</span><span class="sxs-lookup"><span data-stu-id="30c12-514">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="30c12-515">La plupart des tâches ne sont pas affectées par ce basculement.</span><span class="sxs-lookup"><span data-stu-id="30c12-515">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="30c12-516">Toutefois, certaines tâches ont une affinité de thread : autrement dit, ils dépendent de l’identité d’un thread de système d’exploitation physique.</span><span class="sxs-lookup"><span data-stu-id="30c12-516">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="30c12-517">Ces tâches doivent informer l’hôte lorsqu’elles exécutent du code qui ne doit pas être basculée.</span><span class="sxs-lookup"><span data-stu-id="30c12-517">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="30c12-518">Par exemple, si votre application appelle une API système pour acquérir un système d’exploitation de verrouillage qui possède l’affinité de thread, telles que Win32 CRITICAL_SECTION, vous devez appeler <xref:System.Threading.Thread.BeginThreadAffinity%2A> avant d’acquérir le verrou, et <xref:System.Threading.Thread.EndThreadAffinity%2A> après l’avoir libéré le verrou.</span><span class="sxs-lookup"><span data-stu-id="30c12-518">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="30c12-519">À l’aide de cette méthode dans le code qui s’exécute sous SQL Server 2005 nécessite le code à exécuter sur le niveau de protection de l’hôte le plus élevé.</span><span class="sxs-lookup"><span data-stu-id="30c12-519">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-520">L’exemple suivant illustre l’utilisation de la <xref:System.Threading.Thread.BeginThreadAffinity%2A> et <xref:System.Threading.Thread.EndThreadAffinity%2A> méthodes pour avertir un hôte qu’un bloc de code dépend de l’identité d’un thread de système d’exploitation physique.</span><span class="sxs-lookup"><span data-stu-id="30c12-520">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="30c12-521">L'appelant n'a pas l'autorisation requise.</span><span class="sxs-lookup"><span data-stu-id="30c12-521">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="30c12-522">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="30c12-522">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="30c12-523">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="30c12-523">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="30c12-524">Obtient un objet <see cref="T:System.Threading.ExecutionContext" /> qui contient des informations relatives aux divers contextes du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-524">Gets an <see cref="T:System.Threading.ExecutionContext" /> object that contains information about the various contexts of the current thread.</span></span></summary>
        <value><span data-ttu-id="30c12-525">Objet <see cref="T:System.Threading.ExecutionContext" /> qui consolide des informations de contexte pour le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-525">An <see cref="T:System.Threading.ExecutionContext" /> object that consolidates context information for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-526">Le <xref:System.Threading.ExecutionContext> classe fournit un conteneur unique pour toutes les informations relatives à un thread logique d’exécution.</span><span class="sxs-lookup"><span data-stu-id="30c12-526">The <xref:System.Threading.ExecutionContext> class provides a single container for all information relevant to a logical thread of execution.</span></span> <span data-ttu-id="30c12-527">Cela inclut le contexte de sécurité, de contexte d’appel, de contexte de synchronisation, de contexte de localisation et de contexte de transaction.</span><span class="sxs-lookup"><span data-stu-id="30c12-527">This includes security context, call context, synchronization context, localization context, and transaction context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-528">Vérifie que les ressources sont libérées et que toute autre opération de nettoyage est effectuée quand le garbage collector récupère l'objet <see cref="T:System.Threading.Thread" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-528">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.Thread" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-529">Le garbage collector appelle <xref:System.Threading.Thread.Finalize%2A> lorsque l’objet actuel est prêt à être finalisé.</span><span class="sxs-lookup"><span data-stu-id="30c12-529">The garbage collector calls <xref:System.Threading.Thread.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="30c12-530">Nom de l'emplacement de données à libérer.</span><span class="sxs-lookup"><span data-stu-id="30c12-530">The name of the data slot to be freed.</span></span></param>
        <summary><span data-ttu-id="30c12-531">Élimine l'association entre un nom et un emplacement pour tous les threads du processus.</span><span class="sxs-lookup"><span data-stu-id="30c12-531">Eliminates the association between a name and a slot, for all threads in the process.</span></span> <span data-ttu-id="30c12-532">Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-532">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="30c12-533">Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <xref:System.ThreadStaticAttribute> attribut) et emplacements de données.</span><span class="sxs-lookup"><span data-stu-id="30c12-533">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="30c12-534">Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="30c12-534">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="30c12-535">Pour plus d’informations sur l’utilisation de TLS, consultez [stockage Local des threads : Les champs statiques relatifs à un thread et emplacements de données](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="30c12-535">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="30c12-536">Une fois un thread appelle `FreeNamedDataSlot`, n’importe quel autre thread qui appelle <xref:System.Threading.Thread.GetNamedDataSlot%2A> portant le même nom allouera un nouvel emplacement associé au nom.</span><span class="sxs-lookup"><span data-stu-id="30c12-536">After any thread calls `FreeNamedDataSlot`, any other thread that calls <xref:System.Threading.Thread.GetNamedDataSlot%2A> with the same name will allocate a new slot associated with the name.</span></span> <span data-ttu-id="30c12-537">Les appels suivants à `GetNamedDataSlot` par n’importe quel thread retourneront le nouvel emplacement.</span><span class="sxs-lookup"><span data-stu-id="30c12-537">Subsequent calls to `GetNamedDataSlot` by any thread will return the new slot.</span></span> <span data-ttu-id="30c12-538">Toutefois, n’importe quel thread qui a toujours un <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> retourné par un appel antérieur à `GetNamedDataSlot` peuvent continuer à utiliser l’ancien emplacement.</span><span class="sxs-lookup"><span data-stu-id="30c12-538">However, any thread that still has a <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> returned by an earlier call to `GetNamedDataSlot` can continue to use the old slot.</span></span>  
  
 <span data-ttu-id="30c12-539">Un emplacement qui a été associé à un nom est libéré uniquement lorsque chaque `LocalDataStoreSlot` qui a été obtenu avant l’appel à `FreeNamedDataSlot` a été publié et le garbage collector.</span><span class="sxs-lookup"><span data-stu-id="30c12-539">A slot that has been associated with a name is released only when every `LocalDataStoreSlot` that was obtained prior to the call to `FreeNamedDataSlot` has been released and garbage-collected.</span></span>  
  
 <span data-ttu-id="30c12-540">Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-540">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="30c12-541">Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création.</span><span class="sxs-lookup"><span data-stu-id="30c12-541">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="30c12-542">Le thread peut allouer un emplacement de données dans le magasin de données, stockez et récupérez une données valeur dans l’emplacement et libérer l’emplacement pour une réutilisation après l’expiration du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-542">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="30c12-543">Emplacements de données sont uniques pour chaque thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-543">Data slots are unique per thread.</span></span> <span data-ttu-id="30c12-544">Aucun autre thread (pas même un thread enfant) ne peut obtenir les données.</span><span class="sxs-lookup"><span data-stu-id="30c12-544">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-545">Cette section contient deux exemples de code.</span><span class="sxs-lookup"><span data-stu-id="30c12-545">This section contains two code examples.</span></span> <span data-ttu-id="30c12-546">Le premier exemple montre comment utiliser un champ est marqué avec le <xref:System.ThreadStaticAttribute> attribut devant contenir les informations spécifiques aux threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-546">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="30c12-547">Le deuxième exemple montre comment utiliser un emplacement de données pour faire la même chose.</span><span class="sxs-lookup"><span data-stu-id="30c12-547">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="30c12-548">**Premier exemple**</span><span class="sxs-lookup"><span data-stu-id="30c12-548">**First Example**</span></span>  
  
 <span data-ttu-id="30c12-549">L’exemple suivant montre comment utiliser un champ est marqué avec <xref:System.ThreadStaticAttribute> pour contenir des informations spécifiques au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-549">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="30c12-550">Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.</span><span class="sxs-lookup"><span data-stu-id="30c12-550">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="30c12-551">**Deuxième exemple**</span><span class="sxs-lookup"><span data-stu-id="30c12-551">**Second Example**</span></span>  
  
 <span data-ttu-id="30c12-552">L’exemple suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-552">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="30c12-553">Threads et threading</span><span class="sxs-lookup"><span data-stu-id="30c12-553">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="30c12-554">Stockage local des threads : champs static et emplacements de données relatifs à un thread</span><span class="sxs-lookup"><span data-stu-id="30c12-554">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-555">Retourne une valeur <see cref="T:System.Threading.ApartmentState" /> qui indique l'état de cloisonnement.</span><span class="sxs-lookup"><span data-stu-id="30c12-555">Returns an <see cref="T:System.Threading.ApartmentState" /> value indicating the apartment state.</span></span></summary>
        <returns><span data-ttu-id="30c12-556">Une des valeurs <see cref="T:System.Threading.ApartmentState" /> qui indique l'état de cloisonnement du thread managé.</span><span class="sxs-lookup"><span data-stu-id="30c12-556">One of the <see cref="T:System.Threading.ApartmentState" /> values indicating the apartment state of the managed thread.</span></span> <span data-ttu-id="30c12-557">La valeur par défaut est <see cref="F:System.Threading.ApartmentState.Unknown" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-557">The default is <see cref="F:System.Threading.ApartmentState.Unknown" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-558">Cette méthode, avec la <xref:System.Threading.Thread.SetApartmentState%2A> (méthode) et le <xref:System.Threading.Thread.TrySetApartmentState%2A> (méthode), remplace le <xref:System.Threading.Thread.ApartmentState%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="30c12-558">This method, along with the <xref:System.Threading.Thread.SetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-559">L’exemple de code suivant montre le <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, et <xref:System.Threading.Thread.TrySetApartmentState%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="30c12-559">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="30c12-560">L’exemple de code crée un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-560">The code example creates a thread.</span></span> <span data-ttu-id="30c12-561">Avant que le thread est démarré, <xref:System.Threading.Thread.GetApartmentState%2A> affiche initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> état et <xref:System.Threading.Thread.SetApartmentState%2A> modifie l’état à <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="30c12-561">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="30c12-562">Le <xref:System.Threading.Thread.TrySetApartmentState%2A> méthode renvoie alors `false` lorsque vous tentez de modifier l’état à <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> , car l’état de cloisonnement est déjà défini.</span><span class="sxs-lookup"><span data-stu-id="30c12-562">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="30c12-563">Si la même opération avait été tentée avec <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> aurait été levée.</span><span class="sxs-lookup"><span data-stu-id="30c12-563">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="30c12-564">Une fois que le thread est démarré, le <xref:System.Threading.Thread.TrySetApartmentState%2A> méthode est utilisée à nouveau.</span><span class="sxs-lookup"><span data-stu-id="30c12-564">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="30c12-565">Cette fois, elle lève <xref:System.Threading.ThreadStateException> , car le thread a déjà été démarré.</span><span class="sxs-lookup"><span data-stu-id="30c12-565">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-566">Retourne un objet <see cref="T:System.Threading.CompressedStack" /> qui peut être utilisé pour capturer la pile pour le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-566">Returns a <see cref="T:System.Threading.CompressedStack" /> object that can be used to capture the stack for the current thread.</span></span></summary>
        <returns><span data-ttu-id="30c12-567">Aucun.</span><span class="sxs-lookup"><span data-stu-id="30c12-567">None.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-568">Cette méthode n’est plus pris en charge.</span><span class="sxs-lookup"><span data-stu-id="30c12-568">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="30c12-569">Dans tous les cas.</span><span class="sxs-lookup"><span data-stu-id="30c12-569">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="30c12-570">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="30c12-570">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="30c12-571">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="30c12-571">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="30c12-572"><see cref="T:System.LocalDataStoreSlot" /> à partir duquel obtenir la valeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-572">The <see cref="T:System.LocalDataStoreSlot" /> from which to get the value.</span></span></param>
        <summary><span data-ttu-id="30c12-573">Récupère la valeur de l'emplacement spécifié sur le thread actif, dans le domaine actuel du thread actif.</span><span class="sxs-lookup"><span data-stu-id="30c12-573">Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</span></span> <span data-ttu-id="30c12-574">Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-574">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="30c12-575">Valeur récupérée.</span><span class="sxs-lookup"><span data-stu-id="30c12-575">The retrieved value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="30c12-576">Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <xref:System.ThreadStaticAttribute> attribut) et emplacements de données.</span><span class="sxs-lookup"><span data-stu-id="30c12-576">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="30c12-577">Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="30c12-577">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="30c12-578">Pour plus d’informations sur l’utilisation de TLS, consultez [stockage Local des threads : Les champs statiques relatifs à un thread et emplacements de données](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="30c12-578">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="30c12-579">Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-579">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="30c12-580">Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création.</span><span class="sxs-lookup"><span data-stu-id="30c12-580">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="30c12-581">Le thread peut allouer un emplacement de données dans le magasin de données, stockez et récupérez une données valeur dans l’emplacement et libérer l’emplacement pour une réutilisation après l’expiration du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-581">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="30c12-582">Emplacements de données sont uniques pour chaque thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-582">Data slots are unique per thread.</span></span> <span data-ttu-id="30c12-583">Aucun autre thread (pas même un thread enfant) ne peut obtenir les données.</span><span class="sxs-lookup"><span data-stu-id="30c12-583">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-584"><xref:System.Threading.Thread.GetData%2A> est un `Shared` méthode s’applique toujours au thread en cours d’exécution, même si vous appelez à l’aide d’une variable qui fait référence à un autre thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-584"><xref:System.Threading.Thread.GetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="30c12-585">Pour éviter toute confusion, utilisez le nom de classe lors de l’appel `Shared` méthodes : `Dim test As Object = Thread.GetData(testSlot)`.</span><span class="sxs-lookup"><span data-stu-id="30c12-585">To avoid confusion, use the class name when calling `Shared` methods: `Dim test As Object = Thread.GetData(testSlot)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-586">Cette section contient deux exemples de code.</span><span class="sxs-lookup"><span data-stu-id="30c12-586">This section contains two code examples.</span></span> <span data-ttu-id="30c12-587">Le premier exemple montre comment utiliser un champ est marqué avec le <xref:System.ThreadStaticAttribute> attribut devant contenir les informations spécifiques aux threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-587">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="30c12-588">Le deuxième exemple montre comment utiliser un emplacement de données pour faire la même chose.</span><span class="sxs-lookup"><span data-stu-id="30c12-588">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="30c12-589">**Premier exemple**</span><span class="sxs-lookup"><span data-stu-id="30c12-589">**First Example**</span></span>  
  
 <span data-ttu-id="30c12-590">L’exemple suivant montre comment utiliser un champ est marqué avec <xref:System.ThreadStaticAttribute> pour contenir des informations spécifiques au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-590">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="30c12-591">Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.</span><span class="sxs-lookup"><span data-stu-id="30c12-591">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="30c12-592">**Deuxième exemple**</span><span class="sxs-lookup"><span data-stu-id="30c12-592">**Second Example**</span></span>  
  
 <span data-ttu-id="30c12-593">L’exemple suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-593">The following example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="30c12-594">Threads et threading</span><span class="sxs-lookup"><span data-stu-id="30c12-594">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="30c12-595">Stockage local des threads : champs static et emplacements de données relatifs à un thread</span><span class="sxs-lookup"><span data-stu-id="30c12-595">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-596">Retourne le domaine actuel dans lequel le thread actif est en cours d'exécution.</span><span class="sxs-lookup"><span data-stu-id="30c12-596">Returns the current domain in which the current thread is running.</span></span></summary>
        <returns><span data-ttu-id="30c12-597"><see cref="T:System.AppDomain" /> représentant le domaine d'application actuel du thread en cours d'exécution.</span><span class="sxs-lookup"><span data-stu-id="30c12-597">An <see cref="T:System.AppDomain" /> representing the current application domain of the running thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="30c12-598">L’exemple de code suivant montre comment récupérer le nom et l’ID de la `AppDomain` dans lequel le thread s’exécute.</span><span class="sxs-lookup"><span data-stu-id="30c12-598">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-599">Retourne un identificateur unique de domaine d'application.</span><span class="sxs-lookup"><span data-stu-id="30c12-599">Returns a unique application domain identifier.</span></span></summary>
        <returns><span data-ttu-id="30c12-600">Entier signé 32 bits identifiant de manière unique le domaine d'application.</span><span class="sxs-lookup"><span data-stu-id="30c12-600">A 32-bit signed integer uniquely identifying the application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="30c12-601">L’exemple de code suivant montre comment récupérer le nom et l’ID de la `AppDomain` dans lequel le thread s’exécute.</span><span class="sxs-lookup"><span data-stu-id="30c12-601">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-602">Retourne un code de hachage pour le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-602">Returns a hash code for the current thread.</span></span></summary>
        <returns><span data-ttu-id="30c12-603">Valeur de code de hachage entier.</span><span class="sxs-lookup"><span data-stu-id="30c12-603">An integer hash code value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-604">Le code de hachage n’est pas garanti pour être unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-604">The hash code is not guaranteed to be unique.</span></span> <span data-ttu-id="30c12-605">Utilisez le <xref:System.Threading.Thread.ManagedThreadId%2A> propriété si vous avez besoin d’un identificateur unique pour un thread managé.</span><span class="sxs-lookup"><span data-stu-id="30c12-605">Use the <xref:System.Threading.Thread.ManagedThreadId%2A> property if you need a unique identifier for a managed thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="30c12-606">Nom de l'emplacement de données local.</span><span class="sxs-lookup"><span data-stu-id="30c12-606">The name of the local data slot.</span></span></param>
        <summary><span data-ttu-id="30c12-607">Recherche un emplacement de données nommé.</span><span class="sxs-lookup"><span data-stu-id="30c12-607">Looks up a named data slot.</span></span> <span data-ttu-id="30c12-608">Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-608">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="30c12-609"><see cref="T:System.LocalDataStoreSlot" /> alloué pour ce thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-609">A <see cref="T:System.LocalDataStoreSlot" /> allocated for this thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="30c12-610">Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <xref:System.ThreadStaticAttribute> attribut) et emplacements de données.</span><span class="sxs-lookup"><span data-stu-id="30c12-610">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="30c12-611">Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="30c12-611">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="30c12-612">Pour plus d’informations sur l’utilisation de TLS, consultez [stockage Local des threads : Les champs statiques relatifs à un thread et emplacements de données](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="30c12-612">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="30c12-613">Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-613">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="30c12-614">Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création.</span><span class="sxs-lookup"><span data-stu-id="30c12-614">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="30c12-615">Le thread peut allouer un emplacement de données dans le magasin de données, stockez et récupérez une données valeur dans l’emplacement et libérer l’emplacement pour une réutilisation après l’expiration du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-615">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="30c12-616">Emplacements de données sont uniques pour chaque thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-616">Data slots are unique per thread.</span></span> <span data-ttu-id="30c12-617">Aucun autre thread (pas même un thread enfant) ne peut obtenir les données.</span><span class="sxs-lookup"><span data-stu-id="30c12-617">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="30c12-618">Si l’emplacement nommé n’existe pas, un nouvel emplacement est alloué.</span><span class="sxs-lookup"><span data-stu-id="30c12-618">If the named slot does not exist, a new slot is allocated.</span></span> <span data-ttu-id="30c12-619">Emplacements de données nommés sont publiques et peuvent être manipulées par tout le monde.</span><span class="sxs-lookup"><span data-stu-id="30c12-619">Named data slots are public and can be manipulated by anyone.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-620">Cette section contient deux exemples de code.</span><span class="sxs-lookup"><span data-stu-id="30c12-620">This section contains two code examples.</span></span> <span data-ttu-id="30c12-621">Le premier exemple montre comment utiliser un champ est marqué avec le <xref:System.ThreadStaticAttribute> attribut devant contenir les informations spécifiques aux threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-621">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="30c12-622">Le deuxième exemple montre comment utiliser un emplacement de données pour faire la même chose.</span><span class="sxs-lookup"><span data-stu-id="30c12-622">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="30c12-623">**Premier exemple**</span><span class="sxs-lookup"><span data-stu-id="30c12-623">**First Example**</span></span>  
  
 <span data-ttu-id="30c12-624">L’exemple suivant montre comment utiliser un champ est marqué avec <xref:System.ThreadStaticAttribute> pour contenir des informations spécifiques au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-624">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="30c12-625">Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.</span><span class="sxs-lookup"><span data-stu-id="30c12-625">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="30c12-626">**Deuxième exemple**</span><span class="sxs-lookup"><span data-stu-id="30c12-626">**Second Example**</span></span>  
  
 <span data-ttu-id="30c12-627">L’exemple suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-627">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="30c12-628">Threads et threading</span><span class="sxs-lookup"><span data-stu-id="30c12-628">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="30c12-629">Stockage local des threads : champs static et emplacements de données relatifs à un thread</span><span class="sxs-lookup"><span data-stu-id="30c12-629">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-630">Interrompt un thread dont l'état est <see cref="F:System.Threading.ThreadState.WaitSleepJoin" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-630">Interrupts a thread that is in the <see cref="F:System.Threading.ThreadState.WaitSleepJoin" /> thread state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-631">Si ce thread n’est pas actuellement bloqué en attente, de veille ou d’état de jointure, il sera interrompu lorsqu’elle commence ensuite à bloquer.</span><span class="sxs-lookup"><span data-stu-id="30c12-631">If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</span></span>  
  
 <span data-ttu-id="30c12-632"><xref:System.Threading.ThreadInterruptedException> est levée dans le thread interrompu, mais pas jusqu'à ce que le thread se bloque.</span><span class="sxs-lookup"><span data-stu-id="30c12-632"><xref:System.Threading.ThreadInterruptedException> is thrown in the interrupted thread, but not until the thread blocks.</span></span> <span data-ttu-id="30c12-633">Si le thread ne bloque jamais, l’exception n’est jamais levée, et par conséquent, le thread peut se terminer sans jamais être interrompu.</span><span class="sxs-lookup"><span data-stu-id="30c12-633">If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-634">L’exemple de code suivant montre le comportement d’un thread en cours d’exécution lorsqu’elle est interrompue et par la suite est bloqué.</span><span class="sxs-lookup"><span data-stu-id="30c12-634">The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="30c12-635">L’appelant ne possède pas le <see cref="T:System.Security.Permissions.SecurityPermission" /> nécessaire.</span><span class="sxs-lookup"><span data-stu-id="30c12-635">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="30c12-636">pour les opérations avancées sur les threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-636">for advanced operations on threads.</span></span> <span data-ttu-id="30c12-637">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-637">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="30c12-638">Suspension et interruption de threads</span><span class="sxs-lookup"><span data-stu-id="30c12-638">Pausing and interrupting threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="30c12-639">Obtient une valeur indiquant l'état de l'exécution du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-639">Gets a value indicating the execution status of the current thread.</span></span></summary>
        <value><span data-ttu-id="30c12-640"><see langword="true" /> si ce thread a été démarré mais ne s'est pas arrêté normalement ou s'il a été abandonné ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-640"><see langword="true" /> if this thread has been started and has not terminated normally or aborted; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="30c12-641">Obtient ou définit une valeur indiquant si le thread est un thread d'arrière-plan ou non.</span><span class="sxs-lookup"><span data-stu-id="30c12-641">Gets or sets a value indicating whether or not a thread is a background thread.</span></span></summary>
        <value><span data-ttu-id="30c12-642"><see langword="true" /> si ce thread est ou doit devenir un thread d'arrière-plan ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-642"><see langword="true" /> if this thread is or is to become a background thread; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-643">Un thread est un thread d’arrière-plan ou un thread de premier plan.</span><span class="sxs-lookup"><span data-stu-id="30c12-643">A thread is either a background thread or a foreground thread.</span></span> <span data-ttu-id="30c12-644">Threads d’arrière-plan sont identiques aux threads de premier plan, à ceci près que les threads d’arrière-plan n’empêchent pas un processus de se terminer.</span><span class="sxs-lookup"><span data-stu-id="30c12-644">Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</span></span> <span data-ttu-id="30c12-645">Une fois que tous les threads de premier plan appartenant à un processus sont terminés, le common language runtime termine le processus.</span><span class="sxs-lookup"><span data-stu-id="30c12-645">Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</span></span> <span data-ttu-id="30c12-646">Les threads d’arrière-plan restants sont arrêtées et ne se terminent pas.</span><span class="sxs-lookup"><span data-stu-id="30c12-646">Any remaining background threads are stopped and do not complete.</span></span>  
  
 <span data-ttu-id="30c12-647">Par défaut, les threads suivants s’exécutent au premier plan (autrement dit, leur <xref:System.Threading.Thread.IsBackground%2A> retourne de la propriété `false`) :</span><span class="sxs-lookup"><span data-stu-id="30c12-647">By default, the following threads execute in the foreground (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `false`):</span></span>  
  
-   <span data-ttu-id="30c12-648">Le thread principal (ou le thread d’application principal).</span><span class="sxs-lookup"><span data-stu-id="30c12-648">The primary thread (or main application thread).</span></span>  
  
-   <span data-ttu-id="30c12-649">Tous les threads créés en appelant un <xref:System.Threading.Thread> constructeur de classe.</span><span class="sxs-lookup"><span data-stu-id="30c12-649">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="30c12-650">Par défaut, les threads suivants s’exécutent en arrière-plan (autrement dit, leur <xref:System.Threading.Thread.IsBackground%2A> retourne de la propriété `true`) :</span><span class="sxs-lookup"><span data-stu-id="30c12-650">By default, the following threads execute in the background  (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `true`):</span></span>  
  
-   <span data-ttu-id="30c12-651">Thread du pool de threads, qui constituent un pool de threads de travail géré par le runtime.</span><span class="sxs-lookup"><span data-stu-id="30c12-651">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span> <span data-ttu-id="30c12-652">Vous pouvez configurer le travail de pool et de planification de thread sur les threads du pool à l’aide de la <xref:System.Threading.ThreadPool> classe.</span><span class="sxs-lookup"><span data-stu-id="30c12-652">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="30c12-653">Opérations asynchrones basées sur la tâche s’exécute automatiquement sur les threads du pool.</span><span class="sxs-lookup"><span data-stu-id="30c12-653">Task-based asynchronous operations automatically execute on thread pool threads.</span></span>  
  
-   <span data-ttu-id="30c12-654">Tous les threads qui entrent dans l’environnement d’exécution managé à partir de code non managé.</span><span class="sxs-lookup"><span data-stu-id="30c12-654">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-655">L’exemple suivant compare le comportement des threads de premier plan et d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="30c12-655">The following example contrasts the behavior of foreground and background threads.</span></span> <span data-ttu-id="30c12-656">Il crée un thread de premier plan et d’un thread d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="30c12-656">It creates a foreground thread and a background thread.</span></span> <span data-ttu-id="30c12-657">Le thread de premier plan maintient le processus en cours d’exécution jusqu'à ce que se termine son `for` boucle et se termine.</span><span class="sxs-lookup"><span data-stu-id="30c12-657">The foreground thread keeps the process running until completes its `for` loop and terminates.</span></span> <span data-ttu-id="30c12-658">Toutefois, comme le montre la sortie de l’exemple, étant donné que le thread de premier plan a terminé son exécution, le processus est arrêté avant que le thread d’arrière-plan a terminé son exécution.</span><span class="sxs-lookup"><span data-stu-id="30c12-658">However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="30c12-659">Le thread est inactif.</span><span class="sxs-lookup"><span data-stu-id="30c12-659">The thread is dead.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md"><span data-ttu-id="30c12-660">Threads de premier plan et d'arrière-plan</span><span class="sxs-lookup"><span data-stu-id="30c12-660">Foreground and Background Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="30c12-661">Obtient une valeur indiquant si un thread appartient au pool de threads managés ou non.</span><span class="sxs-lookup"><span data-stu-id="30c12-661">Gets a value indicating whether or not a thread belongs to the managed thread pool.</span></span></summary>
        <value><span data-ttu-id="30c12-662"><see langword="true" /> si ce thread appartient au pool de threads managés ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-662"><see langword="true" /> if this thread belongs to the managed thread pool; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-663">Pour plus d’informations, consultez [le pool de threads managés](~/docs/standard/threading/the-managed-thread-pool.md).</span><span class="sxs-lookup"><span data-stu-id="30c12-663">For more information see [The managed thread pool](~/docs/standard/threading/the-managed-thread-pool.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-664">L’exemple de code suivant montre comment déterminer si un thread est le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-664">The following code example shows how to determine whether a thread is from the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="30c12-665">Pool de threads managés</span><span class="sxs-lookup"><span data-stu-id="30c12-665">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="30c12-666">Bloque le thread appelant jusqu’à l’arrêt du thread représenté par cette instance.</span><span class="sxs-lookup"><span data-stu-id="30c12-666">Blocks the calling thread until the thread represented by this instance terminates.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-667">Bloque le thread appelant jusqu’à ce que le thread représenté par cette instance s’arrête, tout en continuant d’exécuter le pompage COM et <see langword="SendMessage" /> standard.</span><span class="sxs-lookup"><span data-stu-id="30c12-667">Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <see langword="SendMessage" /> pumping.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-668"><xref:System.Threading.Thread.Join%2A> est une méthode de synchronisation qui bloque le thread appelant (autrement dit, le thread qui appelle la méthode) jusqu'à ce que le thread dont <xref:System.Threading.Thread.Join%2A> méthode est appelée est terminée.</span><span class="sxs-lookup"><span data-stu-id="30c12-668"><xref:System.Threading.Thread.Join%2A> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed.</span></span> <span data-ttu-id="30c12-669">Utilisez cette méthode pour vous assurer qu’un thread a été arrêté.</span><span class="sxs-lookup"><span data-stu-id="30c12-669">Use this method to ensure that a thread has been terminated.</span></span> <span data-ttu-id="30c12-670">L’appelant se bloquera indéfiniment si le thread ne se termine pas.</span><span class="sxs-lookup"><span data-stu-id="30c12-670">The caller will block indefinitely if the thread does not terminate.</span></span> <span data-ttu-id="30c12-671">Dans l’exemple suivant, le `Thread1` thread appelle le <xref:System.Threading.Thread.Join> méthode de `Thread2`, ce qui conduit `Thread1` au bloc jusqu'à ce que `Thread2` est terminée.</span><span class="sxs-lookup"><span data-stu-id="30c12-671">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block until `Thread2` has completed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 <span data-ttu-id="30c12-672">Si le thread s’est déjà arrêté lorsque <xref:System.Threading.Thread.Join%2A> est appelée, la méthode retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="30c12-672">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="30c12-673">Vous ne devez jamais appeler la <xref:System.Threading.Thread.Join%2A> méthode de la <xref:System.Threading.Thread> objet qui représente le thread actuel du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-673">You should never call the <xref:System.Threading.Thread.Join%2A> method of the <xref:System.Threading.Thread> object that represents the current thread from the current thread.</span></span> <span data-ttu-id="30c12-674">Ainsi, votre application à cesser de répondre, car le thread actuel attend indéfiniment, à elle-même</span><span class="sxs-lookup"><span data-stu-id="30c12-674">This causes your app to become unresponsive because the current thread waits upon itself indefinitely,</span></span>  
  
 <span data-ttu-id="30c12-675">Cette méthode modifie l’état du thread appelant pour inclure <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="30c12-675">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="30c12-676">Vous ne pouvez pas appeler `Join` sur un thread qui se trouve dans le <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> état.</span><span class="sxs-lookup"><span data-stu-id="30c12-676">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="30c12-677">L’appelant a tenté de joindre un thread dont l’état est <see cref="F:System.Threading.ThreadState.Unstarted" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-677">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="30c12-678">Le thread est interrompu lors de l’attente.</span><span class="sxs-lookup"><span data-stu-id="30c12-678">The thread is interrupted while waiting.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="30c12-679">Nombre de millisecondes à attendre l'arrêt du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-679">The number of milliseconds to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="30c12-680">Bloque le thread appelant jusqu'à ce que le thread représenté par cette instance s'arrête ou que la durée spécifiée soit écoulée, tout en continuant d'exécuter le pompage COM et SendMessage standard.</span><span class="sxs-lookup"><span data-stu-id="30c12-680">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="30c12-681"><see langword="true" /> si le thread s'est arrêté ; <see langword="false" /> s'il ne s'est pas arrêté après l'expiration du délai spécifié par le paramètre <paramref name="millisecondsTimeout" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-681"><see langword="true" /> if the thread has terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="millisecondsTimeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-682"><xref:System.Threading.Thread.Join%28System.Int32%29> est une méthode de synchronisation qui bloque le thread appelant (autrement dit, le thread qui appelle la méthode) jusqu'à ce que soit le thread dont <xref:System.Threading.Thread.Join%2A> méthode est appelée est terminée ou l’intervalle de délai d’expiration est écoulé.</span><span class="sxs-lookup"><span data-stu-id="30c12-682"><xref:System.Threading.Thread.Join%28System.Int32%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="30c12-683">Dans l’exemple suivant, le `Thread1` thread appelle le <xref:System.Threading.Thread.Join> méthode de `Thread2`, ce qui conduit `Thread1` pour bloquer jusqu'à `Thread2` terminée ou 2 secondes se soient écoulées.</span><span class="sxs-lookup"><span data-stu-id="30c12-683">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 <span data-ttu-id="30c12-684">Si <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> est spécifié pour le `millisecondsTimeout` paramètre, cette méthode se comporte comme la <xref:System.Threading.Thread.Join> surcharge de méthode, à l’exception de la valeur de retour.</span><span class="sxs-lookup"><span data-stu-id="30c12-684">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for the `millisecondsTimeout` parameter, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="30c12-685">Si le thread s’est déjà arrêté lorsque <xref:System.Threading.Thread.Join%2A> est appelée, la méthode retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="30c12-685">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="30c12-686">Cette méthode modifie l’état du thread appelant pour inclure <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="30c12-686">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="30c12-687">Vous ne pouvez pas appeler `Join` sur un thread qui se trouve dans le <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> état.</span><span class="sxs-lookup"><span data-stu-id="30c12-687">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="30c12-688">La valeur de <paramref name="millisecondsTimeout" /> est négative et n’est pas égale à <see cref="F:System.Threading.Timeout.Infinite" /> en millisecondes.</span><span class="sxs-lookup"><span data-stu-id="30c12-688">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="30c12-689">Le thread n’a pas été démarré.</span><span class="sxs-lookup"><span data-stu-id="30c12-689">The thread has not been started.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="30c12-690"><see cref="T:System.TimeSpan" /> ayant pour valeur la durée à attendre l'arrêt du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-690">A <see cref="T:System.TimeSpan" /> set to the amount of time to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="30c12-691">Bloque le thread appelant jusqu'à ce que le thread représenté par cette instance s'arrête ou que la durée spécifiée soit écoulée, tout en continuant d'exécuter le pompage COM et SendMessage standard.</span><span class="sxs-lookup"><span data-stu-id="30c12-691">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="30c12-692"><see langword="true" /> si le thread s'est arrêté ; <see langword="false" /> s'il ne s'est pas arrêté après l'expiration du délai spécifié par le paramètre <paramref name="timeout" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-692"><see langword="true" /> if the thread terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="timeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-693"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> est une méthode de synchronisation qui bloque le thread appelant (autrement dit, le thread qui appelle la méthode) jusqu'à ce que soit le thread dont <xref:System.Threading.Thread.Join%2A> méthode est appelée est terminée ou l’intervalle de délai d’expiration est écoulé.</span><span class="sxs-lookup"><span data-stu-id="30c12-693"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="30c12-694">Dans l’exemple suivant, le `Thread1` thread appelle le <xref:System.Threading.Thread.Join> méthode de `Thread2`, ce qui conduit `Thread1` pour bloquer jusqu'à `Thread2` terminée ou 2 secondes se soient écoulées.</span><span class="sxs-lookup"><span data-stu-id="30c12-694">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 <span data-ttu-id="30c12-695">Si <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> est spécifiée pour `timeout`, cette méthode se comporte comme la <xref:System.Threading.Thread.Join> surcharge de méthode, à l’exception de la valeur de retour.</span><span class="sxs-lookup"><span data-stu-id="30c12-695">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for `timeout`, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="30c12-696">Si le thread s’est déjà arrêté lorsque <xref:System.Threading.Thread.Join%2A> est appelée, la méthode retourne immédiatement.</span><span class="sxs-lookup"><span data-stu-id="30c12-696">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="30c12-697">Cette méthode modifie l’état du thread actuel pour inclure <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="30c12-697">This method changes the state of the current thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span> <span data-ttu-id="30c12-698">Vous ne pouvez pas appeler `Join` sur un thread qui se trouve dans le <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> état.</span><span class="sxs-lookup"><span data-stu-id="30c12-698">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-699">L’exemple de code suivant montre comment utiliser un `TimeSpan` valeur avec le `Join` (méthode).</span><span class="sxs-lookup"><span data-stu-id="30c12-699">The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="30c12-700">La valeur de <paramref name="timeout" /> est négative et n’est pas égale à <see cref="F:System.Threading.Timeout.Infinite" /> en millisecondes, ou est supérieure à <see cref="F:System.Int32.MaxValue" /> millisecondes.</span><span class="sxs-lookup"><span data-stu-id="30c12-700">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="30c12-701">L’appelant a tenté de joindre un thread dont l’état est <see cref="F:System.Threading.ThreadState.Unstarted" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-701">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="30c12-702">Obtient un identificateur unique pour le thread managé actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-702">Gets a unique identifier for the current managed thread.</span></span></summary>
        <value><span data-ttu-id="30c12-703">Entier représentant un identificateur unique pour ce thread managé.</span><span class="sxs-lookup"><span data-stu-id="30c12-703">An integer that represents a unique identifier for this managed thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-704">D’un thread <xref:System.Threading.Thread.ManagedThreadId%2A> sert de valeur de propriété pour identifier de manière unique ce thread au sein de son processus.</span><span class="sxs-lookup"><span data-stu-id="30c12-704">A thread's <xref:System.Threading.Thread.ManagedThreadId%2A> property value serves to uniquely identify that thread within its process.</span></span>  
  
 <span data-ttu-id="30c12-705">La valeur de la <xref:System.Threading.Thread.ManagedThreadId%2A> propriété ne varie pas au fil du temps, même si le code non managé qui héberge le common language runtime implémente le thread comme une fibre.</span><span class="sxs-lookup"><span data-stu-id="30c12-705">The value of the <xref:System.Threading.Thread.ManagedThreadId%2A> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-706">Synchronise l'accès à la mémoire comme suit : Le processeur qui exécute le thread actuel ne peut pas réorganiser les instructions de manière à ce que les accès à la mémoire antérieurs à l'appel de <see cref="M:System.Threading.Thread.MemoryBarrier" /> s'exécutent après les accès à la mémoire postérieurs à l'appel de <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-706">Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <see cref="M:System.Threading.Thread.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-707"><xref:System.Threading.Thread.MemoryBarrier%2A> est requis uniquement sur les systèmes multiprocesseurs avec faible ordonnancement en mémoire (par exemple, un système employant plusieurs processeurs Intel Itanium).</span><span class="sxs-lookup"><span data-stu-id="30c12-707"><xref:System.Threading.Thread.MemoryBarrier%2A> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="30c12-708">La plupart des cas, le C# `lock` instruction, Visual Basic `SyncLock` instruction, ou la <xref:System.Threading.Monitor> classe fournissent des moyens plus simples pour synchroniser les données.</span><span class="sxs-lookup"><span data-stu-id="30c12-708">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="30c12-709">Obtient ou définit le nom du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-709">Gets or sets the name of the thread.</span></span></summary>
        <value><span data-ttu-id="30c12-710">Chaîne contenant le nom du thread ou <see langword="null" /> si aucun nom n'a été défini.</span><span class="sxs-lookup"><span data-stu-id="30c12-710">A string containing the name of the thread, or <see langword="null" /> if no name was set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-711">Cette propriété est en écriture-une fois.</span><span class="sxs-lookup"><span data-stu-id="30c12-711">This property is write-once.</span></span> <span data-ttu-id="30c12-712">Étant donné que la valeur par défaut d’un thread <xref:System.Threading.Thread.Name%2A> propriété est `null`, vous pouvez déterminer si un nom a déjà été explicitement attribué au thread en le comparant avec `null`.</span><span class="sxs-lookup"><span data-stu-id="30c12-712">Because the default value of a thread's <xref:System.Threading.Thread.Name%2A> property is `null`, you can determine whether a name has already been explicitly assigned to the thread by comparing it with `null`.</span></span>  
  
 <span data-ttu-id="30c12-713">La chaîne assignée à la <xref:System.Threading.Thread.Name%2A> propriété peut inclure n’importe quel caractère Unicode.</span><span class="sxs-lookup"><span data-stu-id="30c12-713">The string assigned to the <xref:System.Threading.Thread.Name%2A> property can include any Unicode character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-714">L’exemple suivant montre comment nommer un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-714">The following example shows how to name a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="30c12-715">Une opération ensembliste a été demandée, mais la propriété <see langword="Name" /> a déjà été définie.</span><span class="sxs-lookup"><span data-stu-id="30c12-715">A set operation was requested, but the <see langword="Name" /> property has already been set.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="30c12-716">Obtient ou définit une valeur indiquant la priorité de planification d'un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-716">Gets or sets a value indicating the scheduling priority of a thread.</span></span></summary>
        <value><span data-ttu-id="30c12-717">Une des valeurs de <see cref="T:System.Threading.ThreadPriority" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-717">One of the <see cref="T:System.Threading.ThreadPriority" /> values.</span></span> <span data-ttu-id="30c12-718">La valeur par défaut est <see cref="F:System.Threading.ThreadPriority.Normal" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-718">The default value is <see cref="F:System.Threading.ThreadPriority.Normal" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-719">Un thread peut avoir l’une de l’ordre de priorité suivant <xref:System.Threading.ThreadPriority> valeurs :</span><span class="sxs-lookup"><span data-stu-id="30c12-719">A thread can be assigned any one of the following priority <xref:System.Threading.ThreadPriority> values:</span></span>  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 <span data-ttu-id="30c12-720">Systèmes d’exploitation n’êtes pas obligés de respecter la priorité d’un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-720">Operating systems are not required to honor the priority of a thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-721">L’exemple suivant montre le résultat de la modification de la priorité d’un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-721">The following example shows the result of changing the priority of a thread.</span></span> <span data-ttu-id="30c12-722">Trois threads sont créés, la priorité d’un thread est définie sur <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, et la priorité de seconde est définie sur <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="30c12-722">Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, and the priority of a second is set to <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span></span> <span data-ttu-id="30c12-723">Chaque thread incrémente une variable dans un `while` boucle et s’exécute pour une durée définie.</span><span class="sxs-lookup"><span data-stu-id="30c12-723">Each thread increments a variable in a `while` loop and runs for a set time.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="30c12-724">Le thread a atteint un état final, tel que <see cref="F:System.Threading.ThreadState.Aborted" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-724">The thread has reached a final state, such as <see cref="F:System.Threading.ThreadState.Aborted" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="30c12-725">La valeur spécifiée pour une opération set n’est pas une valeur <see cref="T:System.Threading.ThreadPriority" /> valide.</span><span class="sxs-lookup"><span data-stu-id="30c12-725">The value specified for a set operation is not a valid <see cref="T:System.Threading.ThreadPriority" /> value.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md"><span data-ttu-id="30c12-726">Planification de threads</span><span class="sxs-lookup"><span data-stu-id="30c12-726">Scheduling threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-727">Annule un <see cref="M:System.Threading.Thread.Abort(System.Object)" /> demandé pour le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-727">Cancels an <see cref="M:System.Threading.Thread.Abort(System.Object)" /> requested for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-728">Cette méthode peut uniquement être appelée par le code avec les autorisations appropriées.</span><span class="sxs-lookup"><span data-stu-id="30c12-728">This method can only be called by code with the proper permissions.</span></span>  
  
 <span data-ttu-id="30c12-729">Lorsqu’un appel est effectué vers `Abort` pour terminer un thread, le système génère un <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="30c12-729">When a call is made to `Abort` to terminate a thread, the system throws a <xref:System.Threading.ThreadAbortException>.</span></span> <span data-ttu-id="30c12-730">`ThreadAbortException` est une exception spéciale qui peut être interceptée par le code d’application, mais qui est levée de nouveau à la fin du bloc catch, sauf si `ResetAbort` est appelée.</span><span class="sxs-lookup"><span data-stu-id="30c12-730">`ThreadAbortException` is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless `ResetAbort` is called.</span></span> <span data-ttu-id="30c12-731">`ResetAbort` Annule la demande d’abandon et empêche le `ThreadAbortException` à partir de l’arrêt du thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-731">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span>  
  
 <span data-ttu-id="30c12-732">Consultez <xref:System.Threading.ThreadAbortException> pour obtenir un exemple qui montre comment appeler le `ResetAbort` (méthode).</span><span class="sxs-lookup"><span data-stu-id="30c12-732">See <xref:System.Threading.ThreadAbortException> for an example that demonstrates calling the `ResetAbort` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="30c12-733">.NET Core uniquement : ce membre n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="30c12-733">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="30c12-734"><see langword="Abort" /> n’a pas été appelé sur le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-734"><see langword="Abort" /> was not invoked on the current thread.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="30c12-735">L’appelant n’a pas l’autorisation de sécurité requise pour le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-735">The caller does not have the required security permission for the current thread.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="30c12-736">pour les opérations avancées sur les threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-736">for advanced operations on threads.</span></span> <span data-ttu-id="30c12-737">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-737">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="30c12-738">Détruire des threads</span><span class="sxs-lookup"><span data-stu-id="30c12-738">Destroying threads</span></span></related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-739">Reprend un thread qui a été suspendu.</span><span class="sxs-lookup"><span data-stu-id="30c12-739">Resumes a thread that has been suspended.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="30c12-740">N’utilisez pas le <xref:System.Threading.Thread.Suspend%2A> et <xref:System.Threading.Thread.Resume%2A> méthodes pour synchroniser les activités de threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-740">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="30c12-741">Vous ne disposez d’aucun moyen de savoir quel code un thread s’exécute lorsque vous l’interrompez.</span><span class="sxs-lookup"><span data-stu-id="30c12-741">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="30c12-742">Si vous suspendez un thread pendant qu’il détient des verrous pendant une évaluation des autorisations de sécurité, d’autres threads le <xref:System.AppDomain> risque d’être bloqué.</span><span class="sxs-lookup"><span data-stu-id="30c12-742">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="30c12-743">Si vous suspendez un thread pendant son exécution un constructeur de classe, d’autres threads le <xref:System.AppDomain> qui tente d’utiliser cette classe sera bloqué.</span><span class="sxs-lookup"><span data-stu-id="30c12-743">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="30c12-744">Blocages peuvent se produire très facilement.</span><span class="sxs-lookup"><span data-stu-id="30c12-744">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="30c12-745">.NET Core uniquement : ce membre n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="30c12-745">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="30c12-746">Le thread n’a pas été démarré, est inactif ou n’est pas dans l’état interrompu.</span><span class="sxs-lookup"><span data-stu-id="30c12-746">The thread has not been started, is dead, or is not in the suspended state.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="30c12-747">L’appelant ne possède pas le <see cref="T:System.Security.Permissions.SecurityPermission" /> nécessaire.</span><span class="sxs-lookup"><span data-stu-id="30c12-747">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="30c12-748">pour les opérations avancées sur les threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-748">for advanced operations on threads.</span></span> <span data-ttu-id="30c12-749">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="30c12-749">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="30c12-750">Suspension et interruption de threads</span><span class="sxs-lookup"><span data-stu-id="30c12-750">Pausing and interrupting threads</span></span></related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="30c12-751">Nouvel état de cloisonnement.</span><span class="sxs-lookup"><span data-stu-id="30c12-751">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="30c12-752">Définit l'état de cloisonnement d'un thread avant qu'il ne soit démarré.</span><span class="sxs-lookup"><span data-stu-id="30c12-752">Sets the apartment state of a thread before it is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-753">Nouveaux threads sont initialisés en tant que <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> si leur état de cloisonnement n’a pas été défini avant leur démarrage.</span><span class="sxs-lookup"><span data-stu-id="30c12-753">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="30c12-754">État de cloisonnement doit être définie avant le démarrage d’un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-754">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-755">Le thread principal de l’application est initialisé à <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> par défaut.</span><span class="sxs-lookup"><span data-stu-id="30c12-755">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="30c12-756">La seule façon de définir l’état de cloisonnement du thread principal de l’application à <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> consiste à appliquer le <xref:System.STAThreadAttribute> d’attribut à la méthode de point d’entrée.</span><span class="sxs-lookup"><span data-stu-id="30c12-756">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="30c12-757">Le <xref:System.Threading.Thread.SetApartmentState%2A> (méthode), avec la <xref:System.Threading.Thread.GetApartmentState%2A> (méthode) et le <xref:System.Threading.Thread.TrySetApartmentState%2A> (méthode), remplace le <xref:System.Threading.Thread.ApartmentState%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="30c12-757">The <xref:System.Threading.Thread.SetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-758">L’exemple de code suivant montre le <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, et <xref:System.Threading.Thread.TrySetApartmentState%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="30c12-758">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="30c12-759">L’exemple de code crée un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-759">The code example creates a thread.</span></span> <span data-ttu-id="30c12-760">Avant que le thread est démarré, <xref:System.Threading.Thread.GetApartmentState%2A> affiche initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> état et <xref:System.Threading.Thread.SetApartmentState%2A> modifie l’état à <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="30c12-760">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="30c12-761">Le <xref:System.Threading.Thread.TrySetApartmentState%2A> méthode renvoie alors `false` lorsque vous tentez de modifier l’état à <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> , car l’état de cloisonnement est déjà défini.</span><span class="sxs-lookup"><span data-stu-id="30c12-761">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="30c12-762">Si la même opération avait été tentée avec <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> aurait été levée.</span><span class="sxs-lookup"><span data-stu-id="30c12-762">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="30c12-763">Une fois que le thread est démarré, le <xref:System.Threading.Thread.TrySetApartmentState%2A> méthode est utilisée à nouveau.</span><span class="sxs-lookup"><span data-stu-id="30c12-763">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="30c12-764">Cette fois, elle lève <xref:System.Threading.ThreadStateException> , car le thread a déjà été démarré.</span><span class="sxs-lookup"><span data-stu-id="30c12-764">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="30c12-765">.NET Core uniquement : ce membre n’est pas pris en charge sur les plateformes macOS et Linux.</span><span class="sxs-lookup"><span data-stu-id="30c12-765">.NET Core only: This member is not supported on the macOS and Linux platforms.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="30c12-766"><paramref name="state" /> n’est pas un état de cloisonnement valide.</span><span class="sxs-lookup"><span data-stu-id="30c12-766"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="30c12-767">Le thread a déjà été démarré.</span><span class="sxs-lookup"><span data-stu-id="30c12-767">The thread has already been started.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="30c12-768">L’état de cloisonnement a déjà été initialisé.</span><span class="sxs-lookup"><span data-stu-id="30c12-768">The apartment state has already been initialized.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="stack"><span data-ttu-id="30c12-769">Objet <see cref="T:System.Threading.CompressedStack" /> à appliquer au thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-769">The <see cref="T:System.Threading.CompressedStack" /> object to be applied to the current thread.</span></span></param>
        <summary><span data-ttu-id="30c12-770">Applique une <see cref="T:System.Threading.CompressedStack" /> capturée au thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-770">Applies a captured <see cref="T:System.Threading.CompressedStack" /> to the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-771">Cette méthode n’est plus pris en charge.</span><span class="sxs-lookup"><span data-stu-id="30c12-771">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="30c12-772">Dans tous les cas.</span><span class="sxs-lookup"><span data-stu-id="30c12-772">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="30c12-773">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="30c12-773">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="30c12-774">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="30c12-774">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="30c12-775"><see cref="T:System.LocalDataStoreSlot" /> dans lequel définir la valeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-775">The <see cref="T:System.LocalDataStoreSlot" /> in which to set the value.</span></span></param>
        <param name="data"><span data-ttu-id="30c12-776">Valeur à définir.</span><span class="sxs-lookup"><span data-stu-id="30c12-776">The value to be set.</span></span></param>
        <summary><span data-ttu-id="30c12-777">Définit les données dans l'emplacement spécifié sur le thread en cours d'exécution, pour le domaine actuel de ce thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-777">Sets the data in the specified slot on the currently running thread, for that thread's current domain.</span></span> <span data-ttu-id="30c12-778">Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-778">For better performance, use fields marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="30c12-779">Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <xref:System.ThreadStaticAttribute> attribut) et emplacements de données.</span><span class="sxs-lookup"><span data-stu-id="30c12-779">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="30c12-780">Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="30c12-780">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="30c12-781">Pour plus d’informations sur l’utilisation de TLS, consultez [stockage Local des threads : Les champs statiques relatifs à un thread et emplacements de données](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="30c12-781">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="30c12-782">Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-782">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="30c12-783">Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création.</span><span class="sxs-lookup"><span data-stu-id="30c12-783">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="30c12-784">Le thread peut allouer un emplacement de données dans le magasin de données, stockez et récupérez une données valeur dans l’emplacement et libérer de l’emplacement pour une réutilisation après la fin de la procédure de thread et le <xref:System.Threading.Thread> objet a été récupéré par le garbage collection.</span><span class="sxs-lookup"><span data-stu-id="30c12-784">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <xref:System.Threading.Thread> object has been reclaimed by garbage collection.</span></span> <span data-ttu-id="30c12-785">Emplacements de données sont uniques pour chaque thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-785">Data slots are unique per thread.</span></span> <span data-ttu-id="30c12-786">Aucun autre thread (pas même un thread enfant) ne peut obtenir les données.</span><span class="sxs-lookup"><span data-stu-id="30c12-786">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-787"><xref:System.Threading.Thread.SetData%2A> est un `Shared` méthode s’applique toujours au thread en cours d’exécution, même si vous appelez à l’aide d’une variable qui fait référence à un autre thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-787"><xref:System.Threading.Thread.SetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="30c12-788">Pour éviter toute confusion, utilisez le nom de classe lors de l’appel `Shared` méthodes : `Thread.SetData(testSlot, "test data")`.</span><span class="sxs-lookup"><span data-stu-id="30c12-788">To avoid confusion, use the class name when calling `Shared` methods: `Thread.SetData(testSlot, "test data")`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-789">Cette section contient deux exemples de code.</span><span class="sxs-lookup"><span data-stu-id="30c12-789">This section contains two code examples.</span></span> <span data-ttu-id="30c12-790">Le premier exemple montre comment utiliser un champ est marqué avec le <xref:System.ThreadStaticAttribute> attribut devant contenir les informations spécifiques aux threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-790">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="30c12-791">Le deuxième exemple montre comment utiliser un emplacement de données pour faire la même chose.</span><span class="sxs-lookup"><span data-stu-id="30c12-791">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="30c12-792">**Premier exemple**</span><span class="sxs-lookup"><span data-stu-id="30c12-792">**First Example**</span></span>  
  
 <span data-ttu-id="30c12-793">L’exemple suivant montre comment utiliser un champ est marqué avec <xref:System.ThreadStaticAttribute> pour contenir des informations spécifiques au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-793">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="30c12-794">Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.</span><span class="sxs-lookup"><span data-stu-id="30c12-794">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="30c12-795">**Deuxième exemple**</span><span class="sxs-lookup"><span data-stu-id="30c12-795">**Second Example**</span></span>  
  
 <span data-ttu-id="30c12-796">L’exemple suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-796">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="30c12-797">Threads et threading</span><span class="sxs-lookup"><span data-stu-id="30c12-797">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="30c12-798">Stockage local des threads : champs static et emplacements de données relatifs à un thread</span><span class="sxs-lookup"><span data-stu-id="30c12-798">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="30c12-799">Suspend le thread actuel pendant la durée spécifiée.</span><span class="sxs-lookup"><span data-stu-id="30c12-799">Suspends the current thread for the specified amount of time.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="30c12-800">Nombre de millisecondes pendant lesquelles le thread est suspendu.</span><span class="sxs-lookup"><span data-stu-id="30c12-800">The number of milliseconds for which the thread is suspended.</span></span> <span data-ttu-id="30c12-801">Si la valeur de l'argument <paramref name="millisecondsTimeout" /> est égale à zéro, le thread abandonne le reste de sa tranche de temps à n'importe quel thread de priorité égale prêt à être exécuté.</span><span class="sxs-lookup"><span data-stu-id="30c12-801">If the value of the <paramref name="millisecondsTimeout" /> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="30c12-802">S'il n'existe pas d'autres threads de priorité égale prêts à être exécutés, l'exécution du thread actuel n'est pas suspendue.</span><span class="sxs-lookup"><span data-stu-id="30c12-802">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="30c12-803">Suspend le thread actuel pendant le nombre spécifié de millisecondes.</span><span class="sxs-lookup"><span data-stu-id="30c12-803">Suspends the current thread for the specified number of milliseconds.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-804">Le thread n’est plus planifié pour l’exécution par le système d’exploitation pendant la durée spécifiée.</span><span class="sxs-lookup"><span data-stu-id="30c12-804">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="30c12-805">Cette méthode modifie l’état du thread pour inclure <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="30c12-805">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="30c12-806">Vous pouvez spécifier <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> pour le `millisecondsTimeout` paramètre d’interruption du thread indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="30c12-806">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the `millisecondsTimeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="30c12-807">Toutefois, nous vous recommandons d’utiliser des autres <xref:System.Threading?displayProperty=nameWithType> classes telles que <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, ou <xref:System.Threading.Semaphore> au lieu de cela pour synchroniser des threads ou de gérer les ressources.</span><span class="sxs-lookup"><span data-stu-id="30c12-807">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to synchronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="30c12-808">Les battements d’horloge système à un rythme spécifique appelée la résolution de l’horloge.</span><span class="sxs-lookup"><span data-stu-id="30c12-808">The system clock ticks at a specific rate called the clock resolution.</span></span> <span data-ttu-id="30c12-809">Le délai d’expiration réelle peut être pas exactement le délai spécifié, car le délai d’expiration spécifié est ajustée pour coïncider avec battements d’horloge.</span><span class="sxs-lookup"><span data-stu-id="30c12-809">The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</span></span> <span data-ttu-id="30c12-810">Pour plus d’informations sur la résolution de l’horloge et le temps d’attente, consultez la [veille fonction](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) rubrique.</span><span class="sxs-lookup"><span data-stu-id="30c12-810">For more information on clock resolution and the waiting time, see the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) topic.</span></span> <span data-ttu-id="30c12-811">Cette méthode appelle la [mise en veille de la fonction](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) à partir de l’API du système Windows.</span><span class="sxs-lookup"><span data-stu-id="30c12-811">This method calls the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) from the Windows system APIs.</span></span>  
  
 <span data-ttu-id="30c12-812">Cette méthode n’effectue pas standard pompage COM et SendMessage.</span><span class="sxs-lookup"><span data-stu-id="30c12-812">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-813">Si vous devez mettre en veille sur un thread qui a <xref:System.STAThreadAttribute>, mais que vous souhaitez effectuer standard pompage COM et SendMessage, envisagez d’utiliser une des surcharges de la <xref:System.Threading.Thread.Join%2A> méthode qui spécifie un intervalle de délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="30c12-813">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-814">L’exemple suivant utilise la <xref:System.Threading.Thread.Sleep%2A> méthode pour bloquer le thread principal de l’application.</span><span class="sxs-lookup"><span data-stu-id="30c12-814">The following example uses the <xref:System.Threading.Thread.Sleep%2A> method to block the application's main thread.</span></span>  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="30c12-815">La valeur du délai d’attente est négative et n’est pas égale à <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-815">The time-out value is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="30c12-816">Durée pendant laquelle le thread est suspendu.</span><span class="sxs-lookup"><span data-stu-id="30c12-816">The amount of time for which the thread is suspended.</span></span> <span data-ttu-id="30c12-817">Si la valeur de l’argument <paramref name="millisecondsTimeout" /> est <see cref="F:System.TimeSpan.Zero" />, le thread abandonne le reste de sa tranche de temps à n’importe quel thread de priorité égale prêt à être exécuté.</span><span class="sxs-lookup"><span data-stu-id="30c12-817">If the value of the <paramref name="millisecondsTimeout" /> argument is <see cref="F:System.TimeSpan.Zero" />, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="30c12-818">S'il n'existe pas d'autres threads de priorité égale prêts à être exécutés, l'exécution du thread actuel n'est pas suspendue.</span><span class="sxs-lookup"><span data-stu-id="30c12-818">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="30c12-819">Suspend le thread actuel pendant la durée spécifiée.</span><span class="sxs-lookup"><span data-stu-id="30c12-819">Suspends the current thread for the specified amount of time.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-820">Le thread n’est plus planifié pour l’exécution par le système d’exploitation pendant la durée spécifiée.</span><span class="sxs-lookup"><span data-stu-id="30c12-820">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="30c12-821">Cette méthode modifie l’état du thread pour inclure <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="30c12-821">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="30c12-822">Vous pouvez spécifier <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> pour le `timeout` paramètre d’interruption du thread indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="30c12-822">You can specify <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> for the `timeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="30c12-823">Toutefois, nous vous recommandons d’utiliser des autres <xref:System.Threading?displayProperty=nameWithType> classes telles que <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, ou <xref:System.Threading.Semaphore> au lieu de cela pour synchroniser des threads ou de gérer les ressources.</span><span class="sxs-lookup"><span data-stu-id="30c12-823">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to synchronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="30c12-824">Cette surcharge de <xref:System.Threading.Thread.Sleep%2A> utilise le nombre total de millisecondes entières dans `timeout`.</span><span class="sxs-lookup"><span data-stu-id="30c12-824">This overload of <xref:System.Threading.Thread.Sleep%2A> uses the total number of whole milliseconds in `timeout`.</span></span> <span data-ttu-id="30c12-825">Fractions de milliseconde sont ignorées.</span><span class="sxs-lookup"><span data-stu-id="30c12-825">Fractional milliseconds are discarded.</span></span>  
  
 <span data-ttu-id="30c12-826">Cette méthode n’effectue pas standard pompage COM et SendMessage.</span><span class="sxs-lookup"><span data-stu-id="30c12-826">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-827">Si vous devez mettre en veille sur un thread qui a <xref:System.STAThreadAttribute>, mais que vous souhaitez effectuer standard pompage COM et SendMessage, envisagez d’utiliser une des surcharges de la <xref:System.Threading.Thread.Join%2A> méthode qui spécifie un intervalle de délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="30c12-827">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-828">L’exemple suivant utilise le <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> surcharge de méthode pour bloquer des cinq fois, thread principal de l’application pendant deux secondes.</span><span class="sxs-lookup"><span data-stu-id="30c12-828">The following example uses the <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> method overload to block the application's main thread five times, for two seconds each time.</span></span>  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="30c12-829">La valeur de <paramref name="timeout" /> est négative et n’est pas égale à <see cref="F:System.Threading.Timeout.Infinite" /> en millisecondes, ou est supérieure à <see cref="F:System.Int32.MaxValue" /> millisecondes.</span><span class="sxs-lookup"><span data-stu-id="30c12-829">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="iterations"><span data-ttu-id="30c12-830">Entier signé 32 bits qui définit le temps pendant lequel un thread doit attendre.</span><span class="sxs-lookup"><span data-stu-id="30c12-830">A 32-bit signed integer that defines how long a thread is to wait.</span></span></param>
        <summary><span data-ttu-id="30c12-831">Provoque l'attente d'un thread pendant le nombre de fois défini par le paramètre <paramref name="iterations" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-831">Causes a thread to wait the number of times defined by the <paramref name="iterations" /> parameter.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-832">Le <xref:System.Threading.Thread.SpinWait%2A> méthode est utile pour implémenter des verrous.</span><span class="sxs-lookup"><span data-stu-id="30c12-832">The <xref:System.Threading.Thread.SpinWait%2A> method is useful for implementing locks.</span></span> <span data-ttu-id="30c12-833">Classes dans le .NET Framework, telles que <xref:System.Threading.Monitor> et <xref:System.Threading.ReaderWriterLock>, utilisez cette méthode en interne.</span><span class="sxs-lookup"><span data-stu-id="30c12-833">Classes in the .NET Framework, such as <xref:System.Threading.Monitor> and <xref:System.Threading.ReaderWriterLock>, use this method internally.</span></span> <span data-ttu-id="30c12-834"><xref:System.Threading.Thread.SpinWait%2A> met essentiellement le processeur dans une boucle serrée très, avec le nombre de boucles spécifié par le `iterations` paramètre.</span><span class="sxs-lookup"><span data-stu-id="30c12-834"><xref:System.Threading.Thread.SpinWait%2A> essentially puts the processor into a very tight loop, with the loop count specified by the `iterations` parameter.</span></span> <span data-ttu-id="30c12-835">Par conséquent, la durée de l’attente dépend de la vitesse du processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-835">The duration of the wait therefore depends on the speed of the processor.</span></span>  
  
 <span data-ttu-id="30c12-836">Comparez ceci avec la <xref:System.Threading.Thread.Sleep%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="30c12-836">Contrast this with the <xref:System.Threading.Thread.Sleep%2A> method.</span></span> <span data-ttu-id="30c12-837">Un thread qui appelle <xref:System.Threading.Thread.Sleep%2A> génère le reste de sa tranche de temps processeur, même si l’intervalle spécifié sont égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="30c12-837">A thread that calls <xref:System.Threading.Thread.Sleep%2A> yields the rest of its current slice of processor time, even if the specified interval is zero.</span></span> <span data-ttu-id="30c12-838">En spécifiant un intervalle différent de zéro pour <xref:System.Threading.Thread.Sleep%2A> supprime le thread d’examen par le Planificateur de threads jusqu'à ce que l’intervalle de temps s’est écoulé.</span><span class="sxs-lookup"><span data-stu-id="30c12-838">Specifying a non-zero interval for <xref:System.Threading.Thread.Sleep%2A> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</span></span>  
  
 <span data-ttu-id="30c12-839"><xref:System.Threading.Thread.SpinWait%2A> est généralement pas utile pour les applications ordinaires.</span><span class="sxs-lookup"><span data-stu-id="30c12-839"><xref:System.Threading.Thread.SpinWait%2A> is not generally useful for ordinary applications.</span></span> <span data-ttu-id="30c12-840">Dans la plupart des cas, vous devez utiliser les classes de synchronisation fournies par le .NET Framework ; par exemple, appeler <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> ou une instruction qui encapsule <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` en c# ou `SyncLock` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="30c12-840">In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> or a statement that wraps <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in C# or `SyncLock` in Visual Basic).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="30c12-841">Dans les rares cas où il est avantageux d’éviter un changement de contexte, par exemple lorsque vous savez qu’un changement d’état est imminent, effectuez un appel à la <xref:System.Threading.Thread.SpinWait%2A> méthode dans la boucle.</span><span class="sxs-lookup"><span data-stu-id="30c12-841">In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <xref:System.Threading.Thread.SpinWait%2A> method in your loop.</span></span> <span data-ttu-id="30c12-842">Le code <xref:System.Threading.Thread.SpinWait%2A> exécute est conçu pour éviter les problèmes qui peuvent se produire sur les ordinateurs avec plusieurs processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-842">The code <xref:System.Threading.Thread.SpinWait%2A> executes is designed to prevent problems that can occur on computers with multiple processors.</span></span> <span data-ttu-id="30c12-843">Par exemple, sur les ordinateurs avec plusieurs processeurs Intel utilisant la technologie Hyper-Threading, <xref:System.Threading.Thread.SpinWait%2A> empêche la privation de processeur dans certaines situations.</span><span class="sxs-lookup"><span data-stu-id="30c12-843">For example, on computers with multiple Intel processors employing Hyper-Threading technology, <xref:System.Threading.Thread.SpinWait%2A> prevents processor starvation in certain situations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="30c12-844">Entraîne la planification de l'exécution d'un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-844">Causes a thread to be scheduled for execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-845">Provoque le changement, par le système d'exploitation, de l'état de l'instance actuelle en <see cref="F:System.Threading.ThreadState.Running" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-845">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-846">Une fois qu’un thread se trouve dans le <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> d’état, le système d’exploitation peut planifier son exécution.</span><span class="sxs-lookup"><span data-stu-id="30c12-846">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="30c12-847">Le thread d’exécution commence à la première ligne de la méthode représentée par le <xref:System.Threading.ThreadStart> ou <xref:System.Threading.ParameterizedThreadStart> délégué fourni au constructeur de thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-847">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="30c12-848">Notez que l’appel à <xref:System.Threading.Thread.Start%2A> ne bloque pas le thread appelant.</span><span class="sxs-lookup"><span data-stu-id="30c12-848">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-849">Si cette surcharge est utilisée avec un thread créé à l’aide un <xref:System.Threading.ParameterizedThreadStart> déléguer, `null` est passé à la méthode exécutée par le thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-849">If this overload is used with a thread created using a <xref:System.Threading.ParameterizedThreadStart> delegate, `null` is passed to the method executed by the thread.</span></span>  
  
 <span data-ttu-id="30c12-850">Une fois que le thread s’arrête, il ne peut pas être redémarré avec un autre appel à `Start`.</span><span class="sxs-lookup"><span data-stu-id="30c12-850">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-851">L’exemple suivant crée et démarre un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-851">The following example creates and starts a thread.</span></span>  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="30c12-852">Le thread a déjà été démarré.</span><span class="sxs-lookup"><span data-stu-id="30c12-852">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="30c12-853">La mémoire disponible est insuffisante pour démarrer ce thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-853">There is not enough memory available to start this thread.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="30c12-854">Threads et threading</span><span class="sxs-lookup"><span data-stu-id="30c12-854">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="30c12-855">Création de threads et passage de données au démarrage</span><span class="sxs-lookup"><span data-stu-id="30c12-855">Creating Threads and Passing Data at Start Time</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="parameter"><span data-ttu-id="30c12-856">Objet contenant les données que la méthode exécutée par le thread doit utiliser.</span><span class="sxs-lookup"><span data-stu-id="30c12-856">An object that contains data to be used by the method the thread executes.</span></span></param>
        <summary><span data-ttu-id="30c12-857">Provoque le changement, par le système d'exploitation, de l'état de l'instance actuelle en <see cref="F:System.Threading.ThreadState.Running" />, et fournit éventuellement un objet contenant les données que la méthode exécutée par le thread doit utiliser.</span><span class="sxs-lookup"><span data-stu-id="30c12-857">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />, and optionally supplies an object containing data to be used by the method the thread executes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-858">Une fois qu’un thread se trouve dans le <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> d’état, le système d’exploitation peut planifier son exécution.</span><span class="sxs-lookup"><span data-stu-id="30c12-858">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="30c12-859">Le thread d’exécution commence à la première ligne de la méthode représentée par le <xref:System.Threading.ThreadStart> ou <xref:System.Threading.ParameterizedThreadStart> délégué fourni au constructeur de thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-859">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="30c12-860">Notez que l’appel à <xref:System.Threading.Thread.Start%2A> ne bloque pas le thread appelant.</span><span class="sxs-lookup"><span data-stu-id="30c12-860">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
 <span data-ttu-id="30c12-861">Une fois que le thread s’arrête, il ne peut pas être redémarré avec un autre appel à `Start`.</span><span class="sxs-lookup"><span data-stu-id="30c12-861">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
 <span data-ttu-id="30c12-862">Cette surcharge et la <xref:System.Threading.ParameterizedThreadStart> délégué facilitent l’utilisation passer des données à une procédure de thread, mais la technique n’est pas de type sécurisé, car n’importe quel objet peut être passé à cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="30c12-862">This overload and the <xref:System.Threading.ParameterizedThreadStart> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</span></span> <span data-ttu-id="30c12-863">Une façon plus fiable pour transmettre des données à une procédure de thread est de placer la procédure de thread et les champs de données dans un objet de travail.</span><span class="sxs-lookup"><span data-stu-id="30c12-863">A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</span></span> <span data-ttu-id="30c12-864">Pour plus d’informations, consultez [création de Threads et passage de données à l’heure de début](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span><span class="sxs-lookup"><span data-stu-id="30c12-864">For more information, see [Creating Threads and Passing Data at Start Time](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-865">L’exemple suivant crée un <xref:System.Threading.ParameterizedThreadStart> délégué avec une méthode statique et une méthode d’instance.</span><span class="sxs-lookup"><span data-stu-id="30c12-865">The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="30c12-866">Le thread a déjà été démarré.</span><span class="sxs-lookup"><span data-stu-id="30c12-866">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="30c12-867">La mémoire disponible est insuffisante pour démarrer ce thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-867">There is not enough memory available to start this thread.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="30c12-868">Ce thread a été créé à l’aide d’un délégué <see cref="T:System.Threading.ThreadStart" /> au lieu d’un délégué <see cref="T:System.Threading.ParameterizedThreadStart" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-868">This thread was created using a <see cref="T:System.Threading.ThreadStart" /> delegate instead of a <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="30c12-869">Création de Threads</span><span class="sxs-lookup"><span data-stu-id="30c12-869">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-870">Suspend le thread ou, s'il est déjà suspendu, n'a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="30c12-870">Either suspends the thread, or if the thread is already suspended, has no effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-871">Si le thread est déjà suspendu, cette méthode n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="30c12-871">If the thread is already suspended, this method has no effect.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="30c12-872">N’utilisez pas le <xref:System.Threading.Thread.Suspend%2A> et <xref:System.Threading.Thread.Resume%2A> méthodes pour synchroniser les activités de threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-872">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="30c12-873">Vous ne disposez d’aucun moyen de savoir quel code un thread s’exécute lorsque vous l’interrompez.</span><span class="sxs-lookup"><span data-stu-id="30c12-873">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="30c12-874">Si vous suspendez un thread pendant qu’il détient des verrous pendant une évaluation des autorisations de sécurité, d’autres threads le <xref:System.AppDomain> risque d’être bloqué.</span><span class="sxs-lookup"><span data-stu-id="30c12-874">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="30c12-875">Si vous suspendez un thread pendant son exécution un constructeur de classe, d’autres threads le <xref:System.AppDomain> qui tente d’utiliser cette classe sera bloqué.</span><span class="sxs-lookup"><span data-stu-id="30c12-875">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="30c12-876">Blocages peuvent se produire très facilement.</span><span class="sxs-lookup"><span data-stu-id="30c12-876">Deadlocks can occur very easily.</span></span>

<span data-ttu-id="30c12-877">Lorsque vous appelez le `Suspend` méthode sur un thread, le système indique qu’une suspension du thread a été demandée et permet au thread de s’exécuter jusqu'à ce qu’il atteigne un point sans risque avant d’interrompre le thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-877">When you call the `Suspend` method on a thread, the system notes that a thread suspension has been requested and allows the thread to execute until it reaches a safe point before actually suspending the thread.</span></span> <span data-ttu-id="30c12-878">Un point sans risque pour un thread est un point de son exécution auquel le nettoyage de la mémoire peut être exécuté.</span><span class="sxs-lookup"><span data-stu-id="30c12-878">A safe point for a thread is a point in its execution at which garbage collection can be performed.</span></span> <span data-ttu-id="30c12-879">Une fois atteint un point sans risque, le runtime garantit que le thread suspendu ne progressera pas dans le code managé.</span><span class="sxs-lookup"><span data-stu-id="30c12-879">Once a safe point is reached, the runtime guarantees that the suspended thread will not make any further progress in managed code.</span></span> <span data-ttu-id="30c12-880">Un thread s’exécutant en dehors du code managé est toujours sûr pour le nettoyage de la mémoire, et son exécution se poursuit jusqu'à ce qu’il tente de reprendre l’exécution du code managé.</span><span class="sxs-lookup"><span data-stu-id="30c12-880">A thread executing outside managed code is always safe for garbage collection, and its execution continues until it attempts to resume execution of managed code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="30c12-881">.NET Core uniquement : ce membre n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="30c12-881">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="30c12-882">Le thread n’a pas été démarré ou est inactif.</span><span class="sxs-lookup"><span data-stu-id="30c12-882">The thread has not been started or is dead.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="30c12-883">L’appelant ne possède pas le <see cref="T:System.Security.Permissions.SecurityPermission" /> nécessaire.</span><span class="sxs-lookup"><span data-stu-id="30c12-883">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="30c12-884">pour les opérations avancées sur les threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-884">for advanced operations on threads.</span></span> <span data-ttu-id="30c12-885">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-885">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="30c12-886">Suspension et interruption de threads</span><span class="sxs-lookup"><span data-stu-id="30c12-886">Pausing and interrupting threads</span></span></related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="30c12-887">Réservé à un usage ultérieur.</span><span class="sxs-lookup"><span data-stu-id="30c12-887">Reserved for future use.</span></span> <span data-ttu-id="30c12-888">Doit être IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="30c12-888">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="30c12-889">Tableau passé des noms à mapper.</span><span class="sxs-lookup"><span data-stu-id="30c12-889">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="30c12-890">Compte des noms à mapper.</span><span class="sxs-lookup"><span data-stu-id="30c12-890">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="30c12-891">Contexte des paramètres régionaux dans lequel interpréter les noms.</span><span class="sxs-lookup"><span data-stu-id="30c12-891">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="30c12-892">Tableau alloué par l'appelant et recevant les ID qui correspondent aux noms.</span><span class="sxs-lookup"><span data-stu-id="30c12-892">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="30c12-893">Mappe un jeu de noms avec un jeu correspondant d'identificateurs de dispatch.</span><span class="sxs-lookup"><span data-stu-id="30c12-893">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-894">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="30c12-894">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="30c12-895">Pour plus d’informations sur `IDispatch::GetIDsOfNames`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="30c12-895">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="30c12-896">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="30c12-896">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="30c12-897">Informations de type à retourner.</span><span class="sxs-lookup"><span data-stu-id="30c12-897">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="30c12-898">Identificateur des paramètres régionaux pour les informations de type.</span><span class="sxs-lookup"><span data-stu-id="30c12-898">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="30c12-899">Reçoit un pointeur vers l'objet d'informations de type demandé.</span><span class="sxs-lookup"><span data-stu-id="30c12-899">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="30c12-900">Récupère les informations de type pour un objet, qui peuvent être utilisées ensuite pour obtenir les informations de type d'une interface.</span><span class="sxs-lookup"><span data-stu-id="30c12-900">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-901">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="30c12-901">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="30c12-902">Pour plus d’informations sur `IDispatch::GetTypeInfo`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="30c12-902">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="30c12-903">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="30c12-903">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="30c12-904">Pointe vers un emplacement qui reçoit le nombre d'interfaces d'informations de type fourni par l'objet.</span><span class="sxs-lookup"><span data-stu-id="30c12-904">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="30c12-905">Récupère le nombre d'interfaces d'informations de type fourni par un objet (0 ou 1).</span><span class="sxs-lookup"><span data-stu-id="30c12-905">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-906">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="30c12-906">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="30c12-907">Pour plus d’informations sur `IDispatch::GetTypeInfoCount`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="30c12-907">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="30c12-908">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="30c12-908">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="30c12-909">Identifie le membre.</span><span class="sxs-lookup"><span data-stu-id="30c12-909">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="30c12-910">Réservé à un usage ultérieur.</span><span class="sxs-lookup"><span data-stu-id="30c12-910">Reserved for future use.</span></span> <span data-ttu-id="30c12-911">Doit être IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="30c12-911">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="30c12-912">Contexte des paramètres régionaux dans lequel interpréter les arguments.</span><span class="sxs-lookup"><span data-stu-id="30c12-912">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="30c12-913">Indicateurs décrivant le contexte de l'appel.</span><span class="sxs-lookup"><span data-stu-id="30c12-913">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="30c12-914">Pointeur vers une structure qui contient un tableau d'arguments, un tableau d'arguments DISPID pour les arguments nommés et le nombre d'éléments de chaque tableau.</span><span class="sxs-lookup"><span data-stu-id="30c12-914">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="30c12-915">Pointeur vers l'emplacement où le résultat doit être stocké.</span><span class="sxs-lookup"><span data-stu-id="30c12-915">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="30c12-916">Pointeur vers une structure qui contient les informations sur les exceptions.</span><span class="sxs-lookup"><span data-stu-id="30c12-916">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="30c12-917">Index du premier argument comportant une erreur.</span><span class="sxs-lookup"><span data-stu-id="30c12-917">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="30c12-918">Fournit l'accès aux propriétés et aux méthodes exposées par un objet.</span><span class="sxs-lookup"><span data-stu-id="30c12-918">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-919">Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé.</span><span class="sxs-lookup"><span data-stu-id="30c12-919">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="30c12-920">Pour plus d’informations sur `IDispatch::Invoke`, consultez MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="30c12-920">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="30c12-921">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="30c12-921">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="30c12-922">Obtient une valeur contenant les états du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-922">Gets a value containing the states of the current thread.</span></span></summary>
        <value><span data-ttu-id="30c12-923">Une des valeurs <see cref="T:System.Threading.ThreadState" /> indiquant l'état du thread actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-923">One of the <see cref="T:System.Threading.ThreadState" /> values indicating the state of the current thread.</span></span> <span data-ttu-id="30c12-924">La valeur initiale est <see cref="F:System.Threading.ThreadState.Unstarted" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-924">The initial value is <see cref="F:System.Threading.ThreadState.Unstarted" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-925">Le <xref:System.Threading.Thread.ThreadState%2A> propriété fournit des informations plus spécifiques que le <xref:System.Threading.Thread.IsAlive%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="30c12-925">The <xref:System.Threading.Thread.ThreadState%2A> property provides more specific information than the <xref:System.Threading.Thread.IsAlive%2A> property.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="30c12-926">État du thread n’est utile dans les scénarios de débogage.</span><span class="sxs-lookup"><span data-stu-id="30c12-926">Thread state is only of interest in debugging scenarios.</span></span> <span data-ttu-id="30c12-927">Votre code ne doit jamais utiliser l’état des threads pour synchroniser les activités des threads.</span><span class="sxs-lookup"><span data-stu-id="30c12-927">Your code should never use thread state to synchronize the activities of threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-928">L’exemple de code suivant illustre l’accès à la `ThreadState` d’un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-928">The following code example demonstrates accessing the `ThreadState` of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="30c12-929">Nouvel état de cloisonnement.</span><span class="sxs-lookup"><span data-stu-id="30c12-929">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="30c12-930">Définit l'état de cloisonnement d'un thread avant qu'il ne soit démarré.</span><span class="sxs-lookup"><span data-stu-id="30c12-930">Sets the apartment state of a thread before it is started.</span></span></summary>
        <returns><span data-ttu-id="30c12-931"><see langword="true" /> si l'état de cloisonnement est défini ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-931"><see langword="true" /> if the apartment state is set; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-932">Nouveaux threads sont initialisés en tant que <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> si leur état de cloisonnement n’a pas été défini avant leur démarrage.</span><span class="sxs-lookup"><span data-stu-id="30c12-932">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="30c12-933">État de cloisonnement doit être définie avant le démarrage d’un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-933">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-934">Le thread principal de l’application est initialisé à <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> par défaut.</span><span class="sxs-lookup"><span data-stu-id="30c12-934">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="30c12-935">La seule façon de définir l’état de cloisonnement du thread principal de l’application à <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> consiste à appliquer le <xref:System.STAThreadAttribute> d’attribut à la méthode de point d’entrée.</span><span class="sxs-lookup"><span data-stu-id="30c12-935">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="30c12-936">Le <xref:System.Threading.Thread.TrySetApartmentState%2A> (méthode), avec la <xref:System.Threading.Thread.GetApartmentState%2A> (méthode) et le <xref:System.Threading.Thread.SetApartmentState%2A> (méthode), remplace le <xref:System.Threading.Thread.ApartmentState%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="30c12-936">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.SetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="30c12-937">L’exemple de code suivant montre le <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, et <xref:System.Threading.Thread.TrySetApartmentState%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="30c12-937">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="30c12-938">L’exemple de code crée un thread.</span><span class="sxs-lookup"><span data-stu-id="30c12-938">The code example creates a thread.</span></span> <span data-ttu-id="30c12-939">Avant que le thread est démarré, <xref:System.Threading.Thread.GetApartmentState%2A> affiche initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> état et <xref:System.Threading.Thread.SetApartmentState%2A> modifie l’état à <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="30c12-939">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="30c12-940">Le <xref:System.Threading.Thread.TrySetApartmentState%2A> méthode renvoie alors `false` lorsque vous tentez de modifier l’état à <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> , car l’état de cloisonnement est déjà défini.</span><span class="sxs-lookup"><span data-stu-id="30c12-940">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="30c12-941">Si la même opération avait été tentée avec <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> aurait été levée.</span><span class="sxs-lookup"><span data-stu-id="30c12-941">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="30c12-942">Une fois que le thread est démarré, le <xref:System.Threading.Thread.TrySetApartmentState%2A> méthode est utilisée à nouveau.</span><span class="sxs-lookup"><span data-stu-id="30c12-942">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="30c12-943">Cette fois, elle lève <xref:System.Threading.ThreadStateException> , car le thread a déjà été démarré.</span><span class="sxs-lookup"><span data-stu-id="30c12-943">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="30c12-944"><paramref name="state" /> n’est pas un état de cloisonnement valide.</span><span class="sxs-lookup"><span data-stu-id="30c12-944"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="30c12-945">Le thread a déjà été démarré.</span><span class="sxs-lookup"><span data-stu-id="30c12-945">The thread has already been started.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="30c12-946">Lit la valeur d'un champ.</span><span class="sxs-lookup"><span data-stu-id="30c12-946">Reads the value of a field.</span></span> <span data-ttu-id="30c12-947">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-947">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-948">Champ à lire.</span><span class="sxs-lookup"><span data-stu-id="30c12-948">The field to be read.</span></span></param>
        <summary><span data-ttu-id="30c12-949">Lit la valeur d'un champ.</span><span class="sxs-lookup"><span data-stu-id="30c12-949">Reads the value of a field.</span></span> <span data-ttu-id="30c12-950">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-950">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="30c12-951">Dernière valeur écrite dans le champ par un processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-951">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-952"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-952"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-953">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-953">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-954">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-954">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="30c12-955">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-955">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-956">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-956">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-957">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-957">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-958">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-958">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-959">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-959">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-960">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-960">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-961">Champ à lire.</span><span class="sxs-lookup"><span data-stu-id="30c12-961">The field to be read.</span></span></param>
        <summary><span data-ttu-id="30c12-962">Lit la valeur d'un champ.</span><span class="sxs-lookup"><span data-stu-id="30c12-962">Reads the value of a field.</span></span> <span data-ttu-id="30c12-963">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-963">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="30c12-964">Dernière valeur écrite dans le champ par un processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-964">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-965"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-965"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-966">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-966">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-967">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-967">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="30c12-968">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-968">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-969">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-969">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-970">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-970">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-971">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-971">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-972">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-972">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-973">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-973">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-974">Champ à lire.</span><span class="sxs-lookup"><span data-stu-id="30c12-974">The field to be read.</span></span></param>
        <summary><span data-ttu-id="30c12-975">Lit la valeur d'un champ.</span><span class="sxs-lookup"><span data-stu-id="30c12-975">Reads the value of a field.</span></span> <span data-ttu-id="30c12-976">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-976">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="30c12-977">Dernière valeur écrite dans le champ par un processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-977">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-978"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-978"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-979">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-979">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-980">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-980">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="30c12-981">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-981">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-982">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-982">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-983">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-983">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-984">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-984">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-985">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-985">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-986">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-986">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-987">Champ à lire.</span><span class="sxs-lookup"><span data-stu-id="30c12-987">The field to be read.</span></span></param>
        <summary><span data-ttu-id="30c12-988">Lit la valeur d'un champ.</span><span class="sxs-lookup"><span data-stu-id="30c12-988">Reads the value of a field.</span></span> <span data-ttu-id="30c12-989">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-989">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="30c12-990">Dernière valeur écrite dans le champ par un processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-990">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-991"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-991"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-992">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-992">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-993">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-993">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="30c12-994">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-994">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-995">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-995">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-996">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-996">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-997">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-997">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-998">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-998">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-999">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-999">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1000">Champ à lire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1000">The field to be read.</span></span></param>
        <summary><span data-ttu-id="30c12-1001">Lit la valeur d'un champ.</span><span class="sxs-lookup"><span data-stu-id="30c12-1001">Reads the value of a field.</span></span> <span data-ttu-id="30c12-1002">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1002">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="30c12-1003">Dernière valeur écrite dans le champ par un processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1003">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1004"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1004"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1005">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1005">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1006">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1006">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="30c12-1007">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1007">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1008">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1008">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1009">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1009">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1010">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1010">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1011">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1011">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1012">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1012">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1013">Champ à lire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1013">The field to be read.</span></span></param>
        <summary><span data-ttu-id="30c12-1014">Lit la valeur d'un champ.</span><span class="sxs-lookup"><span data-stu-id="30c12-1014">Reads the value of a field.</span></span> <span data-ttu-id="30c12-1015">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1015">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="30c12-1016">Dernière valeur écrite dans le champ par un processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1016">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1017"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1017"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1018">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1018">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1019">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1019">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="30c12-1020">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1020">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1021">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1021">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1022">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1022">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1023">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1023">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1024">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1024">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1025">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1025">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1026">Champ à lire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1026">The field to be read.</span></span></param>
        <summary><span data-ttu-id="30c12-1027">Lit la valeur d'un champ.</span><span class="sxs-lookup"><span data-stu-id="30c12-1027">Reads the value of a field.</span></span> <span data-ttu-id="30c12-1028">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1028">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="30c12-1029">Dernière valeur écrite dans le champ par un processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1029">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1030"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1030"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1031">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1031">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1032">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1032">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="30c12-1033">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1033">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1034">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1034">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1035">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1035">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1036">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1036">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1037">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1037">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1038">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1038">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1039">Champ à lire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1039">The field to be read.</span></span></param>
        <summary><span data-ttu-id="30c12-1040">Lit la valeur d'un champ.</span><span class="sxs-lookup"><span data-stu-id="30c12-1040">Reads the value of a field.</span></span> <span data-ttu-id="30c12-1041">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1041">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="30c12-1042">Dernière valeur écrite dans le champ par un processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1042">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1043"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1043"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1044">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1044">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1045">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1045">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="30c12-1046">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1046">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1047">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1047">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1048">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1048">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1049">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1049">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1050">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1050">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1051">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1051">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1052">Champ à lire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1052">The field to be read.</span></span></param>
        <summary><span data-ttu-id="30c12-1053">Lit la valeur d'un champ.</span><span class="sxs-lookup"><span data-stu-id="30c12-1053">Reads the value of a field.</span></span> <span data-ttu-id="30c12-1054">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1054">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="30c12-1055">Dernière valeur écrite dans le champ par un processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1055">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1056"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1056"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1057">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1057">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1058">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1058">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="30c12-1059">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1059">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1060">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1060">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1061">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1061">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1062">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1062">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1063">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1063">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1064">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1064">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1065">Champ à lire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1065">The field to be read.</span></span></param>
        <summary><span data-ttu-id="30c12-1066">Lit la valeur d'un champ.</span><span class="sxs-lookup"><span data-stu-id="30c12-1066">Reads the value of a field.</span></span> <span data-ttu-id="30c12-1067">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1067">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="30c12-1068">Dernière valeur écrite dans le champ par un processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1068">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1069"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1069"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1070">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1070">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1071">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1071">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="30c12-1072">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1072">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1073">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1073">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1074">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1074">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1075">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1075">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1076">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1076">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1077">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1077">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1078">Champ à lire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1078">The field to be read.</span></span></param>
        <summary><span data-ttu-id="30c12-1079">Lit la valeur d'un champ.</span><span class="sxs-lookup"><span data-stu-id="30c12-1079">Reads the value of a field.</span></span> <span data-ttu-id="30c12-1080">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1080">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="30c12-1081">Dernière valeur écrite dans le champ par un processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1081">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1082"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1082"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1083">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1083">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1084">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1084">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="30c12-1085">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1085">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1086">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1086">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1087">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1087">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1088">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1088">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1089">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1089">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1090">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1090">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1091">Champ à lire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1091">The field to be read.</span></span></param>
        <summary><span data-ttu-id="30c12-1092">Lit la valeur d'un champ.</span><span class="sxs-lookup"><span data-stu-id="30c12-1092">Reads the value of a field.</span></span> <span data-ttu-id="30c12-1093">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1093">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="30c12-1094">Dernière valeur écrite dans le champ par un processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1094">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1095"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1095"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1096">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1096">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1097">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1097">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="30c12-1098">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1098">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1099">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1099">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1100">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1100">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1101">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1101">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1102">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1102">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1103">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1103">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1104">Champ à lire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1104">The field to be read.</span></span></param>
        <summary><span data-ttu-id="30c12-1105">Lit la valeur d'un champ.</span><span class="sxs-lookup"><span data-stu-id="30c12-1105">Reads the value of a field.</span></span> <span data-ttu-id="30c12-1106">Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1106">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="30c12-1107">Dernière valeur écrite dans le champ par un processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1107">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1108"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1108"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1109">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1109">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1110">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1110">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="30c12-1111">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1111">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1112">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1112">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1113">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1113">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1114">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1114">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1115">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1115">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1116">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1116">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="30c12-1117">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1117">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Byte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1118">Champ dans lequel la valeur doit être écrite.</span><span class="sxs-lookup"><span data-stu-id="30c12-1118">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="30c12-1119">Valeur à écrire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1119">The value to be written.</span></span></param>
        <summary><span data-ttu-id="30c12-1120">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1120">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1121"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1121"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1122">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1122">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1123">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1123">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="30c12-1124">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1124">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1125">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1125">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1126">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1126">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1127">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1127">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1128">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1128">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1129">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1129">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1130">Champ dans lequel la valeur doit être écrite.</span><span class="sxs-lookup"><span data-stu-id="30c12-1130">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="30c12-1131">Valeur à écrire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1131">The value to be written.</span></span></param>
        <summary><span data-ttu-id="30c12-1132">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1132">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1133"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1133"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1134">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1134">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1135">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1135">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="30c12-1136">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1136">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1137">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1137">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1138">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1138">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1139">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1139">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1140">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1140">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1141">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1141">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Int16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1142">Champ dans lequel la valeur doit être écrite.</span><span class="sxs-lookup"><span data-stu-id="30c12-1142">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="30c12-1143">Valeur à écrire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1143">The value to be written.</span></span></param>
        <summary><span data-ttu-id="30c12-1144">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1144">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1145"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1145"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1146">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1146">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1147">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1147">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="30c12-1148">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1148">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1149">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1149">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1150">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1150">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1151">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1151">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1152">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1152">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1153">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1153">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1154">Champ dans lequel la valeur doit être écrite.</span><span class="sxs-lookup"><span data-stu-id="30c12-1154">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="30c12-1155">Valeur à écrire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1155">The value to be written.</span></span></param>
        <summary><span data-ttu-id="30c12-1156">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1156">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1157"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1157"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1158">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1158">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1159">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1159">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="30c12-1160">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1160">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1161">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1161">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1162">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1162">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1163">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1163">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1164">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1164">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1165">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1165">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1166">Champ dans lequel la valeur doit être écrite.</span><span class="sxs-lookup"><span data-stu-id="30c12-1166">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="30c12-1167">Valeur à écrire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1167">The value to be written.</span></span></param>
        <summary><span data-ttu-id="30c12-1168">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1168">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1169"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1169"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1170">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1170">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1171">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1171">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="30c12-1172">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1172">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1173">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1173">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1174">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1174">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1175">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1175">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1176">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1176">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1177">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1177">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1178">Champ dans lequel la valeur doit être écrite.</span><span class="sxs-lookup"><span data-stu-id="30c12-1178">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="30c12-1179">Valeur à écrire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1179">The value to be written.</span></span></param>
        <summary><span data-ttu-id="30c12-1180">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1180">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1181"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1181"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1182">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1182">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1183">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1183">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="30c12-1184">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1184">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1185">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1185">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1186">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1186">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1187">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1187">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1188">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1188">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1189">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1189">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1190">Champ dans lequel la valeur doit être écrite.</span><span class="sxs-lookup"><span data-stu-id="30c12-1190">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="30c12-1191">Valeur à écrire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1191">The value to be written.</span></span></param>
        <summary><span data-ttu-id="30c12-1192">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1192">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1193"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1193"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1194">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1194">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1195">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1195">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="30c12-1196">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1196">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1197">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1197">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1198">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1198">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1199">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1199">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1200">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1200">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1201">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1201">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.SByte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1202">Champ dans lequel la valeur doit être écrite.</span><span class="sxs-lookup"><span data-stu-id="30c12-1202">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="30c12-1203">Valeur à écrire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1203">The value to be written.</span></span></param>
        <summary><span data-ttu-id="30c12-1204">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1204">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1205"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1205"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1206">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1206">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1207">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1207">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="30c12-1208">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1208">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1209">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1209">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1210">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1210">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1211">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1211">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1212">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1212">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1213">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1213">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1214">Champ dans lequel la valeur doit être écrite.</span><span class="sxs-lookup"><span data-stu-id="30c12-1214">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="30c12-1215">Valeur à écrire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1215">The value to be written.</span></span></param>
        <summary><span data-ttu-id="30c12-1216">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1216">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1217"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1217"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1218">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1218">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1219">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1219">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="30c12-1220">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1220">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1221">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1221">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1222">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1222">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1223">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1223">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1224">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1224">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1225">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1225">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UInt16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1226">Champ dans lequel la valeur doit être écrite.</span><span class="sxs-lookup"><span data-stu-id="30c12-1226">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="30c12-1227">Valeur à écrire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1227">The value to be written.</span></span></param>
        <summary><span data-ttu-id="30c12-1228">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1228">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1229"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1229"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1230">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1230">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1231">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1231">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="30c12-1232">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1232">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1233">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1233">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1234">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1234">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1235">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1235">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1236">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1236">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1237">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1237">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1238">Champ dans lequel la valeur doit être écrite.</span><span class="sxs-lookup"><span data-stu-id="30c12-1238">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="30c12-1239">Valeur à écrire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1239">The value to be written.</span></span></param>
        <summary><span data-ttu-id="30c12-1240">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1240">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1241"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1241"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1242">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1242">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1243">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1243">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="30c12-1244">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1244">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1245">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1245">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1246">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1246">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1247">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1247">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1248">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1248">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1249">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1249">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1250">Champ dans lequel la valeur doit être écrite.</span><span class="sxs-lookup"><span data-stu-id="30c12-1250">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="30c12-1251">Valeur à écrire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1251">The value to be written.</span></span></param>
        <summary><span data-ttu-id="30c12-1252">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1252">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1253"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1253"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1254">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1254">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1255">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1255">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="30c12-1256">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1256">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1257">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1257">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1258">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1258">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1259">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1259">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1260">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1260">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1261">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1261">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UIntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="30c12-1262">Champ dans lequel la valeur doit être écrite.</span><span class="sxs-lookup"><span data-stu-id="30c12-1262">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="30c12-1263">Valeur à écrire.</span><span class="sxs-lookup"><span data-stu-id="30c12-1263">The value to be written.</span></span></param>
        <summary><span data-ttu-id="30c12-1264">Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1264">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1265"><xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="30c12-1265"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="30c12-1266">Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.</span><span class="sxs-lookup"><span data-stu-id="30c12-1266">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="30c12-1267">Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs.</span><span class="sxs-lookup"><span data-stu-id="30c12-1267">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="30c12-1268">Vous devrez peut-être vider les caches de processeur.</span><span class="sxs-lookup"><span data-stu-id="30c12-1268">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="30c12-1269">Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur).</span><span class="sxs-lookup"><span data-stu-id="30c12-1269">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="30c12-1270">Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1270">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="30c12-1271">Appel de cette méthode affecte uniquement un accès à la mémoire unique.</span><span class="sxs-lookup"><span data-stu-id="30c12-1271">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="30c12-1272">Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1272">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30c12-1273">En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="30c12-1273">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="30c12-1274">Oblige le thread appelant à céder l'exécution à un autre thread prêt à s'exécuter sur le processeur actuel.</span><span class="sxs-lookup"><span data-stu-id="30c12-1274">Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</span></span> <span data-ttu-id="30c12-1275">Le système d'exploitation sélectionne le thread auquel l'exécution doit être cédée.</span><span class="sxs-lookup"><span data-stu-id="30c12-1275">The operating system selects the thread to yield to.</span></span></summary>
        <returns><span data-ttu-id="30c12-1276"><see langword="true" /> si le système d'exploitation a basculé l'exécution vers un autre thread ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="30c12-1276"><see langword="true" /> if the operating system switched execution to another thread; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="30c12-1277">Si cette méthode réussit, le reste de la tranche de temps actuelle du thread est obtenue.</span><span class="sxs-lookup"><span data-stu-id="30c12-1277">If this method succeeds, the rest of the thread's current time slice is yielded.</span></span> <span data-ttu-id="30c12-1278">Le système d’exploitation planifie le thread appelant pour une autre tranche de temps, en fonction de sa priorité et l’état des autres threads qui sont disponibles pour l’exécuter.</span><span class="sxs-lookup"><span data-stu-id="30c12-1278">The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</span></span>  
  
 <span data-ttu-id="30c12-1279">Génération de résultats est limitée au processeur qui exécute le thread appelant.</span><span class="sxs-lookup"><span data-stu-id="30c12-1279">Yielding is limited to the processor that is executing the calling thread.</span></span> <span data-ttu-id="30c12-1280">Le système d’exploitation ne bascule pas de l’exécution vers un autre processeur, même si ce processeur est inactif ou exécute un thread de priorité inférieure.</span><span class="sxs-lookup"><span data-stu-id="30c12-1280">The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</span></span> <span data-ttu-id="30c12-1281">Si aucun autre thread qui sont prêts à exécuter sur le processeur actuel, le système d’exploitation ne suspend pas l’exécution, et cette méthode retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="30c12-1281">If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns `false`.</span></span>  
  
 <span data-ttu-id="30c12-1282">Cette méthode est équivalente à l’aide de la plateforme de l’appel pour appeler Win32 natif `SwitchToThread` (fonction).</span><span class="sxs-lookup"><span data-stu-id="30c12-1282">This method is equivalent to using platform invoke to call the native Win32 `SwitchToThread` function.</span></span> <span data-ttu-id="30c12-1283">Vous devez appeler la <xref:System.Threading.Thread.Yield%2A> appeler de méthode au lieu d’utiliser la plateforme, car tout comportement de thread personnalisé l’hôte a demandé de contournements non managé.</span><span class="sxs-lookup"><span data-stu-id="30c12-1283">You should call the <xref:System.Threading.Thread.Yield%2A> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>