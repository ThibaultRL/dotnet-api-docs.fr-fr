<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="38eda2875476a401d6a3442e5e40cebc592a4863" />
    <Meta Name="ms.sourcegitcommit" Value="996ba67625b61917bcf75bfefe6dcb016019c2d8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/02/2018" />
    <Meta Name="ms.locfileid" Value="50965472" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Crée et contrôle un thread, définit sa priorité et obtient son état.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand un processus démarre, le common language runtime crée automatiquement un thread de premier plan pour exécuter le code d’application. En même temps que ce thread de premier plan principal, un processus peut créer un ou plusieurs threads pour exécuter une partie du code du programme associé au processus. Ces threads peuvent exécuter au premier plan ou en arrière-plan. En outre, vous pouvez utiliser la <xref:System.Threading.ThreadPool> classe pour exécuter du code sur les threads de travail qui sont gérés par le common language runtime.  
  
 Dans cette section  
  
 [À partir d’un thread](#Starting)   
 [Récupération d’objets de Thread](#Retrieving)   
 [Threads de premier plan et d’arrière-plan](#Foreground)   
 [Culture et des threads](#Culture)   
 [Obtenir des informations sur et contrôler les threads](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>À partir d’un thread  
 Démarrer un thread en fournissant un délégué qui représente la méthode que le thread consiste à exécuter dans son constructeur de classe. Vous appelez ensuite la <xref:System.Threading.Thread.Start%2A> méthode pour commencer l’exécution.  
  
 Le <xref:System.Threading.Thread> constructeurs peuvent prendre un des types de délégué deux, selon que vous pouvez passer un argument à la méthode à exécuter :  
  
-   Si la méthode n’a aucun argument, vous passez un <xref:System.Threading.ThreadStart> déléguer au constructeur. Il a la signature :  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     L’exemple suivant crée et démarre un thread qui exécute le `ExecuteInForeground` (méthode). La méthode affiche des informations sur certaines propriétés de thread, puis exécute une boucle dans laquelle elle s’interrompt pendant une demi-seconde et affiche le nombre de secondes écoulé. Lorsque le thread a été exécutée pendant au moins cinq secondes, fin de la boucle et le thread se termine l’exécution.  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   Si la méthode possède un argument, vous passez un <xref:System.Threading.ParameterizedThreadStart> déléguer au constructeur. Il a la signature :  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     La méthode exécutée par le délégué peut ensuite effectuer un cast (en c#) ou convertir (en Visual Basic) le paramètre du type approprié.  
  
     L’exemple suivant est identique au précédent, excepté qu’il appelle le <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructeur. Cette version de la `ExecuteInForeground` méthode possède un paramètre unique qui représente le nombre approximatif de millisecondes de la boucle doit s’exécuter.  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 Il n’est pas nécessaire de conserver une référence à un <xref:System.Threading.Thread> une fois que vous avez démarré le thread de l’objet. Le thread continue à s’exécuter jusqu'à la fin de la procédure de thread.  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>Récupération d’objets de Thread  
 Vous pouvez utiliser la méthode statique (`Shared` en Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> propriété à récupérer une référence au thread en cours d’exécution à partir du code que le thread s’exécute. L’exemple suivant utilise le <xref:System.Threading.Thread.CurrentThread%2A> propriété pour afficher des informations sur le thread principal de l’application, un autre thread de premier plan, un thread d’arrière-plan et un thread de pool de threads.  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>Threads de premier plan et d’arrière-plan  
 Instances de la <xref:System.Threading.Thread> classe représentent les threads de premier plan ou de threads d’arrière-plan. Threads d’arrière-plan sont identiques aux threads de premier plan à une exception près : un thread d’arrière-plan ne conserve pas un processus exécuté si tous les threads de premier plan sont terminés. Une fois que tous les threads de premier plan ont été arrêtés, le runtime arrête tous les threads d’arrière-plan et s’arrête.  
  
 Par défaut, les threads suivants s’exécutent au premier plan :  
  
-   Le thread principal de l’application.  
  
-   Tous les threads créés en appelant un <xref:System.Threading.Thread> constructeur de classe.  
  
 Les threads suivants s’exécutent en arrière-plan par défaut :  
  
-   Thread du pool de threads, qui constituent un pool de threads de travail géré par le runtime.  Vous pouvez configurer le travail de pool et de planification de thread sur les threads du pool à l’aide de la <xref:System.Threading.ThreadPool> classe.  
  
    > [!NOTE]
    >  Opérations asynchrones basées sur la tâche s’exécute automatiquement sur les threads du pool. Utilisent des opérations asynchrones basées sur une tâche le <xref:System.Threading.Tasks.Task> et <xref:System.Threading.Tasks.Task%601> classes pour implémenter le [modèle asynchrone basé sur les tâches](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).  
  
-   Tous les threads qui entrent dans l’environnement d’exécution managé à partir de code non managé.  
  
 Vous pouvez modifier un thread d’exécuter en arrière-plan en définissant le <xref:System.Threading.Thread.IsBackground%2A> propriété à tout moment.  Threads d’arrière-plan sont utiles pour toute opération qui doit se poursuivre tant qu’une application est en cours d’exécution mais ne doit pas empêcher l’application à partir de la fin d’exécution, comme la surveillance des modifications de système de fichiers ou les connexions de socket entrante.  
  
 L’exemple suivant illustre la différence entre les threads de premier plan et d’arrière-plan. C’est comme le premier exemple dans le [à partir d’un thread](#Starting) section, sauf qu’il définit le thread de s’exécuter en arrière-plan avant de le démarrer. Comme le montre la sortie, la boucle est interrompue avant de s’exécuter pendant cinq secondes.  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>Culture et des threads  
 Chaque thread possède une culture, représentée par le <xref:System.Threading.Thread.CurrentCulture%2A> propriété et une culture d’interface utilisateur, représentée par le <xref:System.Threading.Thread.CurrentUICulture%2A> propriété.  La culture actuelle prend en charge ces opérations dépendantes de la culture en tant que l’analyse et mise en forme, comparaison de chaînes et le tri et contrôle également le système d’écriture et le calendrier utilisé par un thread. La culture d’interface utilisateur actuelle fournit pour la récupération de la culture des ressources dans les fichiers de ressources.  

> [!IMPORTANT]
> Le <xref:System.Threading.Thread.CurrentCulture> et <xref:System.Threading.Thread.CurrentUICulture> propriétés ne fonctionnent de façon fiable lorsqu’il est utilisé avec n’importe quel thread autre que le thread actuel. Dans .NET Framework, la lecture de ces propriétés est fiable, bien que la définition de ces propriétés pour un thread autre que le thread actuel n’est pas. Sur .NET Core, un <xref:System.InvalidOperationException> est levée si un thread tente de lire ou écrire ces propriétés sur un thread différent.
> Nous vous recommandons d’utiliser le <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> et <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> propriétés à récupérer et définir la culture actuelle.

 Quand un nouveau thread est instancié, sa culture et la culture d’interface utilisateur sont définis par la culture système actuelle et la culture d’interface utilisateur et non par la culture et la culture d’interface utilisateur du thread à partir duquel le nouveau thread est créé. Cela signifie, par exemple, que si la culture système actuelle est anglais (États-Unis) et la culture actuelle du thread d’application principal est le Français (France), la culture d’un nouveau thread créé en appelant le <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructeur à partir du thread principal est anglais (États-Unis) et pas Français (France). Pour plus d’informations, consultez la section « Culture et threads » de la <xref:System.Globalization.CultureInfo> rubrique de la classe.  
  
> [!IMPORTANT]
>  Cela n’est pas vrai pour les threads qui exécutent des opérations asynchrones pour les applications qui ciblent le [!INCLUDE[net_v46](~/includes/net-v46-md.md)] et versions ultérieures, dans ce cas, la culture et la culture d’interface utilisateur fait partie d’une commande asynchrone contexte des opérations ; le thread sur lequel une opération asynchrone s’exécute par défaut hérite de la culture et la culture d’interface utilisateur du thread à partir duquel l’opération asynchrone a été lancée. Pour plus d'informations, consultez la section « Culture et opérations asynchrones basées sur les tâches » de la rubrique relative à la classe <xref:System.Globalization.CultureInfo>.  
  
 Vous pouvez effectuer l’une des opérations suivantes pour vous assurer que tous les threads de l’exécution dans une application partagent la même culture et la culture d’interface utilisateur :  
  
-   Vous pouvez passer un <xref:System.Globalization.CultureInfo> objet qui représente cette culture pour le <xref:System.Threading.ParameterizedThreadStart> déléguer ou <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> (méthode).  
  
-   Pour les applications exécutées le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] et versions ultérieures, vous pouvez définir la culture et la culture d’interface utilisateur qui doit être affecté à tous les threads créés dans un domaine d’application en définissant la valeur de la <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> et <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> propriétés. Notez qu’il s’agit d’un paramètre par domaine d’application.  

 Pour plus d’informations et des exemples, consultez la section « Culture et threads » de la <xref:System.Globalization.CultureInfo> rubrique de la classe.

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>Obtenir des informations sur et contrôler les threads  
 Vous pouvez récupérer un nombre de valeurs de propriétés qui fournissent des informations sur un thread. Dans certains cas, vous pouvez également définir ces valeurs de propriété pour contrôler le fonctionnement du thread. Ces propriétés de thread sont les suivantes :  
  
-   Nom. <xref:System.Threading.Thread.Name%2A> est une écriture-propriété une fois que vous pouvez utiliser pour identifier un thread.  Sa valeur par défaut est `null`.  
  
-   Un code de hachage, vous pouvez récupérer en appelant le <xref:System.Threading.Thread.GetHashCode%2A> (méthode). Le code de hachage peut être utilisé pour identifier de façon unique un thread ; pour la durée de vie de votre thread, son code de hachage ne sera pas entrer en conflit avec la valeur à partir de n’importe quel autre thread, quel que soit le domaine d’application à partir de laquelle vous obtenez la valeur.  
  
-   Un ID de thread. La valeur de la lecture seule <xref:System.Threading.Thread.ManagedThreadId%2A> propriété est attribuée par le runtime et identifie de façon unique un thread au sein de son processus.  
  
    > [!NOTE]
    >  Un [ID de thread](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) de système d'exploitation n'est pas lié de manière fixe à un thread managé, car un hôte non managé peut contrôler la relation entre les threads managés et les threads non managés. Plus précisément, un hôte élaboré peut utiliser le [API d’hébergement CLR](https://msdn.microsoft.com/library/ms404385.aspx) pour planifier de nombreux threads managés sur le même thread de système d’exploitation, ou pour déplacer un thread managé entre les threads de système d’exploitation différent.  
  
-   L’état du thread actuel. Pendant la durée de son existence, un thread se trouve toujours dans un ou plusieurs des états définis par le <xref:System.Threading.ThreadState> propriété.  
  
-   Un niveau de priorité de planification est défini par le <xref:System.Threading.ThreadPriority> propriété. Bien que vous pouvez définir cette valeur pour demander une priorité de thread, il n’est pas garanti à être respectées par le système d’exploitation.  
  
-   En lecture seule <xref:System.Threading.Thread.IsThreadPoolThread%2A> propriété, qui indique si un thread est un thread de pool de threads.  
  
-   La propriété <xref:System.Threading.Thread.IsBackground%2A>. Pour plus d’informations, consultez le [les threads de premier plan et arrière-plan](#Foreground) section.  
  
## Examples  
 L’exemple suivant illustre la fonctionnalité de thread simple.  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 Ce code produit une sortie similaire à ce qui suit :  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads et threading</related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">Utilisation des threads et du threading</related>
    <related type="ExternalDocumentation" href="http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96">Source de référence pour la classe de Thread</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Thread" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">Délégué qui représente les méthodes à appeler au début de l'exécution de ce thread.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Thread" />, en spécifiant un délégué qui permet à un objet d'être passé au thread quand le thread est démarré.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un thread d’exécution ne commence pas lors de sa création. Pour planifier l’exécution du thread, appelez le <xref:System.Threading.Thread.Start%2A> (méthode). Pour passer un objet de données au thread, utilisez la <xref:System.Threading.Thread.Start%28System.Object%29> surcharge de méthode.  
  
> [!NOTE]
>  Les utilisateurs de Visual Basic peuvent omettre le <xref:System.Threading.ThreadStart> constructeur lors de la création d’un thread. Utilisez le `AddressOf` opérateur lorsque vous passez votre méthode, par exemple `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic appelle automatiquement la <xref:System.Threading.ThreadStart> constructeur.  
  
   
  
## Examples  
 L’exemple suivant illustre la syntaxe pour créer et utiliser un <xref:System.Threading.ParameterizedThreadStart> délégué avec une méthode statique et une méthode d’instance.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Création de Threads</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">Délégué <see cref="T:System.Threading.ThreadStart" /> qui représente les méthodes à appeler au début de l'exécution de ce thread.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Thread" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un thread d’exécution ne commence pas lors de sa création. Pour planifier l’exécution du thread, appelez le <xref:System.Threading.Thread.Start%2A> (méthode).  
  
> [!NOTE]
>  Les utilisateurs de Visual Basic peuvent omettre le <xref:System.Threading.ThreadStart> constructeur lors de la création d’un thread. Utilisez le `AddressOf` opérateur lorsque vous passez votre méthode par exemple `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic appelle automatiquement la <xref:System.Threading.ThreadStart> constructeur.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un thread qui exécute une méthode statique.  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 L’exemple de code suivant montre comment créer un thread qui exécute une méthode d’instance.  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="start" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Création de Threads</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Délégué <see cref="T:System.Threading.ParameterizedThreadStart" /> qui représente les méthodes à appeler au début de l'exécution de ce thread.</param>
        <param name="maxStackSize">Taille de pile maximale, en octets, à utiliser par le thread, ou 0 pour utiliser la taille de pile maximale par défaut spécifiée dans l'en-tête pour le fichier exécutable.  
  
Important   Pour le code partiellement fiable, <c>maxStackSize</c> est ignoré s’il est supérieur à la taille de la pile par défaut. Aucune exception n'est levée.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Thread" />, en spécifiant un délégué qui permet à un objet d'être passé au thread quand le thread est démarré et en spécifiant la taille de pile maximale pour le thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Évitez d’utiliser cette surcharge de constructeur. La taille de pile par défaut utilisée par le <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> surcharge de constructeur est la taille de pile recommandée pour les threads. Si un thread a des problèmes de mémoire, la cause la plus probable est la programmation erreur, telle qu’une récurrence infinie.  
  
> [!IMPORTANT]
>  Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]uniquement de confiance suffisant pour le code peut définir `maxStackSize` sur une valeur supérieure à celle de la taille de pile par défaut (1 Mo). Si une valeur supérieure est spécifiée pour `maxStackSize` lorsque le code s’exécute avec une confiance partielle, `maxStackSize` est ignoré et la taille de pile par défaut est utilisée. Aucune exception n'est levée. Le code à tout niveau de confiance peut définir `maxStackSize` sur une valeur inférieure à la taille de pile par défaut.  
  
> [!NOTE]
>  Si vous développez une bibliothèque totalement approuvée qui sera utilisée par du code partiellement fiable, et que vous avez besoin démarrer un thread qui nécessite une importante pile, vous devez déclarer la confiance totale avant de créer le thread ou la taille de pile par défaut sera utilisée. Ne le faites pas, sauf si vous contrôlez entièrement le code qui s’exécute sur le thread.  
  
 Si `maxStackSize` est inférieure à la taille minimale de pile, la taille de pile minimale est utilisée. Si `maxStackSize` n’est pas un multiple de la taille de page, il est arrondi au prochain multiple de la taille de page. Par exemple, si vous utilisez la version 2.0 du .NET Framework sur Windows Vista, 256 Ko (262 144 octets) est la taille de pile minimale et la taille de page est de 64 Ko (65 536 octets).  
  
> [!NOTE]
>  Sur les versions de Windows Microsoft antérieurs à Windows XP et Windows Server 2003, `maxStackSize` est ignoré, et la taille de pile spécifiée dans l’en-tête de l’exécutable est utilisée.  
  
 Si vous spécifiez une très petite taille de pile, vous devrez peut-être désactiver la détection de débordement de pile. Lors de la pile est sévèrement limitée, la détection peut elle-même provoquer un débordement de pile. Pour désactiver la détection de dépassement de capacité de pile, ajoutez le code suivant au fichier de configuration de votre application.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Délégué <see cref="T:System.Threading.ThreadStart" /> qui représente les méthodes à appeler au début de l'exécution de ce thread.</param>
        <param name="maxStackSize">Taille de pile maximale, en octets, à utiliser par le thread, ou 0 pour utiliser la taille de pile maximale par défaut spécifiée dans l'en-tête pour le fichier exécutable.  
  
Important   Pour le code partiellement fiable, <c>maxStackSize</c> est ignoré s’il est supérieur à la taille de la pile par défaut. Aucune exception n'est levée.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Thread" />, en spécifiant la taille de pile maximale pour le thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Évitez d’utiliser cette surcharge de constructeur. La taille de pile par défaut utilisée par le <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> surcharge de constructeur est la taille de pile recommandée pour les threads. Si un thread a des problèmes de mémoire, la cause la plus probable est la programmation erreur, telle qu’une récurrence infinie.  
  
> [!IMPORTANT]
>  Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]uniquement de confiance suffisant pour le code peut définir `maxStackSize` sur une valeur supérieure à celle de la taille de pile par défaut (1 Mo). Si une valeur supérieure est spécifiée pour `maxStackSize` lorsque le code s’exécute avec une confiance partielle, `maxStackSize` est ignoré et la taille de pile par défaut est utilisée. Aucune exception n'est levée. Le code à tout niveau de confiance peut définir `maxStackSize` sur une valeur inférieure à la taille de pile par défaut.  
  
> [!NOTE]
>  Si vous développez une bibliothèque totalement approuvée qui sera utilisée par du code partiellement fiable, et que vous avez besoin démarrer un thread qui nécessite une importante pile, vous devez déclarer la confiance totale avant de créer le thread ou la taille de pile par défaut sera utilisée. Ne le faites pas, sauf si vous contrôlez entièrement le code qui s’exécute sur le thread.  
  
 Si `maxStackSize` est inférieure à la taille minimale de pile, la taille de pile minimale est utilisée. Si `maxStackSize` n’est pas un multiple de la taille de page, il est arrondi au prochain multiple de la taille de page. Par exemple, si vous utilisez la version 2.0 du .NET Framework sur Windows Vista, 256 Ko (262 144 octets) est la taille de pile minimale et la taille de page est de 64 Ko (65 536 octets).  
  
> [!NOTE]
>  Sur les versions de Windows Microsoft antérieurs à Windows XP et Windows Server 2003, `maxStackSize` est ignoré, et la taille de pile spécifiée dans l’en-tête de l’exécutable est utilisée.  
  
 Si vous spécifiez une très petite taille de pile, vous devrez peut-être désactiver la détection de débordement de pile. Lors de la pile est sévèrement limitée, la détection peut elle-même provoquer un débordement de pile. Pour désactiver la détection de dépassement de capacité de pile, ajoutez le code suivant au fichier de configuration de votre application.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Déclenche <see cref="T:System.Threading.ThreadAbortException" /> dans le thread sur lequel l'appel a lieu pour commencer le processus d'arrêt du thread. L'appel de cette méthode arrête généralement le thread.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Déclenche <see cref="T:System.Threading.ThreadAbortException" /> dans le thread sur lequel l'appel a lieu pour commencer le processus d'arrêt du thread. L'appel de cette méthode arrête généralement le thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette méthode est appelée sur un thread, le système lève une <xref:System.Threading.ThreadAbortException> dans le thread pour l’abandonner. `ThreadAbortException` est une exception spéciale qui peut être interceptée par le code d’application, mais est à nouveau levée à la fin de la `catch` bloquer, sauf si <xref:System.Threading.Thread.ResetAbort%2A> est appelée. `ResetAbort` Annule la demande d’abandon et empêche le `ThreadAbortException` à partir de l’arrêt du thread. Non `finally` blocs sont exécutés avant l’abandon du thread.  
  
> [!NOTE]
>  Lorsqu’un thread appelle `Abort` sur lui-même, l’effet est similaire à la levée d’une exception ; le <xref:System.Threading.ThreadAbortException> se produit immédiatement, et le résultat est prévisible. Toutefois, si un thread appelle `Abort` sur un autre thread, l’abandon interrompt le code est en cours d’exécution. Il est également probable qu’un constructeur statique soit abandonné. Dans de rares cas, ceci peut empêcher des instances de cette classe d’être créées dans ce domaine d’application. Dans les versions 1.0 et 1.1 du .NET Framework, il existe un risque le thread abandonné pendant un `finally` bloc est en cours d’exécution, auquel cas la `finally` bloc est abandonné.  
  
 Le thread n’est pas garanti pour abandonner immédiatement, ou du tout. Cette situation peut se produire si un thread effectue un nombre illimité de calcul dans le `finally` blocs qui sont appelées dans le cadre de la procédure d’abandon, ce qui retarde indéfiniment l’abandon. Pour attendre qu’un thread a abandonné, vous pouvez appeler la <xref:System.Threading.Thread.Join%2A> méthode sur le thread après avoir appelé la <xref:System.Threading.Thread.Abort%2A> (méthode), mais il n’existe aucune garantie que l’attente se termine.  
  
> [!NOTE]
>  Le thread qui appelle <xref:System.Threading.Thread.Abort%2A> peut se bloquer si le thread qui est en cours d’abandon est dans une zone protégée du code, comme un `catch` bloc, `finally` bloc ou la région d’exécution limitée. Si le thread qui appelle <xref:System.Threading.Thread.Abort%2A> maintient un verrouillage que le thread interrompu requiert, un interblocage peut se produire.  
  
 Si `Abort` est appelée sur un thread qui n’a pas été démarré, le thread sera abandonnée lorsque <xref:System.Threading.Thread.Start%2A> est appelée. Si `Abort` est appelée sur un thread qui est bloqué ou en état de veille, le thread est interrompu et puis abandonné.  
  
 Si `Abort` est appelée sur un thread qui a été suspendu, un <xref:System.Threading.ThreadStateException> est levée dans le thread qui a appelé <xref:System.Threading.Thread.Abort%2A>, et <xref:System.Threading.ThreadState.AbortRequested> est ajouté à la <xref:System.Threading.Thread.ThreadState%2A> propriété du thread en cours d’abandon. Un <xref:System.Threading.ThreadAbortException> n’est pas levée dans le thread suspendu jusqu'à ce que <xref:System.Threading.Thread.Resume%2A> est appelée.  
  
 Si `Abort` est appelée sur un thread managé, tandis que l’exécution de code non managé, un `ThreadAbortException` n’est pas levée jusqu'à ce que le thread retourne au code managé.  
  
 Si deux appels à `Abort` sont fournis en même temps, il est possible qu’un seul appel à définir les informations d’état et l’autre appel pour exécuter le `Abort`. Toutefois, une application ne peut pas détecter cette situation.  
  
 Après avoir `Abort` est appelé sur un thread, l’état du thread inclut <xref:System.Threading.ThreadState.AbortRequested>. Une fois que le thread s’est arrêté suite à un appel réussi à `Abort`, l’état du thread est passé à <xref:System.Threading.ThreadState.Stopped>. Avec des autorisations suffisantes, un thread qui est la cible d’une `Abort` peut annuler l’abandon à l’aide de la `ResetAbort` (méthode). Pour obtenir un exemple qui montre comment appeler le `ResetAbort` (méthode), consultez la `ThreadAbortException` classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core uniquement : ce membre n’est pas pris en charge.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Le thread en cours d’abandon est actuellement suspendu.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour les opérations avancées sur les threads. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads et threading</related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">Utilisation des threads et du threading</related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">Détruire des threads</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">Objet contenant des informations spécifiques à l'application, telles que l'état, qui peuvent être utilisées par le thread en cours d'abandon.</param>
        <summary>Déclenche une <see cref="T:System.Threading.ThreadAbortException" /> dans le thread sur lequel l'appel a lieu pour commencer le processus d'arrêt du thread, tout en fournissant des informations sur les exceptions relatives à l'arrêt du thread. L'appel de cette méthode arrête généralement le thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette méthode est appelée sur un thread, le système lève une <xref:System.Threading.ThreadAbortException> dans le thread pour l’abandonner. `ThreadAbortException` est une exception spéciale qui peut être interceptée par le code d’application, mais est à nouveau levée à la fin de la `catch` bloquer, sauf si <xref:System.Threading.Thread.ResetAbort%2A> est appelée. `ResetAbort` Annule la demande d’abandon et empêche le `ThreadAbortException` à partir de l’arrêt du thread. Non `finally` blocs sont exécutés avant l’abandon du thread.  
  
> [!NOTE]
>  Lorsqu’un thread appelle `Abort` sur lui-même, l’effet est similaire à la levée d’une exception ; le <xref:System.Threading.ThreadAbortException> se produit immédiatement, et le résultat est prévisible. Toutefois, si un thread appelle `Abort` sur un autre thread, l’abandon interrompt le code est en cours d’exécution. Il est probable qu’un constructeur statique soit abandonné. Dans de rares cas, ceci peut empêcher des instances de cette classe d’être créées dans ce domaine d’application. Dans les versions 1.0 et 1.1 du .NET Framework, il existe un risque le thread abandonné pendant un `finally` bloc est en cours d’exécution, auquel cas la `finally` bloc est abandonné.  
  
 Le thread n’est pas garanti pour abandonner immédiatement, ou du tout. Cette situation peut se produire si un thread effectue un nombre illimité de calcul dans le `finally` blocs qui sont appelées dans le cadre de la procédure d’abandon, ce qui retarde indéfiniment l’abandon. Pour attendre qu’un thread a abandonné, vous pouvez appeler la <xref:System.Threading.Thread.Join%2A> méthode sur le thread après avoir appelé la <xref:System.Threading.Thread.Abort%2A> (méthode), mais il n’existe aucune garantie que l’attente se termine.  
  
> [!NOTE]
>  Le thread qui appelle <xref:System.Threading.Thread.Abort%2A> peut se bloquer si le thread qui est en cours d’abandon est dans une zone protégée du code, comme un `catch` bloc, `finally` bloc ou la région d’exécution limitée. Si le thread qui appelle <xref:System.Threading.Thread.Abort%2A> maintient un verrouillage que le thread interrompu requiert, un interblocage peut se produire.  
  
 Si `Abort` est appelée sur un thread qui n’a pas été démarré, le thread sera abandonnée lorsque <xref:System.Threading.Thread.Start%2A> est appelée. Si `Abort` est appelée sur un thread qui est bloqué ou en état de veille, le thread est interrompu et puis abandonné.  
  
 Si `Abort` est appelée sur un thread qui a été suspendu, un <xref:System.Threading.ThreadStateException> est levée dans le thread qui a appelé <xref:System.Threading.Thread.Abort%2A>, et <xref:System.Threading.ThreadState.AbortRequested> est ajouté à la <xref:System.Threading.Thread.ThreadState%2A> propriété du thread en cours d’abandon. Un <xref:System.Threading.ThreadAbortException> n’est pas levée dans le thread suspendu jusqu'à ce que <xref:System.Threading.Thread.Resume%2A> est appelée.  
  
 Si `Abort` est appelée sur un thread managé, tandis que l’exécution de code non managé, un `ThreadAbortException` n’est pas levée jusqu'à ce que le thread retourne au code managé.  
  
 Si deux appels à `Abort` sont fournis en même temps, il est possible qu’un seul appel à définir les informations d’état et l’autre appel pour exécuter le `Abort`. Toutefois, une application ne peut pas détecter cette situation.  
  
 Après avoir `Abort` est appelé sur un thread, l’état du thread inclut <xref:System.Threading.ThreadState.AbortRequested>. Une fois que le thread s’est arrêté suite à un appel réussi à `Abort`, l’état du thread est passé à <xref:System.Threading.ThreadState.Stopped>. Avec des autorisations suffisantes, un thread qui est la cible d’une `Abort` peut annuler l’abandon à l’aide de la `ResetAbort` (méthode). Pour obtenir un exemple qui montre comment appeler le `ResetAbort` (méthode), consultez la `ThreadAbortException` classe.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment transmettre des informations à un thread qui est en cours d’abandon.  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core uniquement : ce membre n’est pas pris en charge.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Le thread en cours d’abandon est actuellement suspendu.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour les opérations avancées sur les threads. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads et threading</related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">Utilisation des threads et du threading</related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">Détruire des threads</related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Alloue sur tous les threads un emplacement de données sans nom. Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>Emplacement de données nommé alloué sur tous les threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <xref:System.ThreadStaticAttribute> attribut) et emplacements de données. Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation. Pour plus d’informations sur l’utilisation de TLS, consultez [stockage Local des threads : champs statiques relatifs à un Thread et emplacements de données](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 L’emplacement est alloué sur tous les threads.  
  
 Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread. Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création. Le thread peut allouer un emplacement de données dans le magasin de données, stockez et récupérez une données valeur dans l’emplacement et libérer l’emplacement pour une réutilisation après l’expiration du thread. Emplacements de données sont uniques pour chaque thread. Aucun autre thread (pas même un thread enfant) ne peut obtenir les données.  
  
   
  
## Examples  
 Cette section contient deux exemples de code. Le premier exemple montre comment utiliser un champ est marqué avec le <xref:System.ThreadStaticAttribute> attribut devant contenir les informations spécifiques aux threads. Le deuxième exemple montre comment utiliser un emplacement de données pour faire la même chose.  
  
 **Premier exemple**  
  
 L’exemple suivant montre comment utiliser un champ est marqué avec <xref:System.ThreadStaticAttribute> pour contenir des informations spécifiques au thread. Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Deuxième exemple**  
  
 L’exemple de code suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads et threading</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Stockage local des threads : champs statiques et emplacements de données relatifs à un thread</related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l'emplacement de données à allouer.</param>
        <summary>Alloue sur tous les threads un emplacement de données nommé. Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>Emplacement de données nommé alloué sur tous les threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <xref:System.ThreadStaticAttribute> attribut) et emplacements de données. Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation. Pour plus d’informations sur l’utilisation de TLS, consultez [stockage Local des threads : champs statiques relatifs à un Thread et emplacements de données](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread. Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création. Le thread peut allouer un emplacement de données dans le magasin de données, stockez et récupérez une données valeur dans l’emplacement et libérer l’emplacement pour une réutilisation après l’expiration du thread. Emplacements de données sont uniques pour chaque thread. Aucun autre thread (pas même un thread enfant) ne peut obtenir les données.  
  
 Il n’est pas nécessaire d’utiliser le <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> (méthode) à allouer un emplacement de données, car le <xref:System.Threading.Thread.GetNamedDataSlot%2A> méthode alloue l’emplacement s’il n’a pas déjà été alloué.  
  
> [!NOTE]
>  Si le <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> méthode est utilisée, elle doit être appelée dans le thread principal au démarrage du programme, car elle lève une exception si un emplacement avec le nom spécifié a déjà été alloué. Il n’existe aucun moyen pour déterminer si un emplacement a déjà été alloué.  
  
 Emplacements alloués avec cette méthode doivent être libérées avec <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.  
  
   
  
## Examples  
 Cette section contient deux exemples de code. Le premier exemple montre comment utiliser un champ est marqué avec le <xref:System.ThreadStaticAttribute> attribut devant contenir les informations spécifiques aux threads. Le deuxième exemple montre comment utiliser un emplacement de données pour faire la même chose.  
  
 **Premier exemple**  
  
 L’exemple suivant montre comment utiliser un champ est marqué avec <xref:System.ThreadStaticAttribute> pour contenir des informations spécifiques au thread. Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Deuxième exemple**  
  
 L’exemple suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.  
  
> [!NOTE]
>  L’exemple de code n’utilise pas le <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> (méthode), car le <xref:System.Threading.Thread.GetNamedDataSlot%2A> méthode alloue l’emplacement s’il n’a pas déjà été alloué. Si le <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> méthode est utilisée, elle doit être appelée dans le thread principal au démarrage du programme.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un emplacement de données portant le nom spécifié existe déjà.</exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads et threading</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Stockage local des threads : champs statiques et emplacements de données relatifs à un thread</related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'état de cloisonnement de ce thread.</summary>
        <value>Une des valeurs de <see cref="T:System.Threading.ApartmentState" />. La valeur initiale est <see langword="Unknown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Le <xref:System.Threading.Thread.ApartmentState%2A> propriété est obsolète.**  Les alternatives non obsolète sont le <xref:System.Threading.Thread.GetApartmentState%2A> méthode pour récupérer l’état de cloisonnement et le <xref:System.Threading.Thread.SetApartmentState%2A> pour définir l’état de cloisonnement.  
  
 Dans les versions de .NET Framework 1.0 et 1.1, le `ApartmentState` propriété marque un thread pour indiquer qu’il s’exécute dans un cloisonnement monothread ou multithread. Cette propriété peut être définie lorsque le thread est dans le `Unstarted` ou `Running` thread état ; Toutefois, elle peut être définie qu’une seule fois pour un thread. Si la propriété n’a pas été définie, elle retourne `Unknown`.  
  
 Une tentative d’utilisation le <xref:System.Threading.Thread.ApartmentState%2A> propriété à définir l’état de cloisonnement d’un thread dont l’état de cloisonnement a déjà été défini est ignorée. Toutefois, le <xref:System.Threading.Thread.SetApartmentState%2A> méthode lève un <xref:System.InvalidOperationException> dans ce cas.  
  
> [!IMPORTANT]
>  Dans le .NET Framework version 2.0, les nouveaux threads sont initialisés en tant que <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> si leur état de cloisonnement n’a pas été défini avant leur démarrage. Le thread principal de l’application est initialisé à <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> par défaut. Vous ne pouvez plus définir le thread principal de l’application <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> en définissant le <xref:System.Threading.ApartmentState?displayProperty=nameWithType> propriété sur la première ligne de code. Utilisez le <xref:System.STAThreadAttribute> à la place.  
  
 Dans le .NET Framework version 2.0, vous pouvez spécifier le modèle pour une application C++ à l’aide de thread COM le [/CLRTHREADATTRIBUTE (définir l’attribut de Thread CLR)](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) option de l’éditeur de liens.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir l’état de cloisonnement d’un thread.  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une tentative est effectuée pour définir cette propriété sur un état qui n’est pas un état de cloisonnement valide (un état autre que celui de thread unique cloisonné (<see langword="STA" />) ou de multithread cloisonné (<see langword="MTA" />)).</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avertit un hôte que l'exécution est sur le point d'entrer dans une zone de code dans laquelle les effets d'un abandon de thread ou d'une exception non gérée peuvent compromettre d'autres tâches dans le domaine d'application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les hôtes du common language runtime (CLR), tel que Microsoft SQL Server 2005, peuvent établir des stratégies différentes pour les erreurs dans les régions de code critiques et non critiques. Une zone critique est un dans lesquels les effets d’un abandon de thread ou une exception non gérée ne peuvent pas être limités à la tâche actuelle. En revanche, un abandon ou une défaillance dans une région de code non critique affecte uniquement la tâche dans laquelle l’erreur se produit.  
  
 Par exemple, considérez une tâche qui tente d’allouer de la mémoire tout en maintenant un verrou. Si l’allocation de mémoire échoue, l’abandon de la tâche en cours n’est pas suffisante pour assurer la stabilité de le <xref:System.AppDomain>, car il peut y avoir des autres tâches dans le domaine en attente pour le même verrou. Si la tâche en cours est arrêtée, les autres tâches peuvent être bloquées.  
  
 En cas de défaillance dans une zone critique, l’hôte peut décider de décharger l’intégralité de <xref:System.AppDomain> plutôt que de prendre le risque de continuer l’exécution dans un état potentiellement instable. Pour informer l’hôte que votre code entre dans une zone critique, appelez <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Appelez <xref:System.Threading.Thread.EndCriticalRegion%2A> lorsque l’exécution retourne dans une région non critique de code.  
  
 À l’aide de cette méthode dans le code qui s’exécute sous SQL Server 2005 nécessite le code à exécuter sur le niveau de protection de l’hôte le plus élevé.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Threading.Thread.BeginCriticalRegion%2A> et <xref:System.Threading.Thread.EndCriticalRegion%2A> méthodes pour diviser un bloc de code en régions critiques et non critiques.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avertit un hôte que le code managé est sur le point d'exécuter des instructions qui dépendent de l'identité du thread du système d'exploitation physique actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains hôtes du common language runtime, tels que Microsoft SQL Server 2005, fournissent leur propre gestion de threads. Un hôte qui fournit sa propre gestion des threads peut déplacer une tâche en cours d’exécution d’un thread de système d’exploitation physique vers un autre à tout moment. La plupart des tâches ne sont pas affectées par ce basculement. Toutefois, certaines tâches ont une affinité de thread : autrement dit, ils dépendent de l’identité d’un thread de système d’exploitation physique. Ces tâches doivent informer l’hôte lorsqu’elles exécutent du code qui ne doit pas être basculée.  
  
 Par exemple, si votre application appelle une API système pour acquérir un système d’exploitation de verrouillage qui possède l’affinité de thread, telles que Win32 CRITICAL_SECTION, vous devez appeler <xref:System.Threading.Thread.BeginThreadAffinity%2A> avant d’acquérir le verrou, et <xref:System.Threading.Thread.EndThreadAffinity%2A> après l’avoir libéré le verrou.  
  
 À l’aide de cette méthode dans le code qui s’exécute sous SQL Server 2005 nécessite le code à exécuter sur le niveau de protection de l’hôte le plus élevé.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Threading.Thread.BeginThreadAffinity%2A> et <xref:System.Threading.Thread.EndThreadAffinity%2A> méthodes pour avertir un hôte qu’un bloc de code dépend de l’identité d’un thread de système d’exploitation physique.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le contexte actuel dans lequel le thread s'exécute.</summary>
        <value>
          <see cref="T:System.Runtime.Remoting.Contexts.Context" /> représentant le contexte actuel du thread.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la culture du thread actuel.</summary>
        <value>Objet qui représente la culture du thread actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Globalization.CultureInfo> objet qui est retourné par cette propriété, ainsi que ses objets associés, déterminer le format par défaut pour les dates, heures, nombres, les valeurs de devise, l’ordre de tri du texte, conventions de casse et les comparaisons de chaînes. Consultez la <xref:System.Globalization.CultureInfo> classe pour en savoir plus sur les noms de culture et les identificateurs, les différences entre les cultures invariants, neutres et spécifiques, ainsi que les façon dont les informations de culture affectent les domaines d’application et les threads. Consultez le <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriété pour savoir comment est déterminée la culture par défaut d’un thread, et comment les utilisateurs définir les informations de culture pour leurs ordinateurs.  

> [!IMPORTANT]
> Le <xref:System.Threading.Thread.CurrentCulture> propriété ne fonctionne de façon fiable lorsqu’il est utilisé avec n’importe quel thread autre que le thread actuel. Dans .NET Framework, la lecture de la propriété est fiable, bien que la définition pour un thread autre que le thread actuel n’est pas. Sur .NET Core, une <xref:System.InvalidOperationException> est levée si un thread tente de lire ou écrire le <xref:System.Threading.Thread.CurrentCulture> propriété sur un thread différent.
> Nous vous recommandons d’utiliser le <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> propriété pour récupérer et définir la culture actuelle.

 Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], vous pouvez définir le <xref:System.Threading.Thread.CurrentCulture%2A> propriété à une culture neutre. Il s’agit, car le comportement de la <xref:System.Globalization.CultureInfo> classe a été modifiée : quand elle représente une culture neutre, ses valeurs de propriété (en particulier, le <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, et <xref:System.Globalization.CultureInfo.TextInfo%2A> propriétés) maintenant reflète la culture spécifique associée à la culture neutre. Dans les versions antérieures du .NET Framework, le <xref:System.Threading.Thread.CurrentCulture%2A> propriété a levé une <xref:System.NotSupportedException> exception lorsqu’une culture neutre a été affectée.  
  
## Examples  
 L’exemple suivant montre l’instruction de thread qui permet à l’interface utilisateur d’une application Windows Forms à afficher dans la culture qui est définie dans le panneau de configuration. Code supplémentaire est nécessaire.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La propriété est définie sur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">.NET Core uniquement : la lecture ou l’écriture de la culture d’un thread à partir d’un autre thread n’est pas prise en charge.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour définir la propriété. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le principal actuel du thread (pour une sécurité basée sur les rôles).</summary>
        <value>Valeur <see cref="T:System.Security.Principal.IPrincipal" /> représentant le contexte de sécurité.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment définir et récupérer l’entité de sécurité d’un thread.  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas l’autorisation nécessaire pour définir le principal.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour manipuler l’objet principal. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le thread en cours d'exécution.</summary>
        <value>
          <see cref="T:System.Threading.Thread" /> constituant la représentation du thread en cours d'exécution.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée une tâche qui crée à son tour 20 tâches enfants. L’application elle-même, en tant que bien que chaque tâche, appelle le `ShowThreadInformation` (méthode), qui utilise le <xref:System.Threading.Thread.CurrentThread%2A> propriété à afficher des informations sur le thread sur lequel il est en cours d’exécution.  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 Chaque tâche enfant génère 1 million de nombres aléatoires compris entre 1 et 1 million et retourne leur moyenne. Les appels de la tâche parent la <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> méthode pour vous assurer que les tâches enfants terminées avant d’afficher la moyenne retournée par chaque tâche et en calculant la moyenne des moyens.  
  
 Notez que pendant que l’application s’exécute sur un thread de premier plan, chaque tâche s’exécute sur un thread de pool de threads.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la culture actuelle utilisée par le Gestionnaire de ressources pour rechercher des ressources spécifiques à la culture au moment de l'exécution.</summary>
        <value>Objet qui représente la culture actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La culture d’interface utilisateur spécifie les ressources d’une application doit prendre en charge l’entrée d’utilisateur et de sortie et par défaut est identique à la culture du système d’exploitation. Consultez la <xref:System.Globalization.CultureInfo> classe pour en savoir plus sur les noms de culture et les identificateurs, les différences entre les cultures invariants, neutres et spécifiques, ainsi que les façon dont les informations de culture affectent les domaines d’application et les threads. Consultez le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété pour en savoir plus de la détermination de la culture d’interface utilisateur d’un thread par défaut.  

> [!IMPORTANT]
> Le <xref:System.Threading.Thread.CurrentUICulture> propriété ne fonctionne de façon fiable lorsqu’il est utilisé avec n’importe quel thread autre que le thread actuel. Dans .NET Framework, la lecture de la propriété est fiable, bien que la définition pour un thread autre que le thread actuel n’est pas. Sur .NET Core, une <xref:System.InvalidOperationException> est levée si un thread tente de lire ou écrire le <xref:System.Threading.Thread.CurrentUICulture> propriété sur un thread différent.
> Nous vous recommandons d’utiliser le <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> propriété pour récupérer et définir la culture actuelle.

 Le <xref:System.Globalization.CultureInfo> retourné par cette propriété peut être une culture neutre. Cultures neutres ne doivent pas être utilisées avec mise en forme de méthodes telles que <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, et <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>. Utiliser le <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> méthode pour obtenir une culture spécifique, ou utilisez le <xref:System.Threading.Thread.CurrentCulture%2A> propriété.  
  
> [!NOTE]
>  Le <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> méthode lève une exception <xref:System.ArgumentException> pour les cultures neutres « zh-Hant » (« zh-CHT ») et « zh-Hans » (« zh-CHS »).  
  
   
  
## Examples  
 L’exemple suivant détermine si la langue de la culture d’interface utilisateur du thread actuel est le Français. Si elle n’est pas le cas, il définit la culture d’interface utilisateur du thread actuel vers l’anglais (États-Unis).  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 L’exemple de code suivant montre l’instruction de thread qui permet à l’interface utilisateur d’un formulaire Windows à afficher dans la culture qui est définie dans le panneau de configuration. Code supplémentaire est nécessaire.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La propriété est définie sur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété a la valeur d’un nom de culture qui ne peut pas être utilisé pour localiser un fichier de ressources. Les noms de fichiers des ressources doivent inclure uniquement des lettres, des chiffres, des traits d’union ou des traits de soulignement.</exception>
        <exception cref="T:System.InvalidOperationException">.NET Core uniquement : la lecture ou l’écriture de la culture d’un thread à partir d’un autre thread n’est pas prise en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Désactive le nettoyage automatique des wrappers RCW (Runtime Callable Wrapper) pour le thread actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le common language runtime (CLR) nettoie automatiquement les wrappers RCW. Les CLR pompe des messages pendant le nettoyage, ce qui peut provoquer des problèmes de réentrance pour quelques applications qui répondent aux critères inhabituels suivants :  
  
-   L’application effectue son propre pompage des messages.  
  
-   L’application doit contrôler précisément lorsque le pompage de messages se produit.  
  
 Ces applications peuvent utiliser le <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> méthode pour empêcher le CLR d’effectuer une récupération automatique du runtime callable wrapper.  
  
 Lorsque cette méthode a été appelée sur un thread, le nettoyage automatique ne peut pas être réactivé pour ce thread. Lorsque votre application est prête nettoyer les wrappers RCW, utilisez le <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> méthode pour demander au runtime de nettoyer tous les wrappers RCW dans le contexte actuel. Pompage de messages se produit pendant que la méthode s’exécute.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avertit un hôte que l’exécution est sur le point d’entrer dans une zone de code dans laquelle les effets d’un abandon de thread ou d’une exception non gérée sont limités à la tâche actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les hôtes du common language runtime (CLR), tel que Microsoft SQL Server 2005, peuvent établir des stratégies différentes pour les erreurs dans les régions de code critiques et non critiques. Une zone critique est un dans lesquels les effets d’un abandon de thread ou une exception non gérée ne peuvent pas être limités à la tâche actuelle. En revanche, un abandon ou une défaillance dans une région de code non critique affecte uniquement la tâche dans laquelle l’erreur se produit.  
  
 Par exemple, considérez une tâche qui tente d’allouer de la mémoire tout en maintenant un verrou. Si l’allocation de mémoire échoue, l’abandon de la tâche en cours n’est pas suffisante pour assurer la stabilité de le <xref:System.AppDomain>, car il peut y avoir des autres tâches dans le domaine en attente pour le même verrou. Si la tâche en cours est arrêtée, les autres tâches peuvent être bloquées.  
  
 En cas de défaillance dans une zone critique, l’hôte peut décider de décharger l’intégralité de <xref:System.AppDomain> plutôt que de prendre le risque de continuer l’exécution dans un état potentiellement instable. Pour informer l’hôte que votre code entre dans une zone critique, appelez <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Appelez <xref:System.Threading.Thread.EndCriticalRegion%2A> lorsque l’exécution retourne dans une région non critique de code.  
  
 À l’aide de cette méthode dans le code qui s’exécute sous SQL Server 2005 nécessite le code à exécuter sur le niveau de protection de l’hôte le plus élevé.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Threading.Thread.BeginCriticalRegion%2A> et <xref:System.Threading.Thread.EndCriticalRegion%2A> méthodes pour diviser un bloc de code en régions critiques et non critiques.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avertit un hôte que le code managé a terminé l'exécution des instructions qui dépendent de l'identité du thread du système d'exploitation physique actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains hôtes du common language runtime, tels que Microsoft SQL Server 2005, fournissent leur propre gestion de threads. Un hôte qui fournit sa propre gestion des threads peut déplacer une tâche en cours d’exécution d’un thread de système d’exploitation physique vers un autre à tout moment. La plupart des tâches ne sont pas affectées par ce basculement. Toutefois, certaines tâches ont une affinité de thread : autrement dit, ils dépendent de l’identité d’un thread de système d’exploitation physique. Ces tâches doivent informer l’hôte lorsqu’elles exécutent du code qui ne doit pas être basculée.  
  
 Par exemple, si votre application appelle une API système pour acquérir un système d’exploitation de verrouillage qui possède l’affinité de thread, telles que Win32 CRITICAL_SECTION, vous devez appeler <xref:System.Threading.Thread.BeginThreadAffinity%2A> avant d’acquérir le verrou, et <xref:System.Threading.Thread.EndThreadAffinity%2A> après l’avoir libéré le verrou.  
  
 À l’aide de cette méthode dans le code qui s’exécute sous SQL Server 2005 nécessite le code à exécuter sur le niveau de protection de l’hôte le plus élevé.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Threading.Thread.BeginThreadAffinity%2A> et <xref:System.Threading.Thread.EndThreadAffinity%2A> méthodes pour avertir un hôte qu’un bloc de code dépend de l’identité d’un thread de système d’exploitation physique.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Threading.ExecutionContext" /> qui contient des informations relatives aux divers contextes du thread actuel.</summary>
        <value>Objet <see cref="T:System.Threading.ExecutionContext" /> qui consolide des informations de contexte pour le thread actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.ExecutionContext> classe fournit un conteneur unique pour toutes les informations relatives à un thread logique d’exécution. Cela inclut le contexte de sécurité, de contexte d’appel, de contexte de synchronisation, de contexte de localisation et de contexte de transaction.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie que les ressources sont libérées et que toute autre opération de nettoyage est effectuée quand le garbage collector récupère l'objet <see cref="T:System.Threading.Thread" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le garbage collector appelle <xref:System.Threading.Thread.Finalize%2A> lorsque l’objet actuel est prêt à être finalisé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l'emplacement de données à libérer.</param>
        <summary>Élimine l'association entre un nom et un emplacement pour tous les threads du processus. Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <xref:System.ThreadStaticAttribute> attribut) et emplacements de données. Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation. Pour plus d’informations sur l’utilisation de TLS, consultez [stockage Local des threads : champs statiques relatifs à un Thread et emplacements de données](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Une fois un thread appelle `FreeNamedDataSlot`, n’importe quel autre thread qui appelle <xref:System.Threading.Thread.GetNamedDataSlot%2A> portant le même nom allouera un nouvel emplacement associé au nom. Les appels suivants à `GetNamedDataSlot` par n’importe quel thread retourneront le nouvel emplacement. Toutefois, n’importe quel thread qui a toujours un <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> retourné par un appel antérieur à `GetNamedDataSlot` peuvent continuer à utiliser l’ancien emplacement.  
  
 Un emplacement qui a été associé à un nom est libéré uniquement lorsque chaque `LocalDataStoreSlot` qui a été obtenu avant l’appel à `FreeNamedDataSlot` a été publié et le garbage collector.  
  
 Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread. Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création. Le thread peut allouer un emplacement de données dans le magasin de données, stockez et récupérez une données valeur dans l’emplacement et libérer l’emplacement pour une réutilisation après l’expiration du thread. Emplacements de données sont uniques pour chaque thread. Aucun autre thread (pas même un thread enfant) ne peut obtenir les données.  
  
   
  
## Examples  
 Cette section contient deux exemples de code. Le premier exemple montre comment utiliser un champ est marqué avec le <xref:System.ThreadStaticAttribute> attribut devant contenir les informations spécifiques aux threads. Le deuxième exemple montre comment utiliser un emplacement de données pour faire la même chose.  
  
 **Premier exemple**  
  
 L’exemple suivant montre comment utiliser un champ est marqué avec <xref:System.ThreadStaticAttribute> pour contenir des informations spécifiques au thread. Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Deuxième exemple**  
  
 L’exemple suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads et threading</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Stockage local des threads : champs statiques et emplacements de données relatifs à un thread</related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur <see cref="T:System.Threading.ApartmentState" /> qui indique l'état de cloisonnement.</summary>
        <returns>Une des valeurs <see cref="T:System.Threading.ApartmentState" /> qui indique l'état de cloisonnement du thread managé. La valeur par défaut est <see cref="F:System.Threading.ApartmentState.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode, avec la <xref:System.Threading.Thread.SetApartmentState%2A> (méthode) et le <xref:System.Threading.Thread.TrySetApartmentState%2A> (méthode), remplace le <xref:System.Threading.Thread.ApartmentState%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, et <xref:System.Threading.Thread.TrySetApartmentState%2A> méthodes. L’exemple de code crée un thread. Avant que le thread est démarré, <xref:System.Threading.Thread.GetApartmentState%2A> affiche initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> état et <xref:System.Threading.Thread.SetApartmentState%2A> modifie l’état à <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. Le <xref:System.Threading.Thread.TrySetApartmentState%2A> méthode renvoie alors `false` lorsque vous tentez de modifier l’état à <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> , car l’état de cloisonnement est déjà défini. Si la même opération avait été tentée avec <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> aurait été levée.  
  
 Une fois que le thread est démarré, le <xref:System.Threading.Thread.TrySetApartmentState%2A> méthode est utilisée à nouveau. Cette fois, elle lève <xref:System.Threading.ThreadStateException> , car le thread a déjà été démarré.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Threading.CompressedStack" /> qui peut être utilisé pour capturer la pile pour le thread actuel.</summary>
        <returns>Aucun.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’est plus pris en charge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dans tous les cas.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">
          <see cref="T:System.LocalDataStoreSlot" /> à partir duquel obtenir la valeur.</param>
        <summary>Récupère la valeur de l'emplacement spécifié sur le thread actif, dans le domaine actuel du thread actif. Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>Valeur récupérée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <xref:System.ThreadStaticAttribute> attribut) et emplacements de données. Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation. Pour plus d’informations sur l’utilisation de TLS, consultez [stockage Local des threads : champs statiques relatifs à un Thread et emplacements de données](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread. Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création. Le thread peut allouer un emplacement de données dans le magasin de données, stockez et récupérez une données valeur dans l’emplacement et libérer l’emplacement pour une réutilisation après l’expiration du thread. Emplacements de données sont uniques pour chaque thread. Aucun autre thread (pas même un thread enfant) ne peut obtenir les données.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A> est un `Shared` méthode s’applique toujours au thread en cours d’exécution, même si vous appelez à l’aide d’une variable qui fait référence à un autre thread. Pour éviter toute confusion, utilisez le nom de classe lors de l’appel `Shared` méthodes : `Dim test As Object = Thread.GetData(testSlot)`.  
  
   
  
## Examples  
 Cette section contient deux exemples de code. Le premier exemple montre comment utiliser un champ est marqué avec le <xref:System.ThreadStaticAttribute> attribut devant contenir les informations spécifiques aux threads. Le deuxième exemple montre comment utiliser un emplacement de données pour faire la même chose.  
  
 **Premier exemple**  
  
 L’exemple suivant montre comment utiliser un champ est marqué avec <xref:System.ThreadStaticAttribute> pour contenir des informations spécifiques au thread. Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Deuxième exemple**  
  
 L’exemple suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads et threading</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Stockage local des threads : champs statiques et emplacements de données relatifs à un thread</related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le domaine actuel dans lequel le thread actif est en cours d'exécution.</summary>
        <returns>
          <see cref="T:System.AppDomain" /> représentant le domaine d'application actuel du thread en cours d'exécution.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment récupérer le nom et l’ID de la `AppDomain` dans lequel le thread s’exécute.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un identificateur unique de domaine d'application.</summary>
        <returns>Entier signé 32 bits identifiant de manière unique le domaine d'application.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment récupérer le nom et l’ID de la `AppDomain` dans lequel le thread s’exécute.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un code de hachage pour le thread actuel.</summary>
        <returns>Valeur de code de hachage entier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le code de hachage n’est pas garanti pour être unique. Utilisez le <xref:System.Threading.Thread.ManagedThreadId%2A> propriété si vous avez besoin d’un identificateur unique pour un thread managé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l'emplacement de données local.</param>
        <summary>Recherche un emplacement de données nommé. Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>
          <see cref="T:System.LocalDataStoreSlot" /> alloué pour ce thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <xref:System.ThreadStaticAttribute> attribut) et emplacements de données. Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation. Pour plus d’informations sur l’utilisation de TLS, consultez [stockage Local des threads : champs statiques relatifs à un Thread et emplacements de données](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread. Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création. Le thread peut allouer un emplacement de données dans le magasin de données, stockez et récupérez une données valeur dans l’emplacement et libérer l’emplacement pour une réutilisation après l’expiration du thread. Emplacements de données sont uniques pour chaque thread. Aucun autre thread (pas même un thread enfant) ne peut obtenir les données.  
  
 Si l’emplacement nommé n’existe pas, un nouvel emplacement est alloué. Emplacements de données nommés sont publiques et peuvent être manipulées par tout le monde.  
  
   
  
## Examples  
 Cette section contient deux exemples de code. Le premier exemple montre comment utiliser un champ est marqué avec le <xref:System.ThreadStaticAttribute> attribut devant contenir les informations spécifiques aux threads. Le deuxième exemple montre comment utiliser un emplacement de données pour faire la même chose.  
  
 **Premier exemple**  
  
 L’exemple suivant montre comment utiliser un champ est marqué avec <xref:System.ThreadStaticAttribute> pour contenir des informations spécifiques au thread. Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Deuxième exemple**  
  
 L’exemple suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads et threading</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Stockage local des threads : champs statiques et emplacements de données relatifs à un thread</related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Interrompt un thread dont l'état est <see langword="WaitSleepJoin" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si ce thread n’est pas actuellement bloqué en attente, de veille ou d’état de jointure, il sera interrompu lorsqu’elle commence ensuite à bloquer.  
  
 <xref:System.Threading.ThreadInterruptedException> est levée dans le thread interrompu, mais pas jusqu'à ce que le thread se bloque. Si le thread ne bloque jamais, l’exception n’est jamais levée, et par conséquent, le thread peut se terminer sans jamais être interrompu.  
  
   
  
## Examples  
 L’exemple de code suivant montre le comportement d’un thread en cours d’exécution lorsqu’elle est interrompue et par la suite est bloqué.  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L’appelant ne possède pas le <see cref="T:System.Security.Permissions.SecurityPermission" /> nécessaire.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour les opérations avancées sur les threads. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">Suspension et interruption de threads</related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">États des threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant l'état de l'exécution du thread actuel.</summary>
        <value>
          <see langword="true" /> si ce thread a été démarré mais ne s'est pas arrêté normalement ou s'il a été abandonné ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le thread est un thread d'arrière-plan ou non.</summary>
        <value>
          <see langword="true" /> si ce thread est ou doit devenir un thread d'arrière-plan ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un thread est un thread d’arrière-plan ou un thread de premier plan. Threads d’arrière-plan sont identiques aux threads de premier plan, à ceci près que les threads d’arrière-plan n’empêchent pas un processus de se terminer. Une fois que tous les threads de premier plan appartenant à un processus sont terminés, le common language runtime termine le processus. Les threads d’arrière-plan restants sont arrêtées et ne se terminent pas.  
  
 Par défaut, les threads suivants s’exécutent au premier plan (autrement dit, leur <xref:System.Threading.Thread.IsBackground%2A> retourne de la propriété `false`) :  
  
-   Le thread principal (ou le thread d’application principal).  
  
-   Tous les threads créés en appelant un <xref:System.Threading.Thread> constructeur de classe.  
  
 Par défaut, les threads suivants s’exécutent en arrière-plan (autrement dit, leur <xref:System.Threading.Thread.IsBackground%2A> retourne de la propriété `true`) :  
  
-   Thread du pool de threads, qui constituent un pool de threads de travail géré par le runtime. Vous pouvez configurer le travail de pool et de planification de thread sur les threads du pool à l’aide de la <xref:System.Threading.ThreadPool> classe.  
  
    > [!NOTE]
    >  Opérations asynchrones basées sur la tâche s’exécute automatiquement sur les threads du pool.  
  
-   Tous les threads qui entrent dans l’environnement d’exécution managé à partir de code non managé.  
  
   
  
## Examples  
 L’exemple suivant compare le comportement des threads de premier plan et d’arrière-plan. Il crée un thread de premier plan et d’un thread d’arrière-plan. Le thread de premier plan maintient le processus en cours d’exécution jusqu'à ce que se termine son `for` boucle et se termine. Toutefois, comme le montre la sortie de l’exemple, étant donné que le thread de premier plan a terminé son exécution, le processus est arrêté avant que le thread d’arrière-plan a terminé son exécution.  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Le thread est inactif.</exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md">Threads de premier plan et d'arrière-plan</related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si un thread appartient au pool de threads managés ou non.</summary>
        <value>
          <see langword="true" /> si ce thread appartient au pool de threads managés ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez [le pool de threads managés](~/docs/standard/threading/the-managed-thread-pool.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment déterminer si un thread est le pool de threads.  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Pool de threads managés</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bloque le thread appelant jusqu’à l’arrêt du thread représenté par cette instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bloque le thread appelant jusqu’à ce que le thread représenté par cette instance s’arrête, tout en continuant d’exécuter le pompage COM et <see langword="SendMessage" /> standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A> est une méthode de synchronisation qui bloque le thread appelant (autrement dit, le thread qui appelle la méthode) jusqu'à ce que le thread dont <xref:System.Threading.Thread.Join%2A> méthode est appelée est terminée. Utilisez cette méthode pour vous assurer qu’un thread a été arrêté. L’appelant se bloquera indéfiniment si le thread ne se termine pas. Dans l’exemple suivant, le `Thread1` thread appelle le <xref:System.Threading.Thread.Join> méthode de `Thread2`, ce qui conduit `Thread1` au bloc jusqu'à ce que `Thread2` est terminée.  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 Si le thread s’est déjà arrêté lorsque <xref:System.Threading.Thread.Join%2A> est appelée, la méthode retourne immédiatement.  
  
> [!WARNING]
>  Vous ne devez jamais appeler la <xref:System.Threading.Thread.Join%2A> méthode de la <xref:System.Threading.Thread> objet qui représente le thread actuel du thread actuel. Ainsi, votre application se bloque, car le thread actuel attend indéfiniment, à elle-même  
  
 Cette méthode modifie l’état du thread appelant pour inclure <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Vous ne pouvez pas appeler `Join` sur un thread qui se trouve dans le <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> état.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">L’appelant a tenté de joindre un thread dont l’état est <see cref="F:System.Threading.ThreadState.Unstarted" />.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Le thread est interrompu lors de l’attente.</exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">États des threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre l'arrêt du thread.</param>
        <summary>Bloque le thread appelant jusqu'à ce que le thread représenté par cette instance s'arrête ou que la durée spécifiée soit écoulée, tout en continuant d'exécuter le pompage COM et SendMessage standard.</summary>
        <returns>
          <see langword="true" /> si le thread s'est arrêté ; <see langword="false" /> s'il ne s'est pas arrêté après l'expiration du délai spécifié par le paramètre <paramref name="millisecondsTimeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29> est une méthode de synchronisation qui bloque le thread appelant (autrement dit, le thread qui appelle la méthode) jusqu'à ce que soit le thread dont <xref:System.Threading.Thread.Join%2A> méthode est appelée est terminée ou l’intervalle de délai d’expiration est écoulé. Dans l’exemple suivant, le `Thread1` thread appelle le <xref:System.Threading.Thread.Join> méthode de `Thread2`, ce qui conduit `Thread1` pour bloquer jusqu'à `Thread2` terminée ou 2 secondes se soient écoulées.  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 Si <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> est spécifié pour le `millisecondsTimeout` paramètre, cette méthode se comporte comme la <xref:System.Threading.Thread.Join> surcharge de méthode, à l’exception de la valeur de retour.  
  
 Si le thread s’est déjà arrêté lorsque <xref:System.Threading.Thread.Join%2A> est appelée, la méthode retourne immédiatement.  
  
 Cette méthode modifie l’état du thread appelant pour inclure <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Vous ne pouvez pas appeler `Join` sur un thread qui se trouve dans le <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> état.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="millisecondsTimeout" /> est négative et n’est pas égale à <see cref="F:System.Threading.Timeout.Infinite" /> en millisecondes.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Le thread n’a pas été démarré.</exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">États des threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> ayant pour valeur la durée à attendre l'arrêt du thread.</param>
        <summary>Bloque le thread appelant jusqu'à ce que le thread représenté par cette instance s'arrête ou que la durée spécifiée soit écoulée, tout en continuant d'exécuter le pompage COM et SendMessage standard.</summary>
        <returns>
          <see langword="true" /> si le thread s'est arrêté ; <see langword="false" /> s'il ne s'est pas arrêté après l'expiration du délai spécifié par le paramètre <paramref name="timeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29> est une méthode de synchronisation qui bloque le thread appelant (autrement dit, le thread qui appelle la méthode) jusqu'à ce que soit le thread dont <xref:System.Threading.Thread.Join%2A> méthode est appelée est terminée ou l’intervalle de délai d’expiration est écoulé. Dans l’exemple suivant, le `Thread1` thread appelle le <xref:System.Threading.Thread.Join> méthode de `Thread2`, ce qui conduit `Thread1` pour bloquer jusqu'à `Thread2` terminée ou 2 secondes se soient écoulées.  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 Si <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> est spécifiée pour `timeout`, cette méthode se comporte comme la <xref:System.Threading.Thread.Join> surcharge de méthode, à l’exception de la valeur de retour.  
  
 Si le thread s’est déjà arrêté lorsque <xref:System.Threading.Thread.Join%2A> est appelée, la méthode retourne immédiatement.  
  
 Cette méthode modifie l’état du thread actuel pour inclure <xref:System.Threading.ThreadState.WaitSleepJoin>. Vous ne pouvez pas appeler `Join` sur un thread qui se trouve dans le <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> état.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser un `TimeSpan` valeur avec le `Join` (méthode).  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="timeout" /> est négative et n’est pas égale à <see cref="F:System.Threading.Timeout.Infinite" /> en millisecondes, ou est supérieure à <see cref="F:System.Int32.MaxValue" /> millisecondes.</exception>
        <exception cref="T:System.Threading.ThreadStateException">L’appelant a tenté de joindre un thread dont l’état est <see cref="F:System.Threading.ThreadState.Unstarted" />.</exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">États des threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un identificateur unique pour le thread managé actuel.</summary>
        <value>Entier représentant un identificateur unique pour ce thread managé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 D’un thread <xref:System.Threading.Thread.ManagedThreadId%2A> sert de valeur de propriété pour identifier de manière unique ce thread au sein de son processus.  
  
 La valeur de la <xref:System.Threading.Thread.ManagedThreadId%2A> propriété ne varie pas au fil du temps, même si le code non managé qui héberge le common language runtime implémente le thread comme une fibre.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Synchronise l’accès à la mémoire comme suit : le processeur qui exécute le thread actuel ne peut pas réorganiser les instructions de sorte que les accès à la mémoire antérieurs à l’appel de <see cref="M:System.Threading.Thread.MemoryBarrier" /> s’exécutent après les accès à la mémoire postérieurs à l’appel de <see cref="M:System.Threading.Thread.MemoryBarrier" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A> est requis uniquement sur les systèmes multiprocesseurs avec faible ordonnancement en mémoire (par exemple, un système employant plusieurs processeurs Intel Itanium).  
  
 La plupart des cas, le C# `lock` instruction, Visual Basic `SyncLock` instruction, ou la <xref:System.Threading.Monitor> classe fournissent des moyens plus simples pour synchroniser les données.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom du thread.</summary>
        <value>Chaîne contenant le nom du thread ou <see langword="null" /> si aucun nom n'a été défini.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est en écriture-une fois. Étant donné que la valeur par défaut d’un thread <xref:System.Threading.Thread.Name%2A> propriété est `null`, vous pouvez déterminer si un nom a déjà été explicitement attribué au thread en le comparant avec `null`.  
  
 La chaîne assignée à la <xref:System.Threading.Thread.Name%2A> propriété peut inclure n’importe quel caractère Unicode.  
  
   
  
## Examples  
 L’exemple suivant montre comment nommer un thread.  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une opération ensembliste a été demandée, mais la propriété <see langword="Name" /> a déjà été définie.</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant la priorité de planification d'un thread.</summary>
        <value>Une des valeurs de <see cref="T:System.Threading.ThreadPriority" />. La valeur par défaut est <see cref="F:System.Threading.ThreadPriority.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un thread peut avoir l’une de l’ordre de priorité suivant <xref:System.Threading.ThreadPriority> valeurs :  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 Systèmes d’exploitation n’êtes pas obligés de respecter la priorité d’un thread.  
  
   
  
## Examples  
 L’exemple suivant montre le résultat de la modification de la priorité d’un thread. Trois threads sont créés, la priorité d’un thread est définie sur <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, et la priorité de seconde est définie sur <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>. Chaque thread incrémente une variable dans un `while` boucle et s’exécute pour une durée définie.  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Le thread a atteint un état final, tel que <see cref="F:System.Threading.ThreadState.Aborted" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour une opération set n’est pas une valeur <see cref="T:System.Threading.ThreadPriority" /> valide.</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md">Planification de threads</related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annule un <see cref="M:System.Threading.Thread.Abort(System.Object)" /> demandé pour le thread actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut uniquement être appelée par le code avec les autorisations appropriées.  
  
 Lorsqu’un appel est effectué vers `Abort` pour terminer un thread, le système génère un <xref:System.Threading.ThreadAbortException>. `ThreadAbortException` est une exception spéciale qui peut être interceptée par le code d’application, mais qui est levée de nouveau à la fin du bloc catch, sauf si `ResetAbort` est appelée. `ResetAbort` Annule la demande d’abandon et empêche le `ThreadAbortException` à partir de l’arrêt du thread.  
  
 Consultez <xref:System.Threading.ThreadAbortException> pour obtenir un exemple qui montre comment appeler le `ResetAbort` (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core uniquement : ce membre n’est pas pris en charge.</exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <see langword="Abort" /> n’a pas été appelé sur le thread actuel.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas l’autorisation de sécurité requise pour le thread actuel.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour les opérations avancées sur les threads. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">Détruire des threads</related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">États des threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reprend un thread qui a été suspendu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  N’utilisez pas le <xref:System.Threading.Thread.Suspend%2A> et <xref:System.Threading.Thread.Resume%2A> méthodes pour synchroniser les activités de threads. Vous ne disposez d’aucun moyen de savoir quel code un thread s’exécute lorsque vous l’interrompez. Si vous suspendez un thread pendant qu’il détient des verrous pendant une évaluation des autorisations de sécurité, d’autres threads le <xref:System.AppDomain> risque d’être bloqué. Si vous suspendez un thread pendant son exécution un constructeur de classe, d’autres threads le <xref:System.AppDomain> qui tente d’utiliser cette classe sera bloqué. Blocages peuvent se produire très facilement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core uniquement : ce membre n’est pas pris en charge.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Le thread n’a pas été démarré, est inactif ou n’est pas dans l’état interrompu.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant ne possède pas le <see cref="T:System.Security.Permissions.SecurityPermission" /> nécessaire.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour les opérations avancées sur les threads. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">Suspension et interruption de threads</related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">États des threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">Nouvel état de cloisonnement.</param>
        <summary>Définit l'état de cloisonnement d'un thread avant qu'il ne soit démarré.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nouveaux threads sont initialisés en tant que <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> si leur état de cloisonnement n’a pas été défini avant leur démarrage. État de cloisonnement doit être définie avant le démarrage d’un thread.  
  
> [!NOTE]
>  Le thread principal de l’application est initialisé à <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> par défaut. La seule façon de définir l’état de cloisonnement du thread principal de l’application à <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> consiste à appliquer le <xref:System.STAThreadAttribute> d’attribut à la méthode de point d’entrée.  
  
 Le <xref:System.Threading.Thread.SetApartmentState%2A> (méthode), avec la <xref:System.Threading.Thread.GetApartmentState%2A> (méthode) et le <xref:System.Threading.Thread.TrySetApartmentState%2A> (méthode), remplace le <xref:System.Threading.Thread.ApartmentState%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, et <xref:System.Threading.Thread.TrySetApartmentState%2A> méthodes. L’exemple de code crée un thread. Avant que le thread est démarré, <xref:System.Threading.Thread.GetApartmentState%2A> affiche initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> état et <xref:System.Threading.Thread.SetApartmentState%2A> modifie l’état à <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. Le <xref:System.Threading.Thread.TrySetApartmentState%2A> méthode renvoie alors `false` lorsque vous tentez de modifier l’état à <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> , car l’état de cloisonnement est déjà défini. Si la même opération avait été tentée avec <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> aurait été levée.  
  
 Une fois que le thread est démarré, le <xref:System.Threading.Thread.TrySetApartmentState%2A> méthode est utilisée à nouveau. Cette fois, elle lève <xref:System.Threading.ThreadStateException> , car le thread a déjà été démarré.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core uniquement : ce membre n’est pas pris en charge sur les plateformes macOS et Linux.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> n’est pas un état de cloisonnement valide.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Le thread a déjà été démarré.</exception>
        <exception cref="T:System.InvalidOperationException">L’état de cloisonnement a déjà été initialisé.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">Objet <see cref="T:System.Threading.CompressedStack" /> à appliquer au thread actuel.</param>
        <summary>Applique une <see cref="T:System.Threading.CompressedStack" /> capturée au thread actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’est plus pris en charge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dans tous les cas.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">
          <see cref="T:System.LocalDataStoreSlot" /> dans lequel définir la valeur.</param>
        <param name="data">Valeur à définir.</param>
        <summary>Définit les données dans l'emplacement spécifié sur le thread en cours d'exécution, pour le domaine actuel de ce thread. Pour de meilleures performances, utilisez à la place les champs marqués avec l'attribut <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Le .NET Framework fournit deux mécanismes pour utiliser le stockage local des threads (TLS) : les champs statiques relatifs à un thread (autrement dit, les champs qui sont marqués avec le <xref:System.ThreadStaticAttribute> attribut) et emplacements de données. Les champs statiques relatifs à un thread fournissent de meilleures performances que les emplacements de données et activent la vérification de type au moment de la compilation. Pour plus d’informations sur l’utilisation de TLS, consultez [stockage Local des threads : champs statiques relatifs à un Thread et emplacements de données](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Threads utilisent un mécanisme de mémoire de magasin local pour stocker les données propres au thread. Le common language runtime alloue un tableau de magasin de données à chaque processus lors de sa création. Le thread peut allouer un emplacement de données dans le magasin de données, stockez et récupérez une données valeur dans l’emplacement et libérer de l’emplacement pour une réutilisation après la fin de la procédure de thread et le <xref:System.Threading.Thread> objet a été récupéré par le garbage collection. Emplacements de données sont uniques pour chaque thread. Aucun autre thread (pas même un thread enfant) ne peut obtenir les données.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A> est un `Shared` méthode s’applique toujours au thread en cours d’exécution, même si vous appelez à l’aide d’une variable qui fait référence à un autre thread. Pour éviter toute confusion, utilisez le nom de classe lors de l’appel `Shared` méthodes : `Thread.SetData(testSlot, "test data")`.  
  
   
  
## Examples  
 Cette section contient deux exemples de code. Le premier exemple montre comment utiliser un champ est marqué avec le <xref:System.ThreadStaticAttribute> attribut devant contenir les informations spécifiques aux threads. Le deuxième exemple montre comment utiliser un emplacement de données pour faire la même chose.  
  
 **Premier exemple**  
  
 L’exemple suivant montre comment utiliser un champ est marqué avec <xref:System.ThreadStaticAttribute> pour contenir des informations spécifiques au thread. Cette technique offre de meilleures performances que la technique qui est indiquée dans le deuxième exemple.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Deuxième exemple**  
  
 L’exemple suivant montre comment utiliser un emplacement de données pour stocker des informations spécifiques au thread.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads et threading</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">Stockage local des threads : champs statiques et emplacements de données relatifs à un thread</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Suspend le thread actuel pendant la durée spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Nombre de millisecondes pendant lesquelles le thread est suspendu. Si la valeur de l’argument <c>millisecondsTimeout</c> est égale à zéro, le thread abandonne le reste de sa tranche de temps à n’importe quel thread de priorité égale prêt à être exécuté. S'il n'existe pas d'autres threads de priorité égale prêts à être exécutés, l'exécution du thread actuel n'est pas suspendue.</param>
        <summary>Suspend le thread actuel pendant le nombre spécifié de millisecondes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le thread n’est plus planifié pour l’exécution par le système d’exploitation pendant la durée spécifiée. Cette méthode modifie l’état du thread pour inclure <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Vous pouvez spécifier <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> pour le `millisecondsTimeout` paramètre d’interruption du thread indéfiniment. Toutefois, nous vous recommandons d’utiliser des autres <xref:System.Threading?displayProperty=nameWithType> classes telles que <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, ou <xref:System.Threading.Semaphore> au lieu de cela pour synchroniser des threads ou gérer les ressources.  
  
 Les battements d’horloge système à un rythme spécifique appelée la résolution de l’horloge. Le délai d’expiration réelle peut être pas exactement le délai spécifié, car le délai d’expiration spécifié est ajustée pour coïncider avec battements d’horloge. Pour plus d’informations sur la résolution de l’horloge et le temps d’attente, consultez la [veille fonction](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) rubrique. Cette méthode appelle la [mise en veille de la fonction](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) à partir de l’API du système Windows.  
  
 Cette méthode n’effectue pas standard pompage COM et SendMessage.  
  
> [!NOTE]
>  Si vous devez mettre en veille sur un thread qui a <xref:System.STAThreadAttribute>, mais que vous souhaitez effectuer standard pompage COM et SendMessage, envisagez d’utiliser une des surcharges de la <xref:System.Threading.Thread.Join%2A> méthode qui spécifie un intervalle de délai d’attente.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Threading.Thread.Sleep%2A> méthode pour bloquer le thread principal de l’application.  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur du délai d’attente est négative et n’est pas égale à <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Durée pendant laquelle le thread est suspendu. Si la valeur de l’argument <c>millisecondsTimeout</c> est <see cref="F:System.TimeSpan.Zero" />, le thread abandonne le reste de sa tranche de temps à n’importe quel thread de priorité égale prêt à être exécuté. S'il n'existe pas d'autres threads de priorité égale prêts à être exécutés, l'exécution du thread actuel n'est pas suspendue.</param>
        <summary>Suspend le thread actuel pendant la durée spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le thread n’est plus planifié pour l’exécution par le système d’exploitation pendant la durée spécifiée. Cette méthode modifie l’état du thread pour inclure <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Vous pouvez spécifier <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> pour le `timeout` paramètre d’interruption du thread indéfiniment. Toutefois, nous vous recommandons d’utiliser des autres <xref:System.Threading?displayProperty=nameWithType> classes telles que <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, ou <xref:System.Threading.Semaphore> au lieu de cela pour synchroniser des threads ou gérer les ressources.  
  
 Cette surcharge de <xref:System.Threading.Thread.Sleep%2A> utilise le nombre total de millisecondes entières dans `timeout`. Fractions de milliseconde sont ignorées.  
  
 Cette méthode n’effectue pas standard pompage COM et SendMessage.  
  
> [!NOTE]
>  Si vous devez mettre en veille sur un thread qui a <xref:System.STAThreadAttribute>, mais que vous souhaitez effectuer standard pompage COM et SendMessage, envisagez d’utiliser une des surcharges de la <xref:System.Threading.Thread.Join%2A> méthode qui spécifie un intervalle de délai d’attente.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> surcharge de méthode pour bloquer des cinq fois, thread principal de l’application pendant deux secondes.  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="timeout" /> est négative et n’est pas égale à <see cref="F:System.Threading.Timeout.Infinite" /> en millisecondes, ou est supérieure à <see cref="F:System.Int32.MaxValue" /> millisecondes.</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">Entier signé 32 bits qui définit le temps pendant lequel un thread doit attendre.</param>
        <summary>Provoque l'attente d'un thread pendant le nombre de fois défini par le paramètre <paramref name="iterations" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Thread.SpinWait%2A> méthode est utile pour implémenter des verrous. Classes dans le .NET Framework, telles que <xref:System.Threading.Monitor> et <xref:System.Threading.ReaderWriterLock>, utilisez cette méthode en interne. <xref:System.Threading.Thread.SpinWait%2A> met essentiellement le processeur dans une boucle serrée très, avec le nombre de boucles spécifié par le `iterations` paramètre. Par conséquent, la durée de l’attente dépend de la vitesse du processeur.  
  
 Comparez ceci avec la <xref:System.Threading.Thread.Sleep%2A> (méthode). Un thread qui appelle <xref:System.Threading.Thread.Sleep%2A> génère le reste de sa tranche de temps processeur, même si l’intervalle spécifié sont égal à zéro. En spécifiant un intervalle différent de zéro pour <xref:System.Threading.Thread.Sleep%2A> supprime le thread d’examen par le Planificateur de threads jusqu'à ce que l’intervalle de temps s’est écoulé.  
  
 <xref:System.Threading.Thread.SpinWait%2A> est généralement pas utile pour les applications ordinaires. Dans la plupart des cas, vous devez utiliser les classes de synchronisation fournies par le .NET Framework ; par exemple, appeler <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> ou une instruction qui encapsule <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` en c# ou `SyncLock` en Visual Basic).  
  
> [!CAUTION]
>  Dans les rares cas où il est avantageux d’éviter un changement de contexte, par exemple lorsque vous savez qu’un changement d’état est imminent, effectuez un appel à la <xref:System.Threading.Thread.SpinWait%2A> méthode dans la boucle. Le code <xref:System.Threading.Thread.SpinWait%2A> exécute est conçu pour éviter les problèmes qui peuvent se produire sur les ordinateurs avec plusieurs processeurs. Par exemple, sur les ordinateurs avec plusieurs processeurs Intel utilisant la technologie Hyper-Threading, <xref:System.Threading.Thread.SpinWait%2A> empêche la privation de processeur dans certaines situations.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entraîne la planification de l'exécution d'un thread.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provoque le changement, par le système d'exploitation, de l'état de l'instance actuelle en <see cref="F:System.Threading.ThreadState.Running" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fois qu’un thread se trouve dans le <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> d’état, le système d’exploitation peut planifier son exécution. Le thread d’exécution commence à la première ligne de la méthode représentée par le <xref:System.Threading.ThreadStart> ou <xref:System.Threading.ParameterizedThreadStart> délégué fourni au constructeur de thread. Notez que l’appel à <xref:System.Threading.Thread.Start%2A> ne bloque pas le thread appelant.  
  
> [!NOTE]
>  Si cette surcharge est utilisée avec un thread créé à l’aide un <xref:System.Threading.ParameterizedThreadStart> déléguer, `null` est passé à la méthode exécutée par le thread.  
  
 Une fois que le thread s’arrête, il ne peut pas être redémarré avec un autre appel à `Start`.  
  
   
  
## Examples  
 L’exemple suivant crée et démarre un thread.  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Le thread a déjà été démarré.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible est insuffisante pour démarrer ce thread.</exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads et threading</related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Création de threads et passage de données au démarrage</related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">Objet contenant les données que la méthode exécutée par le thread doit utiliser.</param>
        <summary>Provoque le changement, par le système d'exploitation, de l'état de l'instance actuelle en <see cref="F:System.Threading.ThreadState.Running" />, et fournit éventuellement un objet contenant les données que la méthode exécutée par le thread doit utiliser.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fois qu’un thread se trouve dans le <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> d’état, le système d’exploitation peut planifier son exécution. Le thread d’exécution commence à la première ligne de la méthode représentée par le <xref:System.Threading.ThreadStart> ou <xref:System.Threading.ParameterizedThreadStart> délégué fourni au constructeur de thread. Notez que l’appel à <xref:System.Threading.Thread.Start%2A> ne bloque pas le thread appelant.  
  
 Une fois que le thread s’arrête, il ne peut pas être redémarré avec un autre appel à `Start`.  
  
 Cette surcharge et la <xref:System.Threading.ParameterizedThreadStart> délégué facilitent l’utilisation passer des données à une procédure de thread, mais la technique n’est pas de type sécurisé, car n’importe quel objet peut être passé à cette surcharge. Une façon plus fiable pour transmettre des données à une procédure de thread est de placer la procédure de thread et les champs de données dans un objet de travail. Pour plus d’informations, consultez [création de Threads et passage de données à l’heure de début](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Threading.ParameterizedThreadStart> délégué avec une méthode statique et une méthode d’instance.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Le thread a déjà été démarré.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible est insuffisante pour démarrer ce thread.</exception>
        <exception cref="T:System.InvalidOperationException">Ce thread a été créé à l’aide d’un délégué <see cref="T:System.Threading.ThreadStart" /> au lieu d’un délégué <see cref="T:System.Threading.ParameterizedThreadStart" />.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">Création de Threads</related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Suspend le thread ou, s'il est déjà suspendu, n'a aucun effet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le thread est déjà suspendu, cette méthode n’a aucun effet.  
  
> [!CAUTION]
>  N’utilisez pas le <xref:System.Threading.Thread.Suspend%2A> et <xref:System.Threading.Thread.Resume%2A> méthodes pour synchroniser les activités de threads. Vous ne disposez d’aucun moyen de savoir quel code un thread s’exécute lorsque vous l’interrompez. Si vous suspendez un thread pendant qu’il détient des verrous pendant une évaluation des autorisations de sécurité, d’autres threads le <xref:System.AppDomain> risque d’être bloqué. Si vous suspendez un thread pendant son exécution un constructeur de classe, d’autres threads le <xref:System.AppDomain> qui tente d’utiliser cette classe sera bloqué. Blocages peuvent se produire très facilement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core uniquement : ce membre n’est pas pris en charge.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Le thread n’a pas été démarré ou est inactif.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant ne possède pas le <see cref="T:System.Security.Permissions.SecurityPermission" /> nécessaire.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour les opérations avancées sur les threads. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">Suspension et interruption de threads</related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">États des threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Réservé à un usage ultérieur. Doit être IID_NULL.</param>
        <param name="rgszNames">Tableau passé des noms à mapper.</param>
        <param name="cNames">Compte des noms à mapper.</param>
        <param name="lcid">Contexte des paramètres régionaux dans lequel interpréter les noms.</param>
        <param name="rgDispId">Tableau alloué par l'appelant et recevant les ID qui correspondent aux noms.</param>
        <summary>Mappe un jeu de noms avec un jeu correspondant d'identificateurs de dispatch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetIDsOfNames`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informations de type à retourner.</param>
        <param name="lcid">Identificateur des paramètres régionaux pour les informations de type.</param>
        <param name="ppTInfo">Reçoit un pointeur vers l'objet d'informations de type demandé.</param>
        <summary>Récupère les informations de type pour un objet, qui peuvent être utilisées ensuite pour obtenir les informations de type d'une interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfo`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Pointe vers un emplacement qui reçoit le nombre d'interfaces d'informations de type fourni par l'objet.</param>
        <summary>Récupère le nombre d'interfaces d'informations de type fourni par un objet (0 ou 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfoCount`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifie le membre.</param>
        <param name="riid">Réservé à un usage ultérieur. Doit être IID_NULL.</param>
        <param name="lcid">Contexte des paramètres régionaux dans lequel interpréter les arguments.</param>
        <param name="wFlags">Indicateurs décrivant le contexte de l'appel.</param>
        <param name="pDispParams">Pointeur vers une structure qui contient un tableau d’arguments, un tableau d’arguments DISPID pour les arguments nommés et le nombre d’éléments de chaque tableau.</param>
        <param name="pVarResult">Pointeur vers l'emplacement où le résultat doit être stocké.</param>
        <param name="pExcepInfo">Pointeur vers une structure qui contient les informations sur les exceptions.</param>
        <param name="puArgErr">Index du premier argument comportant une erreur.</param>
        <summary>Fournit l'accès aux propriétés et aux méthodes exposées par un objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::Invoke`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur contenant les états du thread actuel.</summary>
        <value>Une des valeurs <see cref="T:System.Threading.ThreadState" /> indiquant l'état du thread actuel. La valeur initiale est <see langword="Unstarted" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Thread.ThreadState%2A> propriété fournit des informations plus spécifiques que le <xref:System.Threading.Thread.IsAlive%2A> propriété.  
  
> [!IMPORTANT]
>  État du thread n’est utile dans les scénarios de débogage. Votre code ne doit jamais utiliser l’état des threads pour synchroniser les activités des threads.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’accès à la `ThreadState` d’un thread.  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">États des threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">Nouvel état de cloisonnement.</param>
        <summary>Définit l'état de cloisonnement d'un thread avant qu'il ne soit démarré.</summary>
        <returns>
          <see langword="true" /> si l'état de cloisonnement est défini ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nouveaux threads sont initialisés en tant que <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> si leur état de cloisonnement n’a pas été défini avant leur démarrage. État de cloisonnement doit être définie avant le démarrage d’un thread.  
  
> [!NOTE]
>  Le thread principal de l’application est initialisé à <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> par défaut. La seule façon de définir l’état de cloisonnement du thread principal de l’application à <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> consiste à appliquer le <xref:System.STAThreadAttribute> d’attribut à la méthode de point d’entrée.  
  
 Le <xref:System.Threading.Thread.TrySetApartmentState%2A> (méthode), avec la <xref:System.Threading.Thread.GetApartmentState%2A> (méthode) et le <xref:System.Threading.Thread.SetApartmentState%2A> (méthode), remplace le <xref:System.Threading.Thread.ApartmentState%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, et <xref:System.Threading.Thread.TrySetApartmentState%2A> méthodes. L’exemple de code crée un thread. Avant que le thread est démarré, <xref:System.Threading.Thread.GetApartmentState%2A> affiche initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> état et <xref:System.Threading.Thread.SetApartmentState%2A> modifie l’état à <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. Le <xref:System.Threading.Thread.TrySetApartmentState%2A> méthode renvoie alors `false` lorsque vous tentez de modifier l’état à <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> , car l’état de cloisonnement est déjà défini. Si la même opération avait été tentée avec <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> aurait été levée.  
  
 Une fois que le thread est démarré, le <xref:System.Threading.Thread.TrySetApartmentState%2A> méthode est utilisée à nouveau. Cette fois, elle lève <xref:System.Threading.ThreadStateException> , car le thread a déjà été démarré.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> n’est pas un état de cloisonnement valide.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Le thread a déjà été démarré.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit la valeur d'un champ. Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Champ à lire.</param>
        <summary>Lit la valeur d'un champ. Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</summary>
        <returns>Dernière valeur écrite dans le champ par un processeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Champ à lire.</param>
        <summary>Lit la valeur d'un champ. Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</summary>
        <returns>Dernière valeur écrite dans le champ par un processeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Champ à lire.</param>
        <summary>Lit la valeur d'un champ. Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</summary>
        <returns>Dernière valeur écrite dans le champ par un processeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Champ à lire.</param>
        <summary>Lit la valeur d'un champ. Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</summary>
        <returns>Dernière valeur écrite dans le champ par un processeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Champ à lire.</param>
        <summary>Lit la valeur d'un champ. Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</summary>
        <returns>Dernière valeur écrite dans le champ par un processeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Champ à lire.</param>
        <summary>Lit la valeur d'un champ. Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</summary>
        <returns>Dernière valeur écrite dans le champ par un processeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Champ à lire.</param>
        <summary>Lit la valeur d'un champ. Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</summary>
        <returns>Dernière valeur écrite dans le champ par un processeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Champ à lire.</param>
        <summary>Lit la valeur d'un champ. Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</summary>
        <returns>Dernière valeur écrite dans le champ par un processeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Champ à lire.</param>
        <summary>Lit la valeur d'un champ. Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</summary>
        <returns>Dernière valeur écrite dans le champ par un processeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Champ à lire.</param>
        <summary>Lit la valeur d'un champ. Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</summary>
        <returns>Dernière valeur écrite dans le champ par un processeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Champ à lire.</param>
        <summary>Lit la valeur d'un champ. Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</summary>
        <returns>Dernière valeur écrite dans le champ par un processeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Champ à lire.</param>
        <summary>Lit la valeur d'un champ. Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</summary>
        <returns>Dernière valeur écrite dans le champ par un processeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Champ à lire.</param>
        <summary>Lit la valeur d'un champ. Il s'agit de la dernière valeur écrite par un processeur d'un ordinateur, quel que soit le nombre de processeurs ou l'état du cache de processeurs.</summary>
        <returns>Dernière valeur écrite dans le champ par un processeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> Obtient la dernière valeur écrite dans un emplacement de mémoire par n’importe quel processeur. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">Champ dans lequel la valeur doit être écrite.</param>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">Champ dans lequel la valeur doit être écrite.</param>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">Champ dans lequel la valeur doit être écrite.</param>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">Champ dans lequel la valeur doit être écrite.</param>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">Champ dans lequel la valeur doit être écrite.</param>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">Champ dans lequel la valeur doit être écrite.</param>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">Champ dans lequel la valeur doit être écrite.</param>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">Champ dans lequel la valeur doit être écrite.</param>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">Champ dans lequel la valeur doit être écrite.</param>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">Champ dans lequel la valeur doit être écrite.</param>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">Champ dans lequel la valeur doit être écrite.</param>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">Champ dans lequel la valeur doit être écrite.</param>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">Champ dans lequel la valeur doit être écrite.</param>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit immédiatement une valeur dans un champ pour que la valeur soit visible pour tous les processeurs de l'ordinateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> sont les cas spéciaux de la synchronisation. Dans des circonstances normales, le C# `lock` instruction, Visual Basic `SyncLock` instruction et le <xref:System.Threading.Monitor> classe offrent des alternatives plus facilités.  
  
 Sur un système multiprocesseur, <xref:System.Threading.Thread.VolatileWrite%2A> garantit qu’une valeur écrite dans un emplacement de mémoire est immédiatement visible pour tous les processeurs. Vous devrez peut-être vider les caches de processeur.  
  
 Même sur un système monoprocesseur, <xref:System.Threading.Thread.VolatileRead%2A> et <xref:System.Threading.Thread.VolatileWrite%2A> assurent qu’une valeur lire ou écrite dans la mémoire et non mis en cache (par exemple, dans un Registre de processeur). Par conséquent, vous pouvez les utiliser pour synchroniser l’accès à un champ pouvant être mis à jour par un autre thread, ou par le matériel.  
  
 Appel de cette méthode affecte uniquement un accès à la mémoire unique. Pour fournir une synchronisation efficace pour un champ, tous les accès au champ doivent utiliser <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En c#, à l’aide de la `volatile` modificateur sur un champ garantit que tous les accès à ce champ utilisent <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oblige le thread appelant à céder l'exécution à un autre thread prêt à s'exécuter sur le processeur actuel. Le système d'exploitation sélectionne le thread auquel l'exécution doit être cédée.</summary>
        <returns>
          <see langword="true" /> si le système d'exploitation a basculé l'exécution vers un autre thread ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette méthode réussit, le reste de la tranche de temps actuelle du thread est obtenue. Le système d’exploitation planifie le thread appelant pour une autre tranche de temps, en fonction de sa priorité et l’état des autres threads qui sont disponibles pour l’exécuter.  
  
 Génération de résultats est limitée au processeur qui exécute le thread appelant. Le système d’exploitation ne bascule pas de l’exécution vers un autre processeur, même si ce processeur est inactif ou exécute un thread de priorité inférieure. Si aucun autre thread qui sont prêts à exécuter sur le processeur actuel, le système d’exploitation ne suspend pas l’exécution, et cette méthode retourne `false`.  
  
 Cette méthode est équivalente à l’aide de la plateforme de l’appel pour appeler Win32 natif `SwitchToThread` (fonction). Vous devez appeler la <xref:System.Threading.Thread.Yield%2A> appeler de méthode au lieu d’utiliser la plateforme, car tout comportement de thread personnalisé l’hôte a demandé de contournements non managé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>