<Type Name="HttpListenerPrefixCollection" FullName="System.Net.HttpListenerPrefixCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="24ed896b5097c0293079cbdb27b8273a2e5a3d0f" /><Meta Name="ms.sourcegitcommit" Value="0609891c89ddaa91e4c02970acb00072fcc29baf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/13/2019" /><Meta Name="ms.locfileid" Value="65558499" /></Metadata><TypeSignature Language="C#" Value="public class HttpListenerPrefixCollection : System.Collections.Generic.ICollection&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;string&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit HttpListenerPrefixCollection extends System.Object implements class System.Collections.Generic.ICollection`1&lt;string&gt;, class System.Collections.Generic.IEnumerable`1&lt;string&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListenerPrefixCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpListenerPrefixCollection&#xA;Implements ICollection(Of String), IEnumerable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListenerPrefixCollection : System::Collections::Generic::ICollection&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;System::String ^&gt;" />
  <TypeSignature Language="F#" Value="type HttpListenerPrefixCollection = class&#xA;    interface ICollection&lt;string&gt;&#xA;    interface seq&lt;string&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente la collection utilisée pour stocker des préfixes d’identificateur URI (Uniform Resource) pour <see cref="T:System.Net.HttpListener" /> objets.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpListener.Prefixes%2A> propriété retourne des instances de cette collection.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.HttpListener> et ajoute des préfixes de spécifié par l’utilisateur à son <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string uriPrefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(string uriPrefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Add(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (uriPrefix As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::String ^ uriPrefix);" />
      <MemberSignature Language="F#" Value="abstract member Add : string -&gt; unit&#xA;override this.Add : string -&gt; unit" Usage="httpListenerPrefixCollection.Add uriPrefix" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriPrefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriPrefix">Un <see cref="T:System.String" /> qui identifie les informations d’URI qui sont comparées dans les demandes entrantes. Le préfixe doit se terminer par une barre oblique (« / »).</param>
        <summary>Ajoute un préfixe URI (Uniform Resource Identifier) à la collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ajoute un préfixe URI pour le jeu de préfixes gérée par associé <xref:System.Net.HttpListener> objet. Lors de la vérification `uriPrefix` pour vous assurer qu’il n’est valide, la casse est ignorée.  
  
 Une chaîne de préfixe URI est composée d’un schéma (http ou https), un ordinateur hôte, un port facultatif et un chemin d’accès facultatif, par exemple, «`http://www.contoso.com:8080/customerData/`». Le préfixe doit se terminer par une barre oblique (« / »). Le <xref:System.Net.HttpListener> avec le préfixe qui correspond le mieux à un URI demandé répond à la demande. Plusieurs <xref:System.Net.HttpListener> objets ne peut pas ajouter le même préfixe. Un <xref:System.Net.HttpListenerException> exception est levée si un <xref:System.Net.HttpListener> ajoute un préfixe qui est déjà utiliser.  
  
 Lorsqu’un port est spécifié, l’élément hôte peut être remplacé par «`*`» pour indiquer que le <xref:System.Net.HttpListener> accepte les demandes envoyées au port si l’URI demandé ne correspond pas à n’importe quel autre préfixe. Par exemple, pour recevoir toutes les demandes envoyées au port 8080 lorsque l’URI demandé n’est pas géré par un autre <xref:System.Net.HttpListener>, le préfixe est «`http://*:8080/`». De même, pour spécifier que le <xref:System.Net.HttpListener> accepte toutes les demandes envoyées à un port, remplacez l’élément hôte avec le «`+`« character »,`https://+:8080/`». Le «`*`« et »`+`» les caractères peuvent être présents dans les préfixes qui incluent des chemins d’accès.  
  
 Les sous-domaines génériques à partir de .NET 4.5.3 et Windows 10, sont pris en charge dans les préfixes URI qui sont gérés par un <xref:System.Net.HttpListener> objet. Pour spécifier un sous-domaine de caractère générique, utilisez le « * » caractère en tant que partie du nom d’hôte dans un préfixe URI : par exemple, `http://*.foo.com/`et le transmettre comme argument à la méthode HttpListenerPrefixCollection.Add. Cela fonctionne sur .NET 4.5.3 et Windows 10 ; dans les versions antérieures, cela générerait une <xref:System.Net.HttpListenerException>  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Net.HttpListener> et ajoute des préfixes de spécifié par l’utilisateur à son <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriPrefix" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="uriPrefix" /> n’utilise pas le schéma http:// ou https://. Ces schémas sont les seuls pris en charge pour les objets <see cref="T:System.Net.HttpListener" />.  
  
ou 
 <paramref name="uriPrefix" /> n’est pas un préfixe d’URI correctement mis en forme. Assurez-vous que la chaîne se termine par une barre oblique (« / »).</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.HttpListener" /> associé à cette collection est fermé.</exception>
        <exception cref="T:System.Net.HttpListenerException">Un appel de fonction Windows a échoué. Vérifiez la propriété <see cref="P:System.Net.HttpListenerException.ErrorCode" /> de l’exception pour déterminer la cause de l’exception. Cette exception est levée si un autre <see cref="T:System.Net.HttpListener" /> a déjà ajouté le préfixe <paramref name="uriPrefix" />.</exception>
        <permission cref="T:System.Net.WebPermission">Pour accepter les connexions réseau. Énumération associée : <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="httpListenerPrefixCollection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les préfixes d’identificateur de ressource uniforme (URI) de la collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Après avoir appelé cette méthode, vous ne pouvez pas démarrer associé <xref:System.Net.HttpListener> sans ajouter de nouveaux préfixes ; si vous essayez de le faire, une exception est levée.  
  
   
  
## Examples  
 L’exemple de code suivant supprime tous les préfixes dans un <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#6)]  
 [!code-vb[Net_Listener_Basic#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Un appel de fonction Windows a échoué. Vérifiez la propriété <see cref="P:System.Net.HttpListenerException.ErrorCode" /> de l’exception pour déterminer la cause de l’exception.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.HttpListener" /> associé à cette collection est fermé.</exception>
        <block subset="none" type="usage"><para>Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string uriPrefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string uriPrefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (uriPrefix As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::String ^ uriPrefix);" />
      <MemberSignature Language="F#" Value="abstract member Contains : string -&gt; bool&#xA;override this.Contains : string -&gt; bool" Usage="httpListenerPrefixCollection.Contains uriPrefix" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriPrefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriPrefix">Un <see cref="T:System.String" /> qui contient le préfixe d’identificateur de ressource uniforme (URI) à tester.</param>
        <summary>Retourne un <see cref="T:System.Boolean" /> valeur qui indique si le préfixe spécifié est contenu dans la collection.</summary>
        <returns><see langword="true" /> Si cette collection contient le préfixe spécifié par <paramref name="uriPrefix" />; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le préfixe spécifié doit correspondre exactement à une valeur existante.  
  
   
  
## Examples  
 Le code suivant exemple vérifie si un préfixe spécifié par l’utilisateur est contenu dans la collection de préfixe d’un <xref:System.Net.HttpListener>.  
  
 [!code-csharp[Net_Listener_Basic#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#4)]  
 [!code-vb[Net_Listener_Basic#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriPrefix" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie le contenu d’un <see cref="T:System.Net.HttpListenerPrefixCollection" /> dans le tableau spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau doit être en mesure de contenir des chaînes et ne peut pas être multidimensionnel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, int offset);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int -&gt; unit" Usage="httpListenerPrefixCollection.CopyTo (array, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Unidimensionnel <see cref="T:System.Array" /> qui reçoit les chaînes de préfixe d’identificateur de ressource uniforme (URI) de cette collection.</param>
        <param name="offset">Index de base zéro dans l'<paramref name="array" /> à partir duquel la copie commence.</param>
        <summary>Copie le contenu d’un <see cref="T:System.Net.HttpListenerPrefixCollection" /> dans le tableau spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau doit être en mesure de contenir des chaînes et ne peut pas être multidimensionnel.  
  
   
  
## Examples  
 L’exemple de code suivant copie les préfixes dans un <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#7)]  
 [!code-vb[Net_Listener_Basic#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> a plusieurs dimensions.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Cette collection contient plus d’éléments que peuvent être stockées dans <paramref name="array" /> en commençant à <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.HttpListener" /> associé à cette collection est fermé.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="array" /> Impossible de stocker les valeurs de chaîne.</exception>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (string[] array, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(string[] array, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.CopyTo(System.String[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As String(), offset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;System::String ^&gt; ^ array, int offset);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : string[] * int -&gt; unit&#xA;override this.CopyTo : string[] * int -&gt; unit" Usage="httpListenerPrefixCollection.CopyTo (array, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.String[]" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Le tableau de chaînes unidimensionnel qui reçoit les chaînes de préfixe d’identificateur URI (Uniform Resource) dans cette collection.</param>
        <param name="offset">Index de base zéro dans l'<paramref name="array" /> à partir duquel la copie commence.</param>
        <summary>Copie le contenu d’un <see cref="T:System.Net.HttpListenerPrefixCollection" /> au tableau de chaînes spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau doit être en mesure de contenir des chaînes et ne peut pas être multidimensionnel.  
  
   
  
## Examples  
 L’exemple de code suivant copie les préfixes dans un <xref:System.Net.HttpListenerPrefixCollection>.  
  
 [!code-csharp[Net_Listener_Basic#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#7)]  
 [!code-vb[Net_Listener_Basic#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> a plusieurs dimensions.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Cette collection contient plus d’éléments que peuvent être stockées dans <paramref name="array" /> en commençant à <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.HttpListener" /> associé à cette collection est fermé.</exception>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerPrefixCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Net.HttpListenerPrefixCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre de préfixes contenus dans la collection.</summary>
        <value>Un <see cref="T:System.Int32" /> qui contient le nombre de préfixes dans cette collection.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant affiche les préfixes d’un regroupement.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;string&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;string&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;System::String ^&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;string&gt;&#xA;override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;string&gt;" Usage="httpListenerPrefixCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet qui peut être utilisé pour itérer la collection.</summary>
        <returns>Un objet qui implémente le <see cref="T:System.Collections.IEnumerator" /> interface et permet d’accéder aux chaînes de cette collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’objet qui est retourné par cette méthode est positionné initialement avant le premier élément dans cette collection. Vous devez appeler la <xref:System.Collections.IEnumerator.MoveNext%2A> méthode avant de pouvoir accéder au premier élément. Pour accéder à l’élément à la position actuelle, appelez le <xref:System.Collections.IEnumerator.Current%2A> propriété.  
  
 Ne modifiez pas la collection lors de l’utilisation de l’énumérateur. Si la collection est modifiée pendant qu’un énumérateur est en utilisation, une tentative de définir la position en appelant <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> provoque un <xref:System.InvalidOperationException>.  
  
 Pour obtenir une description détaillée des énumérateurs, consultez la documentation pour le <xref:System.Collections.IEnumerator> classe et le <xref:System.Collections.IEnumerable.GetEnumerator%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’énumération d’une collection. Notez que les exemples Visual Basic et c# utilisent des instructions de langage spécifique à énumérer la collection au lieu de récupérer l’énumérateur.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerPrefixCollection.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Net.HttpListenerPrefixCollection.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l’accès à la collection est en lecture seule.</summary>
        <value>Retourne toujours <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerPrefixCollection.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Net.HttpListenerPrefixCollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l’accès à la collection est synchronisé (thread-safe).</summary>
        <value>Cette propriété retourne toujours <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'énumération d'une collection n'est intrinsèquement pas une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads pendant l’énumération, vous pouvez verrouiller la collection pendant toute l’énumération ou intercepter les exceptions qui résultent de modifications apportées par d’autres threads.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (string uriPrefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(string uriPrefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (uriPrefix As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(System::String ^ uriPrefix);" />
      <MemberSignature Language="F#" Value="abstract member Remove : string -&gt; bool&#xA;override this.Remove : string -&gt; bool" Usage="httpListenerPrefixCollection.Remove uriPrefix" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriPrefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriPrefix">Un <see cref="T:System.String" /> qui contient le préfixe URI à supprimer.</param>
        <summary>Supprime le spécifié identificateur URI (Uniform Resource) de la liste de préfixes gérée par le <see cref="T:System.Net.HttpListener" /> objet.</summary>
        <returns><see langword="true" /> Si le <paramref name="uriPrefix" /> a été trouvé dans le <see cref="T:System.Net.HttpListenerPrefixCollection" /> et supprimé ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `uriPrefix` est pas dans la collection, cette méthode ne fait rien.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriPrefix" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Net.HttpListenerException">Un appel de fonction Windows a échoué. Pour déterminer la cause de l’exception, vérifiez le code d’erreur de l’exception.</exception>
        <exception cref="T:System.ObjectDisposedException">Le <see cref="T:System.Net.HttpListener" /> associé à cette collection est fermé.</exception>
        <block subset="none" type="usage"><para>Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerPrefixCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet qui peut être utilisé pour itérer la collection.</summary>
        <returns>Un objet qui implémente le <see cref="T:System.Collections.IEnumerator" /> interface et permet d’accéder aux chaînes de cette collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’objet qui est retourné par cette méthode est positionné initialement avant le premier élément dans cette collection. Vous devez appeler la <xref:System.Collections.IEnumerator.MoveNext%2A> méthode avant de pouvoir accéder au premier élément. Pour accéder à l’élément à la position actuelle, appelez le <xref:System.Collections.IEnumerator.Current%2A> propriété.  
  
 Ne modifiez pas la collection lors de l’utilisation de l’énumérateur. Si la collection est modifiée pendant qu’un énumérateur est en utilisation, une tentative de définir la position en appelant <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> provoque un <xref:System.InvalidOperationException>.  
  
 Pour obtenir une description détaillée des énumérateurs, consultez la documentation pour le <xref:System.Collections.IEnumerator> classe et le <xref:System.Collections.IEnumerable.GetEnumerator%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
      </Docs>
    </Member>
  </Members>
</Type>