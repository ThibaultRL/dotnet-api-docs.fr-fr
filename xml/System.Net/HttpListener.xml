<Type Name="HttpListener" FullName="System.Net.HttpListener">
  <Metadata><Meta Name="ms.openlocfilehash" Value="588a6abf2f44e4fe8c587db29a2520e40e47e9bd" /><Meta Name="ms.sourcegitcommit" Value="0609891c89ddaa91e4c02970acb00072fcc29baf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/13/2019" /><Meta Name="ms.locfileid" Value="65558565" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpListener : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListener extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListener" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListener&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListener sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type HttpListener = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fournit un écouteur de protocole HTTP simple, contrôlé par programme. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À l’aide de la <xref:System.Net.HttpListener> (classe), vous pouvez créer un écouteur de protocole HTTP simple qui répond aux demandes HTTP. L’écouteur est actif pendant la durée de vie de la <xref:System.Net.HttpListener> objet et s’exécute au sein de votre application avec ses autorisations.
   
 À utiliser <xref:System.Net.HttpListener>, créer une nouvelle instance de la classe à l’aide de la <xref:System.Net.HttpListener> constructeur et utilisez le <xref:System.Net.HttpListener.Prefixes%2A> le depréfixesdepropriétépouraccéderàlacollectionquicontientleschaînesquispécifientlesressourcesURI(UniformIdentifier)<xref:System.Net.HttpListener>doit traiter.
  
 Une chaîne de préfixe URI est composée d’un schéma (http ou https), un ordinateur hôte, un port facultatif et un chemin d’accès facultatif. Est un exemple d’une chaîne de préfixe complète *http://www.contoso.com:8080/customerData/*. Préfixes doivent se terminer par une barre oblique (« / »). Le <xref:System.Net.HttpListener> objet avec le préfixe qui correspond le mieux à un URI demandé répond à la demande. Plusieurs <xref:System.Net.HttpListener> objets ne peut pas ajouter le même préfixe ; un <xref:System.ComponentModel.Win32Exception> exception est levée si un <xref:System.Net.HttpListener> ajoute un préfixe qui est déjà utiliser.
  
 Lorsqu’un port est spécifié, l’élément hôte peut être remplacé par «\*» pour indiquer que le <xref:System.Net.HttpListener> accepte les demandes envoyées au port si l’URI demandé ne correspond pas à n’importe quel autre préfixe. Par exemple, pour recevoir toutes les demandes envoyées au port 8080 lorsque l’URI demandé n’est pas géré par les <xref:System.Net.HttpListener>, le préfixe est *http://\*: 8080 /*. De même, pour spécifier que le <xref:System.Net.HttpListener> accepte toutes les demandes envoyées à un port, remplacez l’élément hôte par le caractère « + ». Par exemple, *https://+:8080*. Le «\*» et « + » caractères peuvent être présents dans les préfixes qui incluent des chemins d’accès.
  
 Les sous-domaines génériques à partir de .NET Core 2.0 ou .NET Framework 4.6 sur Windows 10, sont pris en charge dans les préfixes URI qui sont gérés par un <xref:System.Net.HttpListener> objet. Pour spécifier un sous-domaine de caractère générique, utilisez le «\*« caractère en tant que partie du nom d’hôte dans un préfixe URI. Par exemple, *http://\*.foo.com/*. Cela passer comme argument à la <xref:System.Net.HttpListenerPrefixCollection.Add%2A> (méthode). Cela fonctionne à compter de .NET Core 2.0 ou .NET Framework 4.6 sur Windows 10 ; dans les versions antérieures, cette opération génère un <xref:System.Net.HttpListenerException>.

 > [!WARNING]
 > Les liaisons génériques de niveau supérieur (*http://\*: 8080 /* et *http://+:8080*) doit **pas** être utilisé. Les liaisons génériques de niveau supérieur peuvent exposer votre application à des failles de sécurité. Cela s’applique aux caractères génériques forts et faibles. Utilisez des noms d’hôte explicites plutôt que des caractères génériques. Une liaison générique de sous-domaine (par exemple, `*.mysub.com`) ne présente pas ce risque de sécurité si vous contrôlez le domaine parent en entier (par opposition à `*.com`, qui est vulnérable). Consultez la [rfc7230 section-5.4](https://tools.ietf.org/html/rfc7230#section-5.4) pour plus d’informations.
  
 Pour commencer à écouter les demandes des clients, ajoutez les préfixes URI à la collection et appeler le <xref:System.Net.HttpListener.Start%2A> (méthode). <xref:System.Net.HttpListener> propose des modèles à la fois synchrones et asynchrones pour traiter les demandes du client. Demandes et leurs réponses associées sont accessibles à l’aide de la <xref:System.Net.HttpListenerContext> objet retourné par la <xref:System.Net.HttpListener.GetContext%2A> méthode ou ses équivalents asynchrones, le <xref:System.Net.HttpListener.BeginGetContext%2A> et <xref:System.Net.HttpListener.EndGetContext%2A> méthodes.
  
 Le modèle synchrone est approprié si votre application doit être bloquée en attendant une demande du client et si vous souhaitez ne traiter qu’une seule demande à la fois. À l’aide du modèle synchrone, appelez le <xref:System.Net.HttpListener.GetContext%2A> (méthode), qui attend qu’un client envoie une demande. La méthode retourne un <xref:System.Net.HttpListenerContext> de l’objet à vous pour traitement lorsque l’une se produit.
  
 Dans le modèle asynchrone plus complexe, votre application ne bloque pas alors que l’attente des demandes et chaque demande est traitée dans son propre thread d’exécution. Utilisez le <xref:System.Net.HttpListener.BeginGetContext%2A> méthode pour spécifier une méthode définie par l’application d’être appelée pour chaque demande entrante. Dans cette méthode, appelez le <xref:System.Net.HttpListener.EndGetContext%2A> méthode pour obtenir la demande, de traiter et de répondre.
  
 Dans les deux modèles, les demandes entrantes sont accessibles à l’aide de la <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType> propriété et sont représentées par <xref:System.Net.HttpListenerRequest> objets. De même, les réponses sont accessibles à l’aide de la <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=nameWithType> propriété et sont représentées par <xref:System.Net.HttpListenerResponse> objets. Ces objets partagent certaines fonctionnalités avec les <xref:System.Net.HttpWebRequest> et <xref:System.Net.HttpWebResponse> objets, mais les objets de ce dernier ne peut pas être utilisé conjointement avec <xref:System.Net.HttpListener> , car ils implémentent client, pas le serveur, des comportements.
  
 Un <xref:System.Net.HttpListener> peut nécessiter l’authentification du client. Vous pouvez spécifier un schéma particulier à utiliser pour l’authentification, ou vous pouvez spécifier un délégué qui détermine le schéma à utiliser. Vous devez exiger une forme d’authentification pour obtenir des informations sur l’identité du client. Pour plus d’informations, consultez le <xref:System.Net.HttpListenerContext.User%2A>, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>, et <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> propriétés.
  
> [!NOTE]
> Si vous créez un <xref:System.Net.HttpListener> à l’aide de https, vous devez sélectionner un certificat de serveur pour cet écouteur. Sinon, un <xref:System.Net.HttpWebRequest> requête de ce <xref:System.Net.HttpListener> échouera avec une fin inattendue de la connexion.
  
> [!NOTE]
> Vous pouvez configurer des certificats de serveur et d’autres options d’écouteur à l’aide de l’environnement réseau (netsh.exe). Consultez [Network Shell (Netsh)](/windows-server/networking/technologies/netsh/netsh) pour plus d’informations. Le fichier exécutable est fourni avec Windows Server 2008 et Windows Vista.
  
> [!NOTE]
> Si vous spécifiez plusieurs schémas d’authentification pour le <xref:System.Net.HttpListener>, l’écouteur sélectionnera les clients dans l’ordre suivant : `Negotiate`, `NTLM`, `Digest`, puis `Basic`.
  
   
  
## Examples
 L’exemple de code suivant montre comment utiliser un <xref:System.Net.HttpListener>.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Modifications apportées à l’authentification NTLM pour HTTPWebRequest dans la Version 3.5 SP1</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpListener();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avant d’utiliser l’instance retournée par ce constructeur, vous devez appeler son <xref:System.Net.HttpListener.Start%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Net.HttpListener> constructeur pour créer un nouveau <xref:System.Net.HttpListener> objet. Pour obtenir un exemple complet, consultez le <xref:System.Net.HttpListener> rubrique de la classe.  
  
 [!code-csharp[Net_listener_Basic#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#9)]  
 [!code-vb[Net_Listener_Basic#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Cette classe ne peut pas être utilisée sur le système d’exploitation actuel. Windows Server 2003 ou Windows XP SP2 est requis pour utiliser des instances de cette classe.</exception>
        <block subset="none" type="usage"><para>Remarque : Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpListener.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arrête immédiatement l'objet <see cref="T:System.Net.HttpListener" />, en ignorant toutes les demandes actuellement mises en file d'attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode supprime toutes les ressources détenues par cet écouteur. Toutes les demandes en attente ne peuvent pas suivre.  
  
 Après avoir appelé cette méthode, vous recevrez un <xref:System.ObjectDisposedException> si vous essayez d’utiliser ce <xref:System.Net.HttpListener>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’appel de cette méthode.  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
 [!code-vb[Net_Listener_Basic#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemes">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.AuthenticationSchemes AuthenticationSchemes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemes" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemes As AuthenticationSchemes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemes AuthenticationSchemes { System::Net::AuthenticationSchemes get(); void set(System::Net::AuthenticationSchemes value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemes : System.Net.AuthenticationSchemes with get, set" Usage="System.Net.HttpListener.AuthenticationSchemes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le schéma utilisé pour authentifier les clients.</summary>
        <value>Combinaison d'opérations de bits de valeurs d'énumération <see cref="T:System.Net.AuthenticationSchemes" /> qui indiquent la manière dont les clients doivent être authentifiés. La valeur par défaut est <see cref="F:System.Net.AuthenticationSchemes.Anonymous" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpListener> utilise le schéma spécifié pour authentifier toutes les demandes entrantes. Le <xref:System.Net.HttpListener.GetContext%2A> et <xref:System.Net.HttpListener.EndGetContext%2A> méthodes retournent une demande entrante du client uniquement si le <xref:System.Net.HttpListener> authentifie correctement la demande.  
  
 Vous pouvez interroger l’identité d’un client correctement authentifié à l’aide de la <xref:System.Net.HttpListenerContext.User%2A?displayProperty=nameWithType> propriété.  
  
 Si vous souhaitez un <xref:System.Net.HttpListener> objet à utiliser différents mécanismes d’authentification selon les caractéristiques des demandes qu’il reçoit (par exemple, de la demande <xref:System.Net.HttpListenerRequest.Url%2A> ou <xref:System.Net.HttpListenerRequest.UserHostName%2A> propriété), vous devez implémenter une méthode qui choisit le schéma d’authentification. Pour savoir comment procéder, consultez la <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> documentation de la propriété.  
  
> [!NOTE]
>  Pour définir cette propriété pour activer Digest, NTLM ou Negotiate nécessite le <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Net.HttpListener.AuthenticationSchemes%2A> propriété pour spécifier un schéma d’authentification.  
  
 [!code-csharp[Net_listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
 [!code-vb[Net_Listener_Basic#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationSchemeSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationSchemeSelectorDelegate As AuthenticationSchemeSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::AuthenticationSchemeSelector ^ AuthenticationSchemeSelectorDelegate { System::Net::AuthenticationSchemeSelector ^ get(); void set(System::Net::AuthenticationSchemeSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationSchemeSelectorDelegate : System.Net.AuthenticationSchemeSelector with get, set" Usage="System.Net.HttpListener.AuthenticationSchemeSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.AuthenticationSchemeSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le délégué appelé pour déterminer le protocole utilisé pendant l'authentification des clients.</summary>
        <value>Délégué <see cref="T:System.Net.AuthenticationSchemeSelector" /> qui appelle la méthode utilisée pour sélectionner un protocole d'authentification. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si vous souhaitez que le même protocole d’authentification à utiliser pour toutes les demandes gérées par une instance particulière de <xref:System.Net.HttpListener>, vous n’avez pas besoin de définir cette propriété. Pour spécifier un protocole à utiliser pour toutes les demandes de client, utilisez le <xref:System.Net.HttpListener.AuthenticationSchemes%2A> propriété.  
  
 Si le client n’a pas spécifié les informations d’authentification dans ses en-têtes, le <xref:System.Net.HttpListener> appelle le délégué spécifié pour chaque demande entrante non authentifiée déterminer le cas échéant, protocole à utiliser pour authentifier le client. Le <xref:System.Net.HttpListener.GetContext%2A> et <xref:System.Net.HttpListener.EndGetContext%2A> méthodes retournent un demande entrante que si le <xref:System.Net.HttpListener> authentifié avec succès la demande. Si une demande ne peut pas être authentifiée, le <xref:System.Net.HttpListener> automatiquement renvoie une réponse 401. Vous pouvez obtenir l’identité d’un client correctement authentifié à l’aide de la <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=nameWithType> propriété.  
  
 La possibilité de déléguer le choix du protocole d’authentification à une méthode spécifique à l’application est utile si vous souhaitez qu’une instance de <xref:System.Net.HttpListener> à utiliser différents protocoles d’authentification selon les caractéristiques de demandes reçues (pour par exemple, la demande <xref:System.Net.HttpListenerRequest.Url%2A> ou <xref:System.Net.HttpListenerRequest.UserHostAddress%2A> propriété).  
  
> [!NOTE]
>  Pour définir cette propriété pour activer Digest, NTLM ou Negotiate nécessite le <xref:System.Security.Permissions.SecurityPermission>, <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal>.  
  
   
  
## Examples  
 L’exemple de code suivant définit la valeur de cette propriété.  
  
 [!code-csharp[NclListener#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#2)]
 [!code-vb[NclListener#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#2)]  
  
 L’exemple de code suivant fournit une implémentation d’une méthode appelée par un <xref:System.Net.AuthenticationSchemeSelector> déléguer.  
  
 [!code-csharp[NclListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#1)]
 [!code-vb[NclListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetContext">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetContext (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetContext(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetContext (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetContext(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginGetContext : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpListener.BeginGetContext (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué <see cref="T:System.AsyncCallback" /> qui fait référence à la méthode à appeler quand une demande du client est disponible.</param>
        <param name="state">Objet défini par l'utilisateur qui comporte des informations sur l'opération. Cet objet est passé au délégué <paramref name="callback" /> quand l'opération se termine.</param>
        <summary>Commence à récupérer une demande entrante de façon asynchrone.</summary>
        <returns>Objet <see cref="T:System.IAsyncResult" /> qui indique l'état de l'opération asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpListener.BeginGetContext%2A> méthode commence un appel asynchrone (sans blocage) pour recevoir les demandes entrantes des clients. Avant d’appeler cette méthode, vous devez appeler la <xref:System.Net.HttpListener.Start%2A> (méthode) et ajoutez au moins un préfixe d’identificateur URI (Uniform Resource) pour écouter en ajoutant les chaînes URI à la <xref:System.Net.HttpListenerPrefixCollection> retourné par la <xref:System.Net.HttpListener.Prefixes%2A> propriété.  
  
 L’opération asynchrone doit être terminée en appelant le <xref:System.Net.HttpListener.EndGetContext%2A> (méthode). En règle générale, la méthode est appelée par le `callback` déléguer.  
  
 Cette méthode ne bloque pas pendant que l’opération se termine. Pour obtenir une demande entrante et le bloc jusqu'à ce que l’opération est terminée, appelez le <xref:System.Net.HttpListener.GetContext%2A> (méthode).  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Net.HttpListener.BeginGetContext%2A> méthode pour spécifier une méthode de rappel qui gérera les demandes entrantes des clients.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
 [!code-vb[Net_Listener_Basic#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#12)]  
  
 L’exemple de code suivant implémente une méthode de rappel.  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
 [!code-vb[Net_Listener_Basic#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Un appel de fonction Win32 a échoué. Vérifiez la propriété <see cref="P:System.Net.HttpListenerException.ErrorCode" /> de l’exception pour déterminer la cause de l’exception.</exception>
        <exception cref="T:System.InvalidOperationException">Cet objet n’a pas été démarré ou est actuellement arrêté.</exception>
        <exception cref="T:System.ObjectDisposedException">Cet objet est fermé.</exception>
        <block subset="none" type="usage"><para>Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpListener.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arrête le <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Après avoir appelé cette méthode, vous ne pouvez plus utiliser le <xref:System.Net.HttpListener> objet. Pour interrompre temporairement une <xref:System.Net.HttpListener> de l’objet, utilisez le <xref:System.Net.HttpListener.Stop%2A> (méthode).  
  
 Cette méthode ferme downs le <xref:System.Net.HttpListener> objet sans traiter les demandes en file d’attente. Toutes les demandes en attente ne peuvent pas suivre.  
  
## Examples  

L’exemple de code suivant montre l’appel la `Close` méthode :
  
[!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
[!code-vb[Net_Listener_Basic#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#12)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DefaultServiceNames">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.DefaultServiceNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultServiceNames As ServiceNameCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ DefaultServiceNames { System::Security::Authentication::ExtendedProtection::ServiceNameCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultServiceNames : System.Security.Authentication.ExtendedProtection.ServiceNameCollection" Usage="System.Net.HttpListener.DefaultServiceNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ServiceNameCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une liste par défaut des noms de fournisseurs de services (SPN) déterminée par les préfixes enregistrés.</summary>
        <value><see cref="T:System.Security.Authentication.ExtendedProtection.ServiceNameCollection" /> qui contient une liste de SPN.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpListener.DefaultServiceNames%2A> propriété est utilisée avec l’authentification Windows intégrée pour fournir une protection étendue. La liste des noms principaux de service est initialisée à partir du <xref:System.Net.HttpListener.Prefixes%2A> propriété lors de l’accès et effacée lorsque de nouveaux préfixes sont ajoutés à la <xref:System.Net.HttpListener.Prefixes%2A> propriété.  
  
 Le <xref:System.Net.HttpListener.DefaultServiceNames%2A> propriété est utilisée si une application ne définit pas le <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> propriété de sa stratégie de protection étendue.  
  
 Le <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection> qui est récupérée avec la <xref:System.Net.HttpListener.DefaultServiceNames%2A> propriété repose sur le <xref:System.Net.HttpListener.Prefixes%2A> propriété selon les règles suivantes :  
  
1.  Si le nom d’hôte est « + », « * », ou un littéral IPv4 ou IPv6 (équivalent à «\*» mais restreint à une interface locale spécifique), le SPN suivant est ajouté :  
  
 `"HTTP/"` plus le nom de domaine complet de l’ordinateur.  
  
1.  Si le nom d’hôte contient pas de points (aucun domaine ou sous-domaines), une tentative est effectuée pour résoudre le nom de domaine complet à l’aide de DNS (le même comportement que celui utilisé par <xref:System.Net.HttpWebRequest>). Si le nom de domaine complet peut être résolu, les SPN suivants sont ajoutés :  
  
 `"HTTP/"` de plus, le nom d’hôte (le nom court).  
  
 `"HTTP/"` plus le nom de domaine complet pour le nom d’hôte.  
  
1.  Si le nom d’hôte ne contient pas de points (aucun domaine ou sous-domaines) et un nom de domaine complet ne peut pas être résolu, le SPN suivant est ajouté :  
  
 `"HTTP/"` de plus, le nom d’hôte.  
  
1.  Si le nom d’hôte contient des points (domaines ou sous-domaines), le SPN suivant est ajouté :  
  
 `"HTTP/"` de plus, le nom d’hôte.  
  
 Le <xref:System.Net.HttpListener.DefaultServiceNames%2A> propriété peut être utilisée par une application pour passer en revue la liste des noms principaux de service par défaut qui sera utilisé pour l’authentification si aucune liste personnalisée n’est fournie. Si d’autres SPN est nécessaires, une application peut ajouter à l’aide de la <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> méthodes.  
  
 Il n’est pas sécurisé lors de l’utilisation de la protection étendue pour prendre des décisions de stratégie selon l’URL demandée, car cela peut être usurpée. Au lieu de cela, les applications doivent s’appuyer sur le <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> ou <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> propriétés pour prendre ces décisions de stratégie.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <Member MemberName="EndGetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext EndGetContext(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetContext (asyncResult As IAsyncResult) As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ EndGetContext(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndGetContext : IAsyncResult -&gt; System.Net.HttpListenerContext" Usage="httpListener.EndGetContext asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Objet <see cref="T:System.IAsyncResult" /> qui a été obtenu au moment du démarrage de l'opération asynchrone.</param>
        <summary>Met fin à une opération asynchrone pour récupérer une demande du client entrante.</summary>
        <returns>Objet <see cref="T:System.Net.HttpListenerContext" /> qui représente la demande du client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpListener.EndGetContext%2A> méthode est appelée, généralement dans une méthode de rappel défini par l’application appelée par un délégué, pour obtenir le <xref:System.Net.HttpListenerContext> objet qui contient une demande entrante du client et sa réponse associée. Cette méthode termine une opération démarrée précédemment en appelant le <xref:System.Net.HttpListener.BeginGetContext%2A> (méthode). Si l’opération n’est pas terminée, cette méthode se bloque jusqu'à ce que c’est le cas.  
  
 Étant donné que l’appel le <xref:System.Net.HttpListener.EndGetContext%2A> méthode requiert le <xref:System.Net.HttpListener> de l’objet, cet objet est généralement passé dans une méthode de rappel par à l’aide de l’objet d’état passé dans le <xref:System.Net.HttpListener.BeginGetContext%2A> (méthode). Vous pouvez obtenir cet objet d’état à l’aide de la <xref:System.IAsyncResult.AsyncState%2A> propriété de la `asyncResult` objet.  
  
 Pour plus d’informations sur l’utilisation du modèle de programmation asynchrone, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
   
  
## Examples  
 L’exemple de code suivant montre l’implémentation d’une méthode de rappel qui appelle le <xref:System.Net.HttpListener.EndGetContext%2A> (méthode).  
  
 [!code-csharp[Net_Listener_Basic#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#13)]  
 [!code-vb[Net_Listener_Basic#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> n’a pas été obtenu en appelant le <see cref="M:System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)" /> (méthode).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Net.HttpListenerException">Un appel de fonction Win32 a échoué. Vérifiez la propriété <see cref="P:System.Net.HttpListenerException.ErrorCode" /> de l’exception pour déterminer la cause de l’exception.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="M:System.Net.HttpListener.EndGetContext(System.IAsyncResult)" /> méthode a déjà été appelée pour spécifié <paramref name="asyncResult" /> objet.</exception>
        <exception cref="T:System.ObjectDisposedException">Cet objet est fermé.</exception>
        <block subset="none" type="usage"><para>Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionPolicy">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionPolicy As ExtendedProtectionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ ExtendedProtectionPolicy { System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ get(); void set(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionPolicy : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy with get, set" Usage="System.Net.HttpListener.ExtendedProtectionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("not used anywhere in the implementation")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> à utiliser pour la protection étendue d’une session.</summary>
        <value><see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> qui spécifie la stratégie à utiliser pour la protection étendue.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> propriété est utilisée avec l’authentification Windows intégrée pour fournir une protection étendue. Le <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> propriété permet la configuration de la stratégie de protection étendue pour l’ensemble <xref:System.Net.HttpListener> session. Le <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> propriété permet la configuration de la stratégie de protection étendue pour chaque demande individuelle.  
  
 Le <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> propriété doit être `null`. Le <xref:System.Net.HttpListener> instance Obtient le jeton de liaison de canal (CBT) directement à partir de sa propre session TLS, le cas échéant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une tentative a été effectuée pour définir la <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> propriété, mais la <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> propriété n’a pas été <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Une tentative a été effectuée pour définir la <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> propriété <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour définir la <see cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" /> propriété après la <see cref="M:System.Net.HttpListener.Start" /> méthode a déjà été appelée.</exception>
        <exception cref="T:System.ObjectDisposedException">Cet objet est fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement" /> propriété a été définie sur <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> sur une plateforme qui ne prend pas en charge la protection étendue.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProtectionSelectorDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListener/ExtendedProtectionSelector ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ExtendedProtectionSelectorDelegate As HttpListener.ExtendedProtectionSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListener::ExtendedProtectionSelector ^ ExtendedProtectionSelectorDelegate { System::Net::HttpListener::ExtendedProtectionSelector ^ get(); void set(System::Net::HttpListener::ExtendedProtectionSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProtectionSelectorDelegate : System.Net.HttpListener.ExtendedProtectionSelector with get, set" Usage="System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListener+ExtendedProtectionSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le délégué appelé pour déterminer le <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> à utiliser pour chaque demande.</summary>
        <value><see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> qui spécifie la stratégie à utiliser pour la protection étendue.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> propriété est utilisée avec l’authentification Windows intégrée pour fournir une protection étendue. Le <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> propriété permet la configuration de la stratégie de protection étendue pour l’ensemble <xref:System.Net.HttpListener> session. Le <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A> propriété permet la configuration de la stratégie de protection étendue par demande individuelle.  
  
 Le <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> propriété doit être `null`. Le <xref:System.Net.HttpListener> instance Obtient le jeton de liaison de canal (CBT) directement à partir de sa propre session TLS, le cas échéant.  
  
 Pour chaque demande, le délégué peut choisir les paramètres qui le <xref:System.Net.HttpListener> instance utilisera pour fournir une protection étendue.  
  
 Si un délégué retourne `null` pour cette propriété, cela représente un <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy> qui le <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> propriété définie sur <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une tentative a été effectuée pour définir la <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> propriété, mais la <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> propriété doit être <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">Une tentative a été effectuée pour définir la <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> propriété <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour définir la <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> propriété après la <see cref="M:System.Net.HttpListener.Start" /> méthode a déjà été appelée.</exception>
        <exception cref="T:System.ObjectDisposedException">Cet objet est fermé.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Une tentative a été effectuée pour définir le <see cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" /> propriété sur une plateforme qui ne prend pas en charge la protection étendue.</exception>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Authentification Windows intégrée avec protection étendue</related>
      </Docs>
    </Member>
    <Member MemberName="GetContext">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerContext GetContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.HttpListenerContext GetContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContext () As HttpListenerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::HttpListenerContext ^ GetContext();" />
      <MemberSignature Language="F#" Value="member this.GetContext : unit -&gt; System.Net.HttpListenerContext" Usage="httpListener.GetContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attend une demande entrante et retourne les résultats quand elle est reçue.</summary>
        <returns>Objet <see cref="T:System.Net.HttpListenerContext" /> qui représente une demande du client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avant d’appeler cette méthode, vous devez appeler la <xref:System.Net.HttpListener.Start%2A> (méthode) et ajoutez au moins un préfixe URI à écouter en ajoutant les chaînes URI à la <xref:System.Net.HttpListenerPrefixCollection> retourné par la <xref:System.Net.HttpListener.Prefixes%2A> propriété. Pour obtenir une description détaillée des préfixes, consultez le <xref:System.Net.HttpListener> vue d’ensemble de la classe.  
  
 Cette méthode se bloque en attendant une demande entrante. Si vous souhaitez les demandes entrantes pour être traité en mode asynchrone (sur des threads séparés) afin que votre application ne bloque pas, utilisez le <xref:System.Net.HttpListener.BeginGetContext%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’appel de cette méthode.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Un appel de fonction Win32 a échoué. Vérifiez la propriété <see cref="P:System.Net.HttpListenerException.ErrorCode" /> de l’exception pour déterminer la cause de l’exception.</exception>
        <exception cref="T:System.InvalidOperationException">Cet objet n’a pas été démarré ou est actuellement arrêté.  
  
ou 
Le <see cref="T:System.Net.HttpListener" /> n’a pas pour répondre à tous les préfixes d’identificateur de ressource uniforme (URI).</exception>
        <exception cref="T:System.ObjectDisposedException">Cet objet est fermé.</exception>
        <block subset="none" type="usage"><para>Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetContextAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt; GetContextAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.HttpListenerContext&gt; GetContextAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.GetContextAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextAsync () As Task(Of HttpListenerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::HttpListenerContext ^&gt; ^ GetContextAsync();" />
      <MemberSignature Language="F#" Value="member this.GetContextAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;" Usage="httpListener.GetContextAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.HttpListenerContext&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attend une demande entrante en tant qu'opération asynchrone.</summary>
        <returns>Objet de tâche représentant l'opération asynchrone. La propriété <see cref="P:System.Threading.Tasks.Task`1.Result" /> sur l’objet de tâche retourne un objet <see cref="T:System.Net.HttpListenerContext" /> qui représente une demande client.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette opération ne bloque pas. Retourné <xref:System.Threading.Tasks.Task%601> objet se termine lorsque la demande entrante a été reçue.  
  
 Avant d’appeler cette méthode, vous devez appeler la <xref:System.Net.HttpListener.Start%2A> (méthode) et ajoutez au moins un préfixe URI à écouter en ajoutant les chaînes URI à la <xref:System.Net.HttpListenerPrefixCollection> retourné par la <xref:System.Net.HttpListener.Prefixes%2A> propriété. Pour obtenir une description détaillée des préfixes, consultez le <xref:System.Net.HttpListener> vue d’ensemble de la classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListenerContext" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreWriteExceptions">
      <MemberSignature Language="C#" Value="public bool IgnoreWriteExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreWriteExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreWriteExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreWriteExceptions { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreWriteExceptions : bool with get, set" Usage="System.Net.HttpListener.IgnoreWriteExceptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> spécifiant si votre application reçoit des exceptions qui se produisent quand <see cref="T:System.Net.HttpListener" /> envoie la réponse au client.</summary>
        <value><see langword="true" /> Si cette <see cref="T:System.Net.HttpListener" /> ne doit pas retourner les exceptions qui se produisent lors de l’envoi de la réponse au client ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez cette propriété sur `true` si votre application ne requiert pas qu’une réponse est envoyée avec succès à chaque client.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir cette propriété.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
 [!code-vb[Net_Listener_Basic#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsListening">
      <MemberSignature Language="C#" Value="public bool IsListening { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsListening" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsListening" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsListening As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsListening { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsListening : bool" Usage="System.Net.HttpListener.IsListening" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.Net.HttpListener" /> a été démarré.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.HttpListener" /> a été démarré ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour démarrer un <xref:System.Net.HttpListener>, appelez le <xref:System.Net.HttpListener.Start%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de cette propriété pour déterminer l’état d’écoute d’une instance.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupported">
      <MemberSignature Language="C#" Value="public static bool IsSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsSupported" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.IsSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsSupported { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSupported : bool" Usage="System.Net.HttpListener.IsSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.Net.HttpListener" /> peut être utilisé avec le système d'exploitation actuel.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.HttpListener" /> est pris en charge ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette classe est disponible uniquement sur les ordinateurs exécutant les systèmes d’exploitation Windows XP SP2 ou Windows Server 2003.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Net.HttpListener.IsSupported%2A> propriété pour détecter si un <xref:System.Net.HttpListener> objet peut être utilisé avec le système d’exploitation actuel.  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
 [!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixes">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerPrefixCollection Prefixes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerPrefixCollection Prefixes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Prefixes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Prefixes As HttpListenerPrefixCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerPrefixCollection ^ Prefixes { System::Net::HttpListenerPrefixCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefixes : System.Net.HttpListenerPrefixCollection" Usage="System.Net.HttpListener.Prefixes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerPrefixCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les préfixes URI (Uniform Resource Identifier) gérés par cet objet <see cref="T:System.Net.HttpListener" />.</summary>
        <value><see cref="T:System.Net.HttpListenerPrefixCollection" /> contenant les préfixes URI que cet objet <see cref="T:System.Net.HttpListener" /> est configuré pour gérer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les préfixes sont au format canonique. Pour obtenir une description détaillée des préfixes, consultez le <xref:System.Net.HttpListener> vue d’ensemble de la classe.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Net.HttpListener.Prefixes%2A> propriété pour obtenir et imprimer les préfixes URI qui sont gérés.  
  
 [!code-csharp[Net_Listener_Basic#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#1)]  
 [!code-vb[Net_Listener_Basic#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Realm">
      <MemberSignature Language="C#" Value="public string Realm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Realm" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.Realm" />
      <MemberSignature Language="VB.NET" Value="Public Property Realm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Realm { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Realm : string with get, set" Usage="System.Net.HttpListener.Realm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le domaine, ou partition de ressource, associé à cet objet <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Valeur <see cref="T:System.String" /> contenant le nom du domaine associé à l'objet <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les serveurs utilisent des domaines pour partitionner les ressources protégées ; chaque partition peut posséder sa propre base de données d’authentification schéma et/ou l’autorisation. Les domaines sont utilisés uniquement pour les authentifications Digest et de base. Lorsqu'un client est correctement authentifié, l'authentification est valide pour toutes les ressources contenues dans un domaine donné. Pour obtenir une description détaillée des domaines, consultez la RFC 2617 à [ https://www.ietf.org/ ](https://www.ietf.org/).  
  
 Une instance de <xref:System.Net.HttpListener> qu’un seul domaine est associé à.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir le <xref:System.Net.HttpListener.Realm%2A> propriété.  
  
 [!code-csharp[Net_Listener_Basic#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#10)]  
 [!code-vb[Net_Listener_Basic#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="httpListener.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permet à cette instance de recevoir des demandes entrantes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode doit être appelée avant d’appeler le <xref:System.Net.HttpListener.GetContext%2A> ou <xref:System.Net.HttpListener.BeginGetContext%2A> (méthode).  
  
 Une fois que vous avez démarré un <xref:System.Net.HttpListener> de l’objet, vous pouvez utiliser la <xref:System.Net.HttpListener.Stop%2A> méthode pour l’arrêter.  
  
> [!NOTE]
>  Si cette instance de l’écouteur utilise le protocole https, vous devez installer et sélectionner un certificat de serveur. Sinon, un <xref:System.Net.HttpWebRequest> requête de ce <xref:System.Net.HttpListener> échouera avec une fin inattendue de la connexion. Vous pouvez configurer des certificats de serveur et d’autres options d’écouteur à l’aide de HttpCfg.exe. Consultez [ http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp ](https://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) pour plus d’informations.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Net.HttpListener.Start%2A> méthode commence à traiter les demandes entrantes.  
  
 [!code-csharp[Net_Listener_Basic#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#12)]  
 [!code-vb[Net_Listener_Basic#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.HttpListenerException">Un appel de fonction Win32 a échoué. Vérifiez la propriété <see cref="P:System.Net.HttpListenerException.ErrorCode" /> de l’exception pour déterminer la cause de l’exception.</exception>
        <exception cref="T:System.ObjectDisposedException">Cet objet est fermé.</exception>
        <block subset="none" type="usage"><para>Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="httpListener.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entraîne l'arrêt de la réception des demandes entrantes par cette instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette instance est déjà arrêtée, l’appel de cette méthode n’a aucun effet.  
  
 Après avoir arrêté un <xref:System.Net.HttpListener> de l’objet, vous pouvez utiliser la <xref:System.Net.HttpListener.Start%2A> méthode pour le redémarrer.  
  
   
  
## Examples  
 
L’exemple de code suivant montre comment utiliser le <xref:System.Net.HttpListener.Stop%2A> méthode pour arrêter le traitement des demandes entrantes.  
 
[!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
[!code-vb[Net_Listener_Basic#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
        <block subset="none" type="usage"><para>Ce membre génère des informations de traçage lorsque vous activez le traçage réseau dans votre application. Pour plus d’informations, consultez [le traçage réseau dans le .NET Framework](~/docs/framework/network-programming/network-tracing.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListener.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources détenues par cet objet <see cref="T:System.Net.HttpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les applications doivent utiliser le <xref:System.Net.HttpListener.Close%2A> méthode au lieu d’appeler cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeoutManager">
      <MemberSignature Language="C#" Value="public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpListenerTimeoutManager TimeoutManager" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.TimeoutManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeoutManager As HttpListenerTimeoutManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpListenerTimeoutManager ^ TimeoutManager { System::Net::HttpListenerTimeoutManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TimeoutManager : System.Net.HttpListenerTimeoutManager" Usage="System.Net.HttpListener.TimeoutManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.HttpListenerTimeoutManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gestionnaire de délai d'attente pour cette instance <see cref="T:System.Net.HttpListener" />.</summary>
        <value>Gestionnaire de délai d'attente pour cette instance <see cref="T:System.Net.HttpListener" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le Gestionnaire de délai d’expiration définit les limites de délai d’expiration de connexion pour ce <xref:System.Net.HttpListener> instance.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeConnectionNtlmAuthentication">
      <MemberSignature Language="C#" Value="public bool UnsafeConnectionNtlmAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeConnectionNtlmAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeConnectionNtlmAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeConnectionNtlmAuthentication : bool with get, set" Usage="System.Net.HttpListener.UnsafeConnectionNtlmAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Support for NTLM needs some loving.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur <see cref="T:System.Boolean" /> qui contrôle si, quand NTLM est utilisé, les demandes supplémentaires utilisant la même connexion TCP (Transmission Control Protocol) doivent être authentifiées.</summary>
        <value><see langword="true" /> si le <see cref="T:System.Security.Principal.IIdentity" /> de la première demande doit être utilisé pour les demandes suivantes sur la même connexion ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette propriété a la valeur `true` et la première demande sur une connexion TCP particulière est authentifiée à l’aide de NTLM, les demandes suivantes sur la même connexion TCP sont traitées en utilisant les informations d’authentification (<xref:System.Security.Principal.IIdentity>) de l’initial demande.  
  
 Cette propriété n'a aucun effet si NTLM n'est pas le protocole d'authentification utilisé. Lors de la négociation est spécifiée comme protocole d’authentification, cette propriété a un effet uniquement si NTLM est le protocole utilisé pour l’authentification.  
  
> [!NOTE]
>  Lors de la définition de cette propriété `true` augmente les performances, car le <xref:System.Net.HttpListener> ne pas envoyer d’authentification NTLM supplémentaire, il existe un risque de sécurité dans toutes les demandes pour fournir des informations d’authentification ne nécessitant ne pas. Vous devez déterminer si l'augmentation des performances vaut la peine de prendre ce risque.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir cette propriété.  
  
 [!code-csharp[Net_Listener_Basic#14](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#14)]  
 [!code-vb[Net_Listener_Basic#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Net_Listener_Basic/VB/test.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’objet a été fermé.</exception>
      </Docs>
    </Member>
  </Members>
</Type>