<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="01c2bfbb26271c13d89c83d143adcc2437859adc" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48711143" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type FileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit un élément <see cref="T:System.IO.Stream" /> pour un fichier, prenant en charge les opérations en lecture et en écriture aussi bien synchrones qu'asynchrones.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.IO.FileStream> classe pour lire, écrire, ouvrir et fermer des fichiers sur un système de fichiers et pour manipuler d’autres handles liées aux fichiers le système d’exploitation, y compris les canaux, d’entrée standard et de sortie standard. Vous pouvez utiliser la <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.Stream.CopyTo%2A>, et <xref:System.IO.FileStream.Flush%2A> méthodes pour effectuer des opérations synchrones, ou le <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, et <xref:System.IO.FileStream.FlushAsync%2A> méthodes pour effectuer des asynchrone opérations. Utiliser les méthodes asynchrones pour effectuer des opérations gourmandes en ressources de fichier sans bloquer le thread principal. Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas. <xref:System.IO.FileStream> mémoires tampons d’entrée et sortie pour de meilleures performances.  
  
> [!IMPORTANT]
>  Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez supprimer il directement ou indirectement. Pour supprimer le type directement, appelez sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.  
  
 Le <xref:System.IO.FileStream.IsAsync%2A> propriété détecte si le handle de fichier a été ouvert de façon asynchrone. Vous spécifiez cette valeur lorsque vous créez une instance de la <xref:System.IO.FileStream> classe à l’aide d’un constructeur ayant un `isAsync`, `useAsync`, ou `options` paramètre. Lorsque la propriété est `true`, le flux de données utilise des e/s avec chevauchement pour effectuer des opérations de fichier de façon asynchrone. Toutefois, le <xref:System.IO.FileStream.IsAsync%2A> propriété ne doit pas être `true` pour appeler le <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, ou <xref:System.IO.Stream.CopyToAsync%2A> (méthode). Lorsque le <xref:System.IO.FileStream.IsAsync%2A> propriété est `false` et vous appelez la lecture asynchrone et les opérations d’écriture, le thread d’interface utilisateur n’est toujours pas bloquée, mais l’opération d’e/s proprement dite est effectuée de façon synchrone.  
  
 Le <xref:System.IO.FileStream.Seek%2A> méthode prend en charge l’accès aléatoire aux fichiers. <xref:System.IO.FileStream.Seek%2A> permet à la position de lecture/écriture à déplacer vers n’importe quelle position dans le fichier. Pour cela, avec des paramètres de point de référence de décalage octets. Est de l’offset d’octet par rapport au point de référence de recherche, qui peut être le début, la position actuelle ou la fin du fichier sous-jacent, tel que représenté par trois membres de le <xref:System.IO.SeekOrigin> énumération.  
  
> [!NOTE]
>  Fichiers de disque prennent toujours en charge l’accès aléatoire. Au moment de la construction, le <xref:System.IO.FileStream.CanSeek%2A> propriété a la valeur `true` ou `false` selon le type de fichier sous-jacent. Si le type de fichier sous-jacent est FILE_TYPE_DISK, tel que défini dans winbase.h, la <xref:System.IO.FileStream.CanSeek%2A> valeur de propriété est `true`. Sinon, le <xref:System.IO.FileStream.CanSeek%2A> valeur de propriété est `false`.  
  
 Si un processus se termine avec une partie d’un fichier verrouillé ou ferme un fichier qui a des verrous en attente, le comportement est indéfini.  
  
 Pour les opérations d’annuaire et d’autres opérations de fichier, consultez le <xref:System.IO.File>, <xref:System.IO.Directory>, et <xref:System.IO.Path> classes. Le <xref:System.IO.File> classe est une classe utilitaire qui a des méthodes statiques principalement pour la création de <xref:System.IO.FileStream> objets basés sur les chemins d’accès de fichier. Le <xref:System.IO.MemoryStream> classe crée un flux à partir d’un tableau d’octets et est semblable à la <xref:System.IO.FileStream> classe.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
## <a name="detection-of-stream-position-changes"></a>Détection des changements de Position Stream  
 Quand un <xref:System.IO.FileStream> objet n’a pas le maintien exclusif de son handle, un autre thread peut accéder simultanément au handle de fichier et modifier la position du pointeur de fichier du système d’exploitation qui est associé au handle de fichier. Dans ce cas, la position mise en cache dans le <xref:System.IO.FileStream> objet et les données mises en cache dans la mémoire tampon peuvent être compromises. Le <xref:System.IO.FileStream> objet effectue régulièrement des contrôles sur les méthodes qui accèdent à la mémoire tampon de mise en cache pour vous assurer que la position du handle du système d’exploitation est identique à la position mise en cache utilisée par le <xref:System.IO.FileStream> objet.  
  
 Si une modification inattendue dans la position du handle est détectée dans un appel à la <xref:System.IO.FileStream.Read%2A> (méthode), le .NET Framework ignore le contenu de la mémoire tampon et relit le flux de données à partir du fichier. Cela peut affecter les performances, selon la taille du fichier et tous les autres processus susceptibles d’affecter la position du flux de fichier.  
  
 Si une modification inattendue dans la position du handle est détectée dans un appel à la <xref:System.IO.FileStream.Write%2A> (méthode), le contenu de la mémoire tampon sont ignorées et un <xref:System.IO.IOException> exception est levée.  
  
 A <xref:System.IO.FileStream> objet n’aura pas maintien exclusif de son handle lorsque soit la <xref:System.IO.FileStream.SafeFileHandle%2A> propriété est accessible pour exposer le handle ou <xref:System.IO.FileStream> objet se voit attribuer le <xref:System.IO.FileStream.SafeFileHandle%2A> propriété dans son constructeur.  
  
   
  
## Examples  
 L’exemple suivant illustre certaines de la <xref:System.IO.FileStream> constructeurs.  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 L’exemple suivant montre comment écrire dans un fichier de façon asynchrone. Ce code s’exécute dans une application WPF qui a un TextBlock nommé UserInput et un bouton rattachée à un gestionnaire d’événements Click nommé Button_Click. Le chemin d’accès du fichier doit être remplacé par un fichier qui existe sur l’ordinateur.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
    <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Handle de fichier pour le fichier que l'objet <see langword="FileStream" /> actuel doit encapsuler.</param>
        <param name="access">Constante qui définit les propriétés <see cref="P:System.IO.FileStream.CanRead" /> et <see cref="P:System.IO.FileStream.CanWrite" /> de l'objet <see langword="FileStream" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" /> pour le handle de fichier spécifié, avec l'autorisation d'accès en lecture/écriture spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.IO.Stream.Close%2A> est appelée, le handle est également fermé et le nombre de handles du fichier est décrémenté.  
  
 `FileStream` suppose qu’il a un contrôle exclusif sur le handle. Lecture, écriture ou qui recherchent tout un `FileStream` détient également un handle peut entraîner une corruption des données. Pour la sécurité des données, appelez <xref:System.IO.FileStream.Flush%2A> avant d’utiliser le handle et évitez d’appeler des méthodes autres que `Close` après avoir effectué à l’aide de la poignée.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 `FileShare.Read` est la valeur par défaut pour ceux <xref:System.IO.FileStream> constructeurs sans un `FileShare` paramètre.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> n’est pas un champ de <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S, telle qu’une erreur disque, s’est produite.  
  
- ou - 
Le flux a été fermé.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <paramref name="access" /> demandé n’est pas autorisé par le système d’exploitation pour le handle de fichier spécifié, par exemple quand <paramref name="access" /> a la valeur <see langword="Write" /> ou <see langword="ReadWrite" /> et que le handle de fichier est défini pour un accès en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture, écriture et ajout de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Handle de fichier pour le fichier que l'objet <see langword="FileStream" /> actuel doit encapsuler.</param>
        <param name="access">Constante qui définit les propriétés <see cref="P:System.IO.FileStream.CanRead" /> et <see cref="P:System.IO.FileStream.CanWrite" /> de l'objet <see langword="FileStream" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" /> pour le handle de fichier spécifié, avec l'autorisation d'accès en lecture/écriture spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.IO.Stream.Close%2A> est appelée, le handle est également fermé et le nombre de handles du fichier est décrémenté.  
  
 `FileStream` suppose qu’il a un contrôle exclusif sur le handle. Lecture, écriture ou qui recherchent tout un `FileStream` détient également un handle peut entraîner une corruption des données. Pour la sécurité des données, appelez <xref:System.IO.FileStream.Flush%2A> avant d’utiliser le handle et évitez d’appeler des méthodes autres que `Close` après avoir effectué à l’aide de la poignée.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 `FileShare.Read` est la valeur par défaut pour ceux <xref:System.IO.FileStream> constructeurs sans un `FileShare` paramètre.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> n’est pas un champ de <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S, telle qu’une erreur disque, s’est produite.  
  
- ou - 
Le flux a été fermé.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <paramref name="access" /> demandé n’est pas autorisé par le système d’exploitation pour le handle de fichier spécifié, par exemple quand <paramref name="access" /> a la valeur <see langword="Write" /> ou <see langword="ReadWrite" /> et que le handle de fichier est défini pour un accès en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture, écriture et ajout de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès relatif ou absolu pour le fichier que l'objet <see langword="FileStream" /> actuel doit encapsuler.</param>
        <param name="mode">Constante qui détermine le mode d'ouverture ou de création du fichier.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" /> avec le chemin d'accès et le mode de création spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le .NET Framework ne prend pas en charge l’accès direct aux disques physiques via les chemins d’accès qui sont des noms de périphériques, tels que «\\\\. \PHYSICALDRIVE0 ».  
  
 Le `path` paramètre peut être un nom de fichier, y compris un fichier sur un partage UNC Universal Naming Convention ().  
  
 Le constructeur dispose d’un accès en lecture/écriture au fichier, et il est ouvert en partageant l’accès en lecture (autrement dit, les demandes d’ouverture du fichier pour écriture par ce processus ou un autre processus échoueront jusqu'à ce que le `FileStream` objet a été fermé, mais sera d’essais de lecture réussisse).  
  
 Vous ne pouvez pas utiliser ce constructeur pour ouvrir des fichiers en lecture seule ; au lieu de cela, vous devez utiliser un constructeur qui accepte un `FileAccess` paramètre avec la valeur est définie sur `FileAccess.Read`.  
  
 La taille de mémoire tampon est définie à la taille par défaut de 4 096 octets (4 Ko).  
  
> [!NOTE]
>  `path` n’est pas obligatoire pour être un fichier stocké sur le disque ; Il peut être n’importe quelle partie d’un système qui prend en charge l’accès via des flux. Par exemple, selon le système, cette classe peut accéder à un appareil physique.  
  
 <xref:System.IO.Stream.CanSeek%2A> est `true` pour toutes les <xref:System.IO.FileStream> les objets qui encapsulent des fichiers. Si `path` indique un appareil qui ne prend pas en charge la recherche, le <xref:System.IO.FileStream.CanSeek%2A> propriété résultant <xref:System.IO.FileStream> est `false`. Pour plus d'informations, consultez <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` est la valeur par défaut pour ceux <xref:System.IO.FileStream> constructeurs sans un `FileShare` paramètre.  
  
 Pour les constructeurs sans un <xref:System.IO.FileAccess> paramètre, si le `mode` paramètre est défini sur <xref:System.IO.FileMode.Append>, <xref:System.IO.FileAccess.Write> est l’accès par défaut. Sinon, l’accès est défini sur <xref:System.IO.FileAccess.ReadWrite>.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment écrire des données dans un fichier, octet par octet et vérifiez que les données ont été écrites correctement.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> est une chaîne vide (""), contient seulement un espace blanc ou contient un ou plusieurs caractères non valides.  
  
- ou - 
 <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement autre que NTFS.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier est introuvable, comme quand <paramref name="mode" /> a pour valeur <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" />, et que le fichier spécifié par <paramref name="path" /> n’existe pas. Le fichier doit déjà exister dans ces modes.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite, par exemple la spécification de <see langword="FileMode.CreateNew" /> quand le fichier spécifié par <paramref name="path" /> existe déjà.  
  
- ou - 
Le flux a été fermé.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide, par exemple si l’emplacement est un lecteur non mappé.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contient une valeur non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture, écriture et ajout de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Handle de fichier pour le fichier que l'objet <see langword="FileStream" /> actuel doit encapsuler.</param>
        <param name="access">Constante <see cref="T:System.IO.FileAccess" /> qui définit les propriétés <see cref="P:System.IO.FileStream.CanRead" /> et <see cref="P:System.IO.FileStream.CanWrite" /> de l'objet <see langword="FileStream" />.</param>
        <param name="bufferSize">Valeur <see cref="T:System.Int32" /> positive supérieure à 0 indiquant la taille de la mémoire tampon. La taille par défaut de la mémoire tampon est 4096.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" /> pour le handle de fichier spécifié, avec l'autorisation d'accès en lecture/écriture et la taille de mémoire tampon spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` suppose qu’il a un contrôle exclusif sur le handle. Lecture, écriture ou qui recherchent tout un `FileStream` détient également un handle peut entraîner une corruption des données. Pour la sécurité des données, appelez <xref:System.IO.FileStream.Flush%2A> avant d’utiliser le handle et évitez d’appeler des méthodes autres que `Close` après avoir effectué à l’aide de la poignée. Vous pouvez également lire et écrire au handle avant d’appeler ce `FileStream` constructeur.  
  
 `FileShare.Read` est la valeur par défaut pour ceux <xref:System.IO.FileStream> constructeurs sans un `FileShare` paramètre.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="handle" /> est un handle non valide.  
  
- ou - 
Le paramètre <paramref name="handle" /> est un handle synchrone et il a été utilisé de façon asynchrone.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="bufferSize" /> est négatif.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S, telle qu’une erreur disque, s’est produite.  
  
- ou - 
Le flux a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <paramref name="access" /> demandé n’est pas autorisé par le système d’exploitation pour le handle de fichier spécifié, par exemple quand <paramref name="access" /> a la valeur <see langword="Write" /> ou <see langword="ReadWrite" /> et que le handle de fichier est défini pour un accès en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture, écriture et ajout de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Énumérations associées : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Handle de fichier pour le fichier que l'objet <see langword="FileStream" /> actuel doit encapsuler.</param>
        <param name="access">Constante qui définit les propriétés <see cref="P:System.IO.FileStream.CanRead" /> et <see cref="P:System.IO.FileStream.CanWrite" /> de l'objet <see langword="FileStream" />.</param>
        <param name="ownsHandle">
          <see langword="true" /> si le handle de fichier appartient à cette instance de <see langword="FileStream" /> ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" /> pour le handle de fichier spécifié, avec l'autorisation d'accès en lecture/écriture et la propriété d'instance <see langword="FileStream" /> spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `FileStream` objet se voit attribuer l’accès spécifié au fichier. La propriété du handle sera comme spécifié. Si ce processus détient le handle, un appel à la <xref:System.IO.Stream.Close%2A> méthode fermera également le handle et nombre de handles du fichier est décrémenté. Le `FileStream` objet se voit attribuer la taille du tampon par défaut de 4 096 octets.  
  
 `FileStream` suppose qu’il a un contrôle exclusif sur le handle. Lecture, écriture ou qui recherchent tout un `FileStream` détient également un handle peut entraîner une corruption des données. Pour la sécurité des données, appelez <xref:System.IO.FileStream.Flush%2A> avant d’utiliser le handle et évitez d’appeler des méthodes autres que `Close` après avoir effectué à l’aide de la poignée.  
  
 `FileShare.Read` est la valeur par défaut pour ceux <xref:System.IO.FileStream> constructeurs sans un `FileShare` paramètre.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> n’est pas un champ de <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S, telle qu’une erreur disque, s’est produite.  
  
- ou - 
Le flux a été fermé.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <paramref name="access" /> demandé n’est pas autorisé par le système d’exploitation pour le handle de fichier spécifié, par exemple quand <paramref name="access" /> a la valeur <see langword="Write" /> ou <see langword="ReadWrite" /> et que le handle de fichier est défini pour un accès en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture, écriture et ajout de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès relatif ou absolu pour le fichier que l'objet <see langword="FileStream" /> actuel doit encapsuler.</param>
        <param name="mode">Constante qui détermine le mode d'ouverture ou de création du fichier.</param>
        <param name="access">Constante qui détermine le mode d'accès au fichier par l'objet <see langword="FileStream" />. Détermine aussi les valeurs retournées par les propriétés <see cref="P:System.IO.FileStream.CanRead" /> et <see cref="P:System.IO.FileStream.CanWrite" /> de l'objet <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> a la valeur <see langword="true" /> si <c>path</c> spécifie un fichier sur disque.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" /> avec le chemin d'accès, le mode de création et les autorisations de lecture/écriture spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le .NET Framework ne prend pas en charge l’accès direct aux disques physiques via les chemins d’accès qui sont des noms de périphériques, tels que «\\\\. \PHYSICALDRIVE0 ».  
  
 Le `path` paramètre peut être un nom de fichier, y compris un fichier sur un partage UNC Universal Naming Convention ().  
  
 Le constructeur dispose d’un accès en lecture/écriture au fichier, et il est ouvert en partageant l’accès en lecture (autrement dit, les demandes d’ouverture du fichier pour écriture par ce processus ou un autre processus échoueront jusqu'à ce que le `FileStream` objet a été fermé, mais sera d’essais de lecture réussisse). La taille de mémoire tampon est définie à la taille par défaut de 4 096 octets (4 Ko).  
  
> [!NOTE]
>  `path` n’est pas obligatoire pour être un fichier stocké sur le disque ; Il peut être n’importe quelle partie d’un système qui prend en charge l’accès via des flux. Par exemple, selon le système, cette classe peut accéder à un appareil physique.  
  
 <xref:System.IO.Stream.CanSeek%2A> est `true` pour toutes les <xref:System.IO.FileStream> les objets qui encapsulent des fichiers. Si `path` indique un appareil qui ne prend pas en charge la recherche, le <xref:System.IO.FileStream.CanSeek%2A> propriété résultant <xref:System.IO.FileStream> est `false`. Pour plus d'informations, consultez <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` est la valeur par défaut pour ceux <xref:System.IO.FileStream> constructeurs sans un `FileShare` paramètre.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> est une chaîne vide (""), contient seulement un espace blanc ou contient un ou plusieurs caractères non valides.  
  
- ou - 
 <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement autre que NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier est introuvable, comme quand <paramref name="mode" /> a pour valeur <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" />, et que le fichier spécifié par <paramref name="path" /> n’existe pas. Le fichier doit déjà exister dans ces modes.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite, par exemple la spécification de <see langword="FileMode.CreateNew" /> quand le fichier spécifié par <paramref name="path" /> existe déjà.  
  
- ou - 
Le flux a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide ; il est, par exemple, sur un lecteur non mappé.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <paramref name="access" /> demandé n’est pas autorisé par le système d’exploitation pour le <paramref name="path" /> spécifié, par exemple quand <paramref name="access" /> a la valeur <see langword="Write" /> ou <see langword="ReadWrite" /> et que le fichier ou le répertoire est défini pour un accès en lecture seule.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contient une valeur non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture, écriture et ajout de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Handle de fichier pour le fichier que cet objet <see langword="FileStream" /> encapsulera.</param>
        <param name="access">Constante qui définit les propriétés <see cref="P:System.IO.FileStream.CanRead" /> et <see cref="P:System.IO.FileStream.CanWrite" /> de l'objet <see langword="FileStream" />.</param>
        <param name="bufferSize">Valeur <see cref="T:System.Int32" /> positive supérieure à 0 indiquant la taille de la mémoire tampon. La taille par défaut de la mémoire tampon est 4096.</param>
        <param name="isAsync">
          <see langword="true" /> si le handle a été ouvert de façon asynchrone (c'est-à-dire en mode E/S avec chevauchement) ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" /> pour le handle de fichier spécifié, avec l'autorisation d'accès en lecture/écriture, la taille de mémoire tampon et l'état synchrone ou asynchrone spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous définissez le `isAsync` paramètre `true` pour ouvrir le handle de fichier de façon asynchrone. Lorsque le paramètre est `true`, le flux de données utilise des e/s avec chevauchement pour effectuer des opérations de fichier de façon asynchrone. Toutefois, le paramètre ne devra pas être `true` pour appeler le <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, ou <xref:System.IO.Stream.CopyToAsync%2A> (méthode). Lorsque le `isAsync` paramètre est `false` et vous appelez la lecture asynchrone et les opérations d’écriture, le thread d’interface utilisateur n’est toujours pas bloquée, mais l’opération d’e/s proprement dite est effectuée de façon synchrone.  
  
 `FileStream` suppose qu’il a un contrôle exclusif sur le handle. Lecture, écriture ou qui recherchent tout un `FileStream` détient également un handle peut entraîner une corruption des données. Pour la sécurité des données, appelez <xref:System.IO.FileStream.Flush%2A> avant d’utiliser le handle et évitez d’appeler des méthodes autres que `Close` après avoir effectué à l’aide de la poignée. Vous pouvez également lire et écrire au handle avant d’appeler ce `FileStream` constructeur.  
  
 `FileShare.Read` est la valeur par défaut pour ceux <xref:System.IO.FileStream> constructeurs sans un `FileShare` paramètre.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="handle" /> est un handle non valide.  
  
- ou - 
Le paramètre <paramref name="handle" /> est un handle synchrone et il a été utilisé de façon asynchrone.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="bufferSize" /> est négatif.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S, telle qu’une erreur disque, s’est produite.  
  
- ou - 
Le flux a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <paramref name="access" /> demandé n’est pas autorisé par le système d’exploitation pour le handle de fichier spécifié, par exemple quand <paramref name="access" /> a la valeur <see langword="Write" /> ou <see langword="ReadWrite" /> et que le handle de fichier est défini pour un accès en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture, écriture et ajout de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé. Énumérations associées : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Handle de fichier pour le fichier que cet objet <see langword="FileStream" /> encapsulera.</param>
        <param name="access">Constante qui définit les propriétés <see cref="P:System.IO.FileStream.CanRead" /> et <see cref="P:System.IO.FileStream.CanWrite" /> de l'objet <see langword="FileStream" />.</param>
        <param name="ownsHandle">
          <see langword="true" /> si le handle de fichier appartient à cette instance de <see langword="FileStream" /> ; sinon, <see langword="false" />.</param>
        <param name="bufferSize">Valeur <see cref="T:System.Int32" /> positive supérieure à 0 indiquant la taille de la mémoire tampon. La taille par défaut de la mémoire tampon est 4096.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" /> pour le handle de fichier spécifié, avec l'autorisation d'accès en lecture/écriture, la propriété de l'instance <see langword="FileStream" /> et la taille de mémoire tampon spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `FileStream` objet se voit attribuer l’accès spécifié au fichier. La propriété du handle sera comme spécifié. Si cette `FileStream` détient le handle, un appel à la <xref:System.IO.Stream.Close%2A> méthode fermera également le handle. En particulier, le nombre de handles du fichier est décrémenté. Le `FileStream` objet se voit attribuer la taille de mémoire tampon spécifiée.  
  
 `FileStream` suppose qu’il a un contrôle exclusif sur le handle. Lecture, écriture ou qui recherchent tout un `FileStream` détient également un handle peut entraîner une corruption des données. Pour la sécurité des données, appelez <xref:System.IO.FileStream.Flush%2A> avant d’utiliser le handle et évitez d’appeler des méthodes autres que `Close` après avoir effectué à l’aide de la poignée. Vous pouvez également lire et écrire au handle avant d’appeler ce `FileStream` constructeur.  
  
 `FileShare.Read` est la valeur par défaut pour ceux <xref:System.IO.FileStream> constructeurs sans un `FileShare` paramètre.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> est un nombre négatif.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S, telle qu’une erreur de disque, s’est produite.  
  
- ou - 
Le flux a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <paramref name="access" /> demandé n’est pas autorisé par le système d’exploitation pour le handle de fichier spécifié, par exemple quand <paramref name="access" /> a la valeur <see langword="Write" /> ou <see langword="ReadWrite" /> et que le handle de fichier est défini pour un accès en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture, écriture et ajout de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès relatif ou absolu pour le fichier que l'objet <see langword="FileStream" /> actuel doit encapsuler.</param>
        <param name="mode">Constante qui détermine le mode d'ouverture ou de création du fichier.</param>
        <param name="access">Constante qui détermine le mode d'accès au fichier par l'objet <see langword="FileStream" />. Détermine aussi les valeurs retournées par les propriétés <see cref="P:System.IO.FileStream.CanRead" /> et <see cref="P:System.IO.FileStream.CanWrite" /> de l'objet <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> a la valeur <see langword="true" /> si <c>path</c> spécifie un fichier sur disque.</param>
        <param name="share">Constante qui détermine le mode de partage du fichier par des processus.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" /> avec le chemin d'accès, le mode de création, l'autorisation de lecture/écriture et l'autorisation de partage spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le .NET Framework ne prend pas en charge l’accès direct aux disques physiques via les chemins d’accès qui sont des noms de périphériques, tels que «\\\\. \PHYSICALDRIVE0 ».  
  
 Le `path` paramètre peut être un nom de fichier, y compris un fichier sur un partage UNC Universal Naming Convention ().  
  
 Le constructeur dispose d’un accès en lecture/écriture au fichier, et il est ouvert en partageant l’accès en lecture (autrement dit, les demandes d’ouverture du fichier pour écriture par ce processus ou un autre processus échoueront jusqu'à ce que le `FileStream` objet a été fermé, mais sera d’essais de lecture réussisse). La taille de mémoire tampon est définie à la taille par défaut de 4 096 octets (4 Ko).  
  
> [!NOTE]
>  `path` n’est pas obligatoire pour être un fichier stocké sur le disque ; Il peut être n’importe quelle partie d’un système qui prend en charge l’accès via des flux. Par exemple, selon le système, cette classe peut accéder à un appareil physique.  
  
 <xref:System.IO.Stream.CanSeek%2A> est `true` pour toutes les <xref:System.IO.FileStream> les objets qui encapsulent des fichiers. Si `path` indique un appareil qui ne prend pas en charge la recherche, le <xref:System.IO.FileStream.CanSeek%2A> propriété résultant <xref:System.IO.FileStream> est `false`. Pour plus d'informations, consultez <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.IO.FileStream.Lock%2A> (méthode).  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> est une chaîne vide (""), contient seulement un espace blanc ou contient un ou plusieurs caractères non valides.  
  
- ou - 
 <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement autre que NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier est introuvable, comme quand <paramref name="mode" /> a pour valeur <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" />, et que le fichier spécifié par <paramref name="path" /> n’existe pas. Le fichier doit déjà exister dans ces modes.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite, par exemple la spécification de <see langword="FileMode.CreateNew" /> quand le fichier spécifié par <paramref name="path" /> existe déjà.  
  
- ou - 
Le système exécute Windows 98 ou Windows 98 Deuxième Édition et <paramref name="share" /> a pour valeur <see langword="FileShare.Delete" />.  
  
- ou - 
Le flux a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide ; il est, par exemple, sur un lecteur non mappé.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <paramref name="access" /> demandé n’est pas autorisé par le système d’exploitation pour le <paramref name="path" /> spécifié, par exemple quand <paramref name="access" /> a la valeur <see langword="Write" /> ou <see langword="ReadWrite" /> et que le fichier ou le répertoire est défini pour un accès en lecture seule.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contient une valeur non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture, écriture et ajout de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Handle de fichier pour le fichier que cet objet <see langword="FileStream" /> encapsulera.</param>
        <param name="access">Constante qui définit les propriétés <see cref="P:System.IO.FileStream.CanRead" /> et <see cref="P:System.IO.FileStream.CanWrite" /> de l'objet <see langword="FileStream" />.</param>
        <param name="ownsHandle">
          <see langword="true" /> si le handle de fichier appartient à cette instance de <see langword="FileStream" /> ; sinon, <see langword="false" />.</param>
        <param name="bufferSize">Valeur <see cref="T:System.Int32" /> positive supérieure à 0 indiquant la taille de la mémoire tampon. La taille par défaut de la mémoire tampon est 4096.</param>
        <param name="isAsync">
          <see langword="true" /> si le handle a été ouvert de façon asynchrone (c'est-à-dire en mode E/S avec chevauchement) ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" /> pour le handle de fichier spécifié, avec l'autorisation d'accès en lecture/écriture, la propriété de l'instance <see langword="FileStream" />, la taille de mémoire tampon et l'état synchrone ou asynchrone spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `FileStream` objet se voit attribuer l’accès spécifié au fichier. La propriété du handle sera comme spécifié. Si cette `FileStream` détient le handle, un appel à la <xref:System.IO.Stream.Close%2A> méthode fermera également le handle. En particulier, le nombre de handles du fichier est décrémenté. Le `FileStream` objet se voit attribuer la taille de mémoire tampon spécifiée.  
  
 `FileStream` suppose qu’il a un contrôle exclusif sur le handle. Lecture, écriture ou qui recherchent tout un `FileStream` détient également un handle peut entraîner une corruption des données. Pour la sécurité des données, appelez <xref:System.IO.FileStream.Flush%2A> avant d’utiliser le handle et évitez d’appeler des méthodes autres que `Close` après avoir effectué à l’aide de la poignée. Vous pouvez également lire et écrire au handle avant d’appeler ce `FileStream` constructeur.  
  
 `FileShare.Read` est la valeur par défaut pour ceux <xref:System.IO.FileStream> constructeurs sans un `FileShare` paramètre.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="access" /> est inférieur à <see langword="FileAccess.Read" /> ou supérieur à <see langword="FileAccess.ReadWrite" /> ou <paramref name="bufferSize" /> est inférieur ou égal à 0.</exception>
        <exception cref="T:System.ArgumentException">Le handle n'est pas valide.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S, telle qu’une erreur disque, s’est produite.  
  
- ou - 
Le flux a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <paramref name="access" /> demandé n’est pas autorisé par le système d’exploitation pour le handle de fichier spécifié, par exemple quand <paramref name="access" /> a la valeur <see langword="Write" /> ou <see langword="ReadWrite" /> et que le handle de fichier est défini pour un accès en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour accéder au code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès relatif ou absolu pour le fichier que l'objet <see langword="FileStream" /> actuel doit encapsuler.</param>
        <param name="mode">Constante qui détermine le mode d'ouverture ou de création du fichier.</param>
        <param name="access">Constante qui détermine le mode d'accès au fichier par l'objet <see langword="FileStream" />. Détermine aussi les valeurs retournées par les propriétés <see cref="P:System.IO.FileStream.CanRead" /> et <see cref="P:System.IO.FileStream.CanWrite" /> de l'objet <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> a la valeur <see langword="true" /> si <c>path</c> spécifie un fichier sur disque.</param>
        <param name="share">Constante qui détermine le mode de partage du fichier par des processus.</param>
        <param name="bufferSize">Valeur <see cref="T:System.Int32" /> positive supérieure à 0 indiquant la taille de la mémoire tampon. La taille par défaut de la mémoire tampon est 4096.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" /> avec le chemin d'accès, le mode de création, l'autorisation de lecture/écriture, l'autorisation de partage et la taille de mémoire tampon spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le .NET Framework ne prend pas en charge l’accès direct aux disques physiques via les chemins d’accès qui sont des noms de périphériques, tels que «\\\\. \PHYSICALDRIVE0 ».  
  
 Le `path` paramètre peut être un nom de fichier, y compris un fichier sur un partage UNC Universal Naming Convention ().  
  
> [!NOTE]
>  `path` n’est pas obligatoire pour être un fichier stocké sur le disque ; Il peut être n’importe quelle partie d’un système qui prend en charge l’accès via des flux. Par exemple, selon le système, cette classe peut accéder à un appareil physique.  
  
 <xref:System.IO.Stream.CanSeek%2A> est `true` pour toutes les <xref:System.IO.FileStream> les objets qui encapsulent des fichiers. Si `path` indique un appareil qui ne prend pas en charge la recherche, le <xref:System.IO.FileStream.CanSeek%2A> propriété résultant <xref:System.IO.FileStream> est `false`. Pour plus d'informations, consultez <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> est une chaîne vide (""), contient seulement un espace blanc ou contient un ou plusieurs caractères non valides.  
  
- ou - 
 <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement autre que NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> est négatif ou égal à zéro.  
  
- ou - 
 <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> contient une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier est introuvable, comme quand <paramref name="mode" /> a pour valeur <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" />, et que le fichier spécifié par <paramref name="path" /> n’existe pas. Le fichier doit déjà exister dans ces modes.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite, par exemple la spécification de <see langword="FileMode.CreateNew" /> quand le fichier spécifié par <paramref name="path" /> existe déjà.  
  
- ou - 
Le système exécute Windows 98 ou Windows 98 Deuxième Édition et <paramref name="share" /> a pour valeur <see langword="FileShare.Delete" />.  
  
- ou - 
Le flux a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide ; il est, par exemple, sur un lecteur non mappé.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <paramref name="access" /> demandé n’est pas autorisé par le système d’exploitation pour le <paramref name="path" /> spécifié, par exemple quand <paramref name="access" /> a la valeur <see langword="Write" /> ou <see langword="ReadWrite" /> et que le fichier ou le répertoire est défini pour un accès en lecture seule.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture, écriture et ajout de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, useAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès relatif ou absolu pour le fichier que l'objet <see langword="FileStream" /> actuel doit encapsuler.</param>
        <param name="mode">Constante qui détermine le mode d'ouverture ou de création du fichier.</param>
        <param name="access">Constante qui détermine le mode d'accès au fichier par l'objet <see langword="FileStream" />. Détermine aussi les valeurs retournées par les propriétés <see cref="P:System.IO.FileStream.CanRead" /> et <see cref="P:System.IO.FileStream.CanWrite" /> de l'objet <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> a la valeur <see langword="true" /> si <c>path</c> spécifie un fichier sur disque.</param>
        <param name="share">Constante qui détermine le mode de partage du fichier par des processus.</param>
        <param name="bufferSize">Valeur <see cref="T:System.Int32" /> positive supérieure à 0 indiquant la taille de la mémoire tampon. La taille par défaut de la mémoire tampon est 4 096.</param>
        <param name="useAsync">Spécifie s’il faut utiliser des E/S asynchrones ou synchrones. Notez cependant qu'il est possible que le système d'exploitation sous-jacent ne prenne pas en charge les E/S asynchrones. Par conséquent, si vous spécifiez <see langword="true" />, le handle peut être ouvert de façon synchrone en fonction de la plateforme. Quand le mode asynchrone est utilisé, les méthodes <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> et <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> donnent de meilleurs résultats pour des lectures ou des écritures de données volumineuses, mais elles peuvent être beaucoup plus lentes quand il s'agit de lectures et d'écritures de données de petite taille. Si l’application est conçue pour tirer parti des E/S asynchrones, affectez au paramètre <c>useAsync</c> la valeur <see langword="true" />. Quand les E/S asynchrones sont utilisées correctement, elles peuvent rendre les applications jusqu'à 10 fois plus rapides. Toutefois, si vous les utilisez dans une application qui n'a pas été reconfigurée pour les E/S asynchrones, l'application peut être jusqu'à 10 fois moins performante.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" /> avec le chemin d'accès, le mode de création, l'autorisation de lecture/écriture, l'autorisation de partage, la taille de mémoire tampon et l'état synchrone ou asynchrone spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le .NET Framework ne prend pas en charge l’accès direct aux disques physiques via les chemins d’accès qui sont des noms de périphériques, tels que «\\\\. \PHYSICALDRIVE0 ».  
  
 Le `path` paramètre peut être un nom de fichier, y compris un fichier sur un partage UNC Universal Naming Convention ().  
  
> [!NOTE]
>  `path` n’est pas obligatoire pour être un fichier stocké sur le disque ; Il peut être n’importe quelle partie d’un système qui prend en charge l’accès via des flux. Par exemple, selon le système, cette classe peut accéder à un appareil physique.  
  
 <xref:System.IO.Stream.CanSeek%2A> est `true` pour toutes les <xref:System.IO.FileStream> les objets qui encapsulent des fichiers. Si `path` indique un appareil qui ne prend pas en charge la recherche, le <xref:System.IO.FileStream.CanSeek%2A> propriété résultant <xref:System.IO.FileStream> est `false`. Pour plus d'informations, consultez <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment écrire des données de façon asynchrone dans un fichier et vérifiez que les données ont été écrites correctement. Un `State` objet est créé pour passer des informations à partir du thread principal pour le `EndReadCallback` et `EndWriteCallback` méthodes.  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> est une chaîne vide (""), contient seulement un espace blanc ou contient un ou plusieurs caractères non valides.  
  
- ou - 
 <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement autre que NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> est négatif ou égal à zéro.  
  
- ou - 
 <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> contient une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier est introuvable, comme quand <paramref name="mode" /> a pour valeur <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" />, et que le fichier spécifié par <paramref name="path" /> n’existe pas. Le fichier doit déjà exister dans ces modes.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite, par exemple la spécification de <see langword="FileMode.CreateNew" /> quand le fichier spécifié par <paramref name="path" /> existe déjà.  
  
- ou - 
Le système exécute Windows 98 ou Windows 98 Deuxième Édition et <paramref name="share" /> a pour valeur <see langword="FileShare.Delete" />.  
  
- ou - 
Le flux a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide ; il est, par exemple, sur un lecteur non mappé.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <paramref name="access" /> demandé n’est pas autorisé par le système d’exploitation pour le <paramref name="path" /> spécifié, par exemple quand <paramref name="access" /> a la valeur <see langword="Write" /> ou <see langword="ReadWrite" /> et que le fichier ou le répertoire est défini pour un accès en lecture seule.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture, écriture et ajout de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="T:System.IO.File" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès relatif ou absolu pour le fichier que l'objet <see langword="FileStream" /> actuel doit encapsuler.</param>
        <param name="mode">Constante qui détermine le mode d'ouverture ou de création du fichier.</param>
        <param name="access">Constante qui détermine le mode d'accès au fichier par l'objet <see langword="FileStream" />. Détermine aussi les valeurs retournées par les propriétés <see cref="P:System.IO.FileStream.CanRead" /> et <see cref="P:System.IO.FileStream.CanWrite" /> de l'objet <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> a la valeur <see langword="true" /> si <c>path</c> spécifie un fichier sur disque.</param>
        <param name="share">Constante qui détermine le mode de partage du fichier par des processus.</param>
        <param name="bufferSize">Valeur <see cref="T:System.Int32" /> positive supérieure à 0 indiquant la taille de la mémoire tampon. La taille par défaut de la mémoire tampon est 4096.</param>
        <param name="options">Valeur qui spécifie des options de fichiers supplémentaires.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" /> avec le chemin d'accès, le mode de création, l'autorisation d'accès en lecture/écriture et de partage, l'accès que d'autres flux de fichiers peuvent avoir au même fichier, la taille de mémoire tampon et les options de fichiers supplémentaires spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le .NET Framework ne prend pas en charge l’accès direct aux disques physiques via les chemins d’accès qui sont des noms de périphériques, tels que «\\\\. \PHYSICALDRIVE0 ».  
  
 Le `fileOptions` paramètre est utilisé pour fournir l’accès à des opérations plus avancées qui peuvent être utilisés lors de la création d’un <xref:System.IO.FileStream> objet.  
  
 Le `path` paramètre peut être un nom de fichier, y compris un fichier sur un partage UNC Universal Naming Convention ().  
  
> [!NOTE]
>  `path` n’est pas obligatoire pour être un fichier stocké sur le disque ; Il peut être n’importe quelle partie d’un système qui prend en charge l’accès via des flux. Par exemple, selon le système, cette classe peut accéder à un appareil physique.  
  
 <xref:System.IO.Stream.CanSeek%2A> est `true` pour toutes les <xref:System.IO.FileStream> les objets qui encapsulent des fichiers. Si `path` indique un appareil qui ne prend pas en charge la recherche, le <xref:System.IO.FileStream.CanSeek%2A> propriété résultant <xref:System.IO.FileStream> est `false`. Pour plus d'informations, consultez <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant écrit des données dans un fichier, puis lit les données à l’aide de la <xref:System.IO.FileStream> objet.  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> est une chaîne vide (""), contient seulement un espace blanc ou contient un ou plusieurs caractères non valides.  
  
- ou - 
 <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement autre que NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> est négatif ou égal à zéro.  
  
- ou - 
 <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> contient une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier est introuvable, comme quand <paramref name="mode" /> a pour valeur <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" />, et que le fichier spécifié par <paramref name="path" /> n’existe pas. Le fichier doit déjà exister dans ces modes.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite, par exemple la spécification de <see langword="FileMode.CreateNew" /> quand le fichier spécifié par <paramref name="path" /> existe déjà.  
  
- ou - 
Le flux a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide ; il est, par exemple, sur un lecteur non mappé.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <paramref name="access" /> demandé n’est pas autorisé par le système d’exploitation pour le <paramref name="path" /> spécifié, par exemple quand <paramref name="access" /> a la valeur <see langword="Write" /> ou <see langword="ReadWrite" /> et que le fichier ou le répertoire est défini pour un accès en lecture seule.  
  
- ou - 
 <see cref="F:System.IO.FileOptions.Encrypted" /> est spécifié pour <paramref name="options" />, mais le chiffrement des fichiers n’est pas pris en charge sur la plateforme actuelle.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture, écriture et ajout de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès relatif ou absolu pour le fichier que l'objet <see cref="T:System.IO.FileStream" /> actuel doit encapsuler.</param>
        <param name="mode">Constante qui détermine le mode d'ouverture ou de création du fichier.</param>
        <param name="rights">Constante qui détermine les droits d'accès à utiliser lors de la création de règles d'accès et d'audit pour le fichier.</param>
        <param name="share">Constante qui détermine le mode de partage du fichier par des processus.</param>
        <param name="bufferSize">Valeur <see cref="T:System.Int32" /> positive supérieure à 0 indiquant la taille de la mémoire tampon. La taille par défaut de la mémoire tampon est 4096.</param>
        <param name="options">Constante qui spécifie des options de fichiers supplémentaires.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" /> avec le chemin d'accès, le mode de création, l'autorisation de droits d'accès, l'autorisation de partage, la taille de mémoire tampon et les options de fichiers supplémentaires spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le .NET Framework ne prend pas en charge l’accès direct aux disques physiques via les chemins d’accès qui sont des noms de périphériques, tels que «\\\\. \PHYSICALDRIVE0 ».  
  
 Utilisez cette <xref:System.IO.FileStream.%23ctor%2A> constructeur pour appliquer l’accès des droits au moment de la création d’un fichier. Pour accéder ou modifier les droits sur un fichier existant, envisagez d’utiliser le <xref:System.IO.File.GetAccessControl%2A> et <xref:System.IO.File.SetAccessControl%2A> méthodes.  
  
 Le `fileOptions` paramètre est utilisé pour fournir l’accès à des opérations plus avancées qui peuvent être utilisés lors de la création d’un <xref:System.IO.FileStream> objet.  
  
 Le `path` paramètre peut être un nom de fichier, y compris un fichier sur un partage UNC Universal Naming Convention ().  
  
> [!NOTE]
>  `path` n’est pas obligatoire pour être un fichier stocké sur le disque ; Il peut être n’importe quelle partie d’un système qui prend en charge l’accès via des flux. Par exemple, selon le système, cette classe peut accéder à un appareil physique.  
  
 <xref:System.IO.Stream.CanSeek%2A> est `true` pour toutes les <xref:System.IO.FileStream> les objets qui encapsulent des fichiers. Si `path` indique un appareil qui ne prend pas en charge la recherche, le <xref:System.IO.FileStream.CanSeek%2A> propriété résultant <xref:System.IO.FileStream> est `false`. Pour plus d'informations, consultez <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> est une chaîne vide (""), contient seulement un espace blanc ou contient un ou plusieurs caractères non valides.  
  
- ou - 
 <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement autre que NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> est négatif ou égal à zéro.  
  
- ou - 
 <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> contient une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier est introuvable, comme quand <paramref name="mode" /> a pour valeur <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" />, et que le fichier spécifié par <paramref name="path" /> n’existe pas. Le fichier doit déjà exister dans ces modes.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Windows NT ou une version ultérieure.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite, par exemple la spécification de <see langword="FileMode.CreateNew" /> quand le fichier spécifié par <paramref name="path" /> existe déjà.  
  
- ou - 
Le flux a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide ; il est, par exemple, sur un lecteur non mappé.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <paramref name="access" /> demandé n’est pas autorisé par le système d’exploitation pour le <paramref name="path" /> spécifié, par exemple quand <paramref name="access" /> a la valeur <see langword="Write" /> ou <see langword="ReadWrite" /> et que le fichier ou le répertoire est défini pour un accès en lecture seule.  
  
- ou - 
 <see cref="F:System.IO.FileOptions.Encrypted" /> est spécifié pour <paramref name="options" />, mais le chiffrement des fichiers n’est pas pris en charge sur la plateforme actuelle.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> ou le nom de fichier spécifiés, ou les deux, dépassent la longueur maximale définie par le système.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture, écriture et ajout de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès relatif ou absolu pour le fichier que l'objet <see cref="T:System.IO.FileStream" /> actuel doit encapsuler.</param>
        <param name="mode">Constante qui détermine le mode d'ouverture ou de création du fichier.</param>
        <param name="rights">Constante qui détermine les droits d'accès à utiliser lors de la création de règles d'accès et d'audit pour le fichier.</param>
        <param name="share">Constante qui détermine le mode de partage du fichier par des processus.</param>
        <param name="bufferSize">Valeur <see cref="T:System.Int32" /> positive supérieure à 0 indiquant la taille de la mémoire tampon. La taille par défaut de la mémoire tampon est 4096.</param>
        <param name="options">Constante qui spécifie des options de fichiers supplémentaires.</param>
        <param name="fileSecurity">Constante qui détermine le contrôle d'accès et la sécurité d'audit pour le fichier.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.FileStream" /> avec le chemin d'accès, le mode de création, l'autorisation de droits d'accès, l'autorisation de partage, la taille de mémoire tampon, les options de fichiers supplémentaires et la sécurité de contrôle d'accès et d'audit spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le .NET Framework ne prend pas en charge l’accès direct aux disques physiques via les chemins d’accès qui sont des noms de périphériques, tels que «\\\\. \PHYSICALDRIVE0 ».  
  
 Utilisez cette <xref:System.IO.FileStream.%23ctor%2A> constructeur pour appliquer l’accès des droits au moment de la création d’un fichier. Pour accéder ou modifier les droits sur un fichier existant, envisagez d’utiliser le <xref:System.IO.File.GetAccessControl%2A> et <xref:System.IO.File.SetAccessControl%2A> méthodes.  
  
 Le `fileOptions` paramètre est utilisé pour fournir l’accès à des opérations plus avancées qui peuvent être utilisés lors de la création d’un <xref:System.IO.FileStream> objet.  
  
 Le `path` paramètre peut être un nom de fichier, y compris un fichier sur un partage UNC Universal Naming Convention ().  
  
> [!NOTE]
>  `path` n’est pas obligatoire pour être un fichier stocké sur le disque ; Il peut être n’importe quelle partie d’un système qui prend en charge l’accès via des flux. Par exemple, selon le système, cette classe peut accéder à un appareil physique.  
  
 <xref:System.IO.Stream.CanSeek%2A> est `true` pour toutes les <xref:System.IO.FileStream> les objets qui encapsulent des fichiers. Si `path` indique un appareil qui ne prend pas en charge la recherche, le <xref:System.IO.FileStream.CanSeek%2A> propriété résultant <xref:System.IO.FileStream> est `false`. Pour plus d'informations, consultez <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Lorsque vous compilez un jeu de caractères avec un paramètre de culture particulière et que vous récupérez ces mêmes caractères avec un paramètre de culture différent, les caractères ne peuvent pas être interprétés et peut provoquer une exception levée.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant écrit des données dans un fichier, puis lit les données à l’aide de la <xref:System.IO.FileStream> objet.  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> est une chaîne vide (""), contient seulement un espace blanc ou contient un ou plusieurs caractères non valides.  
  
- ou - 
 <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> fait référence à un périphérique qui ne prend pas en charge les fichiers, tel que « con: », « com1: », « lpt1: », etc., dans un environnement autre que NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> est négatif ou égal à zéro.  
  
- ou - 
 <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> contient une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier est introuvable, comme quand <paramref name="mode" /> a pour valeur <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" />, et que le fichier spécifié par <paramref name="path" /> n’existe pas. Le fichier doit déjà exister dans ces modes.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite, par exemple la spécification de <see langword="FileMode.CreateNew" /> quand le fichier spécifié par <paramref name="path" /> existe déjà.  
  
- ou - 
Le flux a été fermé.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide ; il est, par exemple, sur un lecteur non mappé.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le <paramref name="access" /> demandé n’est pas autorisé par le système d’exploitation pour le <paramref name="path" /> spécifié, par exemple quand <paramref name="access" /> a la valeur <see langword="Write" /> ou <see langword="ReadWrite" /> et que le fichier ou le répertoire est défini pour un accès en lecture seule.  
  
- ou - 
 <see cref="F:System.IO.FileOptions.Encrypted" /> est spécifié pour <paramref name="options" />, mais le chiffrement des fichiers n’est pas pris en charge sur la plateforme actuelle.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> ou le nom de fichier spécifiés, ou les deux, dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Windows NT ou une version ultérieure.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture, écriture et ajout de fichiers. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, et <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="numBytes">To be added.</param>
        <param name="userCallback">To be added.</param>
        <param name="stateObject">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="numBytes">To be added.</param>
        <param name="userCallback">To be added.</param>
        <param name="stateObject">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le flux actuel prend en charge la lecture.</summary>
        <value>
          <see langword="true" /> si le flux prend en charge la lecture ; <see langword="false" /> si le flux est fermé ou a été ouvert avec un accès en écriture seule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une classe dérivée de <xref:System.IO.Stream> ne prend pas en charge la lecture, les appels à la <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, et <xref:System.IO.FileStream.BeginRead%2A> méthodes lèvent une <xref:System.NotSupportedException>.  
  
 Si le flux est fermé, cette propriété retourne `false`.  
  
   
  
## Examples  
 L’exemple suivant montre une utilisation de la `CanRead` propriété. La sortie de ce code est « MyFile.txt n’est pas accessible en écriture. » Pour obtenir le message de sortie « MyFile.txt peut être écrit à et lire à partir de. », de modifier le `FileAccess` paramètre `ReadWrite` dans le `FileStream` constructeur.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le flux actuel prend en charge la recherche.</summary>
        <value>
          <see langword="true" /> si le flux prend en charge la recherche ; <see langword="false" /> si le flux est fermé ou si l'élément <see langword="FileStream" /> a été construit à partir d'un handle de système d'exploitation comme un canal ou une sortie console.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une classe dérivée de <xref:System.IO.Stream> ne prend pas en charge la recherche, les appels à <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>, et <xref:System.IO.FileStream.Seek%2A> lever un <xref:System.NotSupportedException>.  
  
 Si le flux est fermé, cette propriété retourne `false`.  
  
   
  
## Examples  
 L’exemple suivant utilise le `CanSeek` propriété à vérifier si un flux prend en charge la recherche.  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le flux actuel prend en charge l'écriture.</summary>
        <value>
          <see langword="true" /> si le flux prend en charge l'écriture ; <see langword="false" /> si le flux est fermé ou a été ouvert avec un accès en lecture seule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une classe dérivée de <xref:System.IO.Stream> ne prend pas en charge l’écriture, un appel à <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, ou <xref:System.IO.FileStream.WriteByte%2A> lève un <xref:System.NotSupportedException>.  
  
 Si le flux est fermé, cette propriété retourne `false`.  
  
   
  
## Examples  
 L’exemple suivant utilise le `CanWrite` propriété à vérifier si un flux prend en charge l’écriture.  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 Voici un exemple à l’aide de la `CanWrite` propriété. La sortie de ce code est « MyFile.txt est accessible en écriture. » Pour obtenir le message de sortie « MyFile.txt peut être écrit à et lire à partir de. », de modifier le `FileAccess` paramètre `ReadWrite` dans le `FileStream` constructeur.  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="fileStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.IO.FileStream" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public <xref:System.ComponentModel.Component.Dispose%2A> (méthode) et le <xref:System.Object.Finalize%2A> (méthode). <xref:System.ComponentModel.Component.Dispose%2A> appelle la méthode protégée <xref:System.IO.FileStream.Dispose%2A> méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle <xref:System.IO.FileStream.Dispose%2A> avec `disposing` défini sur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.IO.FileStream>. Cette méthode appelle la méthode <xref:System.ComponentModel.Component.Dispose%2A> de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à <see cref="M:System.ComponentModel.Component.Dispose" />. Pour plus d’informations sur l’implémentation <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Pour plus d’informations sur <see cref="M:System.ComponentModel.Component.Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="fileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Référence à la requête asynchrone en attente qu'il faut attendre.</param>
        <summary>Attend que l'opération de lecture asynchrone en attente se termine. (Utilisez <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> à la place.)</summary>
        <returns>Nombre d'octets lus dans le flux, entre 0 et le nombre d'octets demandés. Les flux retournent 0 seulement à la fin du flux, sinon ils doivent être bloqués jusqu'à ce qu'au moins 1 octet soit disponible.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le .NET Framework 4 et les versions antérieures, vous devez utiliser des méthodes telles que <xref:System.IO.FileStream.BeginRead%2A> et <xref:System.IO.FileStream.EndRead%2A> pour implémenter des opérations de fichier asynchrones. Ces méthodes sont toujours disponibles dans le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] pour prendre en charge du code hérité ; Toutefois, les nouvelles méthodes async, tel que <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, et <xref:System.IO.FileStream.FlushAsync%2A>, aide vous implémenter des opérations de fichier asynchrones plus facilement.  
  
 <xref:System.IO.FileStream.EndRead%2A> doit être appelé exactement pour chaque appel à <xref:System.IO.FileStream.BeginRead%2A>. Impossibilité de terminer un processus de lecture avant de commencer une autre lecture peut provoquer un comportement indésirable telles que de blocage.  
  
 Cette méthode se substitue à <xref:System.IO.Stream.EndRead%2A>.  
  
 <xref:System.IO.FileStream.EndRead%2A> peut être appelée sur chaque <xref:System.IAsyncResult> de <xref:System.IO.FileStream.BeginRead%2A>. Appel <xref:System.IO.FileStream.EndRead%2A> indique le nombre d’octets lus à partir du flux. <xref:System.IO.FileStream.EndRead%2A> bloque jusqu'à ce que l’opération d’e/s est terminée.  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructeur.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Cet objet <see cref="T:System.IAsyncResult" /> n’a pas été créé en appelant <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> sur cette classe.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> est appelé plusieurs fois.</exception>
        <exception cref="T:System.IO.IOException">Le flux est fermé ou une erreur interne s’est produite.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">E/S sur fichier asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="fileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Requête d'E/S asynchrone en attente.</param>
        <summary>Termine une opération d'écriture asynchrone et se bloque jusqu'à la fin de l'opération d'E/S. (Utilisez <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> à la place.)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le .NET Framework 4 et les versions antérieures, vous devez utiliser des méthodes telles que <xref:System.IO.FileStream.BeginWrite%2A> et <xref:System.IO.FileStream.EndWrite%2A> pour implémenter des opérations de fichier asynchrones. Ces méthodes sont toujours disponibles dans le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] pour prendre en charge du code hérité ; Toutefois, les nouvelles méthodes async, tel que <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, et <xref:System.IO.FileStream.FlushAsync%2A>, aide vous implémenter des opérations de fichier asynchrones plus facilement.  
  
 Cette méthode se substitue à <xref:System.IO.Stream.EndWrite%2A>.  
  
 <xref:System.IO.FileStream.EndWrite%2A> doit être appelée une seule fois sur chaque <xref:System.IAsyncResult> de <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A> bloque jusqu'à ce que l’opération d’e/s est terminée.  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructeur.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Cet objet <see cref="T:System.IAsyncResult" /> n’a pas été créé en appelant <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> sur cette classe.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> est appelé plusieurs fois.</exception>
        <exception cref="T:System.IO.IOException">Le flux est fermé ou une erreur interne s’est produite.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">E/S sur fichier asynchrones</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie que les ressources sont libérées et que toute autre opération de nettoyage est effectuée quand le garbage collector récupère l'élément <see langword="FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le garbage collector appelle `Finalize` lorsque l’objet actuel est prêt à être finalisé. `Finalize` ferme le `FileStream`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Efface les mémoires tampons pour ce flux et provoque l'écriture dans le fichier des données mises en mémoire tampon.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="fileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface les mémoires tampons pour ce flux et provoque l'écriture dans le fichier des données mises en mémoire tampon.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>.  
  
 Lorsque vous appelez le <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> (méthode), la mémoire tampon de système d’exploitation d’e/s est également vidé.  
  
 Le codeur d’un flux n’est pas vidé, sauf si vous appelez explicitement <xref:System.IO.FileStream.Flush%2A> ou dispose de l’objet. Paramètre <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> à `true` signifie que les données sont vidées de la mémoire tampon dans le flux, mais l’état de l’encodeur n’est pas vidé. Ainsi, l’encodeur afin de conserver son état (caractères partiels) afin qu’il peut encoder correctement le bloc suivant de caractères. Ce scénario affecte UTF8 et UTF7, où certains caractères peuvent uniquement être encodés après que l’encodeur a reçu les caractères adjacents.  
  
 Une mémoire tampon pouvant être utilisé pour la lecture ou écriture, <xref:System.IO.FileStream.Flush> effectue les deux fonctions suivantes :  
  
-   Les données écrites précédemment dans la mémoire tampon sont copiées dans le fichier et la mémoire tampon est effacée à l’exception de son état de l’encodeur.  
  
-   Si <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> est `true` et les données ont été précédemment copiées à partir du fichier vers la mémoire tampon pour la lecture, la position actuelle dans le fichier est décrémentée du nombre d’octets non lus dans la mémoire tampon. La mémoire tampon est ensuite effacée.  
  
 Utilisez le <xref:System.IO.FileStream.Flush%28System.Boolean%29> surcharge de méthode lorsque vous souhaitez vous assurer que toutes les données mises en mémoire dans les mémoires tampons de fichiers intermédiaires est écrites sur le disque.  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.IO.FileStream.Lock%2A> (méthode).  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="fileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">
          <see langword="true" /> pour vider toutes les mémoires tampons de fichiers intermédiaires ; sinon, <see langword="false" />.</param>
        <summary>Efface les mémoires tampons pour ce flux, provoque l'écriture des données mises en mémoire tampon dans le fichier et efface également toutes les mémoires tampons de fichiers intermédiaires.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge lorsque vous souhaitez vous assurer que toutes les données mises en mémoire dans les mémoires tampons de fichiers intermédiaires est écrites sur le disque.  
  
 Lorsque vous appelez le <xref:System.IO.FileStream.Flush%2A> (méthode), la mémoire tampon de système d’exploitation d’e/s est également vidé.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Jeton pour surveiller les requêtes d'annulation.</param>
        <summary>Efface de façon asynchrone toutes les mémoires tampons pour ce flux, provoque l'écriture des données mises en mémoire tampon sur l'appareil sous-jacent et surveille les requêtes d'annulation.</summary>
        <returns>Tâche qui représente l’opération de vidage asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous appelez le <xref:System.IO.FileStream.FlushAsync%2A> (méthode), la mémoire tampon de système d’exploitation d’e/s est également vidé.  
  
 Si l’opération est annulée avant la fin, la tâche retournée contient le <xref:System.Threading.Tasks.TaskStatus.Canceled> valeur pour le <xref:System.Threading.Tasks.Task.Status%2A> propriété. Si le handle vers le fichier est supprimé, la tâche retournée contient le <xref:System.ObjectDisposedException> exception dans le <xref:System.Threading.Tasks.Task.Exception%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le flux a été supprimé.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Security.AccessControl.FileSecurity" /> qui encapsule les entrées de la liste de contrôle d'accès (ACL) pour le fichier décrit par l'objet <see cref="T:System.IO.FileStream" /> actuel.</summary>
        <returns>Objet qui encapsule les paramètres de contrôle d'accès pour le fichier décrit par l'objet <see cref="T:System.IO.FileStream" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le <xref:System.IO.FileStream> classe et <xref:System.IO.FileStream.GetAccessControl%2A> peut être utilisé pour récupérer les entrées (ACL) d’un fichier existant, envisagez d’utiliser <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> , tel qu’il est plus facile à utiliser.  
  
 Utilisez le <xref:System.IO.FileStream.GetAccessControl%2A> méthode pour récupérer les entrées ACL pour un fichier.  
  
 Une liste ACL décrit les individus et/ou les groupes qui ont ou pas de droits à des actions spécifiques sur le fichier donné. Pour plus d'informations, consultez [Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le fichier est fermé.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.SystemException">Le fichier est introuvable.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
- ou - 
L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le handle de fichier du système d'exploitation que l'objet <see langword="FileStream" /> actuel encapsule.</summary>
        <value>Handle de fichier du système d'exploitation pour le fichier encapsulé par cet objet <see langword="FileStream" />, ou -1 si l'élément <see langword="FileStream" /> a été fermé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est un handle de système d’exploitation pour une utilisation avec les appels système fournis par le système d’exploitation (tel que `ReadFile` sur Windows). Il ne fonctionne pas avec les fonctions de bibliothèque C qui attendent un descripteur de fichier, telles que `fread`.  
  
 Le handle de système d’exploitation peut avoir été ouvert synchrone ou asynchrone, en fonction qui `FileStream` constructeur a été appelé. Utilisez le <xref:System.IO.FileStream.IsAsync%2A> propriété pour découvrir si ce handle a été ouvert de façon asynchrone. Dans Win32, cela signifie que le handle a été ouvert pour les e/s avec chevauchement, et elle requiert des paramètres différents pour `ReadFile` et `WriteFile`.  
  
> [!CAUTION]
>  Une altération des données peut se produire si un `FileStream` est créé, son descripteur est transmis, une opération déplace le pointeur du handle fichier, puis le `FileStream` est utilisé à nouveau. Plusieurs threads ne peut pas écrire en toute sécurité simultanément, dans le même fichier et `FileStream` mise en mémoire tampon de code suppose qu’il contrôle exclusivement le handle. `FileStream` peut lever une <xref:System.IO.IOException> si `FileStream` détecte qu’un autre processus a déplacé le pointeur de fichier. Pour éviter ce problème, n’écrivez pas toutes les données dans une partie du fichier qui `FileStream` peut avoir mis en mémoire tampon et de restaurer le pointeur de fichier à l’emplacement d’origine lorsque le dernier appel à des méthodes sur `FileStream`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’accéder au code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'élément <see langword="FileStream" /> a été ouvert en mode asynchrone ou synchrone.</summary>
        <value>
          <see langword="true" /> si <see langword="FileStream" /> a été ouvert de façon asynchrone ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `IsAsync` propriété détecte si le `FileStream` handle a été ouvert de façon asynchrone, l’activation de votre code pour utiliser le <xref:System.IO.FileStream.Handle%2A> propriété correctement. Dans Win32, `IsAsync` en cours de la valeur true signifie que le handle a été ouvert pour les e/s avec chevauchement et nécessite donc des paramètres différents pour `ReadFile` et `WriteFile`.  
  
 Vous spécifiez cette valeur lorsque vous créez une instance de la <xref:System.IO.FileStream> classe à l’aide d’un constructeur ayant un `isAsync`, `useAsync`, ou `options` paramètre. Lorsque la propriété est `true`, le flux de données utilise des e/s avec chevauchement pour effectuer des opérations de fichier de façon asynchrone. Toutefois, le <xref:System.IO.FileStream.IsAsync%2A> propriété ne doit pas être `true` pour appeler le <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, ou <xref:System.IO.Stream.CopyToAsync%2A> (méthode). Lorsque le <xref:System.IO.FileStream.IsAsync%2A> propriété est `false` et vous appelez la lecture asynchrone et les opérations d’écriture, le thread d’interface utilisateur n’est toujours pas bloquée, mais l’opération d’e/s proprement dite est effectuée de façon synchrone.  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructeur.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la longueur du flux en octets.</summary>
        <value>Valeur de type long représentant la longueur du flux en octets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant utilise le `Length` et `Position` propriétés pour vérifier une condition de fin de fichier.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le <see cref="P:System.IO.FileStream.CanSeek" /> de ce flux est <see langword="false" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S, telle que la fermeture du fichier, s’est produite.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Lock : int64 * int64 -&gt; unit&#xA;override this.Lock : int64 * int64 -&gt; unit" Usage="fileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Début de la plage à verrouiller. La valeur de ce paramètre doit être supérieure ou égale à zéro (0).</param>
        <param name="length">Plage à verrouiller.</param>
        <summary>Empêche d'autres processus de lire ou d'écrire dans l'élément <see cref="T:System.IO.FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verrouillage d’une plage d’un flux de fichier donne les threads de l’accès exclusif processus verrouillage pour cette plage de flux de fichier.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment verrouiller une partie d’un fichier pour un autre processus ne peut pas accéder à cette partie du fichier même si elle a accès en lecture/écriture au fichier. Exécutez le programme simultanément dans différentes fenêtres de commande et d’examiner en utilisant les options d’entrée de console différentes.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> ou <paramref name="length" /> est un nombre négatif.</exception>
        <exception cref="T:System.ObjectDisposedException">Le fichier est fermé.</exception>
        <exception cref="T:System.IO.IOException">Le processus ne peut pas accéder au fichier, car un autre processus a verrouillé une partie du fichier.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le chemin absolu du fichier ouvert dans <see langword="FileStream" />.</summary>
        <value>Chaîne qui est le chemin d’accès absolu du fichier.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Si le chemin d’accès absolu n’est pas connu, cette propriété retourne une chaîne similaire à « [inconnu] ».

 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructeur.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder au chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position actuelle de ce flux.</summary>
        <value>Position actuelle de ce flux.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche au-delà de la longueur du flux est pris en charge.  Lorsque vous recherchez au-delà de la longueur du fichier, la taille du fichier augmente.  Dans Microsoft Windows NT et les versions ultérieures, toutes les données ajoutées à la fin du fichier sont définies à zéro.  Dans Microsoft Windows 98 ou version antérieure, toutes les données ajoutées à la fin du fichier ne sont pas définies à zéro, ce qui signifie que les données supprimées précédemment est visible dans le flux. Définition de la position du flux de données à une valeur élevée après la fin du flux dans Windows 98 ou une version antérieure peut entraîner une exception est levée.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant utilise le `Length` et `Position` propriétés pour vérifier une condition de fin de fichier.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge la recherche.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.  
  
\- ou - 
La position a été définie sur une valeur très élevée allant au-delà de la fin du flux dans Windows 98 ou version antérieure.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Tentative de définition de la position sur une valeur négative.</exception>
        <exception cref="T:System.IO.EndOfStreamException">Tentative de recherche au-delà de la fin d’un flux qui ne prend pas en charge ce type de recherche.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="fileStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Quand cette méthode retourne un résultat, contient le tableau d’octets spécifié dont les valeurs comprises entre <c>offset</c> et (<c>offset</c> + <c>count</c> - 1<c>)</c> sont remplacées par les octets lus dans la source actuelle.</param>
        <param name="offset">Décalage en octets dans <c>array</c> auquel les octets lus seront placés.</param>
        <param name="count">Nombre maximal d'octets à lire.</param>
        <summary>Lit un bloc d'octets dans le flux et écrit les données dans une mémoire tampon donnée.</summary>
        <returns>Nombre total d'octets lus dans la mémoire tampon. Le total peut être inférieur au nombre d'octets demandé si ce nombre d'octets n'est pas disponible actuellement, ou il peut être égal à zéro si la fin du flux est atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.IO.Stream.Read%2A>.  
  
 Le `offset` paramètre indique l’offset d’octet dans `array` (l’index de la mémoire tampon) à partir duquel commencer la lecture et le `count` paramètre indique le nombre maximal d’octets à lire à partir de ce flux. La valeur retournée est le nombre réel d’octets lus, ou zéro si la fin du flux est atteinte. Si l’opération de lecture réussite, la position actuelle du flux est avancée par le nombre d’octets lus. Si une exception se produit, la position actuelle du flux est inchangée.  
  
 Le <xref:System.IO.FileStream.Read%2A> méthode retourne zéro uniquement après avoir atteint la fin du flux. Sinon, <xref:System.IO.FileStream.Read%2A> lit toujours au moins un octet à partir du flux avant de retourner. Si aucune donnée n’est disponible à partir du flux lors d’un appel à <xref:System.IO.FileStream.Read%2A>, la méthode se bloque jusqu'à ce qu’au moins un octet de données peut être retourné. Une implémentation est libre de retourner moins d’octets que demandé même si la fin du flux n’a pas été atteinte.  
  
 Utilisez <xref:System.IO.BinaryReader> pour la lecture des types de données primitifs.  
  
 N’interrompez pas un thread qui exécute une opération de lecture. Bien que l’application peut sembler s’exécuter correctement une fois que le thread est débloqué, l’interruption peut diminuer de performances et la fiabilité de votre application.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant lit le contenu à partir d’un <xref:System.IO.FileStream> et les écrit dans un autre <xref:System.IO.FileStream>.  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge la lecture.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> et <paramref name="count" /> décrivent une plage non valide dans <paramref name="array" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Des méthodes ont été appelées après la fermeture du flux.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dans laquelle les données sont écrites.</param>
        <param name="offset">Dans <c>buffer</c>, décalage d’octet auquel commencer l’écriture des données à partir du flux.</param>
        <param name="count">Nombre maximal d'octets à lire.</param>
        <param name="cancellationToken">Jeton pour surveiller les requêtes d'annulation.</param>
        <summary>Lit de façon asynchrone une séquence d'octets dans le flux actuel, avance la position dans le flux du nombre d'octets lus et surveille les demandes d'annulation.</summary>
        <returns>Tâche qui représente l'opération de lecture asynchrone. La valeur du paramètre <paramref name="TResult" /> contient le nombre total d'octets lus dans la mémoire tampon. La valeur du résultat peut être inférieure au nombre d'octets demandés si le nombre d'octets actuellement disponibles est inférieur au nombre demandé, ou elle peut avoir la valeur 0 (zéro) si la fin du flux a été atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.FileStream.ReadAsync%2A> méthode vous permet d’effectuer des opérations gourmandes en ressources de fichier sans bloquer le thread principal. Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas. Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.  
  
 Utilisez le <xref:System.IO.FileStream.CanRead%2A> propriété afin de déterminer si l’instance actuelle prend en charge la lecture.  
  
 Si l’opération est annulée avant la fin, la tâche retournée contient le <xref:System.Threading.Tasks.TaskStatus.Canceled> valeur pour le <xref:System.Threading.Tasks.Task.Status%2A> propriété. Si le handle vers le fichier est supprimé, la tâche retournée contient le <xref:System.ObjectDisposedException> exception dans le <xref:System.Threading.Tasks.Task.Exception%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant montre comment lire à partir d’un fichier de façon asynchrone.  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.ArgumentException">La somme de <paramref name="offset" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge la lecture.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">Le flux est actuellement utilisé par une opération de lecture antérieure.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="fileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit un octet du fichier et avance la position de lecture d'un octet.</summary>
        <returns>Octet, converti en type (transtypage) <see cref="T:System.Int32" />, ou -1 si la fin du flux a été atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.IO.Stream.ReadByte%2A>.  
  
> [!NOTE]
>  Utilisez le <xref:System.IO.FileStream.CanRead%2A> propriété afin de déterminer si l’instance actuelle prend en charge la lecture. Pour plus d'informations, consultez <xref:System.IO.Stream.CanRead%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment écrire des données dans un fichier, octet par octet et vérifiez que les données ont été écrites correctement.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le flux actuel ne prend pas en charge la lecture.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux actuel est fermé.</exception>
        <block subset="none" type="overrides">
          <para>L’implémentation par défaut sur <see langword="Stream" /> crée un tableau d’un octet, puis appelle <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Bien que ce soit correct, il est inefficace. N’importe quel flux avec une mémoire tampon interne doit substituer cette méthode et fournir une version beaucoup plus efficace qui lit la mémoire tampon directement, vous évitant l’allocation de tableau supplémentaire à chaque appel.  
  
Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</para>
        </block>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> qui représente le handle de fichier du système d'exploitation pour le fichier encapsulé par l'objet <see cref="T:System.IO.FileStream" /> actuel.</summary>
        <value>Objet qui représente le handle de fichier du système d'exploitation pour le fichier encapsulé par l'objet <see cref="T:System.IO.FileStream" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.FileStream.SafeFileHandle%2A> propriété automatiquement vide le flux et la position actuelle du flux à 0.  Ainsi, le fichier à déplacer ou la position du flux d’être réinitialisée par un autre flux de données en utilisant le <xref:System.IO.FileStream.SafeFileHandle%2A> retourné par cette propriété.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation d’appeler du code non managé.  
  
Action de sécurité : demande de liaison 
Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="fileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Point relatif à l’élément <c>origin</c>, où la recherche doit commencer.</param>
        <param name="origin">Spécifie le début, la fin ou la position actuelle comme point de référence pour <c>offset</c>, en utilisant une valeur de type <see cref="T:System.IO.SeekOrigin" />.</param>
        <summary>Définit la position actuelle de ce flux avec la valeur donnée.</summary>
        <returns>Nouvelle position dans le flux.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Utilisez le <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> propriété afin de déterminer si l’instance actuelle prend en charge la recherche. Pour plus d'informations, consultez <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>.  
  
 Vous pouvez chercher à n’importe quel emplacement au-delà de la longueur du flux. Lorsque vous recherchez au-delà de la longueur du fichier, la taille du fichier augmente. Dans Windows NT et versions ultérieures, les données ajoutées à la fin du fichier sont définies à zéro. Dans Windows 98 ou des versions antérieures, ajoutées à la fin du fichier de données ne sont pas définies à zéro, ce qui signifie que les données supprimées précédemment est visible dans le flux.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment écrire des données dans un fichier, octet par octet et vérifiez que les données ont été écrites correctement.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 L’exemple suivant lit le texte dans le sens inverse, à partir de la fin du fichier au début du fichier, à l’aide de divers <xref:System.IO.SeekOrigin> valeurs avec le <xref:System.IO.FileStream.Seek%2A> (méthode).  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge la recherche, notamment comme si le <see langword="FileStream" /> était construit à partir d’une sortie de canal ou de la console.</exception>
        <exception cref="T:System.ArgumentException">Tentative de recherche avant le début du flux.</exception>
        <exception cref="T:System.ObjectDisposedException">Des méthodes ont été appelées après la fermeture du flux.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileStream.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">Objet qui décrit une entrée ACL à appliquer au fichier actuel.</param>
        <summary>Applique les entrées ACL décrites par un objet <see cref="T:System.Security.AccessControl.FileSecurity" /> au fichier décrit par l'objet <see cref="T:System.IO.FileStream" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le <xref:System.IO.FileStream> classe et <xref:System.IO.FileStream.SetAccessControl%2A> peut être utilisé sur un fichier existant, envisagez d’utiliser le <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> méthode tel qu’il est plus facile à utiliser.  
  
 Le <xref:System.IO.FileStream.SetAccessControl%2A> méthode applique les entrées de contrôle d’accès (ACL) de liste à un fichier qui représente la liste ACL non héritée.  
  
> [!CAUTION]
>  La liste ACL spécifiée pour le `fileSecurity` paramètre remplace la liste ACL existante pour le fichier. Pour ajouter des autorisations pour un nouvel utilisateur, utilisez la <xref:System.IO.FileStream.GetAccessControl%2A> méthode pour obtenir la liste ACL existante, modifiez-la et ensuite utiliser <xref:System.IO.FileStream.SetAccessControl%2A> pour l’appliquer au fichier.  
  
 Une liste ACL décrit les individus et/ou les groupes qui ont ou pas de droits à des actions spécifiques sur le fichier donné. Pour plus d'informations, consultez [Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le fichier est fermé.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="fileSecurity" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Le fichier est introuvable ou n’a pas pu être modifié.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le processus en cours n’a pas l’accès requis pour ouvrir le fichier.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="fileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nouvelle longueur du flux.</param>
        <summary>Définit la longueur de ce flux à la valeur donnée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.IO.Stream.SetLength%2A>.  
  
 Si la valeur donnée est inférieure à la longueur actuelle du flux de données, le flux est tronqué. Dans ce scénario, si la position actuelle est supérieure à la nouvelle longueur, la position actuelle est déplacée vers le dernier octet du flux. Si la valeur donnée est supérieure à la longueur actuelle du flux de données, le flux est développé, et la position actuelle reste le même. Si le flux est développé, le contenu du flux de données entre l’ancienne et la nouvelle longueur est non défini.  
  
 Un flux doit prendre en charge écriture et la recherche pour `SetLength` fonctionne.  
  
> [!NOTE]
>  Utilisez le <xref:System.IO.FileStream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture et le <xref:System.IO.FileStream.CanSeek%2A> propriété afin de déterminer si le recherche est pris en charge. Pour plus d'informations, consultez <xref:System.IO.Stream.CanWrite%2A> et <xref:System.IO.Stream.CanSeek%2A>.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge l’écriture et la recherche.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Tentative de définir le paramètre <paramref name="value" /> sur une valeur inférieure à 0.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Unlock : int64 * int64 -&gt; unit&#xA;override this.Unlock : int64 * int64 -&gt; unit" Usage="fileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Début de la plage à déverrouiller.</param>
        <param name="length">Plage à déverrouiller.</param>
        <summary>Permet l'accès par d'autres processus à tout ou partie d'un fichier préalablement verrouillé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment verrouiller une partie d’un fichier pour un autre processus ne peut pas accéder à cette partie du fichier, bien qu’il ait accès en lecture/écriture au fichier et déverrouiller la partie spécifiée du fichier. Exécutez le programme simultanément dans différentes fenêtres de commande et d’examiner en utilisant les options d’entrée de console différentes.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> ou <paramref name="length" /> est un nombre négatif.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="fileStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Mémoire tampon qui contient les données à écrire dans le flux.</param>
        <param name="offset">Le décalage en octets, commençant à zéro, dans <c>array</c>, où commencer la copie des octets dans le flux.</param>
        <param name="count">Nombre maximal d'octets à écrire.</param>
        <summary>Écrit un bloc d'octets dans le flux de fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.IO.Stream.Write%2A>.  
  
 Le `offset` paramètre indique l’offset d’octet dans `array` (l’index de la mémoire tampon) à partir duquel commencer la copie et le `count` paramètre indique le nombre d’octets qui seront écrits dans le flux. Si l’opération d’écriture réussite, la position actuelle du flux est avancée par le nombre d’octets écrits. Si une exception se produit, la position actuelle du flux est inchangée.  
  
> [!NOTE]
>  Utilisez le <xref:System.IO.FileStream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture. Pour plus d'informations, consultez <xref:System.IO.Stream.CanWrite%2A>.  
  
 N’interrompez pas un thread qui exécute une opération d’écriture. Bien que l’application peut sembler s’exécuter correctement une fois que le thread est débloqué, l’interruption peut diminuer de performances et la fiabilité de votre application.  
  
 Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.IO.FileStream.Lock%2A> (méthode).  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> et <paramref name="count" /> décrivent une plage non valide dans <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.  
  
\- ou - 
Un autre thread a peut-être provoqué une modification inattendue de la position du descripteur de fichier du système d’exploitation.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.NotSupportedException">L’instance du flux actuel ne prend pas en charge l’écriture.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Mémoire tampon dont sont issues les données à écrire.</param>
        <param name="offset">Le décalage en octets, commençant à zéro, dans <c>buffer</c>, où commencer la copie des octets dans le flux.</param>
        <param name="count">Nombre maximal d'octets à écrire.</param>
        <param name="cancellationToken">Jeton pour surveiller les requêtes d'annulation.</param>
        <summary>Écrit de façon asynchrone une séquence d'octets dans le flux actuel, avance la position actuelle dans ce flux du nombre d'octets écrits et surveille les demandes d'annulation.</summary>
        <returns>Tâche qui représente l’opération d’écriture asynchrone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.FileStream.WriteAsync%2A> méthode vous permet d’effectuer des opérations gourmandes en ressources de fichier sans bloquer le thread principal. Cette considération de performance est particulièrement importante dans une application [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] ou une application [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] où une longue opération de flux peut bloquer le thread d'interface utilisateur et faire que l'application s'affiche comme si elle ne fonctionnait pas. Les méthodes asynchrones sont utilisées conjointement avec la `async` et `await` mots clés dans Visual Basic et c#.  
  
 Utilisez le <xref:System.IO.FileStream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture.  
  
 Si l’opération est annulée avant la fin, la tâche retournée contient le <xref:System.Threading.Tasks.TaskStatus.Canceled> valeur pour le <xref:System.Threading.Tasks.Task.Status%2A> propriété. Si le handle vers le fichier est supprimé, la tâche retournée contient le <xref:System.ObjectDisposedException> exception dans le <xref:System.Threading.Tasks.Task.Exception%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant montre comment écrire de façon asynchrone dans un fichier.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.ArgumentException">La somme de <paramref name="offset" /> et de <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge l'écriture.</exception>
        <exception cref="T:System.ObjectDisposedException">Le flux a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">Le flux est actuellement utilisé par une opération d’écriture précédente.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="fileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Octet à écrire dans le flux.</param>
        <summary>Écrit un octet à la position actuelle dans le flux de fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.IO.Stream.WriteByte%2A>.  
  
 Utilisez `WriteByte` pour écrire un octet à un `FileStream` efficacement. Si le flux est fermé ou non accessible en écriture, une exception sera levée.  
  
> [!NOTE]
>  Utilisez le <xref:System.IO.FileStream.CanWrite%2A> propriété afin de déterminer si l’instance actuelle prend en charge l’écriture. Pour plus d'informations, consultez <xref:System.IO.Stream.CanWrite%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment écrire des données dans un fichier, octet par octet et vérifiez que les données ont été écrites correctement.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le flux est fermé.</exception>
        <exception cref="T:System.NotSupportedException">Le flux ne prend pas en charge l'écriture.</exception>
        <block subset="none" type="overrides">
          <para>L’implémentation par défaut sur <see langword="Stream" /> crée un tableau d’un octet, puis appelle <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Bien que ce soit correct, il est inefficace. N’importe quel flux avec une mémoire tampon interne doit substituer cette méthode et fournir une version beaucoup plus efficace qui lit la mémoire tampon directement, vous évitant l’allocation de tableau supplémentaire à chaque appel.  
  
Pour obtenir la liste de fichiers courants et les opérations d’annuaire, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</para>
        </block>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Comment : lire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
  </Members>
</Type>