<Type Name="Directory" FullName="System.IO.Directory">
  <Metadata><Meta Name="ms.openlocfilehash" Value="404147596b914bcb31c0227ac1ff5df12042865f" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65014025" /></Metadata><TypeSignature Language="C#" Value="public static class Directory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Directory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Directory" />
  <TypeSignature Language="VB.NET" Value="Public Class Directory" />
  <TypeSignature Language="C++ CLI" Value="public ref class Directory abstract sealed" />
  <TypeSignature Language="F#" Value="type Directory = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Expose des méthodes statiques pour créer, se déplacer dans et énumérer des répertoires et sous-répertoires. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.IO.Directory> classe pour les opérations courantes telles que la copie, le déplacement, changement de nom, création et suppression de répertoires.  
  
-   Pour créer un répertoire, utilisez une de la <xref:System.IO.Directory.CreateDirectory%2A> méthodes.  
  
-   Pour supprimer un répertoire, utilisez une de la <xref:System.IO.Directory.Delete%2A> méthodes.  
  
-   Pour obtenir ou définir le répertoire actuel pour une application, utilisez le <xref:System.IO.Directory.GetCurrentDirectory%2A> ou <xref:System.IO.Directory.SetCurrentDirectory%2A> (méthode).  
  
-   Pour manipuler <xref:System.DateTime> informations relatives à la création, l’accès et l’écriture d’un répertoire, utilisent les méthodes telles que <xref:System.IO.Directory.SetLastAccessTime%2A> et <xref:System.IO.Directory.SetCreationTime%2A>.  
  
 Les méthodes statiques de la <xref:System.IO.Directory> classe effectuer des vérifications de sécurité sur toutes les méthodes. Si vous souhaitez réutiliser un objet plusieurs fois, envisagez d’utiliser la méthode d’instance correspondante de <xref:System.IO.DirectoryInfo> au lieu de cela, étant donné que la vérification de la sécurité sera pas toujours être nécessaire.  
  
 Si vous effectuez une seule action dépendant de l’annuaire, il peut être plus efficace d’utiliser statique <xref:System.IO.Directory> méthode plutôt qu’un <xref:System.IO.DirectoryInfo> méthode d’instance. La plupart des <xref:System.IO.Directory> méthodes nécessitent le chemin d’accès au répertoire que vous manipulez.  
  
> [!NOTE]
>  Dans les membres qui acceptent une chaîne `path` paramètre, ce chemin d’accès doit être bien formée ou une exception est levée. Par exemple, si un chemin d’accès est qualifié complet mais commence par un espace (« c:\temp »), la chaîne de chemin d’accès n’est pas tronquée, afin que le chemin d’accès est considéré comme incorrect et une exception est levée. En outre, un chemin d’accès ou une combinaison de chemins d’accès ne peut pas être qualifiée à deux reprises. Par exemple, « c:\temp c:\windows » déclenche également une exception. Assurez-vous que vos chemins sont correctement construits lors de l’utilisation des méthodes qui acceptent une chaîne de chemin d’accès. Pour plus d'informations, consultez <xref:System.IO.Path>.  
  
 Dans les membres qui acceptent un chemin d’accès, le chemin d’accès peut faire référence à un fichier ou un répertoire. Vous pouvez utiliser un chemin d’accès complet, un chemin d’accès relatif ou un chemin d’accès UNC Universal Naming Convention () pour un nom de serveur et le partage. Par exemple, tous les éléments suivants sont des chemins d’accès acceptables :  
  
-   « c:\\\MyDir » en c# ou « c:\MyDir » en Visual Basic.  
  
-   « MyDir\\\MySubdir » en c# ou « Monrépertoire\monsousrépertoire » en Visual Basic.  
  
-   «\\\\\\\MyServer\\\MyShare » en c#, ou «\\\MyServer\MyShare » en Visual Basic.  
  
 Par défaut, l’accès complet en lecture/écriture pour les nouveaux répertoires est accordé à tous les utilisateurs. Toutefois, l’application doit avoir la sécurité appropriées pour accéder aux répertoires existants.  
  
 Pour demander des autorisations pour un répertoire et tous ses sous-répertoires, fin de la chaîne de chemin d’accès avec le caractère de séparation de répertoire. (Par exemple, « C:\Temp\\« accorde l’accès à C:\Temp\ et tous ses sous-répertoires.) Pour demander des autorisations uniquement pour un répertoire spécifique, la chaîne de chemin d’accès par un point de fin. (Par exemple, « C:\Temp\\. » accorde l’accès uniquement aux C:\Temp\\, et non à ses sous-répertoires.)  
  
 Dans les membres qui acceptent un `searchPattern` paramètre, la chaîne de recherche peut être n’importe quelle combinaison de caractères littéraux et les deux caractères génériques ; \* et ?. Ce paramètre ne reconnaît pas les expressions régulières. Pour plus d’informations, consultez le <xref:System.IO.Directory.EnumerateDirectories%28System.String%2CSystem.String%29> méthode ou toute autre méthode qui utilise le `searchPattern` paramètre.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 <xref:System.IO.Directory> et <xref:System.IO.DirectoryInfo> ne sont pas pris en charge pour une utilisation dans [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] applications. Pour plus d’informations sur la façon d’accéder aux fichiers et dossiers dans [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, consultez l’article [l’accès aux données et les fichiers (applications du Windows Store)](https://msdn.microsoft.com/library/windows/apps/hh758319.aspx).  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer tous les fichiers texte à partir d’un répertoire et de les déplacer vers un nouveau répertoire. Une fois que les fichiers sont déplacés, ils n’existent plus dans le répertoire d’origine.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 L’exemple suivant montre comment utiliser le <xref:System.IO.Directory.EnumerateFiles%2A> méthode pour récupérer une collection de fichiers texte à partir d’un répertoire et ensuite utiliser ce regroupement dans une requête pour rechercher toutes les lignes qui contiennent « Exemple ».  
  
 [!code-csharp[System.IO.Directory#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class3.cs#11)]
 [!code-vb[System.IO.Directory#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class3.vb#11)]  
  
 L’exemple suivant montre comment déplacer un répertoire et tous ses fichiers vers un nouveau répertoire. Le répertoire d’origine n’existe plus après que qu’il a été déplacé.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.DirectoryInfo" />
    <altmember cref="T:System.IO.FileInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procédure : lire et écrire dans un fichier de données créé récemment</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateDirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée tous les répertoires dans un chemin d'accès spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Répertoire à créer.</param>
        <summary>Crée tous les répertoires et sous-répertoires dans le chemin d'accès spécifié, sauf s'ils existent déjà.</summary>
        <returns>Objet qui représente le répertoire dans le chemin d'accès spécifié. Cet objet est retourné, qu'un répertoire existe déjà ou non dans le chemin d'accès spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tous les répertoires spécifiés dans `path` sont créés, sauf s’ils existent déjà ou si une partie du `path` n’est pas valide. Si le répertoire existe déjà, cette méthode ne crée pas un nouveau répertoire, mais elle retourne un <xref:System.IO.DirectoryInfo> objet pour le répertoire existant.  
  
 Le `path` paramètre spécifie un chemin de répertoire, pas un chemin d’accès de fichier.  
  
 Les espaces à droite sont supprimés à la fin de la `path` paramètre avant de créer le répertoire.  
  
 Vous pouvez créer un répertoire sur un ordinateur distant, sur un partage que vous avez un accès en écriture. Chemins d’accès UNC sont prises en charge ; par exemple, vous pouvez spécifier les informations suivantes pour `path`: `\\2009\Archives\December` en Visual Basic, et `\\\\2009\\Archives\\December` en c#.  
  
 Création d’un répertoire avec uniquement le caractère deux-points ( :)) n’est pas pris en charge et entraîne un `NotSupportedException` levée.  
  
   
  
## Examples  
 L’exemple suivant crée et supprime le répertoire spécifié.  
  
 [!code-cpp[Dir_CreateDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_CreateDir/CPP/dir_createdir.cpp#1)]
 [!code-csharp[Dir_CreateDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_CreateDir/CS/dir_createdir.cs#1)]
 [!code-vb[Dir_CreateDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_CreateDir/VB/dir_createdir.vb#1)]  
  
 Pour créer le répertoire C:\Users\User1\Public\Html lorsque le répertoire actif est C:\Users\User1, utilisez un des appels suivants pour garantir que la barre oblique inverse est interprétée correctement.  
  
 En Visual Basic :  
  
```  
Directory.CreateDirectory("Public\Html")   
    Directory.CreateDirectory("\Users\User1\Public\Html")   
    Directory.CreateDirectory("c:\Users\User1\Public\Html")  
```  
  
 En C# :  
  
```  
Directory.CreateDirectory("Public\\Html");  
    Directory.CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory.CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 En C++ :  
  
```  
Directory::CreateDirectory("Public\\Html");  
    Directory::CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory::CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié par <paramref name="path" /> est un fichier.  
  
ou 
Le nom de réseau est inconnu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
 Le préfixe ou le contenu de <paramref name="path" /> est uniquement un signe deux-points (:).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> contient un signe deux-points (:) qui ne fait pas partie d’une étiquette de lecteur (" C:\\ ").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers ou répertoires. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Répertoire à créer.</param>
        <param name="directorySecurity">Contrôle d'accès à appliquer au répertoire.</param>
        <summary>Crée tous les répertoires dans le chemin d'accès spécifié, sauf s'ils existent déjà, en appliquant la sécurité Windows spécifiée.</summary>
        <returns>Objet qui représente le répertoire dans le chemin d'accès spécifié. Cet objet est retourné, qu'un répertoire existe déjà ou non dans le chemin d'accès spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge de méthode pour créer un répertoire avec le contrôle d’accès, il n’existe aucune chance que le répertoire est accessible avant que la sécurité est appliquée.  
  
 Tous les répertoires spécifiés dans le `path` paramètre sont créés, sauf s’ils existent déjà ou si une partie du `path` n’est pas valide. Le `path` paramètre spécifie un chemin de répertoire, pas un chemin d’accès de fichier. Si le répertoire existe déjà, cette méthode ne crée pas un nouveau répertoire, mais elle retourne un <xref:System.IO.DirectoryInfo> objet pour le répertoire existant.  
  
 Les espaces à droite sont supprimés à la fin de la `path` paramètre avant de créer le répertoire.  
  
 Vous pouvez créer un répertoire sur un ordinateur distant, sur un partage que vous avez un accès en écriture. Chemins d’accès UNC sont prises en charge ; par exemple, vous pouvez spécifier les informations suivantes pour `path`: `\\2009\Archives\December` en Visual Basic, et `\\\\2009\\Archives\\December` en c#.  
  
 Création d’un répertoire avec uniquement le caractère deux-points ( :)) n’est pas pris en charge et provoque un `NotSupportedException` levée.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau répertoire avec les règles d’accès pour les deux comptes d’utilisateur.  
  
 [!code-csharp[System.IO.Directory#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class7.cs#15)]
 [!code-vb[System.IO.Directory#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class7.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié par <paramref name="path" /> est un fichier.  
  
ou 
Le nom de réseau est inconnu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
 Le préfixe ou le contenu de <paramref name="path" /> est uniquement un signe deux-points (:).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> contient un signe deux-points (:) qui ne fait pas partie d’une étiquette de lecteur (" C:\\ ").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers et des répertoires et pour l’accès au répertoire de destination. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime un répertoire spécifié, et éventuellement tous ses sous-répertoires.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Directory.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nom du répertoire vide à supprimer. Ce répertoire doit être accessible en écriture et vide.</param>
        <summary>Supprime un répertoire vide dans un chemin d’accès spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se comporte comme <xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29> avec `false` spécifiée pour le deuxième paramètre.  
  
 Le `path` paramètre peut spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Les espaces à droite sont supprimés à la fin de la `path` paramètre avant de supprimer le répertoire.  
  
 Cette méthode lève un <xref:System.IO.IOException> si le répertoire spécifié dans le `path` paramètre contient les fichiers ou sous-répertoires.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Dans certains cas, si le répertoire spécifié est ouvert dans l’Explorateur de fichiers, le <xref:System.IO.Directory.Delete%2A> (méthode) n’est peut-être pas en mesure de le supprimer.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un nouveau répertoire et un sous-répertoire et ensuite supprimer uniquement le sous-répertoire.  
  
 [!code-csharp[System.IO.Directory.Delete#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class1.cs#1)]
 [!code-vb[System.IO.Directory.Delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Un fichier ayant les mêmes nom et emplacement spécifiés par <paramref name="path" /> existe.  
  
ou 
Le répertoire correspond au répertoire de travail actuel de l’application.  
  
ou 
Le répertoire spécifié par <paramref name="path" /> n’est pas vide.  
  
ou 
Le répertoire est en lecture seule ou contient un fichier en lecture seule.  
  
ou 
Le répertoire est utilisé par un autre processus.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’existe pas ou est introuvable.  
  
ou 
Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le répertoire spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path, bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path, bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String, recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path, bool recursive);" />
      <MemberSignature Language="F#" Value="static member Delete : string * bool -&gt; unit" Usage="System.IO.Directory.Delete (path, recursive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Nom du répertoire à supprimer.</param>
        <param name="recursive"><see langword="true" /> pour supprimer les répertoires, sous-répertoires et fichiers dans le chemin d’accès indiqué par <paramref name="path" /> ; sinon, <see langword="false" />.</param>
        <summary>Supprime le répertoire spécifié et, si c’est indiqué, tous les sous-répertoires et fichiers qu’il contient.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre peut spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Les espaces à droite sont supprimés à la fin de la `path` paramètre avant de supprimer le répertoire.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Si le `recursive` paramètre est `true`, l’utilisateur doit avoir l’autorisation d’écriture pour le répertoire actif, ainsi que pour tous les sous-répertoires.  
  
 Le comportement de cette méthode diffère légèrement lors de la suppression d’un répertoire qui contient un point d’analyse, comme un lien symbolique ou un point de montage. Si le point d’analyse est un répertoire, comme un point de montage, il est démonté et le point de montage est supprimé. Cette méthode n’est pas récursive via le point d’analyse. Si le point d’analyse est un lien symbolique vers un fichier, le point d’analyse est supprimé et pas la cible du lien symbolique.  
  
 Dans certains cas, si le répertoire spécifié est ouvert dans l’Explorateur de fichiers, le <xref:System.IO.Directory.Delete%2A> (méthode) n’est peut-être pas en mesure de le supprimer.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un nouveau répertoire, un sous-répertoire et un fichier dans le sous-répertoire, et puis les supprimer de manière récursive tous les nouveaux éléments.  
  
 [!code-csharp[System.IO.Directory.Delete#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class2.cs#2)]
 [!code-vb[System.IO.Directory.Delete#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Un fichier ayant les mêmes nom et emplacement spécifiés par <paramref name="path" /> existe.  
  
ou 
Le répertoire spécifié par <paramref name="path" /> est accessible en lecture seule, ou <paramref name="recursive" /> a la valeur <see langword="false" /> et <paramref name="path" /> n’est pas un répertoire vide.  
  
ou 
Le répertoire correspond au répertoire de travail actuel de l’application.  
  
ou 
Le répertoire contient un fichier en lecture seule.  
  
ou 
Le répertoire est utilisé par un autre processus.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’existe pas ou est introuvable.  
  
ou 
Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le répertoire spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une collection énumérable des noms de répertoires qui répondent aux critères spécifiés.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <summary>Retourne une collection énumérable de noms de répertoires dans un chemin d'accès spécifié.</summary>
        <returns>Collection énumérable des noms d’affichage (chemins d’accès compris) pour les répertoires du répertoire spécifié par <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez spécifier les informations de chemin d’accès relatif ou absolu dans le `path` paramètre. Informations de chemin d’accès relatif sont interprétées comme étant relatif le répertoire de travail actuel, vous pouvez déterminer à l’aide de la <xref:System.IO.Directory.GetCurrentDirectory%2A> (méthode). Les noms de répertoire retournés sont précédés de la valeur que vous avez fourni dans le `path` paramètre. Par exemple, si vous fournissez un chemin d’accès relatif dans le `path` paramètre, les noms de répertoires retourné contiendra un chemin d’accès relatif.  
  
 Le <xref:System.IO.Directory.EnumerateDirectories%2A> et <xref:System.IO.Directory.GetDirectories%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateDirectories%2A>, vous pouvez commencer à énumérer la collection de noms avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetDirectories%2A>, vous devez attendre la totalité du tableau de noms à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateDirectories%2A> peut s’avérer plus efficace.  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> sur la collection démarre une nouvelle énumération.  
  
   
  
## Examples  
 L’exemple suivant énumère les répertoires de niveau supérieur dans un chemin d’accès spécifié.  
  
 [!code-csharp[System.IO.EnumDirs1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs1/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs1/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient des caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’est pas valide, notamment s’il fait référence à un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de répertoires dans <paramref name="path" />.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <summary>Retourne une collection énumérable des noms de répertoires qui correspondent à un modèle de recherche dans un chemin d'accès spécifié.</summary>
        <returns>Collection énumérable des noms complets (chemins d’accès compris) pour les répertoires du répertoire spécifié par <paramref name="path" /> et qui correspondent au modèle de recherche spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|\* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère dans cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, le `searchPattern` chaîne «\*t » recherche tous les noms dans `path` se terminant par la lettre « t ». Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 `searchPattern` ne peut pas se terminer par deux points («.. ») ni contenir deux points («.. ») suivie <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, ni contenir les caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Vous pouvez spécifier les informations de chemin d’accès relatif ou absolu dans le `path` paramètre. Informations de chemin d’accès relatif sont interprétées comme étant relatif le répertoire de travail actuel, vous pouvez déterminer à l’aide de la <xref:System.IO.Directory.GetCurrentDirectory%2A> (méthode). Les noms de répertoire retournés sont précédés de la valeur que vous avez fourni dans le `path` paramètre. Par exemple, si vous fournissez un chemin d’accès relatif dans le `path` paramètre, les noms de répertoires retourné contiendra un chemin d’accès relatif.  
  
 Le <xref:System.IO.Directory.EnumerateDirectories%2A> et <xref:System.IO.Directory.GetDirectories%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateDirectories%2A>, vous pouvez commencer à énumérer la collection de noms avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetDirectories%2A>, vous devez attendre la totalité du tableau de noms à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateDirectories%2A> peut s’avérer plus efficace.  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> sur la collection démarre une nouvelle énumération.  
  
   
  
## Examples  
 L’exemple suivant énumère les répertoires de niveau supérieur dans un chemin d’accès spécifié qui correspondent à un modèle de recherche spécifié.  
  
 [!code-csharp[System.IO.EnumDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs2/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs2/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient des caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
 <paramref name="searchPattern" /> ne contient pas un modèle valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="searchPattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’est pas valide, notamment s’il fait référence à un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de répertoires dans <paramref name="path" />.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <param name="searchOption">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou si elle doit inclure tous les sous-répertoires.  
  
La valeur par défaut est <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retourne une collection énumérable des noms de répertoires qui correspondent à un modèle de recherche dans un chemin d’accès spécifié, et effectue éventuellement la recherche dans les sous-répertoires.</summary>
        <returns>Collection énumérable des noms complets (chemins d’accès compris) pour les répertoires du répertoire spécifié par <paramref name="path" /> et qui correspondent au modèle et à l’option de recherche spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|\* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Exactement un caractère dans cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, le `searchPattern` chaîne «\*t » recherche tous les noms dans `path` se terminant par la lettre « t ». Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 `searchPattern` ne peut pas se terminer par deux points («.. ») ni contenir deux points («.. ») suivie <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, ni contenir les caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Vous pouvez spécifier les informations de chemin d’accès relatif ou absolu dans le `path` paramètre. Informations de chemin d’accès relatif sont interprétées comme étant relatif le répertoire de travail actuel, vous pouvez déterminer à l’aide de la <xref:System.IO.Directory.GetCurrentDirectory%2A> (méthode). Les noms de répertoire retournés sont précédés de la valeur que vous avez fourni dans le `path` paramètre. Par exemple, si vous fournissez un chemin d’accès relatif dans le `path` paramètre, les noms de répertoires retourné contiendra un chemin d’accès relatif.  
  
 Le <xref:System.IO.Directory.EnumerateDirectories%2A> et <xref:System.IO.Directory.GetDirectories%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateDirectories%2A>, vous pouvez commencer à énumérer la collection de noms avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetDirectories%2A>, vous devez attendre la totalité du tableau de noms à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateDirectories%2A> peut s’avérer plus efficace.  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> sur la collection démarre une nouvelle énumération.  
  
   
  
## Examples  
 L’exemple suivant énumère les répertoires dans un chemin d’accès spécifié qui correspondent à un modèle de recherche spécifié. Il utilise le `searchOption` paramètre pour spécifier que tous les sous-répertoires doivent être inclus dans la recherche.  
  
 [!code-csharp[System.IO.EnumDirs3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs3/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs3/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient des caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
 <paramref name="searchPattern" /> ne contient pas un modèle valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="searchPattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> n’est pas une valeur de <see cref="T:System.IO.SearchOption" /> valide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’est pas valide, notamment s’il fait référence à un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une collection énumérable de noms de fichiers qui répondent à des critères spécifiés.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <summary>Retourne une collection énumérable de noms de fichiers dans un chemin d'accès spécifié.</summary>
        <returns>Collection énumérable des noms d’affichage (chemins d’accès compris) pour les fichiers du répertoire spécifié par <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez spécifier les informations de chemin d’accès relatif avec la `path` paramètre. Informations de chemin d’accès relatif sont interprétées comme étant relatif le répertoire de travail actuel, vous pouvez déterminer à l’aide de la <xref:System.IO.Directory.GetCurrentDirectory%2A> (méthode).  
  
 Le <xref:System.IO.Directory.EnumerateFiles%2A> et <xref:System.IO.Directory.GetFiles%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateFiles%2A>, vous pouvez commencer à énumérer la collection de noms avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetFiles%2A>, vous devez attendre la totalité du tableau de noms à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateFiles%2A> peut s’avérer plus efficace.  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> sur la collection démarre une nouvelle énumération.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer tous les fichiers dans un répertoire et de les déplacer vers un nouveau répertoire. Une fois que les fichiers sont déplacés, ils n’existent plus dans le répertoire d’origine.  
  
 [!code-csharp[System.IO.Directory#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class4.cs#12)]
 [!code-vb[System.IO.Directory#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class4.vb#12)]  
  
 L’exemple suivant énumère les fichiers dans le répertoire spécifié, lit chaque ligne du fichier et affiche la ligne si elle contient la chaîne « Europe ».  
  
 [!code-csharp[System.IO.Directory.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient des caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’est pas valide, notamment s’il fait référence à un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de fichiers dans <paramref name="path" />.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <summary>Retourne une collection énumérable des noms de fichiers qui correspondent à un modèle de recherche dans un chemin d'accès spécifié.</summary>
        <returns>Collection énumérable des noms complets (chemins d’accès compris) pour les fichiers du répertoire spécifié par <paramref name="path" /> et qui correspondent au modèle de recherche spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|\* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère dans cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, le `searchPattern` chaîne «\*t » recherche tous les noms dans `path` se terminant par la lettre « t ». Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
> [!NOTE]
>  Lorsque vous utilisez le caractère générique astérisque dans un `searchPattern` tel que «\*.txt », le nombre de caractères dans l’extension spécifiée a une incidence sur la recherche comme suit :  
>   
> -   Si l’extension spécifiée est exactement trois caractères, la méthode retourne les fichiers portant les extensions qui commencent avec l’extension spécifiée. Par exemple, «\*.xls » retourne « book.xls » et « book.xlsx ».  
> -   Dans tous les autres cas, la méthode retourne les fichiers qui correspondent exactement à l’extension spécifiée. Par exemple, «\*.ai » retourne « file.ai » mais pas « file.aif ».  
>   
>  Lorsque vous utilisez le caractère générique de point d’interrogation, cette méthode retourne uniquement les fichiers qui correspondent à l’extension de fichier spécifié. Par exemple, prenons deux fichiers, « file1.txt » et « fichier1.txtautre » situés dans un répertoire, un modèle de recherche de « fichier ?. txt » retourne simplement le premier fichier, alors qu’un modèle de recherche de « fichier\*.txt » renvoie les deux fichiers.  
  
 `searchPattern` ne peut pas se terminer par deux points («.. ») ni contenir deux points («.. ») suivie <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, ni contenir les caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Vous pouvez spécifier les informations de chemin d’accès relatif avec la `path` paramètre. Informations de chemin d’accès relatif sont interprétées comme étant relatif le répertoire de travail actuel, vous pouvez déterminer à l’aide de la <xref:System.IO.Directory.GetCurrentDirectory%2A> (méthode).  
  
 Le <xref:System.IO.Directory.EnumerateFiles%2A> et <xref:System.IO.Directory.GetFiles%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateFiles%2A>, vous pouvez commencer à énumérer la collection de noms avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetFiles%2A>, vous devez attendre la totalité du tableau de noms à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateFiles%2A> peut s’avérer plus efficace.  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> sur la collection démarre une nouvelle énumération.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer tous les fichiers texte dans un répertoire et de les déplacer vers un nouveau répertoire. Une fois que les fichiers sont déplacés, ils n’existent plus dans le répertoire d’origine.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 L’exemple suivant énumère les fichiers dans le répertoire spécifié qui ont une extension .txt, lit chaque ligne du fichier et affiche la ligne si elle contient la chaîne « Europe ».  
  
 [!code-csharp[System.IO.Directory.EnumFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles2/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles2/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient des caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
 <paramref name="searchPattern" /> ne contient pas un modèle valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="searchPattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’est pas valide, notamment s’il fait référence à un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de fichiers dans <paramref name="path" />.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <param name="searchOption">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou si elle doit inclure tous les sous-répertoires.  
  
La valeur par défaut est <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retourne une collection énumérable des noms de fichiers qui correspondent à un modèle de recherche dans un chemin d'accès spécifié, et effectue éventuellement des recherches dans les sous-répertoires.</summary>
        <returns>Collection énumérable des noms complets (chemins d’accès compris) pour les fichiers du répertoire spécifié par <paramref name="path" /> et qui correspondent au modèle et à l’option de recherche spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|\* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère dans cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, le `searchPattern` chaîne «\*t » recherche tous les noms dans `path` se terminant par la lettre « t ». Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
> [!NOTE]
>  Lorsque vous utilisez le caractère générique astérisque dans un `searchPattern` tel que «\*.txt », le nombre de caractères dans l’extension spécifiée a une incidence sur la recherche comme suit :  
>   
> -   Si l’extension spécifiée est exactement trois caractères, la méthode retourne les fichiers portant les extensions qui commencent avec l’extension spécifiée. Par exemple, «\*.xls » retourne « book.xls » et « book.xlsx ».  
> -   Dans tous les autres cas, la méthode retourne les fichiers qui correspondent exactement à l’extension spécifiée. Par exemple, «\*.ai » retourne « file.ai » mais pas « file.aif ».  
>   
>  Lorsque vous utilisez le caractère générique de point d’interrogation, cette méthode retourne uniquement les fichiers qui correspondent à l’extension de fichier spécifié. Par exemple, prenons deux fichiers, « file1.txt » et « fichier1.txtautre » situés dans un répertoire, un modèle de recherche de « fichier ?. txt » retourne simplement le premier fichier, alors qu’un modèle de recherche de « fichier\*.txt » renvoie les deux fichiers.  
  
 `searchPattern` ne peut pas se terminer par deux points («.. ») ni contenir deux points («.. ») suivie <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, ni contenir les caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Vous pouvez spécifier les informations de chemin d’accès relatif avec la `path` paramètre. Informations de chemin d’accès relatif sont interprétées comme étant relatif le répertoire de travail actuel, vous pouvez déterminer à l’aide de la <xref:System.IO.Directory.GetCurrentDirectory%2A> (méthode).  
  
 Le <xref:System.IO.Directory.EnumerateFiles%2A> et <xref:System.IO.Directory.GetFiles%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateFiles%2A>, vous pouvez commencer à énumérer la collection de noms avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetFiles%2A>, vous devez attendre la totalité du tableau de noms à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateFiles%2A> peut s’avérer plus efficace.  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> sur la collection démarre une nouvelle énumération.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer tous les fichiers texte dans un répertoire et ses sous-répertoires et de les déplacer vers un nouveau répertoire. Une fois que les fichiers sont déplacés, ils n’existent plus dans les répertoires d’origine.  
  
 [!code-csharp[System.IO.Directory#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class5.cs#13)]
 [!code-vb[System.IO.Directory#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class5.vb#13)]  
  
 Le de manière récursive exemple suivante énumère tous les fichiers qui ont une extension .txt, lit chaque ligne du fichier et affiche la ligne si elle contient la chaîne « Microsoft ».  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient des caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
 <paramref name="searchPattern" /> ne contient pas un modèle valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="searchPattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> n’est pas une valeur de <see cref="T:System.IO.SearchOption" /> valide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’est pas valide, notamment s’il fait référence à un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une collection énumérable d'entrées de système de fichiers qui répondent à des critères spécifiés.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <summary>Retourne une collection énumérable de noms de fichiers et de noms de répertoires dans un chemin d’accès spécifié.</summary>
        <returns>Collection énumérable des entrées de système de fichiers dans le répertoire spécifié par <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez spécifier les informations de chemin d’accès relatif avec la `path` paramètre. Informations de chemin d’accès relatif sont interprétées comme étant relatif le répertoire de travail actuel, vous pouvez déterminer à l’aide de la <xref:System.IO.Directory.GetCurrentDirectory%2A> (méthode).  
  
 Le <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> et <xref:System.IO.Directory.GetFileSystemEntries%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, vous pouvez commencer à énumérer la collection d’entrées avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetFileSystemEntries%2A>, vous devez attendre la totalité du tableau d’entrées à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateFiles%2A> peut s’avérer plus efficace.  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> sur la collection démarre une nouvelle énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient des caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’est pas valide, notamment s’il fait référence à un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms des entrées du système de fichiers dans <paramref name="path" />.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <summary>Retourne une collection énumérable des noms de fichiers et des noms de répertoires qui correspondent à un modèle de recherche dans un chemin d’accès spécifié.</summary>
        <returns>Collection énumérable des entrées du système de fichiers dans le répertoire spécifié par <paramref name="path" /> et qui correspondent au modèle de recherche spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`. 
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|\* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère dans cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, le `searchPattern` chaîne «\*t » recherche tous les noms dans `path` se terminant par la lettre « t ». Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
> [!NOTE]
>  Lorsque vous utilisez le caractère générique astérisque dans un `searchPattern` tel que «\*.txt », le nombre de caractères dans l’extension spécifiée a une incidence sur la recherche comme suit :  
>   
> -   Si l’extension spécifiée est exactement trois caractères, la méthode retourne les fichiers portant les extensions qui commencent avec l’extension spécifiée. Par exemple, «\*.xls » retourne « book.xls » et « book.xlsx ».  
> -   Dans tous les autres cas, la méthode retourne les fichiers qui correspondent exactement à l’extension spécifiée. Par exemple, «\*.ai » retourne « file.ai » mais pas « file.aif ».  
>   
>  Lorsque vous utilisez le caractère générique de point d’interrogation, cette méthode retourne uniquement les fichiers qui correspondent à l’extension de fichier spécifié. Par exemple, prenons deux fichiers, « file1.txt » et « fichier1.txtautre » situés dans un répertoire, un modèle de recherche de « fichier ?. txt » retourne simplement le premier fichier, alors qu’un modèle de recherche de « fichier\*.txt » renvoie les deux fichiers.  
  
 `searchPattern` ne peut pas se terminer par deux points («.. ») ni contenir deux points («.. ») suivie <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, ni contenir les caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Vous pouvez spécifier les informations de chemin d’accès relatif avec la `path` paramètre. Informations de chemin d’accès relatif sont interprétées comme étant relatif le répertoire de travail actuel, vous pouvez déterminer à l’aide de la <xref:System.IO.Directory.GetCurrentDirectory%2A> (méthode).  
  
 Le <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> et <xref:System.IO.Directory.GetFileSystemEntries%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, vous pouvez commencer à énumérer la collection d’entrées avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetFileSystemEntries%2A>, vous devez attendre la totalité du tableau d’entrées à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateFiles%2A> peut s’avérer plus efficace.  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> sur la collection démarre une nouvelle énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient des caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
 <paramref name="searchPattern" /> ne contient pas un modèle valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="searchPattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’est pas valide, notamment s’il fait référence à un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les entrées de système de fichiers dans <paramref name="path" />.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <param name="searchOption">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou si elle doit inclure tous les sous-répertoires.  
  
La valeur par défaut est <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retourne une collection énumérable des noms de fichiers et des noms de répertoires qui correspondent à un modèle de recherche dans un chemin d'accès spécifié, et effectue éventuellement des recherches dans les sous-répertoires.</summary>
        <returns>Collection énumérable des entrées de système de fichiers dans le répertoire spécifié par <paramref name="path" /> et qui correspondent au modèle et à l’option de recherche spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|\* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère dans cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, le `searchPattern` chaîne «\*t » recherche tous les noms dans `path` se terminant par la lettre « t ». Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
> [!NOTE]
>  Lorsque vous utilisez le caractère générique astérisque dans un `searchPattern` tel que «\*.txt », le nombre de caractères dans l’extension spécifiée a une incidence sur la recherche comme suit :  
>   
> -   Si l’extension spécifiée est exactement trois caractères, la méthode retourne les fichiers portant les extensions qui commencent avec l’extension spécifiée. Par exemple, «\*.xls » retourne « book.xls » et « book.xlsx ».  
> -   Dans tous les autres cas, la méthode retourne les fichiers qui correspondent exactement à l’extension spécifiée. Par exemple, «\*.ai » retourne « file.ai » mais pas « file.aif ».  
>   
>  Lorsque vous utilisez le caractère générique de point d’interrogation, cette méthode retourne uniquement les fichiers qui correspondent à l’extension de fichier spécifié. Par exemple, prenons deux fichiers, « file1.txt » et « fichier1.txtautre » situés dans un répertoire, un modèle de recherche de « fichier ?. txt » retourne simplement le premier fichier, alors qu’un modèle de recherche de « fichier\*.txt » renvoie les deux fichiers.  
  
 `searchPattern` ne peut pas se terminer par deux points («.. ») ni contenir deux points («.. ») suivie <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, ni contenir les caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Vous pouvez spécifier les informations de chemin d’accès relatif avec la `path` paramètre. Informations de chemin d’accès relatif sont interprétées comme étant relatif le répertoire de travail actuel, vous pouvez déterminer à l’aide de la <xref:System.IO.Directory.GetCurrentDirectory%2A> (méthode).  
  
 Le <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> et <xref:System.IO.Directory.GetFileSystemEntries%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, vous pouvez commencer à énumérer la collection d’entrées avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetFileSystemEntries%2A>, vous devez attendre la totalité du tableau d’entrées à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateFiles%2A> peut s’avérer plus efficace.  
  
 La collection retournée n’est pas mis en cache ; chaque appel à la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> sur la collection démarre une nouvelle énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient des caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
 <paramref name="searchPattern" /> ne contient pas un modèle valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="searchPattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> n’est pas une valeur de <see cref="T:System.IO.SearchOption" /> valide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’est pas valide, notamment s’il fait référence à un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.IO.Directory.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès à tester.</param>
        <summary>Détermine si le chemin d'accès donné référence un répertoire existant sur disque.</summary>
        <returns><see langword="true" /> si <paramref name="path" /> référence un répertoire existant ; <see langword="false" /> si le répertoire n’existe pas ou si une erreur se produit quand vous essayez de déterminer si le répertoire spécifié existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel.  
  
 Les espaces à droite sont supprimés à la fin de la `path` paramètre avant de vérifier si le répertoire existe.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Si vous n’avez pas une autorisation en lecture seule minimum au répertoire, le <xref:System.IO.Directory.Exists%2A> méthode retournera `false`.  
  
 Le <xref:System.IO.Directory.Exists%2A> retourne de la méthode `false` si une erreur se produit lors de la tentative déterminer si le fichier spécifié existe. Cela peut se produire dans les situations qui déclenchent des exceptions telles que la transmission d’un nom de fichier avec des caractères non valides ou trop de caractères, un disque défectueux ou manquant, ou si l’appelant n’a pas l’autorisation de lire le fichier.  
  
   
  
## Examples  
 L’exemple suivant prend un tableau de noms de fichier ou répertoire sur la ligne de commande, détermine le type de nom est, elle traite de manière appropriée.  
  
 [!code-cpp[Recursive file finder#2](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#2)]
 [!code-csharp[Recursive file finder#2](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#2)]
 [!code-vb[Recursive file finder#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire les fichiers. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne la liste de contrôle d'accès (ACL) Windows pour un répertoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’un répertoire contenant un objet <see cref="T:System.Security.AccessControl.DirectorySecurity" /> qui décrit les informations ACL du fichier.</param>
        <summary>Obtient un objet <see cref="T:System.Security.AccessControl.DirectorySecurity" /> qui encapsule les entrées de liste de contrôle d’accès (ACL) pour un répertoire spécifié.</summary>
        <returns>Objet qui encapsule les règles de contrôle d’accès pour le fichier décrit par le paramètre <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.Directory.GetAccessControl%2A> méthode pour récupérer les entrées (ACL) pour un répertoire.  
  
 Une liste ACL décrit les individus et/ou les groupes qui ont ou pas de droits à des actions spécifiques sur le fichier donné ou le répertoire. Pour plus d'informations, voir [Procédure : ajouter ou supprimer des entrées dans la liste de contrôle d’accès](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Dans les environnements NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> et <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> sont accordées à l’utilisateur si l’utilisateur a <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> droits sur le dossier parent. Pour refuser <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> et <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, refuser <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> sur le répertoire parent.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.IO.Directory.GetAccessControl%2A> et <xref:System.IO.Directory.SetAccessControl%2A> méthodes pour ajouter un accès à un contrôle d’entrée de liste (ACL) et puis supprimer une entrée ACL dans un répertoire.  Vous devez entrer un compte d'utilisateur ou de groupe valide pour exécuter cet exemple.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ouverture du répertoire.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Windows 2000 ou une version ultérieure.</exception>
        <exception cref="T:System.SystemException">Une erreur est survenue au niveau du système (par exemple, le répertoire est introuvable). L’exception spécifique peut être une sous-classe de <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le paramètre <paramref name="path" /> a spécifié un répertoire accessible en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’autorisation d’énumérer la liste de contrôle d’accès (ACL) pour un répertoire. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Action de sécurité : À la demande.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl (path, includeSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’un répertoire contenant un objet <see cref="T:System.Security.AccessControl.DirectorySecurity" /> qui décrit les informations ACL du fichier.</param>
        <param name="includeSections">Une des valeurs <see cref="T:System.Security.AccessControl.AccessControlSections" /> qui spécifie le type d'informations ACL à recevoir.</param>
        <summary>Obtient un objet <see cref="T:System.Security.AccessControl.DirectorySecurity" /> qui encapsule le type spécifié d’entrées de liste de contrôle d’accès pour un répertoire spécifié.</summary>
        <returns>Objet qui encapsule les règles de contrôle d’accès pour le fichier décrit par le paramètre <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.Directory.GetAccessControl%2A> méthode pour récupérer les entrées (ACL) pour un répertoire.  
  
 Une liste ACL décrit les individus et/ou les groupes qui ont ou pas de droits à des actions spécifiques sur le fichier donné ou le répertoire. Pour plus d'informations, voir [Procédure : ajouter ou supprimer des entrées dans la liste de contrôle d’accès](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Dans les environnements NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> et <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> sont accordées à l’utilisateur si l’utilisateur a <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> droits sur le dossier parent. Pour refuser <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> et <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, refuser <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> sur le répertoire parent.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite lors de l'ouverture du répertoire.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Windows 2000 ou une version ultérieure.</exception>
        <exception cref="T:System.SystemException">Une erreur est survenue au niveau du système (par exemple, le répertoire est introuvable). L’exception spécifique peut être une sous-classe de <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le paramètre <paramref name="path" /> a spécifié un répertoire accessible en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’autorisation d’énumérer la liste de contrôle d’accès (ACL) pour un répertoire. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Action de sécurité : À la demande.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTime : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin du répertoire.</param>
        <summary>Obtient la date et l'heure de création d'un répertoire.</summary>
        <returns>Structure à laquelle est affectée la date/heure de création du répertoire spécifié. Cette valeur est exprimée en heure locale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode peut retourner une valeur inexacte, car elle utilise des fonctions natives dont les valeurs ne peuvent pas continuellement mis à jour par le système d’exploitation.  
  
 Cette méthode est équivalente à <xref:System.IO.File.GetCreationTime%2A?displayProperty=nameWithType>.  
  
 Si le répertoire décrit dans le `path` paramètre n’existe pas, cette méthode retourne 12:00 minuit, le 1er janvier 1601 apr. J.C. (NOTRE ÈRE) Temps universel coordonné (UTC), ajusté à l’heure locale.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant obtient l’heure de création du répertoire spécifié.  
  
 [!code-cpp[Dir_GetCreation#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCreation/CPP/dir_getcreation.cpp#1)]
 [!code-csharp[Dir_GetCreation#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCreation/CS/dir_getcreation.cs#1)]
 [!code-vb[Dir_GetCreation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCreation/VB/dir_getcreation.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire le fichier ou répertoire spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin du répertoire.</param>
        <summary>Obtient la date/heure de création d'un répertoire, au format UTC (Temps universel coordonné).</summary>
        <returns>Structure à laquelle est affectée la date/heure de création du répertoire spécifié. Cette valeur est exprimée en temps UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode peut retourner une valeur inexacte, car elle utilise des fonctions natives dont les valeurs ne peuvent pas continuellement mis à jour par le système d’exploitation.  
  
 Si le répertoire décrit dans le `path` paramètre n’existe pas, cette méthode retourne 12:00 minuit, le 1er janvier 1601 apr. J.C. (NOTRE ÈRE) Temps d’universel coordonné (UTC).  
  
 Utilisez cette méthode pour obtenir l’heure de création d’un répertoire en temps universel coordonné (UTC).  
  
   
  
## Examples  
 L’exemple suivant illustre les différences de sortie lors de l’utilisation de sortie de temps universel coordonné (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire le fichier ou répertoire spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static string GetCurrentDirectory ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCurrentDirectory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentDirectory () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCurrentDirectory();" />
      <MemberSignature Language="F#" Value="static member GetCurrentDirectory : unit -&gt; string" Usage="System.IO.Directory.GetCurrentDirectory " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient le répertoire de travail en cours de l'application.</summary>
        <returns>Chaîne qui contient le chemin absolu du répertoire de travail actuel et qui ne se termine pas par une barre oblique inverse (\\).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le répertoire actif est distinct du répertoire d’origine, qui est celui à partir duquel le processus a démarré.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L'exemple suivant décrit comment utiliser la méthode `GetCurrentDirectory`.  
  
 [!code-cpp[Dir_GetCurDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCurDir/CPP/dir_getcurdir.cpp#1)]
 [!code-csharp[Dir_GetCurDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCurDir/CS/dir_getcurdir.cs#1)]
 [!code-vb[Dir_GetCurDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCurDir/VB/dir_getcurdir.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.NotSupportedException">Le système d’exploitation est Windows CE, qui ne dispose pas de fonctionnalité par rapport au répertoire actif.  
  
Cette méthode est disponible dans le .NET Compact Framework, mais n’est pas prise en charge actuellement.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès pour le répertoire actif. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne les noms des sous-répertoires qui répondent aux critères spécifiés.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; string[]" Usage="System.IO.Directory.GetDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <summary>Retourne les noms des sous-répertoires (y compris leurs chemins d’accès) dans le répertoire spécifié.</summary>
        <returns>Tableau des noms complets (y compris les chemins d'accès) des sous-répertoires dans le chemin d'accès spécifié, ou tableau vide si aucun répertoire n'est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est identique à <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29> avec l’astérisque (\*) spécifié comme modèle de recherche, par conséquent, elle retourne tous les sous-répertoires. Si vous avez besoin de rechercher des sous-répertoires, utilisez la <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> (méthode), qui vous permet de spécifier une recherche de sous-répertoires avec le `searchOption` paramètre.  
  
 Le <xref:System.IO.Directory.EnumerateDirectories%2A> et <xref:System.IO.Directory.GetDirectories%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateDirectories%2A>, vous pouvez commencer à énumérer la collection de noms avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetDirectories%2A>, vous devez attendre la totalité du tableau de noms à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateDirectories%2A> peut s’avérer plus efficace.  
  
 Le `path` paramètre peut spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Les noms retournés par cette méthode sont préfixés avec les informations de répertoire fournies dans `path`.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant prend un tableau de noms de fichier ou répertoire sur la ligne de commande, détermine le type de nom est, elle traite de manière appropriée.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès pour le répertoire actif. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="searchPattern">Chaîne de recherche à faire correspondre avec les noms de sous-répertoires dans <paramref name="path" />. Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques, mais il ne prend pas en charge les expressions régulières.</param>
        <summary>Retourne les noms des sous-répertoires (y compris leurs chemins d’accès) qui correspondent au modèle de recherche spécifié dans le répertoire spécifié.</summary>
        <returns>Tableau des noms complets (y compris les chemins d’accès) des sous-répertoires qui correspondent au modèle de recherche dans le répertoire spécifié, ou tableau vide si aucun répertoire n’est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne tous les sous-répertoires directement sous le répertoire spécifié qui correspondent au modèle de recherche spécifié. Si le répertoire spécifié ne possède pas de sous-répertoires, ou pas de sous-répertoires correspond à la `searchPattern` paramètre, cette méthode retourne un tableau vide. Uniquement le répertoire supérieur est recherché. Si vous souhaitez rechercher les sous-répertoires, utilisez la <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> (méthode) et spécifiez <xref:System.IO.SearchOption.AllDirectories> dans le `searchOption` paramètre.  
  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|\* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère dans cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, le `searchPattern` chaîne «\*t » recherche tous les noms dans `path` se terminant par la lettre « t ». Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 `searchPattern` ne peut pas se terminer par deux points («.. ») ni contenir deux points («.. ») suivie <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, ni contenir les caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Le `path` paramètre peut spécifier des informations de chemin d’accès relatif ou absolu et ne respecte pas la casse.  Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le <xref:System.IO.Directory.EnumerateDirectories%2A> et <xref:System.IO.Directory.GetDirectories%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateDirectories%2A>, vous pouvez commencer à énumérer la collection de noms avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetDirectories%2A>, vous devez attendre la totalité du tableau de noms à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateDirectories%2A> peut s’avérer plus efficace.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant compte le nombre de répertoires dans un chemin d’accès qui commencent par la lettre spécifiée.  
  
 [!code-cpp[Dir_GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetDirs2/CPP/dir_getdirs2.cpp#1)]
 [!code-csharp[Dir_GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs2.cs#1)]
 [!code-vb[Dir_GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
 <paramref name="searchPattern" /> ne contient pas de modèle valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ou <paramref name="searchPattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès pour le répertoire actif. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="searchPattern">Chaîne de recherche à faire correspondre avec les noms de sous-répertoires dans <paramref name="path" />. Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques, mais il ne prend pas en charge les expressions régulières.</param>
        <param name="searchOption">L’une des valeurs d’énumération qui spécifie si l’opération de recherche doit inclure tous les sous-répertoires ou seulement le répertoire actuel.</param>
        <summary>Retourne les noms des sous-répertoires (avec leurs chemins d’accès) qui correspondent au modèle de recherche spécifié dans le répertoire spécifié, et effectue éventuellement une recherche dans les sous-répertoires.</summary>
        <returns>Tableau des noms complets (y compris les chemins d'accès) des sous-répertoires qui correspondent aux critères spécifiés, ou tableau vide si aucun répertoire n'est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre peut spécifier des informations de chemin d’accès relatif ou absolu et ne respecte pas la casse. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|\* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère dans cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, le `searchPattern` chaîne «\*t » recherche tous les noms dans `path` se terminant par la lettre « t ». Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 `searchPattern` ne peut pas se terminer par deux points («.. ») ni contenir deux points («.. ») suivie <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, ni contenir les caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Le <xref:System.IO.Directory.EnumerateDirectories%2A> et <xref:System.IO.Directory.GetDirectories%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateDirectories%2A>, vous pouvez commencer à énumérer la collection de noms avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetDirectories%2A>, vous devez attendre la totalité du tableau de noms à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateDirectories%2A> peut s’avérer plus efficace.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant compte le nombre de répertoires qui commencent par la lettre spécifiée dans un chemin d’accès. Répertoire de niveau supérieur uniquement est recherché.  
  
 [!code-csharp[Dir_GetDirs2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs3.cs#2)]
 [!code-vb[Dir_GetDirs2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
 <paramref name="searchPattern" /> ne contient pas un modèle valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ou <paramref name="searchPattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> n’est pas une valeur de <see cref="T:System.IO.SearchOption" /> valide.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès pour le répertoire actif. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryRoot">
      <MemberSignature Language="C#" Value="public static string GetDirectoryRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectoryRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryRoot : string -&gt; string" Usage="System.IO.Directory.GetDirectoryRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès d’un fichier ou d’un répertoire.</param>
        <summary>Retourne les informations sur le volume, les informations sur la racine ou les deux, pour le chemin d’accès spécifié.</summary>
        <returns>Chaîne qui contient les informations sur le volume, les informations sur la racine ou les deux, pour le chemin d’accès spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode obtient le nom de chemin d’accès qualifié complet de `path`, tel que retourné par <xref:System.IO.Path.GetFullPath%2A>, et retourne racine des informations d’annuaire. Le chemin d’accès spécifié n’est pas requis pour exister.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant illustre comment définir le répertoire en cours et afficher la racine du répertoire.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès pour le répertoire actif. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne les noms des fichiers qui répondent aux critères spécifiés.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; string[]" Usage="System.IO.Directory.GetFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <summary>Retourne les noms des fichiers (y compris leur chemin d’accès) dans le répertoire spécifié.</summary>
        <returns>Tableau des noms complets (y compris les chemins d’accès) pour les fichiers du répertoire spécifié, ou tableau vide si aucun fichier n’est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Directory.EnumerateFiles%2A> et <xref:System.IO.Directory.GetFiles%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateFiles%2A>, vous pouvez commencer à énumérer la collection de noms avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetFiles%2A>, vous devez attendre la totalité du tableau de noms à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateFiles%2A> peut s’avérer plus efficace.  
  
 Les noms de fichier retournés sont ajoutés fourni `path` paramètre.  
  
 Cette méthode est identique à <xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29> avec l’astérisque (\*) spécifié en tant que le modèle de recherche.  
  
 Le `path` paramètre peut spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 L’ordre des noms de fichier retourné n’est pas garanti ; utiliser le <xref:System.Array.Sort%2A> méthode si un ordre de tri spécifique est requis.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.IO.Directory.GetFiles%2A> méthode pour retourner les noms de fichiers à partir d’un emplacement spécifié par l’utilisateur. L’exemple est configuré pour intercepter toutes les erreurs communes à cette méthode.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.  
  
ou 
Une erreur réseau s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié est introuvable ou n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès pour le répertoire actif. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de fichiers dans <paramref name="path" />.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <summary>Retourne les noms des fichiers (y compris leurs chemins d’accès) qui correspondent au modèle de recherche spécifié dans le répertoire spécifié.</summary>
        <returns>Tableau des noms complets (y compris les chemins d'accès) pour les fichiers du répertoire spécifié qui correspondent au modèle de recherche spécifié, ou un tableau vide si aucun fichier n'est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les noms de fichier retournés sont ajoutés fourni `path` paramètre et l’ordre des noms de fichier retourné n’est pas garanti ; utilisez la <xref:System.Array.Sort%2A> méthode si un ordre de tri spécifique est requis.  
  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|\* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère dans cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, le `searchPattern` chaîne «\*t » recherche tous les noms dans `path` se terminant par la lettre « t ». Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 `searchPattern` ne peut pas se terminer par deux points («.. ») ni contenir deux points («.. ») suivie <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, ni contenir les caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Lorsque vous utilisez le caractère générique astérisque dans un `searchPattern` tel que «\*.txt », le nombre de caractères dans l’extension spécifiée a une incidence sur la recherche comme suit :  
>   
> -   Si l’extension spécifiée est exactement trois caractères, la méthode retourne les fichiers portant les extensions qui commencent avec l’extension spécifiée. Par exemple, «\*.xls » retourne « book.xls » et « book.xlsx ».  
> -   Dans tous les autres cas, la méthode retourne les fichiers qui correspondent exactement à l’extension spécifiée. Par exemple, «\*.ai » retourne « file.ai » mais pas « file.aif ».  
>   
>  Lorsque vous utilisez le caractère générique de point d’interrogation, cette méthode retourne uniquement les fichiers qui correspondent à l’extension de fichier spécifié. Par exemple, prenons deux fichiers, « file1.txt » et « fichier1.txtautre » situés dans un répertoire, un modèle de recherche de « fichier ?. txt » retourne simplement le premier fichier, alors qu’un modèle de recherche de « fichier\*.txt » renvoie les deux fichiers.  
  
> [!NOTE]
>  Étant donné que cette méthode vérifie par rapport aux noms de fichier avec le format de nom de 8.3 fichier et le format de nom de fichier long, une modèle de recherche semblable à «\*1\*.txt » peut retourner des noms de fichier inattendue. Par exemple, à l’aide d’un modèle de recherche de «\*1\*.txt » retourne « longfilename.txt », car le format de nom de 8.3 fichier équivalent est « LongFi ~ 1.txt ».  
  
 Le <xref:System.IO.Directory.EnumerateFiles%2A> et <xref:System.IO.Directory.GetFiles%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateFiles%2A>, vous pouvez commencer à énumérer la collection de noms avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetFiles%2A>, vous devez attendre la totalité du tableau de noms à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateFiles%2A> peut s’avérer plus efficace.  
  
 Le `path` paramètre peut spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant compte le nombre de fichiers qui commencent par la lettre spécifiée.  
  
 [!code-cpp[Dir_GetFiles2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetFiles2/CPP/dir_getfiles2.cpp#1)]
 [!code-csharp[Dir_GetFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetFiles2/CS/dir_getfiles2.cs#1)]
 [!code-vb[Dir_GetFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetFiles2/VB/dir_getfiles2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.  
  
ou 
Une erreur réseau s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
 <paramref name="searchPattern" /> ne contient pas de modèle valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ou <paramref name="searchPattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié est introuvable ou n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès pour le répertoire actif. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de fichiers dans <paramref name="path" />.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <param name="searchOption">L’une des valeurs d’énumération qui spécifie si l’opération de recherche doit inclure tous les sous-répertoires ou seulement le répertoire actuel.</param>
        <summary>Retourne les noms des fichiers (y compris leurs chemins d’accès) qui correspondent au modèle de recherche spécifié dans le répertoire spécifié, en utilisant une valeur pour déterminer s’il faut effectuer une recherche dans les sous-répertoires.</summary>
        <returns>Tableau des noms complets (y compris les chemins d'accès) pour les fichiers du répertoire spécifié qui correspondent au modèle et à l'option de recherche spécifiés, ou tableau vide si aucun fichier n'est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les noms de fichier retournés sont ajoutés au paramètre fourni `path` et l’ordre des noms de fichier retourné n’est pas garanti ; utilisez la <xref:System.Array.Sort%2A> méthode si un ordre de tri spécifique est requis.  
  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|\* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère dans cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, le `searchPattern` chaîne «\*t » recherche tous les noms dans `path` se terminant par la lettre « t ». Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 `searchPattern` ne peut pas se terminer par deux points («.. ») ni contenir deux points («.. ») suivie <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, ni contenir les caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Lorsque vous utilisez le caractère générique astérisque dans un `searchPattern` tel que «\*.txt », le nombre de caractères dans l’extension spécifiée a une incidence sur la recherche comme suit :  
>   
> -   Si l’extension spécifiée est exactement trois caractères, la méthode retourne les fichiers portant les extensions qui commencent avec l’extension spécifiée. Par exemple, «\*.xls » retourne « book.xls » et « book.xlsx ».  
> -   Dans tous les autres cas, la méthode retourne les fichiers qui correspondent exactement à l’extension spécifiée. Par exemple, «\*.ai » retourne « file.ai » mais pas « file.aif ».  
>   
>  Lorsque vous utilisez le caractère générique de point d’interrogation, cette méthode retourne uniquement les fichiers qui correspondent à l’extension de fichier spécifié. Par exemple, prenons deux fichiers, « file1.txt » et « fichier1.txtautre » situés dans un répertoire, un modèle de recherche de « fichier ?. txt » retourne simplement le premier fichier, tandis qu’un modèle de recherche de « file*.txt » retourne les deux fichiers.  
  
> [!NOTE]
>  Étant donné que cette méthode vérifie par rapport aux noms de fichier avec le format de nom de 8.3 fichier et le format de nom de fichier long, une modèle de recherche semblable à «\*1\*.txt » peut retourner des noms de fichier inattendue. Par exemple, à l’aide d’un modèle de recherche de «\*1\*.txt » retourne « longfilename.txt », car le format de nom de 8.3 fichier équivalent est « LongFi ~ 1.txt ».  
  
 Le <xref:System.IO.Directory.EnumerateFiles%2A> et <xref:System.IO.Directory.GetFiles%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateFiles%2A>, vous pouvez commencer à énumérer la collection de noms avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetFiles%2A>, vous devez attendre la totalité du tableau de noms à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateFiles%2A> peut s’avérer plus efficace.  
  
 Les noms de fichiers incluent le chemin d’accès complet.  
  
 Le `path` paramètre peut spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
 <paramref name="searchPattern" /> ne contient pas un modèle valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ou <paramref name="searchpattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> n’est pas une valeur de <see cref="T:System.IO.SearchOption" /> valide.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié est introuvable ou n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.  
  
ou 
Une erreur réseau s’est produite.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès pour le répertoire actif. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne les noms de tous les fichiers et sous-répertoires qui répondent à des critères spécifiés.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <summary>Retourne les noms de tous les fichiers et sous-répertoires dans un chemin d’accès spécifié.</summary>
        <returns>Tableau des noms de fichiers et de sous-répertoires dans le répertoire spécifié, ou tableau vide si aucun fichier ni sous-répertoire n'est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre du fichier renvoyé et les noms de répertoire n’est pas garanti ; utiliser le <xref:System.Array.Sort%2A> méthode si un ordre de tri spécifique est requis.  
  
 Le <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> et <xref:System.IO.Directory.GetFileSystemEntries%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, vous pouvez commencer à énumérer la collection d’entrées avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetFileSystemEntries%2A>, vous devez attendre la totalité du tableau d’entrées à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateFiles%2A> peut s’avérer plus efficace.  
  
 Cette méthode est identique à <xref:System.IO.Directory.GetFileSystemEntries%2A> avec l’astérisque (\*) spécifié en tant que le modèle de recherche.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.IO.Directory.GetFileSystemEntries%2A> méthode pour remplir un tableau de chaînes avec les noms de tous les fichiers et sous-répertoires dans un emplacement spécifié par l’utilisateur et imprime chaque chaîne dans le tableau à la console. L’exemple est configuré pour intercepter toutes les erreurs communes à cette méthode.  
  
 [!code-cpp[System.IO.Directory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#1)]
 [!code-csharp[System.IO.Directory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#1)]
 [!code-vb[System.IO.Directory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès pour le répertoire actif. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="T:System.IO.FileSystemInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de fichiers et de répertoires dans <paramref name="path" />.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <summary>Retourne un tableau de noms de fichiers et noms de répertoires qui correspondent à un modèle de recherche dans un chemin spécifié.</summary>
        <returns>Tableau de noms de fichiers et de noms de répertoires qui correspondent aux critères de recherche spécifiés, ou tableau vide si aucun fichier ou répertoire n'est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre du fichier renvoyé et les noms de répertoire n’est pas garanti ; utiliser le <xref:System.Array.Sort%2A> méthode si un ordre de tri spécifique est requis.  
  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|\* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère dans cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, le `searchPattern` chaîne «\*t » recherche tous les noms dans `path` se terminant par la lettre « t ». Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 `searchPattern` ne peut pas se terminer par deux points («.. ») ni contenir deux points («.. ») suivie <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, ni contenir les caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Lorsque vous utilisez le caractère générique astérisque dans un `searchPattern` tel que «\*.txt », le nombre de caractères dans l’extension spécifiée a une incidence sur la recherche comme suit :  
>   
> -   Si l’extension spécifiée est exactement trois caractères, la méthode retourne les fichiers portant les extensions qui commencent avec l’extension spécifiée. Par exemple, «\*.xls » retourne « book.xls » et « book.xlsx ».  
> -   Dans tous les autres cas, la méthode retourne les fichiers qui correspondent exactement à l’extension spécifiée. Par exemple, «\*.ai » retourne « file.ai » mais pas « file.aif ».  
>   
>  Lorsque vous utilisez le caractère générique de point d’interrogation, cette méthode retourne uniquement les fichiers qui correspondent à l’extension de fichier spécifié. Par exemple, prenons deux fichiers, « file1.txt » et « fichier1.txtautre » situés dans un répertoire, un modèle de recherche de « fichier ?. txt » retourne simplement le premier fichier, alors qu’un modèle de recherche de « fichier\*.txt » renvoie les deux fichiers.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.IO.Directory.GetFileSystemEntries%2A> méthode pour remplir un tableau de chaînes avec les noms de tous les fichiers correspondant à un filtre spécifié par l’utilisateur dans un emplacement spécifique et imprime chaque chaîne dans le tableau à la console. L’exemple est configuré pour intercepter toutes les erreurs communes à cette méthode.  
  
 [!code-cpp[System.IO.Directory#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#2)]
 [!code-csharp[System.IO.Directory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#2)]
 [!code-vb[System.IO.Directory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
 <paramref name="searchPattern" /> ne contient pas un modèle valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ou <paramref name="searchPattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations de chemin d’accès pour le répertoire actif. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Le chemin d’accès relatif ou absolu du répertoire où effectuer la recherche. Cette chaîne n'est pas sensible à la casse.</param>
        <param name="searchPattern">Chaîne recherchée à trouver parmi les noms de fichiers et de répertoires dans <paramref name="path" />.  Ce paramètre peut contenir une combinaison d’un chemin littéral valide et de caractères génériques (* et ?), mais il ne prend pas en charge les expressions régulières.</param>
        <param name="searchOption">Une des valeurs d'énumération qui spécifie si l'opération de recherche doit inclure seulement le répertoire actuel ou si elle doit inclure tous les sous-répertoires.  
  
La valeur par défaut est <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retourne un tableau de tous les noms de fichiers et noms de répertoires qui correspondent à un modèle de recherche dans un chemin d’accès spécifié, et effectue éventuellement des recherches dans les sous-répertoires.</summary>
        <returns>Tableau des noms de fichiers et des noms de répertoires qui correspondent aux critères de recherche spécifiés, ou tableau vide si aucun fichier ou répertoire n'est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre du fichier renvoyé et les noms de répertoire n’est pas garanti ; utiliser le <xref:System.Array.Sort%2A> méthode si un ordre de tri spécifique est requis.  
  
 `searchPattern` peut être une combinaison de caractères littéraux et génériques, mais il ne prend pas en charge les expressions régulières. Les spécificateurs de caractères génériques suivants sont autorisés dans `searchPattern`.  
  
|Spécificateur de caractère générique|Correspondances|  
|------------------------|-------------|  
|\* (astérisque)|Zéro ou plusieurs caractères dans cette position.|  
|? (point d’interrogation)|Zéro ou un caractère dans cette position.|  
  
 Caractères autres que le caractère générique sont des caractères littéraux. Par exemple, le `searchPattern` chaîne «\*t » recherche tous les noms dans `path` se terminant par la lettre « t ». Le `searchPattern` chaîne « s\*» recherche tous les noms dans `path` commençant par la lettre « s ».  
  
 `searchPattern` ne peut pas se terminer par deux points («.. ») ni contenir deux points («.. ») suivie <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, ni contenir les caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Lorsque vous utilisez le caractère générique astérisque dans un `searchPattern` tel que «\*.txt », le nombre de caractères dans l’extension spécifiée a une incidence sur la recherche comme suit :  
>   
> -   Si l’extension spécifiée est exactement trois caractères, la méthode retourne les fichiers portant les extensions qui commencent avec l’extension spécifiée. Par exemple, «\*.xls » retourne « book.xls » et « book.xlsx ».  
> -   Dans tous les autres cas, la méthode retourne les fichiers qui correspondent exactement à l’extension spécifiée. Par exemple, «\*.ai » retourne « file.ai » mais pas « file.aif ».  
>   
>  Lorsque vous utilisez le caractère générique de point d’interrogation, cette méthode retourne uniquement les fichiers qui correspondent à l’extension de fichier spécifié. Par exemple, prenons deux fichiers, « file1.txt » et « fichier1.txtautre » situés dans un répertoire, un modèle de recherche de « fichier ?. txt » retourne simplement le premier fichier, alors qu’un modèle de recherche de « fichier\*.txt » renvoie les deux fichiers.  
  
 Le <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> et <xref:System.IO.Directory.GetFileSystemEntries%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, vous pouvez commencer à énumérer la collection d’entrées avant que la collection entière est retournée ; lorsque vous utilisez <xref:System.IO.Directory.GetFileSystemEntries%2A>, vous devez attendre la totalité du tableau d’entrées à retourner avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec de nombreux fichiers et répertoires, <xref:System.IO.Directory.EnumerateFiles%2A> peut s’avérer plus efficace.  
  
 Vous pouvez spécifier les informations de chemin d’accès relatif avec la `path` paramètre. Informations de chemin d’accès relatif sont interprétées comme étant relatif le répertoire de travail actuel, vous pouvez déterminer à l’aide de la <xref:System.IO.Directory.GetCurrentDirectory%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace ou contient des caractères non valides. Vous pouvez rechercher les caractères non valides à l’aide de la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
 <paramref name="searchPattern" /> ne contient pas un modèle valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="searchPattern" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> n’est pas une valeur de <see cref="T:System.IO.SearchOption" /> valide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’est pas valide, notamment s’il fait référence à un lecteur non mappé.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> est un nom de fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier ou répertoire pour lequel obtenir les informations de date/heure d'accès.</param>
        <summary>Retourne la date/heure du dernier accès au fichier ou au répertoire spécifié.</summary>
        <returns>Structure définie avec la date/heure du dernier accès au fichier ou au répertoire spécifié. Cette valeur est exprimée en heure locale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode peut retourner une valeur inexacte, car elle utilise des fonctions natives dont les valeurs ne peuvent pas continuellement mis à jour par le système d’exploitation.  
  
 Cette méthode est identique à <xref:System.IO.File.GetLastAccessTime%2A?displayProperty=nameWithType>.  
  
 Si le répertoire décrit dans le `path` paramètre n’existe pas, cette méthode retourne 12:00 minuit, le 1er janvier 1601 apr. J.C. (NOTRE ÈRE) Temps universel coordonné (UTC), ajusté à l’heure locale.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser `GetLastAccessTime`.  
  
 [!code-cpp[Dir_GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastAccess/CPP/dir_getlastaccess.cpp#1)]
 [!code-csharp[Dir_GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastAccess/CS/dir_getlastaccess.cs#1)]
 [!code-vb[Dir_GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastAccess/VB/dir_getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Le format du paramètre <paramref name="path" /> est non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire le fichier ou répertoire spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier ou répertoire pour lequel obtenir les informations de date/heure d'accès.</param>
        <summary>Retourne la date/heure, au format UTC (Temps universel coordonné), du dernier accès au fichier ou au répertoire spécifié.</summary>
        <returns>Structure définie avec la date/heure du dernier accès au fichier ou au répertoire spécifié. Cette valeur est exprimée en temps UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode peut retourner une valeur inexacte, car elle utilise des fonctions natives dont les valeurs ne peuvent pas continuellement mis à jour par le système d’exploitation.  
  
 Si le répertoire décrit dans le `path` paramètre n’existe pas, cette méthode retourne 12:00 minuit, le 1er janvier 1601 apr. J.C. (NOTRE ÈRE) Temps d’universel coordonné (UTC).  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant illustre les différences de sortie lors de l’utilisation de sortie de temps universel coordonné (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Le format du paramètre <paramref name="path" /> est non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire le fichier ou répertoire spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier ou répertoire pour lequel obtenir les informations de date/heure de modification.</param>
        <summary>Retourne la date/heure du dernier accès en écriture au fichier ou au répertoire spécifié.</summary>
        <returns>Structure définie avec la date/heure de la dernière écriture dans le fichier ou le répertoire spécifié. Cette valeur est exprimée en heure locale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode peut retourner une valeur inexacte, car elle utilise des fonctions natives dont les valeurs ne peuvent pas continuellement mis à jour par le système d’exploitation.  
  
 Si le répertoire décrit dans le `path` paramètre n’existe pas, cette méthode retourne 12:00 minuit, le 1er janvier 1601 apr. J.C. (NOTRE ÈRE) Temps universel coordonné (UTC), ajusté à l’heure locale.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser `GetLastWriteTime`.  
  
 [!code-cpp[Dir_GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastWrite/CPP/dir_getlastwrite.cpp#1)]
 [!code-csharp[Dir_GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastWrite/CS/dir_getlastwrite.cs#1)]
 [!code-vb[Dir_GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastWrite/VB/dir_getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire le fichier ou répertoire spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier ou répertoire pour lequel obtenir les informations de date/heure de modification.</param>
        <summary>Retourne la date/heure, au format UTC (Temps universel coordonné), de la dernière écriture dans le fichier ou le répertoire spécifié.</summary>
        <returns>Structure définie avec la date/heure de la dernière écriture dans le fichier ou le répertoire spécifié. Cette valeur est exprimée en temps UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode peut retourner une valeur inexacte, car elle utilise des fonctions natives dont les valeurs ne peuvent pas continuellement mis à jour par le système d’exploitation.  
  
 Si le répertoire décrit dans le `path` paramètre n’existe pas, cette méthode retourne 12:00 minuit, le 1er janvier 1601 apr. J.C. (NOTRE ÈRE) Temps d’universel coordonné (UTC).  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant illustre les différences de sortie lors de l’utilisation de sortie de temps universel coordonné (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire le fichier ou répertoire spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.IO.Directory.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère les noms des lecteurs logiques sur cet ordinateur, sous la forme "&lt;lettre de lecteur&gt;:\\".</summary>
        <returns>Lecteurs logiques sur cet ordinateur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetLogicalDrives retourne tous les lecteurs accessibles sur un ordinateur particulier, y compris le lecteur de disquette et les lecteurs optiques.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.IO.Directory.GetLogicalDrives%2A> méthode pour attribuer le nom de chaque lecteur de l’ordinateur appelant à un tableau de chaînes. Chaque membre de ce tableau de chaînes est ensuite écrit dans la console. L’exemple est configuré pour intercepter toutes les erreurs communes à cette méthode.  
  
 [!code-cpp[System.IO.Directory#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#3)]
 [!code-csharp[System.IO.Directory#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#3)]
 [!code-vb[System.IO.Directory#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite (par exemple une erreur disque).</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé, telles que l’appel de code natif avec PInvoke ou COM interop. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetParent (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetParent(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetParent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParent (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetParent(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParent : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.GetParent path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin pour lequel récupérer le répertoire parent.</param>
        <summary>Récupère le répertoire parent du chemin d'accès spécifié, y compris les chemins d'accès absolus et relatifs.</summary>
        <returns>Répertoire parent, ou <see langword="null" /> si <paramref name="path" /> est le répertoire racine, y compris la racine d’un nom de serveur ou de partage UNC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre peut spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Les espaces à droite sont supprimés à la fin de la `path` paramètre avant d’obtenir le répertoire.  
  
 La chaîne retournée par cette méthode se compose de tous les caractères dans le chemin d’accès jusqu’au non compris, la dernière <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>. Par exemple, en passant le chemin d’accès « C:\Directory\SubDirectory\test.txt » à <xref:System.IO.Directory.GetParent%2A> retourne « C:\Directory\SubDirectory ». En passant « C:\Directory\SubDirectory » retourne « C:\Directory ». Toutefois, en passant « C:\Directory\SubDirectory\\» retourne « C:\Directory\SubDirectory », car le séparateur de répertoire de fin est après « Sous-répertoire ».  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.IO.Directory.GetParent%2A> méthode pour récupérer le répertoire parent d’un emplacement spécifié par l’utilisateur, « path ». La valeur retournée par la <xref:System.IO.Directory.GetParent%2A> méthode est ensuite affichée dans la console. L’exemple est configuré pour intercepter toutes les erreurs communes à cette méthode.  
  
 [!code-cpp[System.IO.Directory#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#4)]
 [!code-csharp[System.IO.Directory#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#4)]
 [!code-vb[System.IO.Directory#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié par <paramref name="path" /> est en lecture seule.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système. Pour plus d'informations, voir la rubrique <see cref="T:System.IO.PathTooLongException" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié est introuvable.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">.NET Framework uniquement : L’appelant n’a pas les autorisations requises.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire à partir de fichiers ou répertoires. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceDirName, string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceDirName, string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceDirName As String, destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceDirName, System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="static member Move : string * string -&gt; unit" Usage="System.IO.Directory.Move (sourceDirName, destDirName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirName" Type="System.String" />
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirName">Chemin du fichier ou du répertoire à déplacer.</param>
        <param name="destDirName">Chemin du nouvel emplacement pour <paramref name="sourceDirName" />. Si <paramref name="sourceDirName" /> est un fichier, <paramref name="destDirName" /> doit aussi être un nom de fichier.</param>
        <summary>Déplace un fichier, ou un répertoire et son contenu, vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée un répertoire portant le nom spécifié par `destDirName` et déplace le contenu de `sourceDirName` dans le répertoire de destination qui vient d’être créée. Si vous essayez de déplacer un répertoire vers un répertoire qui existe déjà, un <xref:System.IO.IOException> se produira. Par exemple, une exception se produit si vous tentez de déplacer c:\mydir vers c:\public et c:\public existe déjà. Ou bien, vous pouvez spécifier « c:\\\public\\\mydir » en tant que le `destDirName` paramètre, fourni que « mydir » n’existe pas sous « c:\\\public », ou spécifier un nouveau nom de répertoire comme » c:\\\newdir ».  
  
 Le `sourceDirName` et `destDirName` arguments sont autorisés à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Les espaces à droite sont supprimés à la fin des paramètres de chemin d’accès avant de déplacer le répertoire.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  


> [!NOTE]
>  En commençant par .NET Core 3.0, le `Move` méthode lève une exception une <xref:System.IO.IOException> dans toutes les plateformes quand le `destDirName` existe déjà. Dans .NET Core 2.2 et versions antérieures, l’exception a été levée uniquement sur Windows et autres plateformes peuvent échouer ou remplacer le `destDirName`. Consultez [ C++ renommer](https://linux.die.net/man/2/rename).
   
  
## Examples  
 L’exemple suivant montre comment déplacer un répertoire et tous ses fichiers vers un nouveau répertoire. Le répertoire d’origine n’existe plus après que qu’il a été déplacé.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une tentative a été effectuée pour déplacer un répertoire vers un autre volume.
  
ou 
 <paramref name="destDirName" /> existe déjà. Consultez la remarque dans la section Notes.
  
ou 
Les paramètres <paramref name="sourceDirName" /> et <paramref name="destDirName" /> font référence au même fichier ou répertoire.  
  
ou 
Le répertoire ou un fichier contenu dans ce répertoire est utilisé par un autre processus.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceDirName" /> ou <paramref name="destDirName" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirName" /> ou <paramref name="destDirName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié par <paramref name="sourceDirName" /> n’est pas valide (par exemple, il se trouve sur un lecteur non mappé).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir de <paramref name="sourceDirName" /> et l’écriture dans <paramref name="sourceDirName" /> et <paramref name="destDirName" />. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member SetAccessControl : string * System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="System.IO.Directory.SetAccessControl (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Répertoire où des entrées ACL doivent être ajoutées ou supprimées.</param>
        <param name="directorySecurity">Objet <see cref="T:System.Security.AccessControl.DirectorySecurity" /> qui décrit une entrée de liste de contrôle d’accès (ACL) à appliquer au répertoire décrit par le paramètre <paramref name="path" />.</param>
        <summary>Applique les entrées de liste de contrôle d’accès (ACL) décrites par un objet <see cref="T:System.Security.AccessControl.DirectorySecurity" /> au répertoire spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Directory.SetAccessControl%2A> méthode applique les entrées de contrôle d’accès (ACL) de liste à un fichier qui représente la liste ACL non héritée.  
  
> [!CAUTION]
>  La liste ACL spécifiée pour le `directorySecurity` paramètre remplace la liste ACL existante pour le répertoire. Pour ajouter des autorisations pour un nouvel utilisateur, utilisez la <xref:System.IO.Directory.GetAccessControl%2A> méthode pour obtenir la liste ACL existante et la modifier.  
  
 Une liste ACL décrit les individus et/ou les groupes qui ont ou pas de droits à des actions spécifiques sur le fichier donné ou le répertoire. Pour plus d'informations, voir [Procédure : ajouter ou supprimer des entrées dans la liste de contrôle d’accès](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Le <xref:System.IO.Directory.SetAccessControl%2A> méthode persiste uniquement <xref:System.Security.AccessControl.DirectorySecurity> les objets qui ont été modifiées après la création d’objets.  Si un <xref:System.Security.AccessControl.DirectorySecurity> objet n’a pas été modifié, il ne sera pas conservé dans un fichier.  Par conséquent, il n’est pas possible de récupérer un <xref:System.Security.AccessControl.DirectorySecurity> de l’objet à partir d’un fichier et de réappliquer le même objet à un autre fichier.  
  
 Pour copier les informations ACL à partir d’un fichier vers un autre :  
  
1.  Utilisez le <xref:System.IO.Directory.GetAccessControl%2A> méthode pour récupérer le <xref:System.Security.AccessControl.DirectorySecurity> objet à partir du fichier source.  
  
2.  Créer un nouveau <xref:System.Security.AccessControl.DirectorySecurity> objet pour le fichier de destination.  
  
3.  Utilisez le <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> méthode de la source <xref:System.Security.AccessControl.DirectorySecurity> objet pour récupérer les informations ACL.  
  
4.  Utilisez le <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> méthode pour copier les informations récupérées à l’étape 3 vers la destination <xref:System.Security.AccessControl.DirectorySecurity> objet.  
  
5.  Définir la destination <xref:System.Security.AccessControl.DirectorySecurity> objet pour le fichier de destination à l’aide de la <xref:System.IO.Directory.SetAccessControl%2A> (méthode).  
  
 Dans les environnements NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> et <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> sont accordées à l’utilisateur si l’utilisateur a <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> droits sur le dossier parent. Pour refuser <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> et <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, refuser <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> sur le répertoire parent.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.IO.Directory.GetAccessControl%2A> et <xref:System.IO.Directory.SetAccessControl%2A> méthodes pour ajouter un accès à un contrôle d’entrée de liste (ACL) et puis supprimer une entrée ACL dans un répertoire.  Vous devez entrer un compte d'utilisateur ou de groupe valide pour exécuter cet exemple.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="directorySecurity" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire est introuvable.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> n’était pas valide.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le processus en cours n’a pas accès au répertoire spécifié par <paramref name="path" />.  
  
ou 
Le processus en cours n’a pas les privilèges suffisants pour définir l’entrée de la liste ACL.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Windows 2000 ou une version ultérieure.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’autorisation d’énumérer la liste de contrôle d’accès (ACL) pour un répertoire. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Action de sécurité : À la demande.</permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberSignature Language="F#" Value="static member SetCreationTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTime (path, creationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Fichier ou répertoire pour lequel définir les informations de date et heure de création.</param>
        <param name="creationTime">Date/heure de la dernière écriture dans le fichier ou le répertoire. Cette valeur est exprimée en heure locale.</param>
        <summary>Définit la date/heure de création pour le fichier ou le répertoire spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
   
  
## Examples  
 L’exemple suivant illustre les différences de sortie lors de l’utilisation de sortie de temps universel coordonné (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Le chemin spécifié est introuvable.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> spécifie une valeur qui n’est pas comprise dans la plage de dates ou d’heures autorisées pour cette opération.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Windows NT ou version ultérieure.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le fichier ou répertoire spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetCreationTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTimeUtc (path, creationTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Fichier ou répertoire pour lequel définir les informations de date et heure de création.</param>
        <param name="creationTimeUtc">Date/heure de création du répertoire ou du fichier. Cette valeur est exprimée en heure locale.</param>
        <summary>Définit la date et l'heure de création, au format de temps universel (UTC, Universal Coordinated Time) pour le fichier ou le répertoire spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Le chemin spécifié est introuvable.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> spécifie une valeur qui n’est pas comprise dans la plage de dates ou d’heures autorisées pour cette opération.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Windows NT ou version ultérieure.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le fichier ou répertoire spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static void SetCurrentDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCurrentDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCurrentDirectory (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCurrentDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member SetCurrentDirectory : string -&gt; unit" Usage="System.IO.Directory.SetCurrentDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin affecté au répertoire de travail actuel.</param>
        <summary>Définit le répertoire spécifié comme répertoire de travail actuel de l'application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’application se termine, le répertoire de travail est restauré à son emplacement d’origine (le répertoire où le processus a démarré).  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Les espaces à droite sont supprimés à la fin de la `path` paramètre avant de définir le répertoire.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Si vous définissez le répertoire sur un lecteur avec un média amovible (par exemple, « e » pour un lecteur flash USB), vous pouvez déterminer si le lecteur est prêt à l’aide de la <xref:System.IO.DriveInfo.IsReady%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant illustre comment définir le répertoire en cours et afficher la racine du répertoire.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas l’autorisation nécessaire pour accéder au code non managé.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le chemin spécifié est introuvable.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire spécifié est introuvable.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans des fichiers ou répertoires. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTime (path, lastAccessTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Fichier ou répertoire pour lequel définir les informations de date et d’heure d’accès.</param>
        <param name="lastAccessTime">Objet qui contient la valeur à définir pour la date et l’heure d’accès de <paramref name="path" />. Cette valeur est exprimée en heure locale.</param>
        <summary>Définit la date/heure du dernier accès au fichier ou au répertoire spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser `SetLastAccessTime`.  
  
 [!code-cpp[Dir_SetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastAccess/CPP/dir_setlastaccess.cpp#1)]
 [!code-csharp[Dir_SetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastAccess/CS/dir_setlastaccess.cs#1)]
 [!code-vb[Dir_SetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastAccess/VB/dir_setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Le chemin spécifié est introuvable.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Windows NT ou version ultérieure.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTime" /> spécifie une valeur qui n’est pas comprise dans la plage de dates ou d’heures autorisées pour cette opération.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le fichier ou répertoire spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTimeUtc (path, lastAccessTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Fichier ou répertoire pour lequel définir les informations de date et d’heure d’accès.</param>
        <param name="lastAccessTimeUtc">Objet qui contient la valeur à définir pour la date et l’heure d’accès de <paramref name="path" />. Cette valeur est exprimée en temps UTC.</param>
        <summary>Définit la date/heure, au format UTC (Temps universel coordonné), du dernier accès au fichier ou au répertoire spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant illustre les différences de sortie lors de l’utilisation de sortie de temps universel coordonné (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Le chemin spécifié est introuvable.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Windows NT ou version ultérieure.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTimeUtc" /> spécifie une valeur qui n’est pas comprise dans la plage de dates ou d’heures autorisées pour cette opération.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le fichier ou répertoire spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTime (path, lastWriteTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Chemin du répertoire.</param>
        <param name="lastWriteTime">Date/heure de la dernière écriture dans le répertoire. Cette valeur est exprimée en heure locale.</param>
        <summary>Définit la date/heure du dernier accès en écriture au répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser `SetLastWriteTime`.  
  
 [!code-cpp[Dir_SetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastWrite/CPP/dir_setlastwrite.cpp#1)]
 [!code-csharp[Dir_SetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastWrite/CS/dir_setlastwrite.cs#1)]
 [!code-vb[Dir_SetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastWrite/VB/dir_setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" /> est introuvable (par exemple, le répertoire n’existe pas ou se trouve sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> est introuvable (par exemple, le répertoire n’existe pas ou se trouve sur un lecteur non mappé).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Windows NT ou version ultérieure.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTime" /> spécifie une valeur qui n’est pas comprise dans la plage de dates ou d’heures autorisées pour cette opération.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le fichier ou répertoire spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTimeUtc (path, lastWriteTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Chemin du répertoire.</param>
        <param name="lastWriteTimeUtc">Date/heure de la dernière écriture dans le répertoire. Cette valeur est exprimée en temps UTC.</param>
        <summary>Définit la date/heure, au format UTC (Temps universel coordonnée), de la dernière écriture dans un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant illustre les différences de sortie lors de l’utilisation de sortie de temps universel coordonné (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" /> est introuvable (par exemple, le répertoire n’existe pas ou se trouve sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> est introuvable (par exemple, le répertoire n’existe pas ou se trouve sur un lecteur non mappé).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contenant seulement un espace, ou un ou plusieurs caractères non valides. Vous pouvez rechercher les caractères non valides avec la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Windows NT ou version ultérieure.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTimeUtc" /> spécifie une valeur qui n’est pas comprise dans la plage de dates ou d’heures autorisées pour cette opération.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le fichier ou répertoire spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
  </Members>
</Type>