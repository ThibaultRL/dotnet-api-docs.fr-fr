<Type Name="StringReader" FullName="System.IO.StringReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b4674ec0950ec86b70206b1db0845f49482a19c0" /><Meta Name="ms.sourcegitcommit" Value="239d0111d1a083331e4fcfaa4719845f68e733e0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/01/2019" /><Meta Name="ms.locfileid" Value="64977275" /></Metadata><TypeSignature Language="C#" Value="public class StringReader : System.IO.TextReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StringReader extends System.IO.TextReader" />
  <TypeSignature Language="DocId" Value="T:System.IO.StringReader" />
  <TypeSignature Language="VB.NET" Value="Public Class StringReader&#xA;Inherits TextReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringReader : System::IO::TextReader" />
  <TypeSignature Language="F#" Value="type StringReader = class&#xA;    inherit TextReader" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implémente <see cref="T:System.IO.TextReader" /> qui lit une chaîne.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StringReader> vous permet de lire une chaîne de façon synchrone ou asynchrone. Vous pouvez lire un caractère à la fois avec le <xref:System.IO.StringReader.Read%2A> ou le <xref:System.IO.StringReader.ReadAsync%2A> (méthode), une ligne à la fois avec le <xref:System.IO.StringReader.ReadLine%2A> ou le <xref:System.IO.StringReader.ReadLineAsync%2A> (méthode) et un ensemble de la chaîne à l’aide la <xref:System.IO.StringReader.ReadToEnd%2A> ou le <xref:System.IO.StringReader.ReadToEndAsync%2A> (méthode).  
  
[!INCLUDE[note_unnecessary_dispose](~/includes/note-unnecessary-dispose.md)]
  
 Le tableau suivant répertorie des exemples d’autres tâches d’e/s courantes ou apparentées.  
  
|Pour...|Consultez l'exemple décrit dans cette rubrique...|  
|-------------------|--------------------------------------|  
|Créer un fichier texte.|[Guide pratique pour écrire du texte dans un fichier](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Écrire dans un fichier texte.|[Guide pratique pour écrire du texte dans un fichier](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Lire un fichier texte.|[Guide pratique pour lire le texte d’un fichier](~/docs/standard/io/how-to-read-text-from-a-file.md)|  
|Ajouter du texte dans un fichier.|[Guide pratique pour ouvrir un fichier journal et y ajouter des éléments](~/docs/standard/io/how-to-open-and-append-to-a-log-file.md)<br /><br /> <xref:System.IO.File.AppendText%2A?displayProperty=nameWithType><br /><br /> <xref:System.IO.FileInfo.AppendText%2A?displayProperty=nameWithType>|  
|Obtenir la taille d’un fichier.|<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>|  
|Obtenir les attributs d’un fichier.|<xref:System.IO.File.GetAttributes%2A?displayProperty=nameWithType>|  
|Définissez les attributs d’un fichier.|<xref:System.IO.File.SetAttributes%2A?displayProperty=nameWithType>|  
|Déterminer si un fichier existe.|<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>|  
|Lire à partir d’un fichier binaire.|[Guide pratique pour lire et écrire dans un fichier de données créé récemment](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
|Écrire dans un fichier binaire.|[Guide pratique pour lire et écrire dans un fichier de données créé récemment](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
  
   
  
## Examples  
 L’exemple suivant montre comment lire une chaîne complète de façon asynchrone.  
  
 [!code-csharp[System.IO.StringReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stringreader/cs/example2.cs#2)]
 [!code-vb[System.IO.StringReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stringreader/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.TextReader" />
    <altmember cref="T:System.IO.StringWriter" />
    <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringReader (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringReader(System::String ^ s);" />
      <MemberSignature Language="F#" Value="new System.IO.StringReader : string -&gt; System.IO.StringReader" Usage="new System.IO.StringReader s" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne à laquelle <see cref="T:System.IO.StringReader" /> doit être initialisé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.StringReader" /> qui lit la chaîne spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie des exemples d’autres tâches d’e/s courantes ou apparentées.  
  
|Pour...|Consultez l'exemple décrit dans cette rubrique...|  
|-------------------|--------------------------------------|  
|Créer un fichier texte.|[Guide pratique pour écrire du texte dans un fichier](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Écrire dans un fichier texte.|[Guide pratique pour écrire du texte dans un fichier](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Lire un fichier texte.|[Guide pratique pour lire le texte d’un fichier](~/docs/standard/io/how-to-read-text-from-a-file.md)|  
|Ajouter du texte dans un fichier.|[Guide pratique pour ouvrir un fichier journal et y ajouter des éléments](~/docs/standard/io/how-to-open-and-append-to-a-log-file.md)<br /><br /> <xref:System.IO.File.AppendText%2A?displayProperty=nameWithType><br /><br /> <xref:System.IO.FileInfo.AppendText%2A?displayProperty=nameWithType>|  
|Obtenir la taille d’un fichier.|<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>|  
|Obtenir les attributs d’un fichier.|<xref:System.IO.File.GetAttributes%2A?displayProperty=nameWithType>|  
|Définissez les attributs d’un fichier.|<xref:System.IO.File.SetAttributes%2A?displayProperty=nameWithType>|  
|Déterminer si un fichier existe.|<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>|  
|Lire à partir d’un fichier binaire.|[Guide pratique pour lire et écrire dans un fichier de données créé récemment](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
|Écrire dans un fichier binaire.|[Guide pratique pour lire et écrire dans un fichier de données créé récemment](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.StringReader> classe.  
  
 [!code-cpp[System.IO.StringReaderWriter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StringReaderWriter/CPP/stringrw.cpp#2)]
 [!code-csharp[System.IO.StringReaderWriter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StringReaderWriter/CS/stringrw.cs#2)]
 [!code-vb[System.IO.StringReaderWriter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StringReaderWriter/VB/stringrw.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="s" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="stringReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme <see cref="T:System.IO.StringReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Pour obtenir un exemple de création d’un fichier et écrire du texte dans un fichier, consultez [Comment : Écrire du texte dans un fichier](~/docs/standard/io/how-to-write-text-to-a-file.md). Pour obtenir un exemple de lecture de texte à partir d’un fichier, consultez [Comment : Lire le texte d’un fichier](~/docs/standard/io/how-to-read-text-from-a-file.md). Pour obtenir un exemple de lecture et écriture dans un fichier binaire, consultez [Comment : Lire et écrire dans un fichier de données créé récemment](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md).  
  
Cette méthode remplace la <xref:System.IO.TextReader.Close%2A?displayProperty=nameWithType> (méthode).  
  
Cette implémentation de `Close` appelle le <xref:System.IO.StringReader.Dispose%2A>, méthode en passant un `true` valeur. Suit un appel à `Close`, autres méthodes peuvent lever une exception.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="stringReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.IO.StringReader" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.IO.StringReader>. Cette méthode appelle la méthode `Dispose` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.StringReader.Dispose(System.Boolean)" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution <see cref="M:System.IO.StringReader.Dispose(System.Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d’un précédent appel à <see cref="M:System.IO.StringReader.Dispose(System.Boolean)" />.</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public override int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Peek () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Peek();" />
      <MemberSignature Language="F#" Value="override this.Peek : unit -&gt; int" Usage="stringReader.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le caractère disponible suivant, mais ne le consomme pas.</summary>
        <returns>Entier représentant le prochain caractère à lire, ou -1 si plus aucun caractère n’est disponible ou si le flux ne prend pas en charge la recherche.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.StringReader.Peek%2A> méthode retourne une valeur entière afin de déterminer si la fin du fichier ou une autre erreur s’est produite. Cela permet à un utilisateur à vérifier au préalable si la valeur retournée est -1 avant un cast sur un <xref:System.Char> type.  
  
 Cette méthode remplace la <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType> (méthode).  
  
 La position actuelle de la `StringReader` n’est pas modifié par cette opération.  
  
 Le tableau suivant répertorie des exemples d’autres tâches d’e/s courantes ou apparentées.  
  
|Pour...|Consultez l'exemple décrit dans cette rubrique...|  
|-------------------|--------------------------------------|  
|Créer un fichier texte.|[Guide pratique pour écrire du texte dans un fichier](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Écrire dans un fichier texte.|[Guide pratique pour écrire du texte dans un fichier](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Lire un fichier texte.|[Guide pratique pour lire le texte d’un fichier](~/docs/standard/io/how-to-read-text-from-a-file.md)|  
|Obtenir la taille d’un fichier.|<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le lecteur actuel est fermé.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit le caractère ou le jeu de caractères suivant dans la chaîne d’entrée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; int" Usage="stringReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le caractère suivant dans la chaîne d’entrée et avance sa position d’un caractère.</summary>
        <returns>Caractère suivant de la chaîne sous-jacente, ou -1 si plus aucun caractère n’est disponible.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode remplace la <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType> (méthode).  
  
 Le tableau suivant répertorie des exemples d’autres tâches d’e/s courantes ou apparentées.  
  
|Pour...|Consultez l'exemple décrit dans cette rubrique...|  
|-------------------|--------------------------------------|  
|Créer un fichier texte.|[Guide pratique pour écrire du texte dans un fichier](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Écrire dans un fichier texte.|[Guide pratique pour écrire du texte dans un fichier](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Lire un fichier texte.|[Guide pratique pour lire le texte d’un fichier](~/docs/standard/io/how-to-read-text-from-a-file.md)|  
|Ajouter du texte dans un fichier.|[Guide pratique pour ouvrir un fichier journal et y ajouter des éléments](~/docs/standard/io/how-to-open-and-append-to-a-log-file.md)<br /><br /> <xref:System.IO.File.AppendText%2A?displayProperty=nameWithType><br /><br /> <xref:System.IO.FileInfo.AppendText%2A?displayProperty=nameWithType>|  
|Obtenir la taille d’un fichier.|<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>|  
|Obtenir les attributs d’un fichier.|<xref:System.IO.File.GetAttributes%2A?displayProperty=nameWithType>|  
|Définissez les attributs d’un fichier.|<xref:System.IO.File.SetAttributes%2A?displayProperty=nameWithType>|  
|Déterminer si un fichier existe.|<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>|  
|Lire à partir d’un fichier binaire.|[Guide pratique pour lire et écrire dans un fichier de données créé récemment](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
|Écrire dans un fichier binaire.|[Guide pratique pour lire et écrire dans un fichier de données créé récemment](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.StringReader> classe.  
  
 [!code-cpp[System.IO.StringReaderWriter#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StringReaderWriter/CPP/stringrw.cpp#3)]
 [!code-csharp[System.IO.StringReaderWriter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StringReaderWriter/CS/stringrw.cs#3)]
 [!code-vb[System.IO.StringReaderWriter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StringReaderWriter/VB/stringrw.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le lecteur actuel est fermé.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;char&gt; -&gt; int" Usage="stringReader.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : char[] * int * int -&gt; int" Usage="stringReader.Read (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quand cette méthode est retournée, contient le tableau de caractères spécifié dont les valeurs comprises entre <paramref name="index" /> et (<paramref name="index" /> + <paramref name="count" /> - 1) sont remplacées par les caractères lus dans la source actuelle.</param>
        <param name="index">Index de début dans la mémoire tampon.</param>
        <param name="count">Nombre de caractères à lire.</param>
        <summary>Lit un bloc de caractères dans la chaîne d’entrée et avance la position du caractère de <paramref name="count" />.</summary>
        <returns>Nombre total de caractères lus dans la mémoire tampon. Cela peut être inférieur au nombre de caractères demandé si ce nombre n’est pas actuellement disponible, ou égal à zéro si la fin de la chaîne sous-jacente a été atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 La méthode lit jusqu'à `count` caractères à partir de la <xref:System.IO.StringReader> dans le `buffer` tableau de caractères en commençant à la position `index`. Retourne le nombre réel de caractères à lire ou à zéro si la fin de la chaîne a été atteinte et aucune caractères ne sont lus.  
  
 Le tableau suivant répertorie des exemples d’autres tâches d’e/s courantes ou apparentées.  
  
|Pour...|Consultez l'exemple décrit dans cette rubrique...|  
|-------------------|--------------------------------------|  
|Créer un fichier texte.|[Guide pratique pour écrire du texte dans un fichier](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Écrire dans un fichier texte.|[Guide pratique pour écrire du texte dans un fichier](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Lire un fichier texte.|[Guide pratique pour lire le texte d’un fichier](~/docs/standard/io/how-to-read-text-from-a-file.md)|  
|Ajouter du texte dans un fichier.|[Guide pratique pour ouvrir un fichier journal et y ajouter des éléments](~/docs/standard/io/how-to-open-and-append-to-a-log-file.md)<br /><br /> <xref:System.IO.File.AppendText%2A?displayProperty=nameWithType><br /><br /> <xref:System.IO.FileInfo.AppendText%2A?displayProperty=nameWithType>|  
|Obtenir la taille d’un fichier.|<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>|  
|Obtenir les attributs d’un fichier.|<xref:System.IO.File.GetAttributes%2A?displayProperty=nameWithType>|  
|Définissez les attributs d’un fichier.|<xref:System.IO.File.SetAttributes%2A?displayProperty=nameWithType>|  
|Déterminer si un fichier existe.|<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>|  
|Lire à partir d’un fichier binaire.|[Guide pratique pour lire et écrire dans un fichier de données créé récemment](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
|Écrire dans un fichier binaire.|[Guide pratique pour lire et écrire dans un fichier de données créé récemment](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La longueur de la mémoire tampon moins <paramref name="index" /> est inférieure à <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ou <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.ObjectDisposedException">Le lecteur actuel est fermé.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="stringReader.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stringReader.ReadAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Quand cette méthode est retournée, contient le tableau de caractères spécifié dont les valeurs comprises entre <paramref name="index" /> et (<paramref name="index" /> + <paramref name="count" /> - 1) sont remplacées par les caractères lus dans la source actuelle.</param>
        <param name="index">Position dans <paramref name="buffer" /> à partir de laquelle commencer l'écriture.</param>
        <param name="count">Nombre maximal de caractères à lire. Si la fin de la chaîne est atteinte avant que le nombre de caractères spécifié soit écrit dans la mémoire tampon, la méthode est retournée.</param>
        <summary>Lit un nombre maximal spécifié de caractères à partir de la chaîne actuelle de manière asynchrone, et écrit les données dans une mémoire tampon, en commençant à l’index spécifié.</summary>
        <returns>Tâche qui représente l'opération de lecture asynchrone. La valeur du paramètre <paramref name="TResult" /> contient le nombre total d'octets lus dans la mémoire tampon. La valeur de résultat peut être inférieure au nombre d’octets demandés si le nombre d’octets actuellement disponibles est inférieur au nombre demandé, ou elle peut avoir la valeur 0 (zéro) si la fin de la chaîne a été atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tâche termine après un nombre de caractères spécifié par le `count` paramètre sont en lecture ou la fin de la chaîne est atteinte.  
  
   
  
## Examples  
 L’exemple suivant montre comment lire de façon asynchrone les 23 premiers caractères d’une chaîne.  
  
 [!code-csharp[System.IO.StringReader#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stringreader/cs/example1.cs#1)]
 [!code-vb[System.IO.StringReader#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stringreader/vb/example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ou <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.ArgumentException">La somme de <paramref name="index" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</exception>
        <exception cref="T:System.ObjectDisposedException">Le lecteur de chaîne a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">Le lecteur est actuellement utilisé par une opération de lecture antérieure.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadBlock(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : Span&lt;char&gt; -&gt; int" Usage="stringReader.ReadBlock buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadBlockAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadBlockAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadBlockAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="stringReader.ReadBlockAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlockAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadBlockAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stringReader.ReadBlockAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Quand cette méthode est retournée, contient le tableau de caractères spécifié dont les valeurs comprises entre <paramref name="index" /> et (<paramref name="index" /> + <paramref name="count" /> - 1) sont remplacées par les caractères lus dans la source actuelle.</param>
        <param name="index">Position dans <paramref name="buffer" /> à partir de laquelle commencer l'écriture.</param>
        <param name="count">Nombre maximal de caractères à lire. Si la fin de la chaîne est atteinte avant que le nombre de caractères spécifié soit écrit dans la mémoire tampon, la méthode est retournée.</param>
        <summary>Lit un nombre maximal spécifié de caractères à partir de la chaîne actuelle de manière asynchrone, et écrit les données dans une mémoire tampon, en commençant à l’index spécifié.</summary>
        <returns>Tâche qui représente l'opération de lecture asynchrone. La valeur du paramètre <paramref name="TResult" /> contient le nombre total d'octets lus dans la mémoire tampon. La valeur de résultat peut être inférieure au nombre d’octets demandés si le nombre d’octets actuellement disponibles est inférieur au nombre demandé, ou elle peut avoir la valeur 0 (zéro) si la fin de la chaîne a été atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tâche ne termine pas tant que le nombre de caractères spécifié par le `count` paramètre sont en lecture ou la fin de la chaîne a été atteinte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ou <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.ArgumentException">La somme de <paramref name="index" /> et <paramref name="count" /> est supérieure à la longueur de la mémoire tampon.</exception>
        <exception cref="T:System.ObjectDisposedException">Le lecteur de chaîne a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">Le lecteur est actuellement utilisé par une opération de lecture antérieure.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public override string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="override this.ReadLine : unit -&gt; string" Usage="stringReader.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit une ligne de caractères à partir de la chaîne en cours et retourne les données sous forme de chaîne.</summary>
        <returns>Ligne suivante dans la chaîne actuelle ou <see langword="null" /> si la fin de la chaîne est atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode remplace la <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType> (méthode).  
  
 Une ligne est définie comme une séquence de caractères suivi d’un saut de ligne (« \n »), un retour chariot (« \r »), un retour chariot immédiatement suivi d’un saut de ligne (« \r\n ») ou le marqueur de fin de flux. La chaîne retournée ne contient pas le retour chariot ou saut de ligne. La valeur retournée est `null` si le marqueur de fin du flux a été atteinte. Autrement dit, si aucun élément n’entre la dernière lecture de la ligne et le marqueur de fin de flux, la méthode retourne `null`.  
  
 Si la méthode actuelle lève une <xref:System.OutOfMemoryException>, la position du lecteur dans la chaîne sous-jacente est avancée par le nombre de caractères que la méthode a été en mesure de lire, mais les caractères déjà lus dans le texte interne <xref:System.IO.StringReader.ReadLine%2A> tampon sont ignorées. Étant donné que la position du lecteur dans la chaîne ne peut pas être modifiée, les caractères déjà lus sont irrécupérables et sont accessibles uniquement en réinitialisant le <xref:System.IO.StringReader>. Pour éviter une telle situation, utilisez le <xref:System.IO.StringReader.Read%2A> (méthode) et store les caractères lus dans une mémoire tampon préallouée.  
  
 Le tableau suivant répertorie des exemples d’autres tâches d’e/s courantes ou apparentées.  
  
|Pour...|Consultez l'exemple décrit dans cette rubrique...|  
|-------------------|--------------------------------------|  
|Créer un fichier texte.|[Guide pratique pour écrire du texte dans un fichier](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Écrire dans un fichier texte.|[Guide pratique pour écrire du texte dans un fichier](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Lire un fichier texte.|[Guide pratique pour lire le texte d’un fichier](~/docs/standard/io/how-to-read-text-from-a-file.md)|  
|Ajouter du texte dans un fichier.|[Guide pratique pour ouvrir un fichier journal et y ajouter des éléments](~/docs/standard/io/how-to-open-and-append-to-a-log-file.md)<br /><br /> <xref:System.IO.File.AppendText%2A?displayProperty=nameWithType><br /><br /> <xref:System.IO.FileInfo.AppendText%2A?displayProperty=nameWithType>|  
|Obtenir la taille d’un fichier.|<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>|  
|Obtenir les attributs d’un fichier.|<xref:System.IO.File.GetAttributes%2A?displayProperty=nameWithType>|  
|Définissez les attributs d’un fichier.|<xref:System.IO.File.SetAttributes%2A?displayProperty=nameWithType>|  
|Déterminer si un fichier existe.|<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>|  
|Lire à partir d’un fichier binaire.|[Guide pratique pour lire et écrire dans un fichier de données créé récemment](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
|Écrire dans un fichier binaire.|[Guide pratique pour lire et écrire dans un fichier de données créé récemment](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.StringReader> classe.  
  
 [!code-cpp[System.IO.StringReaderWriter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StringReaderWriter/CPP/stringrw.cpp#2)]
 [!code-csharp[System.IO.StringReaderWriter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StringReaderWriter/CS/stringrw.cs#2)]
 [!code-vb[System.IO.StringReaderWriter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StringReaderWriter/VB/stringrw.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Le lecteur actuel est fermé.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire est insuffisante pour allouer une mémoire tampon à la chaîne retournée.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLineAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadLineAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadLineAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="stringReader.ReadLineAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit une ligne de caractères de manière asynchrone à partir de la chaîne en cours et retourne les données sous forme de chaîne.</summary>
        <returns>Tâche qui représente l'opération de lecture asynchrone. La valeur du paramètre <paramref name="TResult" /> contient la ligne suivante issue du lecteur de chaîne, ou a la valeur <see langword="null" /> si tous les caractères ont été lus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment lire une ligne à la fois à partir d’une chaîne de façon asynchrone.  
  
 [!code-csharp[System.IO.StringReader#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stringreader/cs/example3.cs#3)]
 [!code-vb[System.IO.StringReader#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stringreader/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le nombre de caractères dans la ligne suivante est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le lecteur de chaîne a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">Le lecteur est actuellement utilisé par une opération de lecture antérieure.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public override string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="override this.ReadToEnd : unit -&gt; string" Usage="stringReader.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit tous les caractères entre la position actuelle et la fin de la chaîne, puis les retourne sous la forme d’une chaîne unique.</summary>
        <returns>Contenu à partir de la position actuelle jusqu’à la fin du flux sous-jacent.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode remplace la <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType> (méthode).  
  
 Si la méthode actuelle lève une <xref:System.OutOfMemoryException>, la position du lecteur dans la chaîne sous-jacente est avancée par le nombre de caractères que la méthode a été en mesure de lire, mais les caractères déjà lus dans le texte interne <xref:System.IO.StringReader.ReadToEnd%2A> tampon sont ignorées. Étant donné que la position du lecteur dans la chaîne ne peut pas être modifiée, les caractères déjà lus sont irrécupérables et sont accessibles uniquement en réinitialisant le <xref:System.IO.StringReader>. Pour éviter une telle situation, utilisez le <xref:System.IO.StringReader.Read%2A> (méthode) et store les caractères lus dans une mémoire tampon préallouée.  
  
 Le tableau suivant répertorie des exemples d’autres tâches d’e/s courantes ou apparentées.  
  
|Pour...|Consultez l'exemple décrit dans cette rubrique...|  
|-------------------|--------------------------------------|  
|Créer un fichier texte.|[Guide pratique pour écrire du texte dans un fichier](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Écrire dans un fichier texte.|[Guide pratique pour écrire du texte dans un fichier](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Lire un fichier texte.|[Guide pratique pour lire le texte d’un fichier](~/docs/standard/io/how-to-read-text-from-a-file.md)|  
|Ajouter du texte dans un fichier.|[Guide pratique pour ouvrir un fichier journal et y ajouter des éléments](~/docs/standard/io/how-to-open-and-append-to-a-log-file.md)<br /><br /> <xref:System.IO.File.AppendText%2A?displayProperty=nameWithType><br /><br /> <xref:System.IO.FileInfo.AppendText%2A?displayProperty=nameWithType>|  
|Obtenir la taille d’un fichier.|<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>|  
|Obtenir les attributs d’un fichier.|<xref:System.IO.File.GetAttributes%2A?displayProperty=nameWithType>|  
|Définissez les attributs d’un fichier.|<xref:System.IO.File.SetAttributes%2A?displayProperty=nameWithType>|  
|Déterminer si un fichier existe.|<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>|  
|Lire à partir d’un fichier binaire.|[Guide pratique pour lire et écrire dans un fichier de données créé récemment](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
|Écrire dans un fichier binaire.|[Guide pratique pour lire et écrire dans un fichier de données créé récemment](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
  
   
  
## Examples  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.TextReader> classe.  
  
 [!code-cpp[System.IO.TextReaderWriter#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.TextReaderWriter/CPP/textrw.cpp#5)]
 [!code-csharp[System.IO.TextReaderWriter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.TextReaderWriter/CS/textrw.cs#5)]
 [!code-vb[System.IO.TextReaderWriter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.TextReaderWriter/VB/textrw.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">La mémoire est insuffisante pour allouer une mémoire tampon à la chaîne retournée.</exception>
        <exception cref="T:System.ObjectDisposedException">Le lecteur actuel est fermé.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadToEndAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEndAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadToEndAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadToEndAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="stringReader.ReadToEndAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit tous les caractères entre la position actuelle et la fin de la chaîne de manière asynchrone, puis les retourne sous la forme d’une chaîne unique.</summary>
        <returns>Tâche qui représente l'opération de lecture asynchrone. La valeur du paramètre <paramref name="TResult" /> contient une chaîne composée des caractères de la position actuelle jusqu’à la fin de la chaîne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment lire une chaîne complète de façon asynchrone.  
  
 [!code-csharp[System.IO.StringReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stringreader/cs/example2.cs#2)]
 [!code-vb[System.IO.StringReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stringreader/vb/example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le nombre de caractères est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Le lecteur de chaîne a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">Le lecteur est actuellement utilisé par une opération de lecture antérieure.</exception>
      </Docs>
    </Member>
  </Members>
</Type>