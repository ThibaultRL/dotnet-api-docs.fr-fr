<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="87efe827b4d4d649387abf9f4fc5627fccf54480" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65013930" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Effectue des opérations sur des instances de <see cref="T:System.String" /> qui contiennent des informations relatives au chemin d'accès d'un fichier ou d'un répertoire. Ces opérations sont effectuées différemment selon la plateforme.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Un chemin d’accès est une chaîne qui fournit l’emplacement d’un fichier ou répertoire. Un chemin d’accès ne pointe pas nécessairement vers un emplacement sur le disque ; par exemple, un chemin d’accès peut mapper à un emplacement en mémoire ou sur un appareil. Le format exact d’un chemin d’accès est déterminé par la plateforme actuelle. Par exemple, sur certains systèmes, un chemin d’accès peut commencer par une lettre de lecteur ou volume, tandis que cet élément n’est pas présent dans d’autres systèmes. Sur certains systèmes, les chemins d’accès de fichier peuvent contenir des extensions, qui indiquent le type d’informations stockées dans le fichier. Le format d’une extension de nom de fichier est dépendante de la plateforme ; par exemple, certains systèmes de limitent les extensions à trois caractères, et d’autres ne le faites pas. La plateforme actuelle détermine également le jeu de caractères utilisé pour séparer les éléments d’un chemin d’accès et le jeu de caractères qui ne peut pas être utilisé lors de la spécification de chemins d’accès. En raison de ces différences, les champs de la `Path` classe, ainsi que le comportement exact de certains membres de la `Path` classe sont dépendants de la plateforme.  
  
 Un chemin d’accès peut contenir des informations d’emplacement absolu ou relatif. Chemins d’accès absolus spécifient un emplacement : le fichier ou le répertoire peut être identifiée, quel que soit l’emplacement actuel. Chemins d’accès relatifs spécifient un emplacement partiel : l’emplacement actuel est utilisé comme point de départ lors de la localisation d’un fichier spécifié avec un chemin d’accès relatif. Pour déterminer le répertoire actif, appelez <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.  

 .NET core 1.1 et versions ultérieures et .NET Framework 4.6.2 et versions ultérieures prennent également en charge l’accès aux objets de système de fichiers qui sont des noms de périphériques, tels que «\\? \C :\".

Pour plus d’informations sur les formats de chemin d’accès de fichier sur Windows, consultez [les formats de chemin d’accès des fichiers sur les systèmes Windows](~/docs/standard/io/file-path-formats.md).

 La plupart des membres de la `Path` n’interagissent pas avec le système de fichiers de classe et ne pas vérifier l’existence du fichier spécifié par une chaîne de chemin d’accès. `Path` classe les membres qui modifient une chaîne de chemin d’accès, tel que <xref:System.IO.Path.ChangeExtension%2A>, n’ont aucun effet sur les noms de fichiers dans le système de fichiers. `Path` membres, toutefois, valider le contenu d’une chaîne de chemin d’accès spécifié et lève un <xref:System.ArgumentException> exception si la chaîne contient des caractères qui ne sont pas valides dans les chaînes de chemin d’accès, tel que défini dans les caractères renvoyés à partir de la <xref:System.IO.Path.GetInvalidPathChars%2A> (méthode). Par exemple, sur les plateformes de bureau Windows, les caractères de chemin non valide peuvent inclure les guillemets («), inférieur à (\<), supérieur à (>), barre verticale (&#124;), retour arrière (\b), valeur null (\0) et les caractères Unicode 16 et 18 et 20 à 25.  
  
 Les membres de la `Path` classe que vous puissiez rapidement et facilement effectuer des opérations courantes telles que déterminer si une extension de nom de fichier fait partie d’un chemin d’accès et combiner deux chaînes en un chemin d’accès.  
  
 Tous les membres de la `Path` classe sont statique et peuvent donc être appelés sans disposer d’une instance d’un chemin d’accès.  
  
> [!NOTE]
>  Dans les membres qui acceptent un chemin d’accès sous forme de chaîne d’entrée, ce chemin d’accès doit être correctement construit, ou une exception est levée. Par exemple, si un chemin d’accès est qualifié complet mais commence par un espace, le chemin d’accès n’est pas tronqué dans les méthodes de la classe. Par conséquent, le chemin d’accès est incorrect et une exception est levée. De même, un chemin d’accès ou une combinaison de chemins d’accès ne peut pas être qualifiée à deux reprises. Par exemple, « c:\temp c:\windows » déclenche également une exception dans la plupart des cas. Assurez-vous que vos chemins sont correctement construits lors de l’utilisation des méthodes qui acceptent une chaîne de chemin d’accès.  
  
 Dans les membres qui acceptent un chemin d’accès, le chemin d’accès peut faire référence à un fichier ou simplement un répertoire. Le chemin d’accès spécifié peut également faire référence à un chemin d’accès relatif ou un chemin d’accès UNC Universal Naming Convention () pour un nom de serveur et le partage. Par exemple, tous les éléments suivants sont des chemins d’accès acceptables :  
  
-   « c:\\\MyDir\\\MyFile.txt » en c# ou « c:\MyDir\MyFile.txt » en Visual Basic.  
  
-   « c:\\\MyDir » en c# ou « c:\MyDir » en Visual Basic.  
  
-   « MyDir\\\MySubdir » en c# ou « Monrépertoire\monsousrépertoire » en Visual Basic.  
  
-   «\\\\\\\MyServer\\\MyShare » en c#, ou «\\\MyServer\MyShare » en Visual Basic.  
  
 Étant donné que toutes ces opérations sont effectuées sur les chaînes, il est impossible de vérifier que les résultats sont valides dans tous les scénarios. Par exemple, le <xref:System.IO.Path.GetExtension%2A> méthode analyse une chaîne que vous lui transmettez et retourne l’extension de cette chaîne. Toutefois, cela ne signifie pas qu’un fichier avec cette extension existe sur le disque.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).   
  
## Examples  
 L’exemple suivant illustre certains membres principaux de la `Path` classe.  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Procédure : lire et écrire dans un fichier de données créé récemment</related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fournit un caractère de remplacement spécifique à la plateforme, utilisé pour séparer les niveaux de répertoire dans une chaîne de chemin d'accès qui reflète une organisation de système de fichiers hiérarchique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Ce champ peut avoir la même valeur que <xref:System.IO.Path.DirectorySeparatorChar>. `AltDirectorySeparatorChar` et <xref:System.IO.Path.DirectorySeparatorChar> sont tous deux valides pour séparer les niveaux de répertoire dans une chaîne de chemin d’accès.  
  
La valeur de ce champ est une barre oblique (« / ») sur Windows et les systèmes d’exploitation Unix.  
  
## Examples  

L’exemple suivant affiche <xref:System.IO.Path> sur Windows et sur les systèmes Unix de valeurs de champ. Notez que Windows prend en charge soit la barre oblique (qui est retourné par la <xref:System.IO.Path.AltDirectorySeparatorChar> champ) ou la barre oblique inverse (qui est retourné par la <xref:System.IO.Path.DirectorySeparatorChar> champ) comme des caractères de séparateur de chemin d’accès, tandis que les systèmes Unix prend en charge uniquement la barre oblique.

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Informations relatives au chemin d’accès à modifier. Le chemin d'accès ne peut contenir aucun des caractères définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</param>
        <param name="extension">Nouvelle extension (avec ou sans point de début). Spécifiez <see langword="null" /> pour supprimer une extension existante de <paramref name="path" />.</param>
        <summary>Modifie l'extension d'une chaîne de chemin d'accès.</summary>
        <returns>Informations relatives au chemin d'accès modifiées.  
  
Sur les plateformes de bureau Windows, si <paramref name="path" /> est <see langword="null" /> ou est une chaîne vide (""), les informations relatives au chemin d’accès sont retournées inchangées. Si <paramref name="extension" /> est <see langword="null" />, la chaîne retournée contient le chemin d'accès spécifié avec l'extension supprimée. Si <paramref name="path" /> ne possède pas d’extension et si <paramref name="extension" /> n’est pas <see langword="null" />, la chaîne du chemin d’accès retournée contient <paramref name="extension" />, ajouté à la fin de <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si ni `path` ni `extension` contient un point (.), `ChangeExtension` ajoute la période.  
  
 Le `extension` paramètre peut contenir plusieurs points, des caractères de chemin d’accès valide et peut être n’importe quelle longueur. Si `extension` est `null`, la chaîne retournée contient le contenu de `path` avec la dernière période et tous les caractères après celui-ci supprimé.  
  
 Si `extension` est une chaîne vide, la chaîne de chemin d’accès retournée contient le contenu de `path` avec les caractères après le dernier point supprimé.  
  
 Si `path` n’a pas d’extension et `extension` n’est pas `null`, la chaîne retournée contient `path` suivie `extension`.  
  
 Si `extension` n’est pas `null` et ne contient pas un point de début, la période est ajoutée.  
  
 Si `path` contient plusieurs extensions séparées par plusieurs points, la chaîne retournée contient le contenu de `path` avec la dernière période et tous les caractères après celui-ci remplacé par `extension`. Par exemple, si `path` est « \Dir1\examples\pathtests.csx.txt » et `extension` est « cs », le chemin d’accès modifié est « \Dir1\examples\pathtests.csx.cs ».  
  
 Il n’est pas possible de vérifier que les résultats retournés sont valides dans tous les scénarios. Par exemple, si `path` est vide, `extension` est ajouté.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre une utilisation de la `ChangeExtension` (méthode).  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Combine des chaînes en un chemin d'accès.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Cette méthode est destinée à concaténer des chaînes individuelles en une seule chaîne qui représente un chemin d’accès de fichier. Toutefois, si un argument différent du premier contient un chemin d’accès racine, des composants de chemin d’accès précédente sont ignorées, et la chaîne retournée commence par ce composant de chemin d’accès associé. Comme alternative à la `Combine` (méthode), envisagez d’utiliser le <xref:System.IO.Path.Join%2A> ou <xref:System.IO.Path.TryJoin%2A> méthodes.

> [!IMPORTANT]
> Cette méthode suppose que le premier argument est un chemin d’accès absolu et que l’ou les arguments suivants sont des chemins d’accès relatifs. Si ce n’est pas le cas, et en particulier si des arguments suivants sont des chaînes entrées par l’utilisateur, appelez le <xref:System.IO.Path.Join%2A> ou <xref:System.IO.Path.TryJoin%2A> méthode à la place.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">Tableau de parties du chemin d’accès.</param>
        <summary>Combine un tableau de chaînes en un chemin d’accès.</summary>
        <returns>Chemins d'accès combinés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`paths` doit être un tableau des parties du chemin d’accès à combiner. Si l’un des chemins d’accès suivants est un chemin d’accès absolu, l’opération de combinaison réinitialise en commençant par ce chemin d’accès absolu, en ignorant tous les chemins d’accès combinés précédentes.  

Si n’importe quel élément dans `paths` mais il n’est pas un lecteur et ne se termine pas par une les <xref:System.IO.Path.DirectorySeparatorChar> ou le <xref:System.IO.Path.AltDirectorySeparatorChar> caractère, le `Combine` méthode ajoute un <xref:System.IO.Path.DirectorySeparatorChar> caractère entre cet élément et la suivante. Notez que, si l’élément se termine par un caractère de séparation du chemin d’accès qui n’est pas approprié pour la plateforme cible, le `Combine` méthode conserve le caractère de séparateur de chemin d’accès d’origine et ajoute une prise en charge. L’exemple suivant compare le résultat sur les systèmes Unix et Windows lors de la barre oblique inverse est utilisée comme un caractère de séparateur de chemin d’accès.

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 Chaînes de longueur nulle sont omis dans le chemin combiné.  
  
 Les paramètres ne sont pas analysés s’ils ont un espace blanc.  
  
 Pas tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par le `Combine` (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche. Par exemple, bien que `Path.Combine("c:\\", "*.txt")` ne soit pas valide si vous deviez créer un fichier à partir de celui-ci, il est une chaîne de recherche valide. Il est donc interprété correctement par le `Combine` (méthode).  
  
## Examples  
 L’exemple suivant combine un tableau de chaînes en un chemin d’accès.  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’une des chaînes du tableau contient un ou plusieurs des caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">L’une des chaînes du tableau est <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Premier chemin d'accès à combiner.</param>
        <param name="path2">Deuxième chemin d'accès à combiner.</param>
        <summary>Combine deux chaînes en un chemin d’accès.</summary>
        <returns>Chemins d'accès combinés. Si un des chemins d'accès spécifiés est une chaîne de longueur zéro, cette méthode retourne l'autre chemin d'accès. Si <paramref name="path2" /> contient un chemin d’accès absolu, cette méthode retourne <paramref name="path2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `path1` n’est pas une référence de lecteur (autrement dit, « C: » ou « D: ») et ne se termine pas par un caractère de séparation valide comme défini dans <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, ou <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> est ajouté à `path1` avant la concaténation. Notez que si `path1` se termine par un caractère de séparation du chemin d’accès qui n’est pas approprié pour la plateforme cible, le `Combine` méthode conserve le caractère de séparateur de chemin d’accès d’origine et ajoute une prise en charge. L’exemple suivant compare le résultat sur les systèmes Unix et Windows lors de la barre oblique inverse est utilisée comme un caractère de séparateur de chemin d’accès.  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 Si `path2` n’inclut pas de racine (par exemple, si `path2` ne commence pas par un caractère de séparation ou une spécification de lecteur), le résultat est une concaténation de deux chemins, avec un caractère de séparation intermédiaire. Si `path2` inclut une racine, `path2` est retournée.  
  
 Les paramètres ne sont pas analysés s’ils ont un espace blanc. Par conséquent, si `path2` inclut un espace blanc (par exemple, « \file.txt »), le <xref:System.IO.Path.Combine%2A> ajoute de la méthode `path2` à `path1` au lieu de retourner uniquement `path2`.  
  
 Pas tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par le `Combine` (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche. Par exemple, bien que `Path.Combine("c:\\", "*.txt")` ne soit pas valide si vous deviez créer un fichier à partir de celui-ci, il est une chaîne de recherche valide. Il est donc interprété correctement par le `Combine` (méthode).  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le `Combine` méthode sur une plateforme de bureau Windows.  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" /> ou <paramref name="path2" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" /> ou <paramref name="path2" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Premier chemin d'accès à combiner.</param>
        <param name="path2">Deuxième chemin d'accès à combiner.</param>
        <param name="path3">Troisième chemin d'accès à combiner.</param>
        <summary>Combine trois chaînes en un chemin d'accès.</summary>
        <returns>Chemins d'accès combinés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` doit être un chemin d’accès absolu (par exemple, « d:\archives » ou «\\\archives\public »). Si `path2` ou `path3` est également un chemin absolu, les chemins d’accès de combiner opération ignore tout précédemment associées et les réinitialisations ce chemin d’accès absolu.  
  
 Chaînes de longueur nulle sont omis dans le chemin combiné.  
  
 Si `path1` ou `path2` n’est pas une référence de lecteur (autrement dit, « C: » ou « D: ») et ne se termine pas par un caractère de séparation valide comme défini dans <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, ou <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> est ajouté à `path1` ou `path2` avant la concaténation. Notez que si `path1` ou `path2` se termine par un caractère de séparation du chemin d’accès qui n’est pas approprié pour la plateforme cible, le `Combine` méthode conserve le caractère de séparateur de chemin d’accès d’origine et ajoute une prise en charge. L’exemple suivant compare le résultat sur les systèmes Unix et Windows lors de la barre oblique inverse est utilisée comme un caractère de séparateur de chemin d’accès. 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 Si `path2` n’inclut pas de racine (par exemple, si `path2` ne commence pas par un caractère de séparation ou une spécification de lecteur), le résultat est une concaténation de deux chemins, avec un caractère de séparation intermédiaire. Si `path2` inclut une racine, `path2` est retournée.  
  
 Les paramètres ne sont pas analysés s’ils ont un espace blanc. Par conséquent, si `path2` inclut un espace blanc (par exemple, « \file.txt »), le <xref:System.IO.Path.Combine%2A> ajoute de la méthode `path2` à `path1`.  
  
 Pas tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par le `Combine` (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche. Par exemple, bien que `Path.Combine("c:\\", "*.txt")` ne soit pas valide si vous deviez créer un fichier à partir de celui-ci, il est une chaîne de recherche valide. Il est donc interprété correctement par le `Combine` (méthode).  
  
   
  
## Examples  
 L’exemple suivant combine trois chemins d’accès.  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" /> ou <paramref name="path3" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />, <paramref name="path2" /> ou <paramref name="path3" /> est <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Premier chemin d'accès à combiner.</param>
        <param name="path2">Deuxième chemin d'accès à combiner.</param>
        <param name="path3">Troisième chemin d'accès à combiner.</param>
        <param name="path4">Quatrième chemin d'accès à combiner.</param>
        <summary>Combine quatre chaînes en un chemin d'accès.</summary>
        <returns>Chemins d'accès combinés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` doit être un chemin d’accès absolu (par exemple, « d:\archives » ou «\\\archives\public »). Si un des chemins suivants est également un chemin d’accès absolu, l’opération de combinaison ignore tous les chemins d’accès précédemment combinés et réinitialise ce chemin d’accès absolu.  
  
 Chaînes de longueur nulle sont omis dans le chemin combiné.  
  
 Si `path1`, `path2`, ou `path3` n’est pas une référence de lecteur (autrement dit, « C: » ou « D: ») et ne se termine pas par un caractère de séparation valide comme défini dans <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, ou <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> est ajouté à la fin avant la concaténation. Notez que si `path1`, `path2`, ou `path3` se termine par un caractère de séparation du chemin d’accès qui n’est pas approprié pour la plateforme cible, le `Combine` méthode conserve le caractère de séparateur de chemin d’accès d’origine et ajoute une prise en charge. L’exemple suivant compare le résultat sur les systèmes Unix et Windows lors de la barre oblique inverse est utilisée comme un caractère de séparateur de chemin d’accès. 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 Si `path2` n’inclut pas de racine (par exemple, si `path2` ne commence pas par un caractère de séparation ou une spécification de lecteur), le résultat est une concaténation de deux chemins, avec un caractère de séparation intermédiaire. Si `path2` inclut une racine, `path2` est retournée.  
  
 Les paramètres ne sont pas analysés s’ils ont un espace blanc. Par conséquent, si `path2` inclut un espace blanc (par exemple, « \file.txt »), le <xref:System.IO.Path.Combine%2A> ajoute de la méthode `path2` à `path1`.  
  
 Pas tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par le `Combine` (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche. Par exemple, bien que `Path.Combine("c:\\", "*.txt")` ne soit pas valide si vous deviez créer un fichier à partir de celui-ci, il est une chaîne de recherche valide. Il est donc interprété correctement par le `Combine` (méthode).  
  
   
  
## Examples  
 L’exemple suivant combine quatre chemins d’accès.  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> ou <paramref name="path4" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> ou <paramref name="path4" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fournit un caractère spécifique à la plateforme, utilisé pour séparer les niveaux de répertoire dans une chaîne de chemin d'accès qui reflète une organisation de système de fichiers hiérarchique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.IO.Path.AltDirectorySeparatorChar> et `DirectorySeparatorChar` sont tous deux valides pour séparer les niveaux de répertoire dans une chaîne de chemin d’accès.  
  
Lorsque vous utilisez .NET Core pour développer des applications qui s’exécutent sur plusieurs plateformes :

- Si vous préférez coder en dur le caractère de séparation de répertoire, vous devez utiliser la barre oblique (`/`) caractères. Il est le caractère de séparation de répertoire reconnu uniquement sur les systèmes Unix, en tant que la sortie de l’exemple et le <xref:System.IO.Path.AltDirectorySeparatorChar> sur Windows.

- Concaténation de chaînes permet de récupérer le caractère de séparateur de chemin d’accès lors de l’exécution dynamiquement et l’incorporer dans les chemins d’accès de système de fichiers. Par exemple : 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```
   ```vb
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ``` 
   Vous pouvez également récupérer la valeur à partir de la <xref:System.IO.Path.AltDirectorySeparatorChar> propriété, puisqu’il s’agit de la même sur Windows et les systèmes basés sur Unx.

- Récupérer le <xref:System.IO.Path.AltDirectorySeparatorChar> propriété

Si votre application n’est pas multiplateforme, vous pouvez utiliser le séparateur approprié pour votre système.

## Examples  

L’exemple suivant affiche <xref:System.IO.Path> sur Windows et sur les systèmes Unix de valeurs de champ. Notez que Windows prend en charge soit la barre oblique (qui est retourné par la <xref:System.IO.Path.AltDirectorySeparatorChar> champ) ou la barre oblique inverse (qui est retourné par la <xref:System.IO.Path.DirectorySeparatorChar> champ) comme des caractères de séparateur de chemin d’accès, tandis que les systèmes Unix prend en charge uniquement la barre oblique.  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>Renvoie les informations relatives au répertoire pour le chemin spécifié représenté par une étendue de caractères.</summary>
        <returns>Informations relatives au répertoire pour <paramref name="path" />, ou une étendue vide si <paramref name="path" /> correspond à <see langword="null" />, à une étendue vide ou à une racine (telle que \, C: ou \\serveur\partage).</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès d’un fichier ou d’un répertoire.</param>
        <summary>Retourne les informations relatives au répertoire pour la chaîne de chemin d’accès spécifiée.</summary>
        <returns>Informations relatives au répertoire pour <paramref name="path" />, ou <see langword="null" /> si <paramref name="path" /> indique un répertoire racine ou est null. Retourne un élément <see cref="F:System.String.Empty" /> si <paramref name="path" /> ne contient pas d'informations relatives au répertoire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans la plupart des cas, la chaîne retournée par cette méthode se compose de tous les caractères dans le chemin d’accès jusqu'à mais pas compris la dernière <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>. Si le chemin d’accès se compose d’un répertoire racine, tel que « c:\\», la valeur null est retournée. Notez que cette méthode ne prend pas en charge les chemins d’accès à l’aide de « fichier : ». Étant donné que le chemin d’accès retournée n’inclut pas le <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, en passant le chemin d’accès retourné de nouveau la <xref:System.IO.Path.GetDirectoryName%2A> méthode entraîne la troncation d’un niveau de dossier chaque appel suivant sur la chaîne de résultat. Par exemple, en passant le chemin d’accès « C:\Directory\SubDirectory\test.txt » dans le <xref:System.IO.Path.GetDirectoryName%2A> méthode retournera « C:\Directory\SubDirectory ». Passage de cette chaîne, « C:\Directory\SubDirectory », dans <xref:System.IO.Path.GetDirectoryName%2A> entraîne « C:\Directory ».  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le `GetDirectoryName` méthode sur une plateforme de bureau Windows.  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="path" /> est vide, contient seulement des espaces blancs ou contient des caractères non valides.</exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.IO.IOException" />, à la place.  
  
</para>
          </block>  
  
 Le paramètre <paramref name="path" /> est plus long que la longueur maximale définie par le système.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès de fichier à partir duquel vous pouvez obtenir l'extension.</param>
        <summary>Renvoie l'extension d'un chemin d'accès de fichier représenté par une étendue de caractères en lecture seule.</summary>
        <returns>Extension du chemin d'accès spécifié (point « . » compris), ou <see cref="P:System.ReadOnlySpan`1.Empty" /> ou si <paramref name="path" /> ne comporte pas d'informations d'extension.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Cette méthode obtient l’extension de `path` en effectuant une recherche `path` pendant une période («. »), à partir du dernier caractère dans l’étendue en lecture seule et en continuant vers son premier caractère. Si un point est trouvé avant un <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar> caractère, l’étendue en lecture seule retournée contient la période et les caractères après celui-ci ; sinon, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> est retournée.  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chaîne de chemin d’accès pour laquelle obtenir l’extension.</param>
        <summary>Retourne l’extension (y compris le point «. ») de la chaîne de chemin d’accès spécifié.</summary>
        <returns>Extension du chemin d’accès spécifié (y compris le point ".") ou <see langword="null" /> ou <see cref="F:System.String.Empty" />. Si <paramref name="path" /> est <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> retourne <see langword="null" />. Si <paramref name="path" /> ne contient pas d’informations relatives à l’extension, <see cref="M:System.IO.Path.GetExtension(System.String)" /> retourne <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Cette méthode obtient l’extension de `path` en effectuant une recherche `path` pour un point (.), en commençant par le dernier caractère de `path` et en continuant vers le premier caractère. Si un point est trouvé avant un <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar> caractère, la chaîne retournée contient la période et les caractères après celui-ci ; sinon, <xref:System.String.Empty?displayProperty=nameWithType> est retournée.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).
 
## Examples  
 L’exemple suivant montre comment utiliser le `GetExtension` méthode sur une plateforme de bureau Windows.  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Étendue en lecture seule contenant le chemin d'accès à partir duquel vous pouvez obtenir le nom et l'extension du fichier.</param>
        <summary>Renvoie le nom et l'extension d'un chemin de fichier représenté par une étendue de caractères en lecture seule.</summary>
        <returns>Caractères situés après le dernier caractère de séparation du répertoire dans <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

L’étendue en lecture seule retournée contient les caractères du chemin qui suivent le dernier séparateur dans `path`. Si le dernier caractère de `path` est un caractère de séparation de volume ou un répertoire, la méthode retourne <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>. Si `path` ne contient aucun caractère de séparation, la méthode retourne `path`.

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chaîne de chemin d'accès à partir de laquelle obtenir le nom et l'extension de fichier.</param>
        <summary>Retourne le nom et l’extension de fichier de la chaîne de chemin d’accès spécifiée.</summary>
        <returns>Caractères situés après le dernier caractère de séparation du répertoire dans <paramref name="path" />. Si le dernier caractère de <paramref name="path" /> est un caractère de séparation de répertoire ou de volume, cette méthode retourne <see cref="F:System.String.Empty" />. Si <paramref name="path" /> est <see langword="null" />, cette méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

La valeur retournée est `null` si le chemin d’accès de fichier est `null`.  
  
Les caractères de séparation utilisés pour déterminer le début du nom de fichier sont <xref:System.IO.Path.DirectorySeparatorChar> et <xref:System.IO.Path.AltDirectorySeparatorChar>.  

Étant donné que *\\* est un nom de fichier juridiques sur Unix, `GetFileName` en cours d’exécution sous les plates-formes basées sur Unix ne peut pas retourner correctement le nom de fichier à partir d’un chemin d’accès basé sur Windows, tels que *C:\\mydir\\myfile.ext*, mais `GetFileName` en cours d’exécution sous les plates-formes basées sur Windows peut retourner correctement le nom de fichier à partir d’un chemin d’accès basés sur Unix comme */tmp/myfile.ext*, de sorte que le comportement de la `GetFileName` méthode n’est pas strictement identique sur les plateformes Unix et Windows.

Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant illustre le comportement de la `GetFileName` méthode sur une plateforme de bureau Windows.  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Étendue en lecture seule contenant le chemin d'accès à partir duquel vous pouvez obtenir le nom de fichier sans l'extension.</param>
        <summary>Renvoie le nom de fichier sans l'extension d'un chemin d'accès de fichier représenté par une étendue de caractères en lecture seule.</summary>
        <returns>Caractères de l'étendue en lecture seule renvoyés par <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, moins le dernier point (.) et tous les caractères qui le suivent.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès au fichier.</param>
        <summary>Retourne le nom de fichier de la chaîne de chemin d'accès spécifiée sans l'extension.</summary>
        <returns>Chaîne retournée par <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, moins le dernier point (.) et tous les caractères après celui-ci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne vérifie pas que le chemin d’accès ou nom de fichier existe.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre une utilisation de la `GetFileNameWithoutExtension` (méthode).  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Fichier ou répertoire pour lequel obtenir les informations sur le chemin d’accès absolu.</param>
        <summary>Retourne le chemin d'accès absolu de la chaîne de chemin d'accès spécifiée.</summary>
        <returns>Emplacement qualifié complet de <paramref name="path" />, par exemple « C:\MonFichier.txt ».</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Le chemin d’accès absolu inclut toutes les informations requises pour rechercher un fichier ou répertoire sur un système.  
  
 Le fichier ou le répertoire spécifié par `path` n’est pas requis pour exister. Par exemple, si *c:\temp\newdir* est le répertoire actif, l’appel `GetFullPath` sur un nom de fichier, tel que *test.txt* retourne *c:\temp\newdir\test.txt*. Le fichier ne doit pas exister.  

> [!IMPORTANT]
> Si `path` est un chemin d’accès relatif, cette surcharge retourne un chemin d’accès qualifié complet qui peut être basée sur le lecteur actuel et le répertoire actif. Le lecteur actuel et le répertoire actuel peuvent modifier à tout moment comme une application s’exécute. Par conséquent, le chemin d’accès retourné par cette surcharge ne peut pas être déterminé à l’avance. Pour retourner un chemin d’accès déterministe, appelez le <xref:System.IO.Path.GetFullPath(System.String,System.String)> de surcharge. Vous pouvez également appeler le <xref:System.IO.Path.IsPathFullyQualified%2A> méthode pour déterminer si un chemin d’accès complet ou relatif et par conséquent, si un appel à `GetFullPath` est nécessaire.

 Toutefois, si `path` existe, l’appelant doit avoir l’autorisation pour obtenir des informations de chemin d’accès pour `path`. Notez que contrairement à la plupart des membres de la <xref:System.IO.Path> classe, cette méthode accède au système de fichiers.  
  
 Cette méthode utilise le répertoire actif et les informations de volume actuel pour qualifier complètement `path`. Si vous spécifiez un fichier de nom uniquement dans `path`, `GetFullPath` retourne le chemin d’accès qualifié complet du répertoire actif.  
  
 Si vous passez un nom de fichier court, il est développé pour un nom de fichier long.  
  
 Si un chemin d’accès ne contient aucun caractère significatifs, il n’est pas valide, sauf si elle contient un ou plusieurs «. » caractères suivis par n’importe quel nombre d’espaces ; Il sera analysé en tant que «. « ou ».. ».  

.NET core 1.1 et versions ultérieures et .NET Framework 4.6.2 et versions ultérieures prennent également en charge les chemins d’accès qui comprennent les noms de périphérique, telles que «\\? \C :\".

Pour plus d’informations sur les formats de chemin d’accès de fichier sur Windows, consultez [les formats de chemin d’accès des fichiers sur les systèmes Windows](~/docs/standard/io/file-path-formats.md). Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).
  
## Examples  
 L’exemple suivant montre le `GetFullPath` méthode sur une plateforme de bureau Windows.  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, ne contient que des espaces blancs ou contient un ou plusieurs des caractères non valides définis par <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
Le système n’a pas pu récupérer le chemin d’accès absolu.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas les autorisations requises.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> contient un caractère deux-points (« : ») qui ne fait pas partie d’un identificateur de volume (par exemple, « c:\\ »).</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder au chemin d’accès.</permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès relatif à concaténer au sein de <paramref name="basePath" />.</param>
        <param name="basePath">Début d'un chemin d'accès complet.</param>
        <summary>Renvoie un chemin d'accès complet à partir d'un chemin de base complet et d'un chemin relatif.</summary>
        <returns>Chemin d'accès complet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Si `path` est un chemin d’accès vide, la méthode retourne `basePath`. Si `path` est un chemin d’accès qualifié complet, les passes de méthode `path` à la <xref:System.IO.Path.GetFullPath(System.String)> méthode et retourne le résultat.

Utilisez cette méthode pour retourner un chemin d’accès déterministe basée sur un volume spécifié et associé à une racine de répertoire lorsque vous utilisez des chemins d’accès relatifs. À l’aide de prédéfini `basePath` au lieu d’une basée sur l’actuel lecteur directory protège des chemins de fichiers indésirables causés par des modifications inattendues dans le lecteur actuel et le répertoire. 

## <a name="example"></a>Exemple

L’exemple suivant définit une variable, `basePath`, pour représenter le répertoire en cours d’une application. Il passe ensuite à la `GetFullPath` méthode pour obtenir un chemin d’accès complet au répertoire de données de l’application.

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ou <paramref name="basePath" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="basePath" /> n'est pas un chemin d'accès complet.

ou

<paramref name="path" /> ou <paramref name="basePath" /> contient des caractères de chemin non valides, tels que U+0000.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un tableau contenant les caractères qui ne sont pas autorisés dans les noms de fichiers.</summary>
        <returns>Tableau contenant les caractères qui ne sont pas autorisés dans les noms de fichiers.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau renvoyé par cette méthode n’est pas garanti pour contenir l’ensemble complet des caractères qui ne sont pas valides dans les noms de fichiers et de répertoires. L’ensemble des caractères non valides peut varier selon le système de fichiers. Par exemple, sur les plateformes de bureau Windows, les caractères de chemin non valide peuvent inclure des caractères ASCII/Unicode 1 à 31, ainsi que mettre entre guillemets («), inférieur à (\<), supérieur à (>), barre verticale (&#124;), retour arrière (\b), valeur null (\0) et tabulation (\t).  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.IO.Path.GetInvalidFileNameChars%2A> (méthode) et le <xref:System.IO.Path.GetInvalidPathChars%2A> méthode pour récupérer les caractères non valides.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un tableau contenant les caractères qui ne sont pas autorisés dans les noms de chemins d'accès.</summary>
        <returns>Tableau contenant les caractères qui ne sont pas autorisés dans les noms de chemins d'accès.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau renvoyé par cette méthode n’est pas garanti pour contenir l’ensemble complet des caractères qui ne sont pas valides dans les noms de fichiers et de répertoires. L’ensemble des caractères non valides peut varier selon le système de fichiers. Par exemple, sur les plateformes de bureau Windows, les caractères de chemin non valide peuvent inclure des caractères ASCII/Unicode 1 à 31, ainsi que mettre entre guillemets («), inférieur à (\<), supérieur à (>), barre verticale (&#124;), retour arrière (\b), valeur null (\0) et tabulation (\t).  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.IO.Path.GetInvalidFileNameChars%2A> (méthode) et le <xref:System.IO.Path.GetInvalidPathChars%2A> méthode pour récupérer les caractères non valides.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès à partir duquel obtenir les informations relatives au répertoire racine.</param>
        <summary>Obtient les informations du répertoire racine à partir du chemin d’accès contenu dans l’étendue de caractères spécifiée.</summary>
        <returns>Étendue de caractères qui contient le répertoire racine de `path`.</returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès à partir duquel obtenir les informations relatives au répertoire racine.</param>
        <summary>Obtient les informations relatives au répertoire racine du chemin d’accès spécifié.</summary>
        <returns>Répertoire racine de <paramref name="path" />, ou <see langword="null" /> si <paramref name="path" /> est <see langword="null" />, ou une chaîne vide si <paramref name="path" /> ne contient pas d’informations relatives au répertoire racine.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne vérifie pas que le chemin d’accès ou nom de fichier existe.  
  
 Les modèles possibles pour la chaîne retournée par cette méthode sont les suivantes :  
  
- Une chaîne vide (`path` spécifié un chemin d’accès relatif sur le lecteur en cours ou le volume).  
  
- «\" (`path` spécifié un chemin d’accès absolu sur le lecteur actif).  
  
- « X: » (`path` spécifié un chemin d’accès relatif sur un lecteur, où X représente une lettre de lecteur ou volume).  
  
- « X :\" (`path` spécifié un chemin d’accès absolu sur un lecteur donné).  
  
- «\\\ComputerName\SharedFolder » (un chemin d’accès UNC).  
  
- «\\? \C : » (un chemin de périphérique DOS, prise en charge dans .NET Core 1.1 et versions ultérieures et .NET Framework 4.6.2 et versions ultérieures)
   
 Pour plus d’informations sur les chemins d’accès sur Windows, consultez [les formats de chemin d’accès des fichiers sur les systèmes Windows](~/docs/standard/io/file-path-formats.md). Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
## Examples  
 L’exemple suivant montre une utilisation de la `GetPathRoot` (méthode).  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
ou 
 <see cref="F:System.String.Empty" /> a été passé à <paramref name="path" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un nom de dossier ou de fichier aléatoire.</summary>
        <returns>Nom de dossier ou de fichier aléatoire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Path.GetRandomFileName%2A> méthode retourne une chaîne aléatoire et forte qui peut être utilisée comme un nom de dossier ou un nom de fichier. Contrairement aux <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> ne crée pas de fichier. Lorsque la sécurité de votre système de fichiers est primordiale, cette méthode doit être utilisée à la place de <xref:System.IO.Path.GetTempFileName%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre la sortie de la <xref:System.IO.Path.GetRandomFileName%2A> (méthode).  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo">Chemin d'accès source auquel le résultat doit être relatif. Ce chemin d'accès est toujours considéré comme un répertoire.</param>
        <param name="path">Chemin d'accès de destination.</param>
        <summary>Renvoie un chemin d'accès relatif d'un chemin à un autre.</summary>
        <returns>Chemin d'accès relatif, ou <paramref name="path" /> si les chemins ne partagent pas la même racine.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Chemins d’accès sont résolus en appelant le <xref:System.IO.Path.GetFullPath%2A> méthode avant de calculer la différence. La méthode utilise la comparaison de chemin d’accès de fichier par défaut pour la plateforme actuelle (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> pour Windows et MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> pour Linux. 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relativeTo" /> ou <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un fichier temporaire de zéro octet nommé de façon univoque sur le disque et retourne le chemin d’accès complet de ce fichier.</summary>
        <returns>Chemin d'accès complet du fichier temporaire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée un fichier temporaire avec une. Extension de fichier TMP. Le fichier temporaire est créé dans le dossier temporaire de l’utilisateur, qui est le chemin d’accès retourné par la <xref:System.IO.Path.GetTempPath%2A> (méthode).  
  
 Le <xref:System.IO.Path.GetTempFileName%2A> méthode déclenchera un <xref:System.IO.IOException> s’il est utilisé pour créer plus de 65 535 fichiers sans supprimer les fichiers temporaires antérieurs.  
  
 Le <xref:System.IO.Path.GetTempFileName%2A> méthode déclenchera un <xref:System.IO.IOException> si aucun nom de fichier temporaire unique n’est disponible. Pour résoudre cette erreur, supprimez tous les fichiers temporaires inutiles.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit, par exemple si aucun nom de fichier temporaire unique n’est disponible.  
  
ou 
Cette méthode n’a pas pu créer un fichier temporaire.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le répertoire temporaire. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le chemin d’accès du dossier temporaire de l’utilisateur actuel.</summary>
        <returns>Chemin d’accès au dossier temporaire, se terminant par une barre oblique inverse.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode vérifie l’existence de variables d’environnement dans l’ordre suivant et utilise le premier chemin d’accès trouvé :  
  
1.  Le chemin d’accès spécifié par la variable d’environnement TMP.  
  
2.  Le chemin d’accès spécifié par la variable d’environnement TEMP.  
  
3.  Le chemin d’accès spécifié par la variable d’environnement USERPROFILE.  
  
4.  Le répertoire Windows.  
  
   
  
## Examples  
 Le code suivant montre comment appeler la méthode <xref:System.IO.Path.GetTempPath%2A>.  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 Cet exemple produit une sortie similaire à ce qui suit.  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas les autorisations requises.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour un accès illimité aux variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès où rechercher une extension.</param>
        <summary>Détermine si le chemin d'accès représenté par l'étendue de caractères spécifiée comprend une extension de nom de fichier.</summary>
        <returns><see langword="true" /> si les caractères qui suivent le dernier caractère de séparation de répertoire ou le dernier séparateur de volume du chemin d'accès incluent un point (« . ») suivi d'un ou plusieurs caractères ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Un point final dans `path` n’est pas considéré comme une extension.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès où rechercher une extension.</param>
        <summary>Détermine si un chemin d'accès inclut une extension de nom de fichier.</summary>
        <returns><see langword="true" /> si les caractères qui suivent le dernier séparateur de répertoire (\\\ ou /) ou le dernier séparateur de volume (:) dans le chemin d’accès incluent un point (.) suivi d’un ou plusieurs caractères ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À partir de la fin de `path`, cette méthode recherche un point (.) suivi d’au moins un caractère. Si ce modèle est trouvé avant un <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, ou <xref:System.IO.Path.VolumeSeparatorChar> caractère est rencontré, cette méthode retourne `true`.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `HasExtension`.  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fournit un tableau de caractères (spécifique à la plateforme) qui ne peuvent pas être spécifiés dans des arguments de chaîne de chemin d’accès passés aux membres de la classe <see cref="T:System.IO.Path" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau renvoyé par cette méthode n’est pas garanti pour contenir l’ensemble complet des caractères qui ne sont pas valides dans les noms de fichiers et de répertoires. L’ensemble des caractères non valides peut varier selon le système de fichiers. Par exemple, sur les plateformes de bureau Windows, les caractères de chemin non valide peuvent inclure des caractères ASCII/Unicode 1 à 31, ainsi que mettre entre guillemets («), inférieur à (\<), supérieur à (>), barre verticale (&#124;), retour arrière (\b), valeur null (\0) et tabulation (\t).  
  
> [!CAUTION]
>  N’utilisez pas <xref:System.IO.Path.InvalidPathChars> si vous pensez que votre code peut s’exécuter dans le même domaine d’application en tant que code non fiable. <xref:System.IO.Path.InvalidPathChars> est un tableau, donc ses éléments peuvent être remplacés. Si le code non fiable remplace des éléments de <xref:System.IO.Path.InvalidPathChars>, il peut entraîner votre code un dysfonctionnement de façons qui pourraient être exploitées.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la `InvalidPathChars` propriété.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary>Renvoie une valeur qui indique si un chemin d'accès de fichier est complet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Les surcharges de la `IsPathFullyQualified` chemins d’accès du handle de méthode qui utilisent toutes deux le <xref:System.IO.Path.DirectorySeparatorChar> et <xref:System.IO.Path.AltDirectorySeparatorChar> caractères. Il n’effectue aucune validation sur le chemin d’accès qui lui est passé en tant qu’argument. Par conséquent, les URI sont interprétés comme des chemins d’accès relatifs et retourner `false`. 

Il existe une différence entre un chemin d’accès qualifié complet (tel qu’indiqué par le `IsPathFullyQualified` méthode) et un chemin d’accès racine (comme indiqué par le <xref:System.IO.Path.IsPathRooted%2A> (méthode)). Un *chemin qualifié complet* ou *chemin d’accès absolu* toujours définit un chemin d’accès exact à partir d’un lecteur particulier ou un périphérique à un fichier ou répertoire cible et ne repose pas sur le lecteur en cours ou le répertoire actuel. Par exemple, sur les systèmes Windows, *C:/users/user1/documents/reports/2019/january/highlights.pdf* définit un chemin d’accès absolu à partir de la racine du lecteur C: dans le fichier cible, *highlights.pdf*. Un *chemin d’accès racine* spécifie un lecteur de démarrage ou un répertoire racine, mais varie selon le répertoire actuel (si elle est enraciné par un lecteur spécifié) ou le lecteur actuel (si elle est enraciné par le répertoire racine). L’exemple suivant illustre la différence entre les chemins d’accès complets et les chemins d’accès racine.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès de fichier.</param>
        <summary>Renvoie une valeur qui indique si le chemin d'accès de fichier représenté par l'étendue de caractères spécifiée est fixé sur un lecteur ou un chemin d'accès UNC spécifique.</summary>
        <returns><see langword="true" /> si le chemin d'accès est fixé sur un lecteur ou chemin d'accès UNC spécifique ; <see langword="false" /> si le chemin d'accès est relatif au lecteur ou au répertoire de travail actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès de fichier.</param>
        <summary>Renvoie une valeur qui indique si le chemin d'accès du fichier spécifié est fixé sur un lecteur ou un chemin d'accès UNC spécifique.</summary>
        <returns><see langword="true" /> si le chemin d'accès est fixé sur un lecteur ou chemin d'accès UNC spécifique ; <see langword="false" /> si le chemin d'accès est relatif au lecteur ou au répertoire de travail actuel.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary>Renvoie une valeur qui indique si un chemin d'accès contient une racine.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Un **chemin d’accès racine** est le chemin d’accès du fichier qui est fixe à un lecteur spécifique ou un chemin d’accès UNIC ; elle s’oppose à un chemin d’accès relatif du lecteur en cours ou le répertoire de travail. Par exemple, sur les systèmes Windows, un chemin d’accès racine commence par une barre oblique inverse (par exemple, « \Documents ») ou une lettre de lecteur et les deux-points (par exemple, « C:Documents »). 

Notez que les chemins d’accès racine peuvent être absolue (qui est, qualifié complet) ou relatif. Un chemin d’accès racine absolu est un chemin d’accès qualifié complet à partir de la racine d’un lecteur dans un répertoire spécifique. Un chemin d’accès racine relatif spécifie un lecteur, mais son chemin d’accès qualifié complet est résolu en fonction du répertoire actif. L'exemple suivant illustre la différence.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès à tester.</param>
        <summary>Renvoie une valeur indiquant si l'étendue de caractères spécifiée qui représente un chemin de fichier contient une racine.</summary>
        <returns><see langword="true" /> si <paramref name="path" /> contient une racine ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès à tester.</param>
        <summary>Renvoie une valeur indiquant si la chaîne de chemin d'accès spécifiée contient une racine.</summary>
        <returns><see langword="true" /> si <paramref name="path" /> contient une racine ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Path.IsPathRooted%2A> retourne de la méthode `true` si le premier caractère est un caractère de séparation de répertoire tel que «\\», ou si le chemin d’accès commence par une lettre de lecteur et le signe deux-points ( :)). Par exemple, elle retourne `true` pour `path` des chaînes telles que «\\\MyDir\\\MyFile.txt », « C:\\\MyDir », ou « C : mydir ». Elle retourne `false` pour `path` chaînes telles que « MyDir ».  
  
 Cette méthode ne vérifie pas que le chemin d’accès ou nom de fichier existe.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  

## Examples  
 L’exemple suivant montre comment la `IsPathRooted` méthode peut être utilisée pour tester les trois chaînes.  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Étendue de caractères contenant le premier chemin d'accès à joindre.</param>
        <param name="path2">Étendue de caractères contenant le deuxième chemin d'accès à joindre.</param>
        <summary>Concatène deux composants de chemin d'accès en un seul chemin.</summary>
        <returns>Chemins d'accès combinés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Cette méthode concatène simplement `path` et `path2` et ajoute un caractère de séparation de répertoire entre les composants de chemin de deux accès si aucun n’est pas déjà présent à la fin de `path1` ou le début du `path2`. Si le <xref:System.ReadOnlySpan%601.Length> du `path1` ou `path2` est égal à zéro, la méthode retourne le chemin d’accès. Si le <xref:System.ReadOnlySpan%601.Length> des deux `path1` et `path2` est égal à zéro, la méthode retourne <xref:System.String.Empty?displayProperty=nameWithType>. 

Si `path1` se termine par un caractère de séparation du chemin d’accès qui n’est pas approprié pour la plateforme cible, le `Join` méthode conserve le caractère de séparateur de chemin d’accès d’origine et ajoute celui pris en charge. Ce problème survient dans les chemins codés en dur qui utilisent la barre oblique inverse de Windows («\") caractère, qui n’est pas reconnu comme un séparateur de chemin d’accès sur les systèmes basés sur Unix. Pour contourner ce problème, vous pouvez :

- Récupérer la valeur de la <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propriété plutôt que de coder en dur un caractère de séparation de répertoire.

- Utilisez une barre oblique (« / ») comme séparateur de répertoire. Ce caractère est retourné par la <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propriété sur les systèmes Unix et par le <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> propriété sur les systèmes Windows. 

Contrairement à la <xref:System.IO.Path.Combine%2A> (méthode), le <xref:System.IO.Path.Join%2A> méthode ne tente pas de racine du chemin d’accès retournée. (Autrement dit, si `path2` est un chemin d’accès absolu, le `Join` n’ignore pas la méthode `path1` et retourner `path2` comme le <xref:System.IO.Path.Combine%2A> méthode.) L’exemple suivant illustre la différence dans les chemins d’accès retourné par les deux méthodes. Si la source de `path2` est l’entrée utilisateur, le <xref:System.IO.Path.Combine%2A> méthode rend possible pour un utilisateur à accéder à une ressource de système de fichier (tel que *C:/utilisateurs/User1/Documents/Financial/* dans le cas de l’exemple) qui a effectué l’application n’envisagez pas de rendre accessible.  

Pas tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par le `Join` (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche. Par exemple, tandis que `Path.Join("c:\\", "*.txt")` peut être non valide quand créer un fichier, il est une chaîne de recherche valide. Le `Join` méthode correctement l’interprète donc il. 

## <a name="example"></a>Exemple

L’exemple suivant illustre la différence dans les chemins d’accès retourné par la <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> et <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> méthodes. Lorsque la première chaîne est un chemin d’accès qualifié complet qui inclut un lecteur et le répertoire racine et le second est un chemin d’accès relatif à partir du premier chemin d’accès, les deux méthodes produisent des résultats identiques. Dans les appels de deuxième et troisième à la `ShowPathInformation` divergent de méthode, les chaînes retournées par les deux méthodes. Dans le deuxième appel de méthode, la première chaîne d’argument est un lecteur, tandis que la deuxième est un répertoire racine. Le `Join` méthode concatène deux chaînes et conserve dupliquer les séparateurs de chemin d’accès. Le `Combine` méthode abandonne le lecteur et retourne un répertoire racine du lecteur actif. Si le lecteur en cours de l’application est C:\ et la chaîne est utilisée pour accéder à un ou plusieurs fichiers dans le répertoire, il doit accéder à C: au lieu de D:. Enfin, étant donné que les deux arguments dans le troisième appel `ShowPathInformation` sont associés à une racine, le `Join` méthode ajoute simplement les pour créer un chemin d’accès de fichier absurde, tandis que le `Combine` méthode ignore la première chaîne et retourne le deuxième. À l’aide de cette chaîne pour l’accès au fichier pourrait donner à l’application l’accès involontaire à des fichiers sensibles.  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-csharp[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Étendue de caractères contenant le premier chemin d'accès à joindre.</param>
        <param name="path2">Étendue de caractères contenant le deuxième chemin d'accès à joindre.</param>
        <param name="path3">Étendue de caractères contenant le troisième chemin d'accès à joindre.</param>
        <summary>Concatène trois composants de chemin d'accès en un seul chemin.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Cette méthode concatène simplement `path`, `path2`, et `path3` et ajoute un caractère de séparation de répertoire entre les composants de chemin d’accès si un n’est pas déjà présent. Si le <xref:System.ReadOnlySpan%601.Length> des `path1`, `path2`, ou `path3` argument est égal à zéro, la méthode concatène les arguments restants. Si le <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> de tous les composants est égal à zéro, la méthode retourne <xref:System.String.Empty?displayProperty=nameWithType>.    

Si `path1` ou `path2` se termine par un caractère de séparation du chemin d’accès qui n’est pas approprié pour la plateforme cible, le `Join` méthode conserve le caractère de séparateur de chemin d’accès d’origine et ajoute celui pris en charge. Ce problème survient dans les chemins codés en dur qui utilisent la barre oblique inverse de Windows («\") caractère, qui n’est pas reconnu comme un séparateur de chemin d’accès sur les systèmes basés sur Unix. Pour contourner ce problème, vous pouvez :

- Récupérer la valeur de la <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propriété plutôt que de coder en dur un caractère de séparation de répertoire.

- Utilisez une barre oblique (« / ») comme séparateur de répertoire. Ce caractère est retourné par la <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propriété sur les systèmes Unix et par le <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> propriété sur les systèmes Windows. 

Contrairement à la <xref:System.IO.Path.Combine%2A> (méthode), le <xref:System.IO.Path.Join%2A> méthode ne tente pas de racine du chemin d’accès retournée. (Autrement dit, si `path2` ou `path2` est un chemin d’accès absolu, le `Join` méthode n’ignore pas les chemins d’accès précédentes en tant que le <xref:System.IO.Path.Combine%2A> méthode effectue.  
  
Pas tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par le `Join` (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche. Par exemple, tandis que `Path.Join("c:\\", "temp", "*.txt")` peut être non valide quand créer un fichier, il est une chaîne de recherche valide. Le `Join` méthode correctement l’interprète donc il. 

## <a name="example"></a>Exemple

L’exemple suivant illustre la différence dans les chemins d’accès retourné par la <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> et <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> méthodes. Lorsque la première chaîne est un chemin d’accès qualifié complet qui inclut un lecteur et le répertoire racine et le second est un chemin d’accès relatif à partir du premier chemin d’accès, les deux méthodes produisent des résultats identiques. Dans les appels de deuxième et troisième à la `ShowPathInformation` divergent de méthode, les chaînes retournées par les deux méthodes. Dans le deuxième appel de méthode, la première chaîne d’argument est un lecteur, tandis que la deuxième est un répertoire racine. Le `Join` méthode concatène deux chaînes et conserve dupliquer les séparateurs de chemin d’accès. Un appel à la <xref:System.IO.Path.GetFullPath%2A> méthode supprimerait la duplication. Le `Combine` méthode abandonne le lecteur et retourne un répertoire racine du lecteur actif. Si le lecteur en cours de l’application est C:\ et la chaîne est utilisée pour accéder à un ou plusieurs fichiers dans le répertoire, il doit accéder à C: au lieu de D:. Enfin, étant donné que l’argument final dans le troisième appel `ShowPathInformation` sont associés à une racine, le `Join` méthode ajoute simplement pour les deux premiers arguments pour créer un chemin d’accès du fichier absurde, tandis que le `Combine` méthode ignore les deux premières chaînes et retourne la troisième. À l’aide de cette chaîne pour l’accès au fichier pourrait donner à l’application l’accès involontaire à des fichiers sensibles.  

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)] 
[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)] 

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Caractère de séparation spécifique à la plateforme, utilisé pour séparer les chaînes de chemin d'accès dans les variables d'environnement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sur les plateformes de bureau Windows, la valeur de ce champ est le point-virgule ( ;) par défaut, mais elle peut varier sur d’autres plateformes.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la `PathSeparator` champ.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary>Tente de concaténer des composants de chemin d'accès individuels au sein d'une étendue de caractères préallouée, et renvoie une valeur indiquant si l'opération est un succès.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

L’étendue de caractères de destination doit être suffisamment grande pour contenir le chemin d’accès concaténée. Vous pouvez ensuite récupérer le chemin d’accès concaténée en appelant le <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> (méthode), comme dans l’exemple suivant illustre.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Étendue de caractères contenant le premier chemin d'accès à joindre.</param>
        <param name="path2">Étendue de caractères contenant le deuxième chemin d'accès à joindre.</param>
        <param name="destination">Étendue de caractères permettant de contenir le chemin d'accès concaténé.</param>
        <param name="charsWritten">Lorsque la méthode renvoie une valeur qui indique le nombre de caractères écrits dans le <paramref name="destination" />.</param>
        <summary>Tente de concaténer deux composants de chemin d'accès au sein d'une seule étendue de caractères préallouée, et renvoie une valeur indiquant si l'opération est un succès.</summary>
        <returns><see langword="true" /> si l’opération de concaténation réussit ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination` doit être suffisamment grande pour contenir le chemin d’accès concaténée. Vous pouvez ensuite récupérer le chemin d’accès concaténée en appelant le <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> (méthode), comme dans l’exemple illustre.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Étendue de caractères contenant le premier chemin d'accès à joindre.</param>
        <param name="path2">Étendue de caractères contenant le deuxième chemin d'accès à joindre.</param>
        <param name="path3">Étendue de caractères contenant le troisième chemin d'accès à joindre.</param>
        <param name="destination">Étendue de caractères permettant de contenir le chemin d'accès concaténé.</param>
        <param name="charsWritten">Lorsque la méthode renvoie une valeur qui indique le nombre de caractères écrits dans le <paramref name="destination" />.</param>
        <summary>Tente de concaténer deux composants de chemin d'accès au sein d'une seule étendue de caractères préallouée, et renvoie une valeur indiquant si l'opération est un succès.</summary>
        <returns><see langword="true" /> si l’opération de concaténation réussit ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination` doit être suffisamment grande pour contenir le chemin d’accès concaténée. Vous pouvez ensuite récupérer le chemin d’accès concaténée en appelant le <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> (méthode), comme dans l’exemple illustre.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formats de chemin de fichier sur les systèmes Windows</related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fournit un caractère de séparation de volume spécifique à la plateforme.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de ce champ est un signe deux-points ( :)) sur Windows et Macintosh et une barre oblique (/) sur les systèmes d’exploitation UNIX. Cela est particulièrement utile pour l’analyse des chemins d’accès tel que « c:\windows » ou « Dossier MacVolume : System ».  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la `VolumeSeparatorChar` champ.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Procédure : lire le texte d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Procédure : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
  </Members>
</Type>