<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="87efe827b4d4d649387abf9f4fc5627fccf54480" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65013930" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="8ea1a-101">Effectue des opérations sur des instances de <see cref="T:System.String" /> qui contiennent des informations relatives au chemin d'accès d'un fichier ou d'un répertoire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-101">Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information.</span></span> <span data-ttu-id="8ea1a-102">Ces opérations sont effectuées différemment selon la plateforme.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-102">These operations are performed in a cross-platform manner.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="8ea1a-103">Un chemin d’accès est une chaîne qui fournit l’emplacement d’un fichier ou répertoire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-103">A path is a string that provides the location of a file or directory.</span></span> <span data-ttu-id="8ea1a-104">Un chemin d’accès ne pointe pas nécessairement vers un emplacement sur le disque ; par exemple, un chemin d’accès peut mapper à un emplacement en mémoire ou sur un appareil.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-104">A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</span></span> <span data-ttu-id="8ea1a-105">Le format exact d’un chemin d’accès est déterminé par la plateforme actuelle.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-105">The exact format of a path is determined by the current platform.</span></span> <span data-ttu-id="8ea1a-106">Par exemple, sur certains systèmes, un chemin d’accès peut commencer par une lettre de lecteur ou volume, tandis que cet élément n’est pas présent dans d’autres systèmes.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-106">For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</span></span> <span data-ttu-id="8ea1a-107">Sur certains systèmes, les chemins d’accès de fichier peuvent contenir des extensions, qui indiquent le type d’informations stockées dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-107">On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</span></span> <span data-ttu-id="8ea1a-108">Le format d’une extension de nom de fichier est dépendante de la plateforme ; par exemple, certains systèmes de limitent les extensions à trois caractères, et d’autres ne le faites pas.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-108">The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</span></span> <span data-ttu-id="8ea1a-109">La plateforme actuelle détermine également le jeu de caractères utilisé pour séparer les éléments d’un chemin d’accès et le jeu de caractères qui ne peut pas être utilisé lors de la spécification de chemins d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-109">The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</span></span> <span data-ttu-id="8ea1a-110">En raison de ces différences, les champs de la `Path` classe, ainsi que le comportement exact de certains membres de la `Path` classe sont dépendants de la plateforme.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-110">Because of these differences, the fields of the `Path` class as well as the exact behavior of some members of the `Path` class are platform-dependent.</span></span>  
  
 <span data-ttu-id="8ea1a-111">Un chemin d’accès peut contenir des informations d’emplacement absolu ou relatif.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-111">A path can contain absolute or relative location information.</span></span> <span data-ttu-id="8ea1a-112">Chemins d’accès absolus spécifient un emplacement : le fichier ou le répertoire peut être identifiée, quel que soit l’emplacement actuel.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-112">Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</span></span> <span data-ttu-id="8ea1a-113">Chemins d’accès relatifs spécifient un emplacement partiel : l’emplacement actuel est utilisé comme point de départ lors de la localisation d’un fichier spécifié avec un chemin d’accès relatif.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-113">Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</span></span> <span data-ttu-id="8ea1a-114">Pour déterminer le répertoire actif, appelez <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-114">To determine the current directory, call <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="8ea1a-115">.NET core 1.1 et versions ultérieures et .NET Framework 4.6.2 et versions ultérieures prennent également en charge l’accès aux objets de système de fichiers qui sont des noms de périphériques, tels que «\\? \C :\".</span><span class="sxs-lookup"><span data-stu-id="8ea1a-115">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support access to file system objects that are device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="8ea1a-116">Pour plus d’informations sur les formats de chemin d’accès de fichier sur Windows, consultez [les formats de chemin d’accès des fichiers sur les systèmes Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-116">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span>

 <span data-ttu-id="8ea1a-117">La plupart des membres de la `Path` n’interagissent pas avec le système de fichiers de classe et ne pas vérifier l’existence du fichier spécifié par une chaîne de chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-117">Most members of the `Path` class do not interact with the file system and do not verify the existence of the file specified by a path string.</span></span> <span data-ttu-id="8ea1a-118">`Path` classe les membres qui modifient une chaîne de chemin d’accès, tel que <xref:System.IO.Path.ChangeExtension%2A>, n’ont aucun effet sur les noms de fichiers dans le système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-118">`Path` class members that modify a path string, such as <xref:System.IO.Path.ChangeExtension%2A>, have no effect on names of files in the file system.</span></span> <span data-ttu-id="8ea1a-119">`Path` membres, toutefois, valider le contenu d’une chaîne de chemin d’accès spécifié et lève un <xref:System.ArgumentException> exception si la chaîne contient des caractères qui ne sont pas valides dans les chaînes de chemin d’accès, tel que défini dans les caractères renvoyés à partir de la <xref:System.IO.Path.GetInvalidPathChars%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-119">`Path` members do, however, validate the contents of a specified path string, and throw an <xref:System.ArgumentException> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <xref:System.IO.Path.GetInvalidPathChars%2A> method.</span></span> <span data-ttu-id="8ea1a-120">Par exemple, sur les plateformes de bureau Windows, les caractères de chemin non valide peuvent inclure les guillemets («), inférieur à (\<), supérieur à (>), barre verticale (&#124;), retour arrière (\b), valeur null (\0) et les caractères Unicode 16 et 18 et 20 à 25.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-120">For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</span></span>  
  
 <span data-ttu-id="8ea1a-121">Les membres de la `Path` classe que vous puissiez rapidement et facilement effectuer des opérations courantes telles que déterminer si une extension de nom de fichier fait partie d’un chemin d’accès et combiner deux chaînes en un chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-121">The members of the `Path` class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</span></span>  
  
 <span data-ttu-id="8ea1a-122">Tous les membres de la `Path` classe sont statique et peuvent donc être appelés sans disposer d’une instance d’un chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-122">All members of the `Path` class are static and can therefore be called without having an instance of a path.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8ea1a-123">Dans les membres qui acceptent un chemin d’accès sous forme de chaîne d’entrée, ce chemin d’accès doit être correctement construit, ou une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-123">In members that accept a path as an input string, that path must be well-formed or an exception is raised.</span></span> <span data-ttu-id="8ea1a-124">Par exemple, si un chemin d’accès est qualifié complet mais commence par un espace, le chemin d’accès n’est pas tronqué dans les méthodes de la classe.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-124">For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</span></span> <span data-ttu-id="8ea1a-125">Par conséquent, le chemin d’accès est incorrect et une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-125">Therefore, the path is malformed and an exception is raised.</span></span> <span data-ttu-id="8ea1a-126">De même, un chemin d’accès ou une combinaison de chemins d’accès ne peut pas être qualifiée à deux reprises.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-126">Similarly, a path or a combination of paths cannot be fully qualified twice.</span></span> <span data-ttu-id="8ea1a-127">Par exemple, « c:\temp c:\windows » déclenche également une exception dans la plupart des cas.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-127">For example, "c:\temp c:\windows" also raises an exception in most cases.</span></span> <span data-ttu-id="8ea1a-128">Assurez-vous que vos chemins sont correctement construits lors de l’utilisation des méthodes qui acceptent une chaîne de chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-128">Ensure that your paths are well-formed when using methods that accept a path string.</span></span>  
  
 <span data-ttu-id="8ea1a-129">Dans les membres qui acceptent un chemin d’accès, le chemin d’accès peut faire référence à un fichier ou simplement un répertoire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-129">In members that accept a path, the path can refer to a file or just a directory.</span></span> <span data-ttu-id="8ea1a-130">Le chemin d’accès spécifié peut également faire référence à un chemin d’accès relatif ou un chemin d’accès UNC Universal Naming Convention () pour un nom de serveur et le partage.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-130">The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</span></span> <span data-ttu-id="8ea1a-131">Par exemple, tous les éléments suivants sont des chemins d’accès acceptables :</span><span class="sxs-lookup"><span data-stu-id="8ea1a-131">For example, all the following are acceptable paths:</span></span>  
  
-   <span data-ttu-id="8ea1a-132">« c:\\\MyDir\\\MyFile.txt » en c# ou « c:\MyDir\MyFile.txt » en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-132">"c:\\\MyDir\\\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="8ea1a-133">« c:\\\MyDir » en c# ou « c:\MyDir » en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-133">"c:\\\MyDir" in C#, or "c:\MyDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="8ea1a-134">« MyDir\\\MySubdir » en c# ou « Monrépertoire\monsousrépertoire » en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-134">"MyDir\\\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="8ea1a-135">«\\\\\\\MyServer\\\MyShare » en c#, ou «\\\MyServer\MyShare » en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-135">"\\\\\\\MyServer\\\MyShare" in C#, or "\\\MyServer\MyShare" in Visual Basic.</span></span>  
  
 <span data-ttu-id="8ea1a-136">Étant donné que toutes ces opérations sont effectuées sur les chaînes, il est impossible de vérifier que les résultats sont valides dans tous les scénarios.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-136">Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</span></span> <span data-ttu-id="8ea1a-137">Par exemple, le <xref:System.IO.Path.GetExtension%2A> méthode analyse une chaîne que vous lui transmettez et retourne l’extension de cette chaîne.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-137">For example, the <xref:System.IO.Path.GetExtension%2A> method parses a string that you pass to it and returns the extension from that string.</span></span> <span data-ttu-id="8ea1a-138">Toutefois, cela ne signifie pas qu’un fichier avec cette extension existe sur le disque.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-138">However, this does not mean that a file with that extension exists on the disk.</span></span>  
  
 <span data-ttu-id="8ea1a-139">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-139">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>   
  
## Examples  
 <span data-ttu-id="8ea1a-140">L’exemple suivant illustre certains membres principaux de la `Path` classe.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-140">The following example demonstrates some of the main members of the `Path` class.</span></span>  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-141">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-141">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-142">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-142">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-143">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-143">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="8ea1a-144">Procédure : lire et écrire dans un fichier de données créé récemment</span><span class="sxs-lookup"><span data-stu-id="8ea1a-144">How to: Read and Write to a Newly Created Data File</span></span></related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-145">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-145">File path formats on Windows systems</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8ea1a-146">Fournit un caractère de remplacement spécifique à la plateforme, utilisé pour séparer les niveaux de répertoire dans une chaîne de chemin d'accès qui reflète une organisation de système de fichiers hiérarchique.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-146">Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="8ea1a-147">Ce champ peut avoir la même valeur que <xref:System.IO.Path.DirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-147">This field can have the same value as <xref:System.IO.Path.DirectorySeparatorChar>.</span></span> <span data-ttu-id="8ea1a-148">`AltDirectorySeparatorChar` et <xref:System.IO.Path.DirectorySeparatorChar> sont tous deux valides pour séparer les niveaux de répertoire dans une chaîne de chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-148">`AltDirectorySeparatorChar` and <xref:System.IO.Path.DirectorySeparatorChar> are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="8ea1a-149">La valeur de ce champ est une barre oblique (« / ») sur Windows et les systèmes d’exploitation Unix.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-149">The value of this field is a slash ('/') on both Windows and Unix-based operating systems.</span></span>  
  
## Examples  

<span data-ttu-id="8ea1a-150">L’exemple suivant affiche <xref:System.IO.Path> sur Windows et sur les systèmes Unix de valeurs de champ.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-150">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="8ea1a-151">Notez que Windows prend en charge soit la barre oblique (qui est retourné par la <xref:System.IO.Path.AltDirectorySeparatorChar> champ) ou la barre oblique inverse (qui est retourné par la <xref:System.IO.Path.DirectorySeparatorChar> champ) comme des caractères de séparateur de chemin d’accès, tandis que les systèmes Unix prend en charge uniquement la barre oblique.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-151">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-152">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-152">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-153">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-153">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-154">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-154">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-155">Informations relatives au chemin d’accès à modifier.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-155">The path information to modify.</span></span> <span data-ttu-id="8ea1a-156">Le chemin d'accès ne peut contenir aucun des caractères définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-156">The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></param>
        <param name="extension"><span data-ttu-id="8ea1a-157">Nouvelle extension (avec ou sans point de début).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-157">The new extension (with or without a leading period).</span></span> <span data-ttu-id="8ea1a-158">Spécifiez <see langword="null" /> pour supprimer une extension existante de <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-158">Specify <see langword="null" /> to remove an existing extension from <paramref name="path" />.</span></span></param>
        <summary><span data-ttu-id="8ea1a-159">Modifie l'extension d'une chaîne de chemin d'accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-159">Changes the extension of a path string.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-160">Informations relatives au chemin d'accès modifiées.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-160">The modified path information.</span></span>  
  
<span data-ttu-id="8ea1a-161">Sur les plateformes de bureau Windows, si <paramref name="path" /> est <see langword="null" /> ou est une chaîne vide (""), les informations relatives au chemin d’accès sont retournées inchangées.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-161">On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified.</span></span> <span data-ttu-id="8ea1a-162">Si <paramref name="extension" /> est <see langword="null" />, la chaîne retournée contient le chemin d'accès spécifié avec l'extension supprimée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-162">If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed.</span></span> <span data-ttu-id="8ea1a-163">Si <paramref name="path" /> ne possède pas d’extension et si <paramref name="extension" /> n’est pas <see langword="null" />, la chaîne du chemin d’accès retournée contient <paramref name="extension" />, ajouté à la fin de <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-163">If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-164">Si ni `path` ni `extension` contient un point (.), `ChangeExtension` ajoute la période.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-164">If neither `path` nor `extension` contains a period (.), `ChangeExtension` adds the period.</span></span>  
  
 <span data-ttu-id="8ea1a-165">Le `extension` paramètre peut contenir plusieurs points, des caractères de chemin d’accès valide et peut être n’importe quelle longueur.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-165">The `extension` parameter can contain multiple periods and any valid path characters, and can be any length.</span></span> <span data-ttu-id="8ea1a-166">Si `extension` est `null`, la chaîne retournée contient le contenu de `path` avec la dernière période et tous les caractères après celui-ci supprimé.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-166">If `extension` is `null`, the returned string contains the contents of `path` with the last period and all characters following it removed.</span></span>  
  
 <span data-ttu-id="8ea1a-167">Si `extension` est une chaîne vide, la chaîne de chemin d’accès retournée contient le contenu de `path` avec les caractères après le dernier point supprimé.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-167">If `extension` is an empty string, the returned path string contains the contents of `path` with any characters following the last period removed.</span></span>  
  
 <span data-ttu-id="8ea1a-168">Si `path` n’a pas d’extension et `extension` n’est pas `null`, la chaîne retournée contient `path` suivie `extension`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-168">If `path` does not have an extension and `extension` is not `null`, the returned string contains `path` followed by `extension`.</span></span>  
  
 <span data-ttu-id="8ea1a-169">Si `extension` n’est pas `null` et ne contient pas un point de début, la période est ajoutée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-169">If `extension` is not `null` and does not contain a leading period, the period is added.</span></span>  
  
 <span data-ttu-id="8ea1a-170">Si `path` contient plusieurs extensions séparées par plusieurs points, la chaîne retournée contient le contenu de `path` avec la dernière période et tous les caractères après celui-ci remplacé par `extension`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-170">If `path` contains a multiple extension separated by multiple periods, the returned string contains the contents of `path` with the last period and all characters following it replaced by `extension`.</span></span> <span data-ttu-id="8ea1a-171">Par exemple, si `path` est « \Dir1\examples\pathtests.csx.txt » et `extension` est « cs », le chemin d’accès modifié est « \Dir1\examples\pathtests.csx.cs ».</span><span class="sxs-lookup"><span data-stu-id="8ea1a-171">For example, if `path` is "\Dir1\examples\pathtests.csx.txt" and `extension` is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</span></span>  
  
 <span data-ttu-id="8ea1a-172">Il n’est pas possible de vérifier que les résultats retournés sont valides dans tous les scénarios.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-172">It is not possible to verify that the returned results are valid in all scenarios.</span></span> <span data-ttu-id="8ea1a-173">Par exemple, si `path` est vide, `extension` est ajouté.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-173">For example, if `path` is empty, `extension` is appended.</span></span>  
  
 <span data-ttu-id="8ea1a-174">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-174">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ea1a-175">L’exemple suivant montre une utilisation de la `ChangeExtension` (méthode).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-175">The following example demonstrates a use of the `ChangeExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8ea1a-176"><paramref name="path" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-176"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-177">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-177">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-178">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-178">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-179">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-179">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-180">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-180">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8ea1a-181">Combine des chaînes en un chemin d'accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-181">Combines strings into a path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="8ea1a-182">Cette méthode est destinée à concaténer des chaînes individuelles en une seule chaîne qui représente un chemin d’accès de fichier.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-182">This method is intended to concatenate individual strings into a single string that represents a file path.</span></span> <span data-ttu-id="8ea1a-183">Toutefois, si un argument différent du premier contient un chemin d’accès racine, des composants de chemin d’accès précédente sont ignorées, et la chaîne retournée commence par ce composant de chemin d’accès associé.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-183">However, if an argument other than the first contains a rooted path, any previous path components are ignored, and the returned string begins with that rooted path component.</span></span> <span data-ttu-id="8ea1a-184">Comme alternative à la `Combine` (méthode), envisagez d’utiliser le <xref:System.IO.Path.Join%2A> ou <xref:System.IO.Path.TryJoin%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-184">As an alternative to the `Combine` method, consider using the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> methods.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="8ea1a-185">Cette méthode suppose que le premier argument est un chemin d’accès absolu et que l’ou les arguments suivants sont des chemins d’accès relatifs.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-185">This method assumes that the first argument is an absolute path and that the following argument or arguments are relative paths.</span></span> <span data-ttu-id="8ea1a-186">Si ce n’est pas le cas, et en particulier si des arguments suivants sont des chaînes entrées par l’utilisateur, appelez le <xref:System.IO.Path.Join%2A> ou <xref:System.IO.Path.TryJoin%2A> méthode à la place.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-186">If this is not the case, and particularly if any subsequent arguments are strings input by the user, call the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> method instead.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="8ea1a-187">Tableau de parties du chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-187">An array of parts of the path.</span></span></param>
        <summary><span data-ttu-id="8ea1a-188">Combine un tableau de chaînes en un chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-188">Combines an array of strings into a path.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-189">Chemins d'accès combinés.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-189">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="8ea1a-190">`paths` doit être un tableau des parties du chemin d’accès à combiner.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-190">`paths` should be an array of the parts of the path to combine.</span></span> <span data-ttu-id="8ea1a-191">Si l’un des chemins d’accès suivants est un chemin d’accès absolu, l’opération de combinaison réinitialise en commençant par ce chemin d’accès absolu, en ignorant tous les chemins d’accès combinés précédentes.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-191">If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</span></span>  

<span data-ttu-id="8ea1a-192">Si n’importe quel élément dans `paths` mais il n’est pas un lecteur et ne se termine pas par une les <xref:System.IO.Path.DirectorySeparatorChar> ou le <xref:System.IO.Path.AltDirectorySeparatorChar> caractère, le `Combine` méthode ajoute un <xref:System.IO.Path.DirectorySeparatorChar> caractère entre cet élément et la suivante.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-192">If any element in `paths` but the last one is not a drive and does not end with either the <xref:System.IO.Path.DirectorySeparatorChar> or the <xref:System.IO.Path.AltDirectorySeparatorChar> character, the `Combine` method adds a <xref:System.IO.Path.DirectorySeparatorChar> character between that element and the next one.</span></span> <span data-ttu-id="8ea1a-193">Notez que, si l’élément se termine par un caractère de séparation du chemin d’accès qui n’est pas approprié pour la plateforme cible, le `Combine` méthode conserve le caractère de séparateur de chemin d’accès d’origine et ajoute une prise en charge.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-193">Note that, if the element ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="8ea1a-194">L’exemple suivant compare le résultat sur les systèmes Unix et Windows lors de la barre oblique inverse est utilisée comme un caractère de séparateur de chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-194">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 <span data-ttu-id="8ea1a-195">Chaînes de longueur nulle sont omis dans le chemin combiné.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-195">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="8ea1a-196">Les paramètres ne sont pas analysés s’ils ont un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-196">The parameters are not parsed if they have white space.</span></span>  
  
 <span data-ttu-id="8ea1a-197">Pas tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par le `Combine` (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-197">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8ea1a-198">Par exemple, bien que `Path.Combine("c:\\", "*.txt")` ne soit pas valide si vous deviez créer un fichier à partir de celui-ci, il est une chaîne de recherche valide.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-198">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="8ea1a-199">Il est donc interprété correctement par le `Combine` (méthode).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-199">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
## Examples  
 <span data-ttu-id="8ea1a-200">L’exemple suivant combine un tableau de chaînes en un chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-200">The following example combines an array of strings into a path.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8ea1a-201">L’une des chaînes du tableau contient un ou plusieurs des caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-201">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8ea1a-202">L’une des chaînes du tableau est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-202">One of the strings in the array is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-203">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-203">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8ea1a-204">Premier chemin d'accès à combiner.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-204">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="8ea1a-205">Deuxième chemin d'accès à combiner.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-205">The second path to combine.</span></span></param>
        <summary><span data-ttu-id="8ea1a-206">Combine deux chaînes en un chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-206">Combines two strings into a path.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-207">Chemins d'accès combinés.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-207">The combined paths.</span></span> <span data-ttu-id="8ea1a-208">Si un des chemins d'accès spécifiés est une chaîne de longueur zéro, cette méthode retourne l'autre chemin d'accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-208">If one of the specified paths is a zero-length string, this method returns the other path.</span></span> <span data-ttu-id="8ea1a-209">Si <paramref name="path2" /> contient un chemin d’accès absolu, cette méthode retourne <paramref name="path2" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-209">If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-210">Si `path1` n’est pas une référence de lecteur (autrement dit, « C: » ou « D: ») et ne se termine pas par un caractère de séparation valide comme défini dans <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, ou <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> est ajouté à `path1` avant la concaténation.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-210">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span> <span data-ttu-id="8ea1a-211">Notez que si `path1` se termine par un caractère de séparation du chemin d’accès qui n’est pas approprié pour la plateforme cible, le `Combine` méthode conserve le caractère de séparateur de chemin d’accès d’origine et ajoute une prise en charge.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-211">Note that if `path1` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="8ea1a-212">L’exemple suivant compare le résultat sur les systèmes Unix et Windows lors de la barre oblique inverse est utilisée comme un caractère de séparateur de chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-212">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 <span data-ttu-id="8ea1a-213">Si `path2` n’inclut pas de racine (par exemple, si `path2` ne commence pas par un caractère de séparation ou une spécification de lecteur), le résultat est une concaténation de deux chemins, avec un caractère de séparation intermédiaire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-213">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="8ea1a-214">Si `path2` inclut une racine, `path2` est retournée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-214">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="8ea1a-215">Les paramètres ne sont pas analysés s’ils ont un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-215">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="8ea1a-216">Par conséquent, si `path2` inclut un espace blanc (par exemple, « \file.txt »), le <xref:System.IO.Path.Combine%2A> ajoute de la méthode `path2` à `path1` au lieu de retourner uniquement `path2`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-216">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1` instead of returning only `path2`.</span></span>  
  
 <span data-ttu-id="8ea1a-217">Pas tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par le `Combine` (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-217">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8ea1a-218">Par exemple, bien que `Path.Combine("c:\\", "*.txt")` ne soit pas valide si vous deviez créer un fichier à partir de celui-ci, il est une chaîne de recherche valide.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-218">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="8ea1a-219">Il est donc interprété correctement par le `Combine` (méthode).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-219">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
 <span data-ttu-id="8ea1a-220">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-220">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ea1a-221">L’exemple suivant montre comment utiliser le `Combine` méthode sur une plateforme de bureau Windows.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-221">The following example demonstrates using the `Combine` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8ea1a-222"><paramref name="path1" /> ou <paramref name="path2" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-222"><paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8ea1a-223"><paramref name="path1" /> ou <paramref name="path2" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-223"><paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-224">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-224">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-225">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-225">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-226">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-226">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-227">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-227">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8ea1a-228">Premier chemin d'accès à combiner.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-228">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="8ea1a-229">Deuxième chemin d'accès à combiner.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-229">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="8ea1a-230">Troisième chemin d'accès à combiner.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-230">The third path to combine.</span></span></param>
        <summary><span data-ttu-id="8ea1a-231">Combine trois chaînes en un chemin d'accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-231">Combines three strings into a path.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-232">Chemins d'accès combinés.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-232">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-233">`path1` doit être un chemin d’accès absolu (par exemple, « d:\archives » ou «\\\archives\public »).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-233">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").</span></span> <span data-ttu-id="8ea1a-234">Si `path2` ou `path3` est également un chemin absolu, les chemins d’accès de combiner opération ignore tout précédemment associées et les réinitialisations ce chemin d’accès absolu.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-234">If `path2` or `path3` is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="8ea1a-235">Chaînes de longueur nulle sont omis dans le chemin combiné.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-235">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="8ea1a-236">Si `path1` ou `path2` n’est pas une référence de lecteur (autrement dit, « C: » ou « D: ») et ne se termine pas par un caractère de séparation valide comme défini dans <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, ou <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> est ajouté à `path1` ou `path2` avant la concaténation.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-236">If `path1` or `path2` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` or `path2` before concatenation.</span></span> <span data-ttu-id="8ea1a-237">Notez que si `path1` ou `path2` se termine par un caractère de séparation du chemin d’accès qui n’est pas approprié pour la plateforme cible, le `Combine` méthode conserve le caractère de séparateur de chemin d’accès d’origine et ajoute une prise en charge.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-237">Note that if `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="8ea1a-238">L’exemple suivant compare le résultat sur les systèmes Unix et Windows lors de la barre oblique inverse est utilisée comme un caractère de séparateur de chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-238">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 <span data-ttu-id="8ea1a-239">Si `path2` n’inclut pas de racine (par exemple, si `path2` ne commence pas par un caractère de séparation ou une spécification de lecteur), le résultat est une concaténation de deux chemins, avec un caractère de séparation intermédiaire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-239">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="8ea1a-240">Si `path2` inclut une racine, `path2` est retournée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-240">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="8ea1a-241">Les paramètres ne sont pas analysés s’ils ont un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-241">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="8ea1a-242">Par conséquent, si `path2` inclut un espace blanc (par exemple, « \file.txt »), le <xref:System.IO.Path.Combine%2A> ajoute de la méthode `path2` à `path1`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-242">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="8ea1a-243">Pas tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par le `Combine` (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-243">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8ea1a-244">Par exemple, bien que `Path.Combine("c:\\", "*.txt")` ne soit pas valide si vous deviez créer un fichier à partir de celui-ci, il est une chaîne de recherche valide.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-244">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="8ea1a-245">Il est donc interprété correctement par le `Combine` (méthode).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-245">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ea1a-246">L’exemple suivant combine trois chemins d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-246">The following example combines three paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8ea1a-247"><paramref name="path1" />, <paramref name="path2" /> ou <paramref name="path3" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-247"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8ea1a-248"><paramref name="path1" />, <paramref name="path2" /> ou <paramref name="path3" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-248"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-249">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-249">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8ea1a-250">Premier chemin d'accès à combiner.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-250">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="8ea1a-251">Deuxième chemin d'accès à combiner.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-251">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="8ea1a-252">Troisième chemin d'accès à combiner.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-252">The third path to combine.</span></span></param>
        <param name="path4"><span data-ttu-id="8ea1a-253">Quatrième chemin d'accès à combiner.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-253">The fourth path to combine.</span></span></param>
        <summary><span data-ttu-id="8ea1a-254">Combine quatre chaînes en un chemin d'accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-254">Combines four strings into a path.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-255">Chemins d'accès combinés.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-255">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-256">`path1` doit être un chemin d’accès absolu (par exemple, « d:\archives » ou «\\\archives\public »). Si un des chemins suivants est également un chemin d’accès absolu, l’opération de combinaison ignore tous les chemins d’accès précédemment combinés et réinitialise ce chemin d’accès absolu.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-256">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="8ea1a-257">Chaînes de longueur nulle sont omis dans le chemin combiné.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-257">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="8ea1a-258">Si `path1`, `path2`, ou `path3` n’est pas une référence de lecteur (autrement dit, « C: » ou « D: ») et ne se termine pas par un caractère de séparation valide comme défini dans <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, ou <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> est ajouté à la fin avant la concaténation.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-258">If `path1`, `path2`, or `path3` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to it before concatenation.</span></span> <span data-ttu-id="8ea1a-259">Notez que si `path1`, `path2`, ou `path3` se termine par un caractère de séparation du chemin d’accès qui n’est pas approprié pour la plateforme cible, le `Combine` méthode conserve le caractère de séparateur de chemin d’accès d’origine et ajoute une prise en charge.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-259">Note that if `path1`, `path2`, or `path3` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="8ea1a-260">L’exemple suivant compare le résultat sur les systèmes Unix et Windows lors de la barre oblique inverse est utilisée comme un caractère de séparateur de chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-260">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 <span data-ttu-id="8ea1a-261">Si `path2` n’inclut pas de racine (par exemple, si `path2` ne commence pas par un caractère de séparation ou une spécification de lecteur), le résultat est une concaténation de deux chemins, avec un caractère de séparation intermédiaire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-261">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="8ea1a-262">Si `path2` inclut une racine, `path2` est retournée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-262">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="8ea1a-263">Les paramètres ne sont pas analysés s’ils ont un espace blanc.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-263">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="8ea1a-264">Par conséquent, si `path2` inclut un espace blanc (par exemple, « \file.txt »), le <xref:System.IO.Path.Combine%2A> ajoute de la méthode `path2` à `path1`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-264">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="8ea1a-265">Pas tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par le `Combine` (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-265">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8ea1a-266">Par exemple, bien que `Path.Combine("c:\\", "*.txt")` ne soit pas valide si vous deviez créer un fichier à partir de celui-ci, il est une chaîne de recherche valide.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-266">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="8ea1a-267">Il est donc interprété correctement par le `Combine` (méthode).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-267">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ea1a-268">L’exemple suivant combine quatre chemins d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-268">The following example combines four paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8ea1a-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> ou <paramref name="path4" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8ea1a-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> ou <paramref name="path4" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-271">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-271">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8ea1a-272">Fournit un caractère spécifique à la plateforme, utilisé pour séparer les niveaux de répertoire dans une chaîne de chemin d'accès qui reflète une organisation de système de fichiers hiérarchique.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-272">Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="8ea1a-273"><xref:System.IO.Path.AltDirectorySeparatorChar> et `DirectorySeparatorChar` sont tous deux valides pour séparer les niveaux de répertoire dans une chaîne de chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-273"><xref:System.IO.Path.AltDirectorySeparatorChar> and `DirectorySeparatorChar` are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="8ea1a-274">Lorsque vous utilisez .NET Core pour développer des applications qui s’exécutent sur plusieurs plateformes :</span><span class="sxs-lookup"><span data-stu-id="8ea1a-274">When you are using .NET Core to develop applications that run on multiple platforms:</span></span>

- <span data-ttu-id="8ea1a-275">Si vous préférez coder en dur le caractère de séparation de répertoire, vous devez utiliser la barre oblique (`/`) caractères.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-275">If you prefer to hard-code the directory separator character, you should use the forward slash (`/`) character.</span></span> <span data-ttu-id="8ea1a-276">Il est le caractère de séparation de répertoire reconnu uniquement sur les systèmes Unix, en tant que la sortie de l’exemple et le <xref:System.IO.Path.AltDirectorySeparatorChar> sur Windows.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-276">It is the only recognized directory separator character on Unix systems, as the output from the example shows, and is the <xref:System.IO.Path.AltDirectorySeparatorChar> on Windows.</span></span>

- <span data-ttu-id="8ea1a-277">Concaténation de chaînes permet de récupérer le caractère de séparateur de chemin d’accès lors de l’exécution dynamiquement et l’incorporer dans les chemins d’accès de système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-277">Use string concatenation to dynamically retrieve the path separator character at runtime and incorporate it into file system paths.</span></span> <span data-ttu-id="8ea1a-278">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="8ea1a-278">For example,</span></span> 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```
   ```vb
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ``` 
   <span data-ttu-id="8ea1a-279">Vous pouvez également récupérer la valeur à partir de la <xref:System.IO.Path.AltDirectorySeparatorChar> propriété, puisqu’il s’agit de la même sur Windows et les systèmes basés sur Unx.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-279">You can also retrieve the value from the <xref:System.IO.Path.AltDirectorySeparatorChar> property, since it is the same on both Windows and Unx-based systems.</span></span>

- <span data-ttu-id="8ea1a-280">Récupérer le <xref:System.IO.Path.AltDirectorySeparatorChar> propriété</span><span class="sxs-lookup"><span data-stu-id="8ea1a-280">Retrieve the <xref:System.IO.Path.AltDirectorySeparatorChar> property</span></span>

<span data-ttu-id="8ea1a-281">Si votre application n’est pas multiplateforme, vous pouvez utiliser le séparateur approprié pour votre système.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-281">If your application is not cross-platform, you can use the separator appropriate for your system.</span></span>

## Examples  

<span data-ttu-id="8ea1a-282">L’exemple suivant affiche <xref:System.IO.Path> sur Windows et sur les systèmes Unix de valeurs de champ.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-282">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="8ea1a-283">Notez que Windows prend en charge soit la barre oblique (qui est retourné par la <xref:System.IO.Path.AltDirectorySeparatorChar> champ) ou la barre oblique inverse (qui est retourné par la <xref:System.IO.Path.DirectorySeparatorChar> champ) comme des caractères de séparateur de chemin d’accès, tandis que les systèmes Unix prend en charge uniquement la barre oblique.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-283">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-284">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-284">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-285">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-285">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-286">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-286">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-287">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-287">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary><span data-ttu-id="8ea1a-288">Renvoie les informations relatives au répertoire pour le chemin spécifié représenté par une étendue de caractères.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-288">Returns the directory information for the specified path represented by a character span.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-289">Informations relatives au répertoire pour <paramref name="path" />, ou une étendue vide si <paramref name="path" /> correspond à <see langword="null" />, à une étendue vide ou à une racine (telle que \, C: ou \\serveur\partage).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-289">Directory information for <paramref name="path" />, or an empty span if <paramref name="path" /> is <see langword="null" />, an empty span, or a root (such as \, C:, or \\server\share).</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-290">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-290">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-291">Chemin d’accès d’un fichier ou d’un répertoire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-291">The path of a file or directory.</span></span></param>
        <summary><span data-ttu-id="8ea1a-292">Retourne les informations relatives au répertoire pour la chaîne de chemin d’accès spécifiée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-292">Returns the directory information for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-293">Informations relatives au répertoire pour <paramref name="path" />, ou <see langword="null" /> si <paramref name="path" /> indique un répertoire racine ou est null.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-293">Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null.</span></span> <span data-ttu-id="8ea1a-294">Retourne un élément <see cref="F:System.String.Empty" /> si <paramref name="path" /> ne contient pas d'informations relatives au répertoire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-294">Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-295">Dans la plupart des cas, la chaîne retournée par cette méthode se compose de tous les caractères dans le chemin d’accès jusqu'à mais pas compris la dernière <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-295">In most cases, the string returned by this method consists of all characters in the path up to but not including the last <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span> <span data-ttu-id="8ea1a-296">Si le chemin d’accès se compose d’un répertoire racine, tel que « c:\\», la valeur null est retournée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-296">If the path consists of a root directory, such as "c:\\", null is returned.</span></span> <span data-ttu-id="8ea1a-297">Notez que cette méthode ne prend pas en charge les chemins d’accès à l’aide de « fichier : ».</span><span class="sxs-lookup"><span data-stu-id="8ea1a-297">Note that this method does not support paths using "file:".</span></span> <span data-ttu-id="8ea1a-298">Étant donné que le chemin d’accès retournée n’inclut pas le <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, en passant le chemin d’accès retourné de nouveau la <xref:System.IO.Path.GetDirectoryName%2A> méthode entraîne la troncation d’un niveau de dossier chaque appel suivant sur la chaîne de résultat.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-298">Because the returned path does not include the <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, passing the returned path back into the <xref:System.IO.Path.GetDirectoryName%2A> method will result in the truncation of one folder level per subsequent call on the result string.</span></span> <span data-ttu-id="8ea1a-299">Par exemple, en passant le chemin d’accès « C:\Directory\SubDirectory\test.txt » dans le <xref:System.IO.Path.GetDirectoryName%2A> méthode retournera « C:\Directory\SubDirectory ».</span><span class="sxs-lookup"><span data-stu-id="8ea1a-299">For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <xref:System.IO.Path.GetDirectoryName%2A> method will return "C:\Directory\SubDirectory".</span></span> <span data-ttu-id="8ea1a-300">Passage de cette chaîne, « C:\Directory\SubDirectory », dans <xref:System.IO.Path.GetDirectoryName%2A> entraîne « C:\Directory ».</span><span class="sxs-lookup"><span data-stu-id="8ea1a-300">Passing that string, "C:\Directory\SubDirectory", into <xref:System.IO.Path.GetDirectoryName%2A> will result in "C:\Directory".</span></span>  
  
 <span data-ttu-id="8ea1a-301">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-301">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ea1a-302">L’exemple suivant montre comment utiliser le `GetDirectoryName` méthode sur une plateforme de bureau Windows.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-302">The following example demonstrates using the `GetDirectoryName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8ea1a-303">Le paramètre <paramref name="path" /> est vide, contient seulement des espaces blancs ou contient des caractères non valides.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-303">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="8ea1a-304">Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.IO.IOException" />, à la place.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-304">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="8ea1a-305">Le paramètre <paramref name="path" /> est plus long que la longueur maximale définie par le système.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-305">The <paramref name="path" /> parameter is longer than the system-defined maximum length.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-306">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-306">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-307">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-307">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-308">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-308">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-309">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-309">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-310">Chemin d'accès de fichier à partir duquel vous pouvez obtenir l'extension.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-310">The file path from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="8ea1a-311">Renvoie l'extension d'un chemin d'accès de fichier représenté par une étendue de caractères en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-311">Returns the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-312">Extension du chemin d'accès spécifié (point « . » compris), ou <see cref="P:System.ReadOnlySpan`1.Empty" /> ou si <paramref name="path" /> ne comporte pas d'informations d'extension.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-312">The extension of the specified path (including the period, "."), or <see cref="P:System.ReadOnlySpan`1.Empty" /> if <paramref name="path" /> does not have extension information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="8ea1a-313">Cette méthode obtient l’extension de `path` en effectuant une recherche `path` pendant une période («. »), à partir du dernier caractère dans l’étendue en lecture seule et en continuant vers son premier caractère.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-313">This method obtains the extension of `path` by searching `path` for a period ("."), starting from the last character in the read-only span and continuing toward its first character.</span></span> <span data-ttu-id="8ea1a-314">Si un point est trouvé avant un <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar> caractère, l’étendue en lecture seule retournée contient la période et les caractères après celui-ci ; sinon, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> est retournée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-314">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned read-only span contains the period and the characters after it; otherwise, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> is returned.</span></span>  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-315">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-315">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-316">Chaîne de chemin d’accès pour laquelle obtenir l’extension.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-316">The path string from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="8ea1a-317">Retourne l’extension (y compris le point «. ») de la chaîne de chemin d’accès spécifié.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-317">Returns the extension (including the period ".") of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-318">Extension du chemin d’accès spécifié (y compris le point ".") ou <see langword="null" /> ou <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-318">The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="8ea1a-319">Si <paramref name="path" /> est <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> retourne <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-319">If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />.</span></span> <span data-ttu-id="8ea1a-320">Si <paramref name="path" /> ne contient pas d’informations relatives à l’extension, <see cref="M:System.IO.Path.GetExtension(System.String)" /> retourne <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-320">If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="8ea1a-321">Cette méthode obtient l’extension de `path` en effectuant une recherche `path` pour un point (.), en commençant par le dernier caractère de `path` et en continuant vers le premier caractère.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-321">This method obtains the extension of `path` by searching `path` for a period (.), starting with the last character in `path` and continuing toward the first character.</span></span> <span data-ttu-id="8ea1a-322">Si un point est trouvé avant un <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar> caractère, la chaîne retournée contient la période et les caractères après celui-ci ; sinon, <xref:System.String.Empty?displayProperty=nameWithType> est retournée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-322">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned string contains the period and the characters after it; otherwise, <xref:System.String.Empty?displayProperty=nameWithType> is returned.</span></span>  
  
 <span data-ttu-id="8ea1a-323">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-323">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
 
## Examples  
 <span data-ttu-id="8ea1a-324">L’exemple suivant montre comment utiliser le `GetExtension` méthode sur une plateforme de bureau Windows.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-324">The following example demonstrates using the `GetExtension` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8ea1a-325"><paramref name="path" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-325"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-326">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-326">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-327">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-327">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-328">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-328">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-329">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-329">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-330">Étendue en lecture seule contenant le chemin d'accès à partir duquel vous pouvez obtenir le nom et l'extension du fichier.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-330">A read-only span that contains the path from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="8ea1a-331">Renvoie le nom et l'extension d'un chemin de fichier représenté par une étendue de caractères en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-331">Returns the file name and extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-332">Caractères situés après le dernier caractère de séparation du répertoire dans <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-332">The characters after the last directory separator character in <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="8ea1a-333">L’étendue en lecture seule retournée contient les caractères du chemin qui suivent le dernier séparateur dans `path`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-333">The returned read-only span contains the characters of the path that follow the last separator in `path`.</span></span> <span data-ttu-id="8ea1a-334">Si le dernier caractère de `path` est un caractère de séparation de volume ou un répertoire, la méthode retourne <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-334">If the last character in `path` is a volume or directory separator character, the method returns <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8ea1a-335">Si `path` ne contient aucun caractère de séparation, la méthode retourne `path`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-335">If `path` contains no separator character, the method returns `path`.</span></span>

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-336">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-336">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-337">Chaîne de chemin d'accès à partir de laquelle obtenir le nom et l'extension de fichier.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-337">The path string from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="8ea1a-338">Retourne le nom et l’extension de fichier de la chaîne de chemin d’accès spécifiée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-338">Returns the file name and extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-339">Caractères situés après le dernier caractère de séparation du répertoire dans <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-339">The characters after the last directory separator character in <paramref name="path" />.</span></span> <span data-ttu-id="8ea1a-340">Si le dernier caractère de <paramref name="path" /> est un caractère de séparation de répertoire ou de volume, cette méthode retourne <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-340">If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="8ea1a-341">Si <paramref name="path" /> est <see langword="null" />, cette méthode retourne <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-341">If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="8ea1a-342">La valeur retournée est `null` si le chemin d’accès de fichier est `null`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-342">The returned value is `null` if the file path is `null`.</span></span>  
  
<span data-ttu-id="8ea1a-343">Les caractères de séparation utilisés pour déterminer le début du nom de fichier sont <xref:System.IO.Path.DirectorySeparatorChar> et <xref:System.IO.Path.AltDirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-343">The separator characters used to determine the start of the file name are <xref:System.IO.Path.DirectorySeparatorChar> and <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span>  

<span data-ttu-id="8ea1a-344">Étant donné que *\\* est un nom de fichier juridiques sur Unix, `GetFileName` en cours d’exécution sous les plates-formes basées sur Unix ne peut pas retourner correctement le nom de fichier à partir d’un chemin d’accès basé sur Windows, tels que *C:\\mydir\\myfile.ext*, mais `GetFileName` en cours d’exécution sous les plates-formes basées sur Windows peut retourner correctement le nom de fichier à partir d’un chemin d’accès basés sur Unix comme */tmp/myfile.ext*, de sorte que le comportement de la `GetFileName` méthode n’est pas strictement identique sur les plateformes Unix et Windows.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-344">Because *\\* is a legal file name on Unix, `GetFileName` running under Unix-based platforms cannot correctly return the file name from a Windows-based path like *C:\\mydir\\myfile.ext*, but `GetFileName` running under Windows-based platforms can correctly return the file name from a Unix-based path like */tmp/myfile.ext*, so the behavior of the `GetFileName` method is not strictly the same on Unix-based and Windows-based platforms.</span></span>

<span data-ttu-id="8ea1a-345">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-345">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ea1a-346">L’exemple suivant illustre le comportement de la `GetFileName` méthode sur une plateforme de bureau Windows.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-346">The following example demonstrates the behavior of the `GetFileName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8ea1a-347"><paramref name="path" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-347"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-348">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-348">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-349">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-349">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-350">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-350">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-351">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-351">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-352">Étendue en lecture seule contenant le chemin d'accès à partir duquel vous pouvez obtenir le nom de fichier sans l'extension.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-352">A read-only span that contains the path from which to obtain the file name without the extension.</span></span></param>
        <summary><span data-ttu-id="8ea1a-353">Renvoie le nom de fichier sans l'extension d'un chemin d'accès de fichier représenté par une étendue de caractères en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-353">Returns the file name without the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-354">Caractères de l'étendue en lecture seule renvoyés par <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, moins le dernier point (.) et tous les caractères qui le suivent.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-354">The characters in the read-only span returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-355">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-355">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-356">Chemin d’accès au fichier.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-356">The path of the file.</span></span></param>
        <summary><span data-ttu-id="8ea1a-357">Retourne le nom de fichier de la chaîne de chemin d'accès spécifiée sans l'extension.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-357">Returns the file name of the specified path string without the extension.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-358">Chaîne retournée par <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, moins le dernier point (.) et tous les caractères après celui-ci.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-358">The string returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-359">Cette méthode ne vérifie pas que le chemin d’accès ou nom de fichier existe.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-359">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="8ea1a-360">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-360">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ea1a-361">L’exemple suivant montre une utilisation de la `GetFileNameWithoutExtension` (méthode).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-361">The following example demonstrates a use of the `GetFileNameWithoutExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8ea1a-362"><paramref name="path" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-362"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-363">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-363">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-364">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-364">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-365">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-365">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-366">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-366">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-367">Fichier ou répertoire pour lequel obtenir les informations sur le chemin d’accès absolu.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-367">The file or directory for which to obtain absolute path information.</span></span></param>
        <summary><span data-ttu-id="8ea1a-368">Retourne le chemin d'accès absolu de la chaîne de chemin d'accès spécifiée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-368">Returns the absolute path for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-369">Emplacement qualifié complet de <paramref name="path" />, par exemple « C:\MonFichier.txt ».</span><span class="sxs-lookup"><span data-stu-id="8ea1a-369">The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="8ea1a-370">Le chemin d’accès absolu inclut toutes les informations requises pour rechercher un fichier ou répertoire sur un système.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-370">The absolute path includes all information required to locate a file or directory on a system.</span></span>  
  
 <span data-ttu-id="8ea1a-371">Le fichier ou le répertoire spécifié par `path` n’est pas requis pour exister.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-371">The file or directory specified by `path` is not required to exist.</span></span> <span data-ttu-id="8ea1a-372">Par exemple, si *c:\temp\newdir* est le répertoire actif, l’appel `GetFullPath` sur un nom de fichier, tel que *test.txt* retourne *c:\temp\newdir\test.txt*.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-372">For example, if *c:\temp\newdir* is the current directory, calling `GetFullPath` on a file name such as *test.txt* returns *c:\temp\newdir\test.txt*.</span></span> <span data-ttu-id="8ea1a-373">Le fichier ne doit pas exister.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-373">The file need not exist.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="8ea1a-374">Si `path` est un chemin d’accès relatif, cette surcharge retourne un chemin d’accès qualifié complet qui peut être basée sur le lecteur actuel et le répertoire actif.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-374">If `path` is a relative path, this overload returns a fully qualified path that can be based on the current drive and current directory.</span></span> <span data-ttu-id="8ea1a-375">Le lecteur actuel et le répertoire actuel peuvent modifier à tout moment comme une application s’exécute.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-375">The current drive and current directory can change at any time as an application executes.</span></span> <span data-ttu-id="8ea1a-376">Par conséquent, le chemin d’accès retourné par cette surcharge ne peut pas être déterminé à l’avance.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-376">As a result, the path returned by this overload cannot be determined in advance.</span></span> <span data-ttu-id="8ea1a-377">Pour retourner un chemin d’accès déterministe, appelez le <xref:System.IO.Path.GetFullPath(System.String,System.String)> de surcharge.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-377">To return a deterministic path, call the <xref:System.IO.Path.GetFullPath(System.String,System.String)> overload.</span></span> <span data-ttu-id="8ea1a-378">Vous pouvez également appeler le <xref:System.IO.Path.IsPathFullyQualified%2A> méthode pour déterminer si un chemin d’accès complet ou relatif et par conséquent, si un appel à `GetFullPath` est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-378">You can also call the <xref:System.IO.Path.IsPathFullyQualified%2A> method to determine whether a path is fully qualified or relative and therefore whether a call to `GetFullPath` is necessary.</span></span>

 <span data-ttu-id="8ea1a-379">Toutefois, si `path` existe, l’appelant doit avoir l’autorisation pour obtenir des informations de chemin d’accès pour `path`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-379">However, if `path` does exist, the caller must have permission to obtain path information for `path`.</span></span> <span data-ttu-id="8ea1a-380">Notez que contrairement à la plupart des membres de la <xref:System.IO.Path> classe, cette méthode accède au système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-380">Note that unlike most members of the <xref:System.IO.Path> class, this method accesses the file system.</span></span>  
  
 <span data-ttu-id="8ea1a-381">Cette méthode utilise le répertoire actif et les informations de volume actuel pour qualifier complètement `path`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-381">This method uses the current directory and current volume information to fully qualify `path`.</span></span> <span data-ttu-id="8ea1a-382">Si vous spécifiez un fichier de nom uniquement dans `path`, `GetFullPath` retourne le chemin d’accès qualifié complet du répertoire actif.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-382">If you specify a file name only in `path`, `GetFullPath` returns the fully qualified path of the current directory.</span></span>  
  
 <span data-ttu-id="8ea1a-383">Si vous passez un nom de fichier court, il est développé pour un nom de fichier long.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-383">If you pass in a short file name, it is expanded to a long file name.</span></span>  
  
 <span data-ttu-id="8ea1a-384">Si un chemin d’accès ne contient aucun caractère significatifs, il n’est pas valide, sauf si elle contient un ou plusieurs «. » caractères suivis par n’importe quel nombre d’espaces ; Il sera analysé en tant que «. « ou ».. ».</span><span class="sxs-lookup"><span data-stu-id="8ea1a-384">If a path contains no significant characters, it is invalid unless it contains one or more "." characters followed by any number of spaces; then it will be parsed as either "." or "..".</span></span>  

<span data-ttu-id="8ea1a-385">.NET core 1.1 et versions ultérieures et .NET Framework 4.6.2 et versions ultérieures prennent également en charge les chemins d’accès qui comprennent les noms de périphérique, telles que «\\? \C :\".</span><span class="sxs-lookup"><span data-stu-id="8ea1a-385">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support paths that include device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="8ea1a-386">Pour plus d’informations sur les formats de chemin d’accès de fichier sur Windows, consultez [les formats de chemin d’accès des fichiers sur les systèmes Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-386">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="8ea1a-387">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-387">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
  
## Examples  
 <span data-ttu-id="8ea1a-388">L’exemple suivant montre le `GetFullPath` méthode sur une plateforme de bureau Windows.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-388">The following example demonstrates the `GetFullPath` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8ea1a-389"><paramref name="path" /> est une chaîne de longueur nulle, ne contient que des espaces blancs ou contient un ou plusieurs des caractères non valides définis par <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-389"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="8ea1a-390">ou</span><span class="sxs-lookup"><span data-stu-id="8ea1a-390">-or-</span></span> 
<span data-ttu-id="8ea1a-391">Le système n’a pas pu récupérer le chemin d’accès absolu.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-391">The system could not retrieve the absolute path.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8ea1a-392">L’appelant n’a pas les autorisations requises.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-392">The caller does not have the required permissions.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8ea1a-393"><paramref name="path" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-393"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8ea1a-394"><paramref name="path" /> contient un caractère deux-points (« : ») qui ne fait pas partie d’un identificateur de volume (par exemple, « c:\\ »).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-394"><paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="8ea1a-395">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-395">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="8ea1a-396">Pour accéder au chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-396">for access to the path.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-397">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-397">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-398">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-398">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-399">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-399">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-400">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-400">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-401">Chemin d'accès relatif à concaténer au sein de <paramref name="basePath" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-401">A relative path to concatenate to <paramref name="basePath" />.</span></span></param>
        <param name="basePath"><span data-ttu-id="8ea1a-402">Début d'un chemin d'accès complet.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-402">The beginning of a fully qualified path.</span></span></param>
        <summary><span data-ttu-id="8ea1a-403">Renvoie un chemin d'accès complet à partir d'un chemin de base complet et d'un chemin relatif.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-403">Returns an absolute path from a fully qualified base path and a relative path.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-404">Chemin d'accès complet.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-404">The absolute path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="8ea1a-405">Si `path` est un chemin d’accès vide, la méthode retourne `basePath`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-405">If `path` is an empty path, the method returns `basePath`.</span></span> <span data-ttu-id="8ea1a-406">Si `path` est un chemin d’accès qualifié complet, les passes de méthode `path` à la <xref:System.IO.Path.GetFullPath(System.String)> méthode et retourne le résultat.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-406">If `path` is a fully qualified path, the method passes `path` to the <xref:System.IO.Path.GetFullPath(System.String)> method and returns the result.</span></span>

<span data-ttu-id="8ea1a-407">Utilisez cette méthode pour retourner un chemin d’accès déterministe basée sur un volume spécifié et associé à une racine de répertoire lorsque vous utilisez des chemins d’accès relatifs.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-407">Use this method to return a deterministic path based on a specified volume and rooted directory when you're using relative paths.</span></span> <span data-ttu-id="8ea1a-408">À l’aide de prédéfini `basePath` au lieu d’une basée sur l’actuel lecteur directory protège des chemins de fichiers indésirables causés par des modifications inattendues dans le lecteur actuel et le répertoire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-408">Using a predefined `basePath` rather than one based on the current drive directory guards against unwanted file paths caused by unexpected changes in the current drive and directory.</span></span> 

## <a name="example"></a><span data-ttu-id="8ea1a-409">Exemple</span><span class="sxs-lookup"><span data-stu-id="8ea1a-409">Example</span></span>

<span data-ttu-id="8ea1a-410">L’exemple suivant définit une variable, `basePath`, pour représenter le répertoire en cours d’une application.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-410">The following example defines a variable, `basePath`, to represent an application's current directory.</span></span> <span data-ttu-id="8ea1a-411">Il passe ensuite à la `GetFullPath` méthode pour obtenir un chemin d’accès complet au répertoire de données de l’application.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-411">It then passes it to the `GetFullPath` method to get a fully qualified path to the application's data directory.</span></span>

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8ea1a-412"><paramref name="path" /> ou <paramref name="basePath" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-412"><paramref name="path" /> or <paramref name="basePath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8ea1a-413"><paramref name="basePath" /> n'est pas un chemin d'accès complet.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-413"><paramref name="basePath" /> is not a fully qualified path.</span></span>

<span data-ttu-id="8ea1a-414">ou</span><span class="sxs-lookup"><span data-stu-id="8ea1a-414">-or-</span></span>

<span data-ttu-id="8ea1a-415"><paramref name="path" /> ou <paramref name="basePath" /> contient des caractères de chemin non valides, tels que U+0000.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-415"><paramref name="path" /> or <paramref name="basePath" /> contains invalid path characters, such as U+0000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8ea1a-416">Obtient un tableau contenant les caractères qui ne sont pas autorisés dans les noms de fichiers.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-416">Gets an array containing the characters that are not allowed in file names.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-417">Tableau contenant les caractères qui ne sont pas autorisés dans les noms de fichiers.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-417">An array containing the characters that are not allowed in file names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-418">Le tableau renvoyé par cette méthode n’est pas garanti pour contenir l’ensemble complet des caractères qui ne sont pas valides dans les noms de fichiers et de répertoires.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-418">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="8ea1a-419">L’ensemble des caractères non valides peut varier selon le système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-419">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="8ea1a-420">Par exemple, sur les plateformes de bureau Windows, les caractères de chemin non valide peuvent inclure des caractères ASCII/Unicode 1 à 31, ainsi que mettre entre guillemets («), inférieur à (\<), supérieur à (>), barre verticale (&#124;), retour arrière (\b), valeur null (\0) et tabulation (\t).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-420">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ea1a-421">L’exemple suivant montre le <xref:System.IO.Path.GetInvalidFileNameChars%2A> (méthode) et le <xref:System.IO.Path.GetInvalidPathChars%2A> méthode pour récupérer les caractères non valides.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-421">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8ea1a-422">Obtient un tableau contenant les caractères qui ne sont pas autorisés dans les noms de chemins d'accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-422">Gets an array containing the characters that are not allowed in path names.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-423">Tableau contenant les caractères qui ne sont pas autorisés dans les noms de chemins d'accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-423">An array containing the characters that are not allowed in path names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-424">Le tableau renvoyé par cette méthode n’est pas garanti pour contenir l’ensemble complet des caractères qui ne sont pas valides dans les noms de fichiers et de répertoires.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-424">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="8ea1a-425">L’ensemble des caractères non valides peut varier selon le système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-425">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="8ea1a-426">Par exemple, sur les plateformes de bureau Windows, les caractères de chemin non valide peuvent inclure des caractères ASCII/Unicode 1 à 31, ainsi que mettre entre guillemets («), inférieur à (\<), supérieur à (>), barre verticale (&#124;), retour arrière (\b), valeur null (\0) et tabulation (\t).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-426">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ea1a-427">L’exemple suivant montre le <xref:System.IO.Path.GetInvalidFileNameChars%2A> (méthode) et le <xref:System.IO.Path.GetInvalidPathChars%2A> méthode pour récupérer les caractères non valides.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-427">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-428">Chemin d'accès à partir duquel obtenir les informations relatives au répertoire racine.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-428">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="8ea1a-429">Obtient les informations du répertoire racine à partir du chemin d’accès contenu dans l’étendue de caractères spécifiée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-429">Gets the root directory information from the path contained in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-430">Étendue de caractères qui contient le répertoire racine de `path`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-430">A character span containing the root directory of `path`.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-431">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-431">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-432">Chemin d'accès à partir duquel obtenir les informations relatives au répertoire racine.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-432">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="8ea1a-433">Obtient les informations relatives au répertoire racine du chemin d’accès spécifié.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-433">Gets the root directory information of the specified path.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-434">Répertoire racine de <paramref name="path" />, ou <see langword="null" /> si <paramref name="path" /> est <see langword="null" />, ou une chaîne vide si <paramref name="path" /> ne contient pas d’informations relatives au répertoire racine.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-434">The root directory of <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> is <see langword="null" />, or an empty string if <paramref name="path" /> does not contain root directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-435">Cette méthode ne vérifie pas que le chemin d’accès ou nom de fichier existe.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-435">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="8ea1a-436">Les modèles possibles pour la chaîne retournée par cette méthode sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="8ea1a-436">Possible patterns for the string returned by this method are as follows:</span></span>  
  
- <span data-ttu-id="8ea1a-437">Une chaîne vide (`path` spécifié un chemin d’accès relatif sur le lecteur en cours ou le volume).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-437">An empty string (`path` specified a relative path on the current drive or volume).</span></span>  
  
- <span data-ttu-id="8ea1a-438">«\" (`path` spécifié un chemin d’accès absolu sur le lecteur actif).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-438">"\" (`path` specified an absolute path on the current drive).</span></span>  
  
- <span data-ttu-id="8ea1a-439">« X: » (`path` spécifié un chemin d’accès relatif sur un lecteur, où X représente une lettre de lecteur ou volume).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-439">"X:" (`path` specified a relative path on a drive, where X represents a drive or volume letter).</span></span>  
  
- <span data-ttu-id="8ea1a-440">« X :\" (`path` spécifié un chemin d’accès absolu sur un lecteur donné).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-440">"X:\" (`path` specified an absolute path on a given drive).</span></span>  
  
- <span data-ttu-id="8ea1a-441">«\\\ComputerName\SharedFolder » (un chemin d’accès UNC).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-441">"\\\ComputerName\SharedFolder" (a UNC path).</span></span>  
  
- <span data-ttu-id="8ea1a-442">«\\? \C : » (un chemin de périphérique DOS, prise en charge dans .NET Core 1.1 et versions ultérieures et .NET Framework 4.6.2 et versions ultérieures)</span><span class="sxs-lookup"><span data-stu-id="8ea1a-442">"\\?\C:" (a DOS device path, supported in .NET Core 1.1 and later versions and in .NET Framework 4.6.2 and later versions)</span></span>
   
 <span data-ttu-id="8ea1a-443">Pour plus d’informations sur les chemins d’accès sur Windows, consultez [les formats de chemin d’accès des fichiers sur les systèmes Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-443">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="8ea1a-444">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-444">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
## Examples  
 <span data-ttu-id="8ea1a-445">L’exemple suivant montre une utilisation de la `GetPathRoot` (méthode).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-445">The following example demonstrates a use of the `GetPathRoot` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8ea1a-446"><paramref name="path" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-446"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="8ea1a-447">ou</span><span class="sxs-lookup"><span data-stu-id="8ea1a-447">-or-</span></span> 
 <span data-ttu-id="8ea1a-448"><see cref="F:System.String.Empty" /> a été passé à <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-448"><see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-449">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-449">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-450">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-450">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-451">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-451">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-452">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-452">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8ea1a-453">Retourne un nom de dossier ou de fichier aléatoire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-453">Returns a random folder name or file name.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-454">Nom de dossier ou de fichier aléatoire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-454">A random folder name or file name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-455">Le <xref:System.IO.Path.GetRandomFileName%2A> méthode retourne une chaîne aléatoire et forte qui peut être utilisée comme un nom de dossier ou un nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-455">The <xref:System.IO.Path.GetRandomFileName%2A> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</span></span> <span data-ttu-id="8ea1a-456">Contrairement aux <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> ne crée pas de fichier.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-456">Unlike <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> does not create a file.</span></span> <span data-ttu-id="8ea1a-457">Lorsque la sécurité de votre système de fichiers est primordiale, cette méthode doit être utilisée à la place de <xref:System.IO.Path.GetTempFileName%2A>.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-457">When the security of your file system is paramount, this method should be used instead of <xref:System.IO.Path.GetTempFileName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ea1a-458">L’exemple suivant montre la sortie de la <xref:System.IO.Path.GetRandomFileName%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-458">The following example show output from the <xref:System.IO.Path.GetRandomFileName%2A> method.</span></span>  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo"><span data-ttu-id="8ea1a-459">Chemin d'accès source auquel le résultat doit être relatif.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-459">The source path the result should be relative to.</span></span> <span data-ttu-id="8ea1a-460">Ce chemin d'accès est toujours considéré comme un répertoire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-460">This path is always considered to be a directory.</span></span></param>
        <param name="path"><span data-ttu-id="8ea1a-461">Chemin d'accès de destination.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-461">The destination path.</span></span></param>
        <summary><span data-ttu-id="8ea1a-462">Renvoie un chemin d'accès relatif d'un chemin à un autre.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-462">Returns a relative path from one path to another.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-463">Chemin d'accès relatif, ou <paramref name="path" /> si les chemins ne partagent pas la même racine.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-463">The relative path, or <paramref name="path" /> if the paths don't share the same root.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="8ea1a-464">Chemins d’accès sont résolus en appelant le <xref:System.IO.Path.GetFullPath%2A> méthode avant de calculer la différence.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-464">Paths are resolved by calling the <xref:System.IO.Path.GetFullPath%2A> method before calculating the difference.</span></span> <span data-ttu-id="8ea1a-465">La méthode utilise la comparaison de chemin d’accès de fichier par défaut pour la plateforme actuelle (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> pour Windows et MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> pour Linux.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-465">The method uses the default file path comparison for the current platform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for Windows and MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> for Linux.</span></span> 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8ea1a-466"><paramref name="relativeTo" /> ou <paramref name="path" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-466"><paramref name="relativeTo" /> or <paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-467">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-467">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8ea1a-468">Crée un fichier temporaire de zéro octet nommé de façon univoque sur le disque et retourne le chemin d’accès complet de ce fichier.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-468">Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-469">Chemin d'accès complet du fichier temporaire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-469">The full path of the temporary file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-470">Cette méthode crée un fichier temporaire avec une. Extension de fichier TMP.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-470">This method creates a temporary file with a .TMP file extension.</span></span> <span data-ttu-id="8ea1a-471">Le fichier temporaire est créé dans le dossier temporaire de l’utilisateur, qui est le chemin d’accès retourné par la <xref:System.IO.Path.GetTempPath%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-471">The temporary file is created within the user's temporary folder, which is the path returned by the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
 <span data-ttu-id="8ea1a-472">Le <xref:System.IO.Path.GetTempFileName%2A> méthode déclenchera un <xref:System.IO.IOException> s’il est utilisé pour créer plus de 65 535 fichiers sans supprimer les fichiers temporaires antérieurs.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-472">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if it is used to create more than 65535 files without deleting previous temporary files.</span></span>  
  
 <span data-ttu-id="8ea1a-473">Le <xref:System.IO.Path.GetTempFileName%2A> méthode déclenchera un <xref:System.IO.IOException> si aucun nom de fichier temporaire unique n’est disponible.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-473">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if no unique temporary file name is available.</span></span> <span data-ttu-id="8ea1a-474">Pour résoudre cette erreur, supprimez tous les fichiers temporaires inutiles.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-474">To resolve this error, delete all unneeded temporary files.</span></span>  
  
 <span data-ttu-id="8ea1a-475">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-475">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="8ea1a-476">Une erreur d’E/S se produit, par exemple si aucun nom de fichier temporaire unique n’est disponible.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-476">An I/O error occurs, such as no unique temporary file name is available.</span></span>  
  
<span data-ttu-id="8ea1a-477">ou</span><span class="sxs-lookup"><span data-stu-id="8ea1a-477">-or-</span></span> 
<span data-ttu-id="8ea1a-478">Cette méthode n’a pas pu créer un fichier temporaire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-478">This method was unable to create a temporary file.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="8ea1a-479">pour écrire dans le répertoire temporaire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-479">for writing to the temporary directory.</span></span> <span data-ttu-id="8ea1a-480">Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span><span class="sxs-lookup"><span data-stu-id="8ea1a-480">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-481">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-481">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-482">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-482">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-483">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-483">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8ea1a-484">Retourne le chemin d’accès du dossier temporaire de l’utilisateur actuel.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-484">Returns the path of the current user's temporary folder.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-485">Chemin d’accès au dossier temporaire, se terminant par une barre oblique inverse.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-485">The path to the temporary folder, ending with a backslash.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-486">Cette méthode vérifie l’existence de variables d’environnement dans l’ordre suivant et utilise le premier chemin d’accès trouvé :</span><span class="sxs-lookup"><span data-stu-id="8ea1a-486">This method checks for the existence of environment variables in the following order and uses the first path found:</span></span>  
  
1.  <span data-ttu-id="8ea1a-487">Le chemin d’accès spécifié par la variable d’environnement TMP.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-487">The path specified by the TMP environment variable.</span></span>  
  
2.  <span data-ttu-id="8ea1a-488">Le chemin d’accès spécifié par la variable d’environnement TEMP.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-488">The path specified by the TEMP environment variable.</span></span>  
  
3.  <span data-ttu-id="8ea1a-489">Le chemin d’accès spécifié par la variable d’environnement USERPROFILE.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-489">The path specified by the USERPROFILE environment variable.</span></span>  
  
4.  <span data-ttu-id="8ea1a-490">Le répertoire Windows.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-490">The Windows directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ea1a-491">Le code suivant montre comment appeler la méthode <xref:System.IO.Path.GetTempPath%2A>.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-491">The following code shows how to call the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 <span data-ttu-id="8ea1a-492">Cet exemple produit une sortie similaire à ce qui suit.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-492">This example produces output similar to the following.</span></span>  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8ea1a-493">L’appelant n’a pas les autorisations requises.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-493">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission"><span data-ttu-id="8ea1a-494">pour un accès illimité aux variables d’environnement.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-494">for unrestricted access to environment variables.</span></span> <span data-ttu-id="8ea1a-495">Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="8ea1a-495">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-496">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-496">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-497">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-497">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-498">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-498">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-499">Chemin d'accès où rechercher une extension.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-499">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="8ea1a-500">Détermine si le chemin d'accès représenté par l'étendue de caractères spécifiée comprend une extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-500">Determines whether the path represented by the specified character span includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-501"><see langword="true" /> si les caractères qui suivent le dernier caractère de séparation de répertoire ou le dernier séparateur de volume du chemin d'accès incluent un point (« . ») suivi d'un ou plusieurs caractères ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-501"><see langword="true" /> if the characters that follow the last directory separator character or volume separator in the path include a period (".") followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="8ea1a-502">Un point final dans `path` n’est pas considéré comme une extension.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-502">A trailing period in `path` is not considered an extension.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-503">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-503">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-504">Chemin d'accès où rechercher une extension.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-504">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="8ea1a-505">Détermine si un chemin d'accès inclut une extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-505">Determines whether a path includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-506"><see langword="true" /> si les caractères qui suivent le dernier séparateur de répertoire (\\\ ou /) ou le dernier séparateur de volume (:) dans le chemin d’accès incluent un point (.) suivi d’un ou plusieurs caractères ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-506"><see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-507">À partir de la fin de `path`, cette méthode recherche un point (.) suivi d’au moins un caractère.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-507">Starting from the end of `path`, this method searches for a period (.) followed by at least one character.</span></span> <span data-ttu-id="8ea1a-508">Si ce modèle est trouvé avant un <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, ou <xref:System.IO.Path.VolumeSeparatorChar> caractère est rencontré, cette méthode retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-508">If this pattern is found before a <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar> character is encountered, this method returns `true`.</span></span>  
  
 <span data-ttu-id="8ea1a-509">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-509">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ea1a-510">L'exemple suivant illustre l'utilisation de la méthode `HasExtension`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-510">The following example demonstrates the use of the `HasExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8ea1a-511"><paramref name="path" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-511"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-512">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-512">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-513">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-513">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-514">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-514">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-515">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-515">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8ea1a-516">Fournit un tableau de caractères (spécifique à la plateforme) qui ne peuvent pas être spécifiés dans des arguments de chaîne de chemin d’accès passés aux membres de la classe <see cref="T:System.IO.Path" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-516">Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-517">Le tableau renvoyé par cette méthode n’est pas garanti pour contenir l’ensemble complet des caractères qui ne sont pas valides dans les noms de fichiers et de répertoires.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-517">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="8ea1a-518">L’ensemble des caractères non valides peut varier selon le système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-518">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="8ea1a-519">Par exemple, sur les plateformes de bureau Windows, les caractères de chemin non valide peuvent inclure des caractères ASCII/Unicode 1 à 31, ainsi que mettre entre guillemets («), inférieur à (\<), supérieur à (>), barre verticale (&#124;), retour arrière (\b), valeur null (\0) et tabulation (\t).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-519">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8ea1a-520">N’utilisez pas <xref:System.IO.Path.InvalidPathChars> si vous pensez que votre code peut s’exécuter dans le même domaine d’application en tant que code non fiable.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-520">Do not use <xref:System.IO.Path.InvalidPathChars> if you think your code might execute in the same application domain as untrusted code.</span></span> <span data-ttu-id="8ea1a-521"><xref:System.IO.Path.InvalidPathChars> est un tableau, donc ses éléments peuvent être remplacés.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-521"><xref:System.IO.Path.InvalidPathChars> is an array, so its elements can be overwritten.</span></span> <span data-ttu-id="8ea1a-522">Si le code non fiable remplace des éléments de <xref:System.IO.Path.InvalidPathChars>, il peut entraîner votre code un dysfonctionnement de façons qui pourraient être exploitées.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-522">If untrusted code overwrites elements of <xref:System.IO.Path.InvalidPathChars>, it might cause your code to malfunction in ways that could be exploited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ea1a-523">L’exemple suivant illustre l’utilisation de la `InvalidPathChars` propriété.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-523">The following example demonstrates the use of the `InvalidPathChars` property.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-524">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-524">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-525">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-525">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-526">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-526">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary><span data-ttu-id="8ea1a-527">Renvoie une valeur qui indique si un chemin d'accès de fichier est complet.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-527">Returns a value that indicates whether a file path is fully qualified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="8ea1a-528">Les surcharges de la `IsPathFullyQualified` chemins d’accès du handle de méthode qui utilisent toutes deux le <xref:System.IO.Path.DirectorySeparatorChar> et <xref:System.IO.Path.AltDirectorySeparatorChar> caractères.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-528">The overloads of the `IsPathFullyQualified` method handle paths that use both the <xref:System.IO.Path.DirectorySeparatorChar> and the <xref:System.IO.Path.AltDirectorySeparatorChar> characters.</span></span> <span data-ttu-id="8ea1a-529">Il n’effectue aucune validation sur le chemin d’accès qui lui est passé en tant qu’argument.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-529">It does not perform any validation on the path that is passed to it as an argument.</span></span> <span data-ttu-id="8ea1a-530">Par conséquent, les URI sont interprétés comme des chemins d’accès relatifs et retourner `false`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-530">As a result, URIs are interpreted as relative paths and return `false`.</span></span> 

<span data-ttu-id="8ea1a-531">Il existe une différence entre un chemin d’accès qualifié complet (tel qu’indiqué par le `IsPathFullyQualified` méthode) et un chemin d’accès racine (comme indiqué par le <xref:System.IO.Path.IsPathRooted%2A> (méthode)).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-531">There is a difference between a fully qualified path (as indicated by the `IsPathFullyQualified` method) and a rooted path (as indicated by the <xref:System.IO.Path.IsPathRooted%2A> method).</span></span> <span data-ttu-id="8ea1a-532">Un *chemin qualifié complet* ou *chemin d’accès absolu* toujours définit un chemin d’accès exact à partir d’un lecteur particulier ou un périphérique à un fichier ou répertoire cible et ne repose pas sur le lecteur en cours ou le répertoire actuel.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-532">A *fully qualified path* or *absolute path* always defines an exact path from a particular drive or device to a target file or directory, and does not depend on the current drive or current directory.</span></span> <span data-ttu-id="8ea1a-533">Par exemple, sur les systèmes Windows, *C:/users/user1/documents/reports/2019/january/highlights.pdf* définit un chemin d’accès absolu à partir de la racine du lecteur C: dans le fichier cible, *highlights.pdf*.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-533">For example, on Windows systems, *C:/users/user1/documents/reports/2019/january/highlights.pdf* defines an absolute path from the root of the C: drive to the target file, *highlights.pdf*.</span></span> <span data-ttu-id="8ea1a-534">Un *chemin d’accès racine* spécifie un lecteur de démarrage ou un répertoire racine, mais varie selon le répertoire actuel (si elle est enraciné par un lecteur spécifié) ou le lecteur actuel (si elle est enraciné par le répertoire racine).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-534">A *rooted path* specifies either a starting drive or root directory, but depends on either the current directory (if it is rooted by a specified drive) or the current drive (if it is rooted by the root directory).</span></span> <span data-ttu-id="8ea1a-535">L’exemple suivant illustre la différence entre les chemins d’accès complets et les chemins d’accès racine.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-535">The following example illustrates the difference between fully qualified paths and rooted paths.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-536">Chemin d'accès de fichier.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-536">A file path.</span></span></param>
        <summary><span data-ttu-id="8ea1a-537">Renvoie une valeur qui indique si le chemin d'accès de fichier représenté par l'étendue de caractères spécifiée est fixé sur un lecteur ou un chemin d'accès UNC spécifique.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-537">Returns a value that indicates whether the file path represented by the specified character span is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-538"><see langword="true" /> si le chemin d'accès est fixé sur un lecteur ou chemin d'accès UNC spécifique ; <see langword="false" /> si le chemin d'accès est relatif au lecteur ou au répertoire de travail actuel.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-538"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-539">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-539">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-540">Chemin d'accès de fichier.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-540">A file path.</span></span></param>
        <summary><span data-ttu-id="8ea1a-541">Renvoie une valeur qui indique si le chemin d'accès du fichier spécifié est fixé sur un lecteur ou un chemin d'accès UNC spécifique.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-541">Returns a value that indicates whether the specified file path is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-542"><see langword="true" /> si le chemin d'accès est fixé sur un lecteur ou chemin d'accès UNC spécifique ; <see langword="false" /> si le chemin d'accès est relatif au lecteur ou au répertoire de travail actuel.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-542"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8ea1a-543"><paramref name="path" /> a la valeur <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-543"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-544">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-544">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary><span data-ttu-id="8ea1a-545">Renvoie une valeur qui indique si un chemin d'accès contient une racine.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-545">Returns a value that indicates whether a file path contains a root.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="8ea1a-546">Un **chemin d’accès racine** est le chemin d’accès du fichier qui est fixe à un lecteur spécifique ou un chemin d’accès UNIC ; elle s’oppose à un chemin d’accès relatif du lecteur en cours ou le répertoire de travail.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-546">A **rooted path** is file path that is fixed to a specific drive or UNIC path; it contrasts with a path that is relative to the current drive or working directory.</span></span> <span data-ttu-id="8ea1a-547">Par exemple, sur les systèmes Windows, un chemin d’accès racine commence par une barre oblique inverse (par exemple, « \Documents ») ou une lettre de lecteur et les deux-points (par exemple, « C:Documents »).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-547">For example, on Windows systems, a rooted path begins with a backslash (for example, "\Documents") or a drive letter and colon (for example, "C:Documents").</span></span> 

<span data-ttu-id="8ea1a-548">Notez que les chemins d’accès racine peuvent être absolue (qui est, qualifié complet) ou relatif.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-548">Note that rooted paths can be either absolute (that is, fully qualified) or relative.</span></span> <span data-ttu-id="8ea1a-549">Un chemin d’accès racine absolu est un chemin d’accès qualifié complet à partir de la racine d’un lecteur dans un répertoire spécifique.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-549">An absolute rooted path is a fully qualified path from the root of a drive to a specific directory.</span></span> <span data-ttu-id="8ea1a-550">Un chemin d’accès racine relatif spécifie un lecteur, mais son chemin d’accès qualifié complet est résolu en fonction du répertoire actif.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-550">A relative rooted path specifies a drive, but its fully qualified path is resolved against the current directory.</span></span> <span data-ttu-id="8ea1a-551">L'exemple suivant illustre la différence.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-551">The following example illustrates the difference.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-552">Chemin d’accès à tester.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-552">The path to test.</span></span></param>
        <summary><span data-ttu-id="8ea1a-553">Renvoie une valeur indiquant si l'étendue de caractères spécifiée qui représente un chemin de fichier contient une racine.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-553">Returns a value that indicates whether the specified character span that represents a file path contains a root.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-554"><see langword="true" /> si <paramref name="path" /> contient une racine ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-554"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-555">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-555">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8ea1a-556">Chemin d’accès à tester.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-556">The path to test.</span></span></param>
        <summary><span data-ttu-id="8ea1a-557">Renvoie une valeur indiquant si la chaîne de chemin d'accès spécifiée contient une racine.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-557">Returns a value indicating whether the specified path string contains a root.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-558"><see langword="true" /> si <paramref name="path" /> contient une racine ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-558"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-559">Le <xref:System.IO.Path.IsPathRooted%2A> retourne de la méthode `true` si le premier caractère est un caractère de séparation de répertoire tel que «\\», ou si le chemin d’accès commence par une lettre de lecteur et le signe deux-points ( :)).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-559">The <xref:System.IO.Path.IsPathRooted%2A> method returns `true` if the first character is a directory separator character such as "\\", or if the path starts with a drive letter and colon (:).</span></span> <span data-ttu-id="8ea1a-560">Par exemple, elle retourne `true` pour `path` des chaînes telles que «\\\MyDir\\\MyFile.txt », « C:\\\MyDir », ou « C : mydir ».</span><span class="sxs-lookup"><span data-stu-id="8ea1a-560">For example, it returns `true` for `path` strings such as "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", or "C:MyDir".</span></span> <span data-ttu-id="8ea1a-561">Elle retourne `false` pour `path` chaînes telles que « MyDir ».</span><span class="sxs-lookup"><span data-stu-id="8ea1a-561">It returns `false` for `path` strings such as "MyDir".</span></span>  
  
 <span data-ttu-id="8ea1a-562">Cette méthode ne vérifie pas que le chemin d’accès ou nom de fichier existe.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-562">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="8ea1a-563">Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="8ea1a-563">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  

## Examples  
 <span data-ttu-id="8ea1a-564">L’exemple suivant montre comment la `IsPathRooted` méthode peut être utilisée pour tester les trois chaînes.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-564">The following example demonstrates how the `IsPathRooted` method can be used to test three strings.</span></span>  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8ea1a-565"><paramref name="path" /> contient un ou plusieurs caractères non valides définis dans <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-565"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-566">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-566">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-567">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-567">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-568">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-568">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-569">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-569">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8ea1a-570">Étendue de caractères contenant le premier chemin d'accès à joindre.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-570">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8ea1a-571">Étendue de caractères contenant le deuxième chemin d'accès à joindre.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-571">A character span that contains the second path to join.</span></span></param>
        <summary><span data-ttu-id="8ea1a-572">Concatène deux composants de chemin d'accès en un seul chemin.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-572">Concatenates two path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-573">Chemins d'accès combinés.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-573">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="8ea1a-574">Cette méthode concatène simplement `path` et `path2` et ajoute un caractère de séparation de répertoire entre les composants de chemin de deux accès si aucun n’est pas déjà présent à la fin de `path1` ou le début du `path2`.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-574">This method simply concatenates `path` and `path2` and adds a directory separator character between the two path components if one is not already present at the end of `path1` or the beginning of `path2`.</span></span> <span data-ttu-id="8ea1a-575">Si le <xref:System.ReadOnlySpan%601.Length> du `path1` ou `path2` est égal à zéro, la méthode retourne le chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-575">If the <xref:System.ReadOnlySpan%601.Length> of either `path1` or `path2` is zero, the method returns the other path.</span></span> <span data-ttu-id="8ea1a-576">Si le <xref:System.ReadOnlySpan%601.Length> des deux `path1` et `path2` est égal à zéro, la méthode retourne <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-576">If the <xref:System.ReadOnlySpan%601.Length> of both `path1` and `path2` is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="8ea1a-577">Si `path1` se termine par un caractère de séparation du chemin d’accès qui n’est pas approprié pour la plateforme cible, le `Join` méthode conserve le caractère de séparateur de chemin d’accès d’origine et ajoute celui pris en charge.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-577">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8ea1a-578">Ce problème survient dans les chemins codés en dur qui utilisent la barre oblique inverse de Windows («\") caractère, qui n’est pas reconnu comme un séparateur de chemin d’accès sur les systèmes basés sur Unix.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-578">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8ea1a-579">Pour contourner ce problème, vous pouvez :</span><span class="sxs-lookup"><span data-stu-id="8ea1a-579">To work around this issue, you can:</span></span>

- <span data-ttu-id="8ea1a-580">Récupérer la valeur de la <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propriété plutôt que de coder en dur un caractère de séparation de répertoire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-580">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8ea1a-581">Utilisez une barre oblique (« / ») comme séparateur de répertoire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-581">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8ea1a-582">Ce caractère est retourné par la <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propriété sur les systèmes Unix et par le <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> propriété sur les systèmes Windows.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-582">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="8ea1a-583">Contrairement à la <xref:System.IO.Path.Combine%2A> (méthode), le <xref:System.IO.Path.Join%2A> méthode ne tente pas de racine du chemin d’accès retournée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-583">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8ea1a-584">(Autrement dit, si `path2` est un chemin d’accès absolu, le `Join` n’ignore pas la méthode `path1` et retourner `path2` comme le <xref:System.IO.Path.Combine%2A> méthode.) L’exemple suivant illustre la différence dans les chemins d’accès retourné par les deux méthodes.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-584">(That is, if `path2` is an absolute path, the `Join` method does not discard `path1` and return `path2` as the <xref:System.IO.Path.Combine%2A> method does.) The following example illustrates the difference in the paths returned by the two methods.</span></span> <span data-ttu-id="8ea1a-585">Si la source de `path2` est l’entrée utilisateur, le <xref:System.IO.Path.Combine%2A> méthode rend possible pour un utilisateur à accéder à une ressource de système de fichier (tel que *C:/utilisateurs/User1/Documents/Financial/* dans le cas de l’exemple) qui a effectué l’application n’envisagez pas de rendre accessible.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-585">If the source of `path2` is user input, the <xref:System.IO.Path.Combine%2A> method makes it possible for a user to access a file system resource (such as *C:/Users/User1/Documents/Financial/* in the case of the example) that the application did not intend to make accessible.</span></span>  

<span data-ttu-id="8ea1a-586">Pas tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par le `Join` (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-586">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8ea1a-587">Par exemple, tandis que `Path.Join("c:\\", "*.txt")` peut être non valide quand créer un fichier, il est une chaîne de recherche valide.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-587">For example, while `Path.Join("c:\\", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8ea1a-588">Le `Join` méthode correctement l’interprète donc il.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-588">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="8ea1a-589">Exemple</span><span class="sxs-lookup"><span data-stu-id="8ea1a-589">Example</span></span>

<span data-ttu-id="8ea1a-590">L’exemple suivant illustre la différence dans les chemins d’accès retourné par la <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> et <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> méthodes.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-590">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="8ea1a-591">Lorsque la première chaîne est un chemin d’accès qualifié complet qui inclut un lecteur et le répertoire racine et le second est un chemin d’accès relatif à partir du premier chemin d’accès, les deux méthodes produisent des résultats identiques.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-591">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="8ea1a-592">Dans les appels de deuxième et troisième à la `ShowPathInformation` divergent de méthode, les chaînes retournées par les deux méthodes.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-592">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="8ea1a-593">Dans le deuxième appel de méthode, la première chaîne d’argument est un lecteur, tandis que la deuxième est un répertoire racine.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-593">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="8ea1a-594">Le `Join` méthode concatène deux chaînes et conserve dupliquer les séparateurs de chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-594">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="8ea1a-595">Le `Combine` méthode abandonne le lecteur et retourne un répertoire racine du lecteur actif.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-595">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="8ea1a-596">Si le lecteur en cours de l’application est C:\ et la chaîne est utilisée pour accéder à un ou plusieurs fichiers dans le répertoire, il doit accéder à C: au lieu de D:.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-596">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="8ea1a-597">Enfin, étant donné que les deux arguments dans le troisième appel `ShowPathInformation` sont associés à une racine, le `Join` méthode ajoute simplement les pour créer un chemin d’accès de fichier absurde, tandis que le `Combine` méthode ignore la première chaîne et retourne le deuxième.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-597">Finally, because both arguments in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends them to create a nonsensical file path, while the `Combine` method discards the first string and returns the second.</span></span> <span data-ttu-id="8ea1a-598">À l’aide de cette chaîne pour l’accès au fichier pourrait donner à l’application l’accès involontaire à des fichiers sensibles.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-598">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-csharp[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-599">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-599">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8ea1a-600">Étendue de caractères contenant le premier chemin d'accès à joindre.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-600">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8ea1a-601">Étendue de caractères contenant le deuxième chemin d'accès à joindre.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-601">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="8ea1a-602">Étendue de caractères contenant le troisième chemin d'accès à joindre.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-602">A character span that contains the third path to join.</span></span></param>
        <summary><span data-ttu-id="8ea1a-603">Concatène trois composants de chemin d'accès en un seul chemin.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-603">Concatenates three path components into a single path.</span></span></summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="8ea1a-604">Cette méthode concatène simplement `path`, `path2`, et `path3` et ajoute un caractère de séparation de répertoire entre les composants de chemin d’accès si un n’est pas déjà présent.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-604">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="8ea1a-605">Si le <xref:System.ReadOnlySpan%601.Length> des `path1`, `path2`, ou `path3` argument est égal à zéro, la méthode concatène les arguments restants.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-605">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, or `path3` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="8ea1a-606">Si le <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> de tous les composants est égal à zéro, la méthode retourne <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-606">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>    

<span data-ttu-id="8ea1a-607">Si `path1` ou `path2` se termine par un caractère de séparation du chemin d’accès qui n’est pas approprié pour la plateforme cible, le `Join` méthode conserve le caractère de séparateur de chemin d’accès d’origine et ajoute celui pris en charge.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-607">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8ea1a-608">Ce problème survient dans les chemins codés en dur qui utilisent la barre oblique inverse de Windows («\") caractère, qui n’est pas reconnu comme un séparateur de chemin d’accès sur les systèmes basés sur Unix.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-608">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8ea1a-609">Pour contourner ce problème, vous pouvez :</span><span class="sxs-lookup"><span data-stu-id="8ea1a-609">To work around this issue, you can:</span></span>

- <span data-ttu-id="8ea1a-610">Récupérer la valeur de la <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propriété plutôt que de coder en dur un caractère de séparation de répertoire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-610">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8ea1a-611">Utilisez une barre oblique (« / ») comme séparateur de répertoire.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-611">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8ea1a-612">Ce caractère est retourné par la <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propriété sur les systèmes Unix et par le <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> propriété sur les systèmes Windows.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-612">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="8ea1a-613">Contrairement à la <xref:System.IO.Path.Combine%2A> (méthode), le <xref:System.IO.Path.Join%2A> méthode ne tente pas de racine du chemin d’accès retournée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-613">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8ea1a-614">(Autrement dit, si `path2` ou `path2` est un chemin d’accès absolu, le `Join` méthode n’ignore pas les chemins d’accès précédentes en tant que le <xref:System.IO.Path.Combine%2A> méthode effectue.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-614">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>  
  
<span data-ttu-id="8ea1a-615">Pas tous les caractères non valides pour les noms de répertoires et les fichiers sont interprétés comme étant inacceptables par le `Join` (méthode), car vous pouvez utiliser ces caractères pour les caractères génériques de recherche.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-615">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8ea1a-616">Par exemple, tandis que `Path.Join("c:\\", "temp", "*.txt")` peut être non valide quand créer un fichier, il est une chaîne de recherche valide.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-616">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8ea1a-617">Le `Join` méthode correctement l’interprète donc il.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-617">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="8ea1a-618">Exemple</span><span class="sxs-lookup"><span data-stu-id="8ea1a-618">Example</span></span>

<span data-ttu-id="8ea1a-619">L’exemple suivant illustre la différence dans les chemins d’accès retourné par la <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> et <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> méthodes.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-619">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="8ea1a-620">Lorsque la première chaîne est un chemin d’accès qualifié complet qui inclut un lecteur et le répertoire racine et le second est un chemin d’accès relatif à partir du premier chemin d’accès, les deux méthodes produisent des résultats identiques.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-620">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="8ea1a-621">Dans les appels de deuxième et troisième à la `ShowPathInformation` divergent de méthode, les chaînes retournées par les deux méthodes.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-621">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="8ea1a-622">Dans le deuxième appel de méthode, la première chaîne d’argument est un lecteur, tandis que la deuxième est un répertoire racine.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-622">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="8ea1a-623">Le `Join` méthode concatène deux chaînes et conserve dupliquer les séparateurs de chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-623">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="8ea1a-624">Un appel à la <xref:System.IO.Path.GetFullPath%2A> méthode supprimerait la duplication.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-624">A call to the <xref:System.IO.Path.GetFullPath%2A> method would eliminate the duplication.</span></span> <span data-ttu-id="8ea1a-625">Le `Combine` méthode abandonne le lecteur et retourne un répertoire racine du lecteur actif.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-625">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="8ea1a-626">Si le lecteur en cours de l’application est C:\ et la chaîne est utilisée pour accéder à un ou plusieurs fichiers dans le répertoire, il doit accéder à C: au lieu de D:.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-626">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="8ea1a-627">Enfin, étant donné que l’argument final dans le troisième appel `ShowPathInformation` sont associés à une racine, le `Join` méthode ajoute simplement pour les deux premiers arguments pour créer un chemin d’accès du fichier absurde, tandis que le `Combine` méthode ignore les deux premières chaînes et retourne la troisième.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-627">Finally, because the final argument in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends it to the first two arguments to create a nonsensical file path, while the `Combine` method discards the first two strings and returns the third.</span></span> <span data-ttu-id="8ea1a-628">À l’aide de cette chaîne pour l’accès au fichier pourrait donner à l’application l’accès involontaire à des fichiers sensibles.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-628">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)] 
[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)] 

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-629">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-629">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8ea1a-630">Caractère de séparation spécifique à la plateforme, utilisé pour séparer les chaînes de chemin d'accès dans les variables d'environnement.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-630">A platform-specific separator character used to separate path strings in environment variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-631">Sur les plateformes de bureau Windows, la valeur de ce champ est le point-virgule ( ;) par défaut, mais elle peut varier sur d’autres plateformes.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-631">On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ea1a-632">L’exemple suivant illustre l’utilisation de la `PathSeparator` champ.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-632">The following example demonstrates the use of the `PathSeparator` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-633">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-633">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-634">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-634">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-635">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-635">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary><span data-ttu-id="8ea1a-636">Tente de concaténer des composants de chemin d'accès individuels au sein d'une étendue de caractères préallouée, et renvoie une valeur indiquant si l'opération est un succès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-636">Attempts to concatenate individual path components to a preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="8ea1a-637">L’étendue de caractères de destination doit être suffisamment grande pour contenir le chemin d’accès concaténée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-637">The destination character span must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="8ea1a-638">Vous pouvez ensuite récupérer le chemin d’accès concaténée en appelant le <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> (méthode), comme dans l’exemple suivant illustre.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-638">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the following example illustrates.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8ea1a-639">Étendue de caractères contenant le premier chemin d'accès à joindre.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-639">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8ea1a-640">Étendue de caractères contenant le deuxième chemin d'accès à joindre.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-640">A character span that contains the second path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="8ea1a-641">Étendue de caractères permettant de contenir le chemin d'accès concaténé.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-641">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="8ea1a-642">Lorsque la méthode renvoie une valeur qui indique le nombre de caractères écrits dans le <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-642">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="8ea1a-643">Tente de concaténer deux composants de chemin d'accès au sein d'une seule étendue de caractères préallouée, et renvoie une valeur indiquant si l'opération est un succès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-643">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-644"><see langword="true" /> si l’opération de concaténation réussit ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-644"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="8ea1a-645">`destination` doit être suffisamment grande pour contenir le chemin d’accès concaténée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-645">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="8ea1a-646">Vous pouvez ensuite récupérer le chemin d’accès concaténée en appelant le <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> (méthode), comme dans l’exemple illustre.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-646">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-647">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-647">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8ea1a-648">Étendue de caractères contenant le premier chemin d'accès à joindre.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-648">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8ea1a-649">Étendue de caractères contenant le deuxième chemin d'accès à joindre.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-649">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="8ea1a-650">Étendue de caractères contenant le troisième chemin d'accès à joindre.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-650">A character span that contains the third path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="8ea1a-651">Étendue de caractères permettant de contenir le chemin d'accès concaténé.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-651">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="8ea1a-652">Lorsque la méthode renvoie une valeur qui indique le nombre de caractères écrits dans le <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-652">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="8ea1a-653">Tente de concaténer deux composants de chemin d'accès au sein d'une seule étendue de caractères préallouée, et renvoie une valeur indiquant si l'opération est un succès.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-653">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="8ea1a-654"><see langword="true" /> si l’opération de concaténation réussit ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-654"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="8ea1a-655">`destination` doit être suffisamment grande pour contenir le chemin d’accès concaténée.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-655">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="8ea1a-656">Vous pouvez ensuite récupérer le chemin d’accès concaténée en appelant le <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> (méthode), comme dans l’exemple illustre.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-656">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8ea1a-657">Formats de chemin de fichier sur les systèmes Windows</span><span class="sxs-lookup"><span data-stu-id="8ea1a-657">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8ea1a-658">Fournit un caractère de séparation de volume spécifique à la plateforme.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-658">Provides a platform-specific volume separator character.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ea1a-659">La valeur de ce champ est un signe deux-points ( :)) sur Windows et Macintosh et une barre oblique (/) sur les systèmes d’exploitation UNIX.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-659">The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</span></span> <span data-ttu-id="8ea1a-660">Cela est particulièrement utile pour l’analyse des chemins d’accès tel que « c:\windows » ou « Dossier MacVolume : System ».</span><span class="sxs-lookup"><span data-stu-id="8ea1a-660">This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ea1a-661">L’exemple suivant illustre l’utilisation de la `VolumeSeparatorChar` champ.</span><span class="sxs-lookup"><span data-stu-id="8ea1a-661">The following example demonstrates the use of the `VolumeSeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8ea1a-662">Fichier et flux de données E/S</span><span class="sxs-lookup"><span data-stu-id="8ea1a-662">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8ea1a-663">Procédure : lire le texte d’un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-663">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8ea1a-664">Procédure : écrire du texte dans un fichier</span><span class="sxs-lookup"><span data-stu-id="8ea1a-664">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>