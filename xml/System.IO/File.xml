<Type Name="File" FullName="System.IO.File">
  <Metadata><Meta Name="ms.openlocfilehash" Value="21b93b49655aaa60f9b2d6867687101f2df0cd1c" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56351931" /></Metadata><TypeSignature Language="C#" Value="public static class File" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit File extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.File" />
  <TypeSignature Language="VB.NET" Value="Public Class File" />
  <TypeSignature Language="C++ CLI" Value="public ref class File abstract sealed" />
  <TypeSignature Language="F#" Value="type File = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit des méthodes statiques pour créer, copier, supprimer, déplacer et ouvrir un fichier unique, et facilite la création d'objets <see cref="T:System.IO.FileStream" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.IO.File> classe pour les opérations courantes telles que la copie, déplacer, renommer, création, ouverture, la suppression et ajout à un seul fichier à la fois. Vous pouvez également utiliser le <xref:System.IO.File> classe pour obtenir et définir des attributs de fichier ou <xref:System.DateTime> informations relatives à la création, d’accès et l’écriture d’un fichier. Si vous souhaitez effectuer des opérations sur plusieurs fichiers, consultez <xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType> ou <xref:System.IO.DirectoryInfo.GetFiles%2A?displayProperty=nameWithType>.  
  
 Un grand nombre de la <xref:System.IO.File> méthodes retournent des autres types d’e/s lorsque vous créez ou ouvrez des fichiers. Vous pouvez utiliser ces autres types pour manipuler un fichier. Pour plus d’informations, consultez spécifique <xref:System.IO.File> membres comme <xref:System.IO.File.OpenText%2A>, <xref:System.IO.File.CreateText%2A>, ou <xref:System.IO.File.Create%2A>.  
  
 Étant donné que tous les <xref:System.IO.File> méthodes sont statiques, il peut être plus efficace d’utiliser un <xref:System.IO.File> méthode plutôt qu’un <xref:System.IO.FileInfo> méthode d’instance si vous souhaitez effectuer une seule action. Tous les <xref:System.IO.File> méthodes nécessitent le chemin d’accès au fichier que vous manipulez.  
  
 Les méthodes statiques de la <xref:System.IO.File> classe effectuer des vérifications de sécurité sur toutes les méthodes. Si vous souhaitez réutiliser un objet plusieurs fois, envisagez d’utiliser la méthode d’instance correspondante de <xref:System.IO.FileInfo> au lieu de cela, étant donné que la vérification de la sécurité sera pas toujours être nécessaire.  
  
 Par défaut, accès complet en lecture/écriture aux nouveaux fichiers est accordé à tous les utilisateurs.  
  
 Le tableau suivant décrit les énumérations qui sont utilisées pour personnaliser le comportement de divers <xref:System.IO.File> méthodes.  
  
|Énumération|Description |  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|Spécifie l’accès en lecture et écriture dans un fichier.|  
|<xref:System.IO.FileShare>|Spécifie le niveau d’accès autorisé pour un fichier qui est déjà en cours d’utilisation.|  
|<xref:System.IO.FileMode>|Spécifie si le contenu d’un fichier existant est conservé ou remplacé, et si les demandes de création d’un fichier existant provoquent une exception.|  
  
> [!NOTE]
>  Dans les membres qui acceptent un chemin d’accès sous forme de chaîne d’entrée, ce chemin d’accès doit être correctement construit, ou une exception est levée. Par exemple, si un chemin d’accès est qualifié complet mais commence par un espace, le chemin d’accès n’est pas tronqué dans les méthodes de la classe. Par conséquent, le chemin d’accès est incorrect et une exception est levée. De même, un chemin d’accès ou une combinaison de chemins d’accès ne peut pas être qualifiée à deux reprises. Par exemple, « c:\temp c:\windows » déclenche également une exception dans la plupart des cas. Assurez-vous que vos chemins sont correctement construits lors de l’utilisation des méthodes qui acceptent une chaîne de chemin d’accès.  
  
 Dans les membres qui acceptent un chemin d’accès, le chemin d’accès peut faire référence à un fichier ou simplement un répertoire. Le chemin d’accès spécifié peut également faire référence à un chemin d’accès relatif ou un chemin d’accès UNC Universal Naming Convention () pour un nom de serveur et le partage. Par exemple, tous les éléments suivants sont des chemins d’accès acceptables :  
  
-   « c:\\\MyDir\\\MyFile.txt » en c# ou « c:\MyDir\MyFile.txt » en Visual Basic.  
  
-   « c:\\\MyDir » en c# ou « c:\MyDir » en Visual Basic.  
  
-   « MyDir\\\MySubdir » en c# ou « Monrépertoire\monsousrépertoire » en Visual Basic.  
  
-   «\\\\\\\MyServer\\\MyShare » en c#, ou «\\\MyServer\MyShare » en Visual Basic.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.IO.File> class à vérifier si un fichier existe et qu’en fonction du résultat, soit créer un nouveau fichier et y écrire, ou ouvrez le fichier existant et le lire. Avant d’exécuter le code, créez un `c:\temp` dossier.  
  
 [!code-cpp[File Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Class Example/CPP/file class example.cpp#1)]
 [!code-csharp[File Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Class Example/CS/file class example.cs#1)]
 [!code-vb[File Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Class Example/VB/file class example.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="AppendAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute des lignes à un fichier, puis ferme le fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberSignature Language="F#" Value="static member AppendAllLines : string * seq&lt;string&gt; -&gt; unit" Usage="System.IO.File.AppendAllLines (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">Fichier auquel ajouter les lignes. Le fichier est créé s'il n'existe pas.</param>
        <param name="contents">Lignes à ajouter au fichier.</param>
        <summary>Ajoute des lignes à un fichier, puis ferme le fichier. Si le fichier spécifié n'existe pas, cette méthode crée un fichier, écrit les lignes spécifiées dans le fichier, puis ferme le fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode crée le fichier s’il n’existe pas, mais il ne crée pas de nouveaux répertoires. Par conséquent, la valeur de la `path` paramètre doit contenir des répertoires existants.  
  
   
  
## Examples  
 L’exemple suivant écrit des lignes sélectionnées à partir d’un exemple de fichier de données dans un fichier, puis ajoute plus de lignes. Le répertoire nommé `temp` sur le lecteur C doit exister pour l’exemple se termine correctement.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ou <paramref name="contents" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> est non valide (par exemple, le répertoire n’existe pas ou se trouve sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié par <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’est pas autorisé à écrire dans le fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> spécifie un fichier qui est en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> est un répertoire.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member AppendAllLines : string * seq&lt;string&gt; * System.Text.Encoding -&gt; unit" Usage="System.IO.File.AppendAllLines (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Fichier auquel ajouter les lignes. Le fichier est créé s'il n'existe pas.</param>
        <param name="contents">Lignes à ajouter au fichier.</param>
        <param name="encoding">Encodage des caractères à utiliser.</param>
        <summary>Ajoute des lignes à un fichier en utilisant un encodage spécifié, puis ferme le fichier. Si le fichier spécifié n'existe pas, cette méthode crée un fichier, écrit les lignes spécifiées dans le fichier, puis ferme le fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode crée le fichier s’il n’existe pas, mais il ne crée pas de nouveaux répertoires. Par conséquent, la valeur de la `path` paramètre doit contenir des répertoires existants.  
  
 Vous pouvez utiliser cette méthode pour créer un fichier qui contient les éléments suivants :  
  
-   Les résultats d’une [LINQ to Objects](https://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) interroger sur les lignes d’un fichier, tel qu’obtenu à l’aide de la <xref:System.IO.File.ReadLines%2A> (méthode).  
  
-   Le contenu d’une collection qui implémente un <xref:System.Collections.Generic.IEnumerable%601> de chaînes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />, <paramref name="contents" /> ou <paramref name="encoding" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> est non valide (par exemple, le répertoire n’existe pas ou se trouve sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié par <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> spécifie un fichier qui est en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> est un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllLinesAsync : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllLinesAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllLinesAsync : string * seq&lt;string&gt; * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllLinesAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute la chaîne spécifiée au fichier, en créant le fichier s'il n'existe pas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents);" />
      <MemberSignature Language="F#" Value="static member AppendAllText : string * string -&gt; unit" Usage="System.IO.File.AppendAllText (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier auquel ajouter la chaîne spécifiée.</param>
        <param name="contents">Chaîne à ajouter au fichier.</param>
        <summary>Ouvre un fichier, ajoute la chaîne spécifiée au fichier, puis ferme le fichier. Si le fichier n'existe pas, cette méthode crée un fichier, écrit la chaîne spécifiée dans le fichier, puis ferme le fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une chaîne et un chemin d’accès de fichier donnés, cette méthode ouvre le fichier spécifié, ajoute la chaîne à la fin du fichier, puis ferme le fichier. Le handle de fichier est toujours fermé par cette méthode, même si les exceptions sont levées.  
  
 La méthode crée le fichier s’il n’existe pas, mais il ne crée pas de nouveaux répertoires. Par conséquent, la valeur de la `path` paramètre doit contenir des répertoires existants.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.File.AppendAllText%2A> méthode pour ajouter du texte à la fin d’un fichier. Dans cet exemple, un fichier est créé s’il n’existe pas déjà, et texte est ajouté à ce dernier. Toutefois, le répertoire nommé `temp` sur le lecteur C doit exister pour l’exemple se termine correctement.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié est non valide (par exemple, le répertoire n’existe pas ou se trouve sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un fichier en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’accès en écriture à un fichier ou répertoire. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member AppendAllText : string * string * System.Text.Encoding -&gt; unit" Usage="System.IO.File.AppendAllText (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Fichier auquel ajouter la chaîne spécifiée.</param>
        <param name="contents">Chaîne à ajouter au fichier.</param>
        <param name="encoding">Encodage des caractères à utiliser.</param>
        <summary>Ajoute la chaîne spécifiée au fichier, en créant le fichier s'il n'existe pas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une chaîne et un chemin d’accès de fichier donnés, cette méthode ouvre le fichier spécifié, ajoute la chaîne à la fin du fichier à l’aide de l’encodage spécifié, puis ferme le fichier. Le handle de fichier est toujours fermé par cette méthode, même si les exceptions sont levées.  
  
 La méthode crée le fichier s’il n’existe pas, mais il ne crée pas de nouveaux répertoires. Par conséquent, la valeur de la `path` paramètre doit contenir des répertoires existants.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.File.AppendAllText%2A> méthode pour ajouter du texte à la fin d’un fichier. Dans cet exemple, un fichier est créé s’il n’existe pas déjà, et texte est ajouté à ce dernier. Toutefois, le répertoire nommé `temp` sur le lecteur C doit exister pour l’exemple se termine correctement.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié est non valide (par exemple, le répertoire n’existe pas ou se trouve sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un fichier en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’accès en écriture à un fichier ou répertoire. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllTextAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllTextAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllTextAsync : string * string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllTextAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter AppendText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter AppendText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AppendText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ AppendText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member AppendText : string -&gt; System.IO.StreamWriter" Usage="System.IO.File.AppendText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès du fichier auquel le texte doit être ajouté.</param>
        <summary>Crée un élément <see cref="T:System.IO.StreamWriter" /> qui ajoute du texte encodé en UTF-8 à un fichier existant ou à un nouveau fichier si le fichier spécifié n'existe pas.</summary>
        <returns>Writer de flux qui ajoute du texte encodé en UTF-8 au fichier spécifié ou à un nouveau fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est équivalente à la <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> surcharge de constructeur. Si le fichier spécifié par `path` n’existe pas, il est créé. Opérations en écriture si le fichier n’existe pas, le <xref:System.IO.StreamWriter> ajouter du texte au fichier. Les threads supplémentaires sont autorisés à lire le fichier lorsqu’il est ouvert.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Le `path` paramètre ne respecte pas la casse.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant ajoute du texte dans un fichier. La méthode crée un nouveau fichier si le fichier n’existe pas. Toutefois, le répertoire nommé `temp` sur le lecteur C doit exister pour l’exemple se termine correctement.  
  
 [!code-cpp[File_AppendText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File_AppendText/CPP/file_appendtext.cpp#1)]
 [!code-csharp[File_AppendText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File_AppendText/CS/file_appendtext.cs#1)]
 [!code-vb[File_AppendText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File_AppendText/VB/file_appendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides tels que définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié est non valide (par exemple, le répertoire n’existe pas ou se trouve sur un lecteur non mappé).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour ajouter des données dans le fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie un fichier existant vers un nouveau fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="static member Copy : string * string -&gt; unit" Usage="System.IO.File.Copy (sourceFileName, destFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Fichier à copier.</param>
        <param name="destFileName">Nom du fichier de destination. Celui-ci ne peut pas être un répertoire ou un fichier existant.</param>
        <summary>Copie un fichier existant vers un nouveau fichier. Le remplacement d'un fichier du même nom n'est pas autorisé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est équivalente à la <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29> surcharge de méthode avec le `overwrite` paramètre défini sur `false`.  
  
 Le `sourceFileName` et `destFileName` les paramètres peuvent spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez le <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType> (méthode). Cette méthode ne prend pas en charge les caractères génériques dans les paramètres.  
  
 Les attributs du fichier d’origine sont conservées dans le fichier copié.  
  
   
  
## Examples  
 L’exemple suivant copie les fichiers dans le dossier de sauvegarde C:\archives\2008. Il utilise les deux surcharges de la <xref:System.IO.File.Copy%2A> méthode comme suit :  
  
-   Elle utilise d’abord le <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> surcharge de méthode pour copier des fichiers texte (.txt). Le code montre que cette surcharge n’autorise pas l’écrasement des fichiers qui ont déjà été copiés.  
  
-   Il utilise ensuite le <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> surcharge de méthode pour copier des images (fichiers .jpg). Le code montre que cette surcharge n’autorise en remplaçant les fichiers qui ont déjà été copiés.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceFileName" /> ou <paramref name="destFileName" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides tels que définis par <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
ou 
 <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> spécifie un répertoire.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceFileName" /> ou <paramref name="destFileName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié dans <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="sourceFileName" /> est introuvable.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="destFileName" /> existe.  
  
ou 
Une erreur d’E/S s’est produite.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="sourceFileName" /> ou <paramref name="destFileName" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir de <paramref name="sourceFileName" /> et l’écriture dans <paramref name="destFileName" />. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member Copy : string * string * bool -&gt; unit" Usage="System.IO.File.Copy (sourceFileName, destFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Fichier à copier.</param>
        <param name="destFileName">Nom du fichier de destination. Il ne peut pas s'agir d'un répertoire.</param>
        <param name="overwrite"><see langword="true" /> si le fichier de destination peut être remplacé ; sinon, <see langword="false" />.</param>
        <summary>Copie un fichier existant vers un nouveau fichier. Le remplacement d'un fichier du même nom est autorisé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `sourceFileName` et `destFileName` les paramètres peuvent spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Cette méthode ne prend pas en charge les caractères génériques dans les paramètres.  
  
 Les attributs du fichier d’origine sont conservées dans le fichier copié.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant copie les fichiers dans le dossier de sauvegarde C:\archives\2008. Il utilise les deux surcharges de la <xref:System.IO.File.Copy%2A> méthode comme suit :  
  
-   Elle utilise d’abord le <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> surcharge de méthode pour copier des fichiers texte (.txt). Le code montre que cette surcharge n’autorise pas l’écrasement des fichiers qui ont déjà été copiés.  
  
 Il utilise ensuite le <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> surcharge de méthode pour copier des images (fichiers .jpg). Le code montre que cette surcharge n’autorise en remplaçant les fichiers qui ont déjà été copiés.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.  
  
ou 
 <paramref name="destFileName" /> est en lecture seule.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceFileName" /> ou <paramref name="destFileName" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides tels que définis par <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
ou 
 <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> spécifie un répertoire.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceFileName" /> ou <paramref name="destFileName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié dans <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="sourceFileName" /> est introuvable.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="destFileName" /> existe et <paramref name="overwrite" /> est <see langword="false" />.  
  
ou 
Une erreur d’E/S s’est produite.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="sourceFileName" /> ou <paramref name="destFileName" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir de <paramref name="sourceFileName" /> et l’écriture dans <paramref name="destFileName" />. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un fichier dans le chemin d'accès spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.IO.FileStream" Usage="System.IO.File.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès et nom du fichier à créer.</param>
        <summary>Crée ou remplace un fichier dans le chemin d'accès spécifié.</summary>
        <returns>Élément <see cref="T:System.IO.FileStream" /> qui fournit l'accès en lecture/écriture au fichier spécifié dans <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.FileStream> objet créé par cette méthode a une valeur par défaut <xref:System.IO.FileShare> valeur <xref:System.IO.FileShare.None>; aucun autre processus ou un autre code ne peut accéder au fichier créé jusqu'à ce que le handle de fichier d’origine est fermé.  
  
 Cette méthode est équivalente à la <xref:System.IO.File.Create%28System.String%2CSystem.Int32%29> surcharge de méthode à l’aide de la taille du tampon par défaut.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Si le fichier spécifié n’existe pas, il est créé ; Si elle n’existe pas et il n’est pas en lecture seule, le contenu est remplacé.  
  
 Par défaut, accès complet en lecture/écriture aux nouveaux fichiers est accordé à tous les utilisateurs. Le fichier est ouvert avec accès en lecture/écriture et doit être fermé avant d’être ouvert par une autre application.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant crée un fichier dans le chemin d’accès spécifié, écrit des informations dans le fichier et lit à partir du fichier.  
  
 [!code-cpp[File Create1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create1/CPP/file create1.cpp#1)]
 [!code-csharp[File Create1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create1/CS/file create1.cs#1)]
 [!code-vb[File Create1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create1/VB/file create1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.  
  
ou 
 <paramref name="path" /> a spécifié un fichier qui est en lecture seule.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de la création du fichier.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">autorisation de lire et écrire dans le fichier décrit par le <paramref name="path" /> paramètre. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" /> . Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize);" />
      <MemberSignature Language="F#" Value="static member Create : string * int -&gt; System.IO.FileStream" Usage="System.IO.File.Create (path, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Nom du fichier.</param>
        <param name="bufferSize">Nombre d'octets mis en mémoire tampon pour les opérations de lecture et d'écriture dans le fichier.</param>
        <summary>Crée ou remplace le fichier spécifié.</summary>
        <returns>Élément <see cref="T:System.IO.FileStream" /> avec la taille de la mémoire tampon spécifiée qui fournit l'accès en lecture/écriture au fichier spécifié dans <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.FileStream> objet créé par cette méthode a une valeur par défaut <xref:System.IO.FileShare> valeur <xref:System.IO.FileShare.None>; aucun autre processus ou un autre code ne peut accéder au fichier créé jusqu'à ce que le handle de fichier d’origine est fermé.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Cette méthode est équivalente à la <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> surcharge de constructeur. Si le fichier spécifié n’existe pas, il est créé ; Si elle n’existe pas et il n’est pas en lecture seule, le contenu est remplacé.  
  
 Par défaut, accès complet en lecture/écriture aux nouveaux fichiers est accordé à tous les utilisateurs. Le fichier est ouvert avec accès en lecture/écriture et doit être fermé avant d’être ouvert par une autre application.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant crée un fichier avec la taille de mémoire tampon spécifiée.  
  
 [!code-cpp[File Create2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create2/CPP/file create2.cpp#1)]
 [!code-csharp[File Create2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create2/CS/file create2.cs#1)]
 [!code-vb[File Create2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create2/VB/file create2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.  
  
ou 
 <paramref name="path" /> a spécifié un fichier qui est en lecture seule.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de la création du fichier.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">autorisation de lire et écrire dans le fichier décrit par le <paramref name="path" /> paramètre. Action de sécurité : À la demande. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer, options As FileOptions) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="static member Create : string * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="System.IO.File.Create (path, bufferSize, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Nom du fichier.</param>
        <param name="bufferSize">Nombre d'octets mis en mémoire tampon pour les opérations de lecture et d'écriture dans le fichier.</param>
        <param name="options">Une des valeurs <see cref="T:System.IO.FileOptions" /> qui décrit comment créer ou remplacer le fichier.</param>
        <summary>Crée ou remplace le fichier spécifié en spécifiant une taille de mémoire tampon et une valeur de <see cref="T:System.IO.FileOptions" /> qui décrit comment créer ou remplacer le fichier.</summary>
        <returns>Nouveau fichier avec la taille de mémoire tampon spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Cette méthode est équivalente à la <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> surcharge de constructeur. Si le fichier spécifié n’existe pas, il est créé ; Si elle n’existe pas et il n’est pas en lecture seule, le contenu est remplacé.  
  
 Par défaut, accès complet en lecture/écriture aux nouveaux fichiers est accordé à tous les utilisateurs. Le fichier est ouvert avec accès en lecture/écriture et doit être fermé avant d’être ouvert par une autre application.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.  
  
ou 
 <paramref name="path" /> a spécifié un fichier qui est en lecture seule.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de la création du fichier.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">autorisation de lire et écrire dans le fichier décrit par le <paramref name="path" /> paramètre. Action de sécurité : À la demande. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="static member Create : string * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="System.IO.File.Create (path, bufferSize, options, fileSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Nom du fichier.</param>
        <param name="bufferSize">Nombre d'octets mis en mémoire tampon pour les opérations de lecture et d'écriture dans le fichier.</param>
        <param name="options">Une des valeurs <see cref="T:System.IO.FileOptions" /> qui décrit comment créer ou remplacer le fichier.</param>
        <param name="fileSecurity">Une des valeurs de <see cref="T:System.Security.AccessControl.FileSecurity" /> qui détermine le contrôle d'accès et la sécurité d'audit pour le fichier.</param>
        <summary>Crée ou remplace le fichier spécifié avec la taille de mémoire tampon, les options du fichier et la sécurité du fichier spécifiées.</summary>
        <returns>Nouveau fichier avec la taille de mémoire tampon, les options du fichier et la sécurité du fichier spécifiées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Cette méthode est équivalente à la <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> surcharge de constructeur. Si le fichier spécifié n’existe pas, il est créé ; Si elle n’existe pas et il n’est pas en lecture seule, le contenu est remplacé.  
  
 Par défaut, accès complet en lecture/écriture aux nouveaux fichiers est accordé à tous les utilisateurs. Le fichier est ouvert avec accès en lecture/écriture et doit être fermé avant d’être ouvert par une autre application.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.  
  
ou 
 <paramref name="path" /> a spécifié un fichier qui est en lecture seule.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de la création du fichier.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">autorisation de lire et écrire dans le fichier décrit par le <paramref name="path" /> paramètre. Action de sécurité : À la demande. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter CreateText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter CreateText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.CreateText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ CreateText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateText : string -&gt; System.IO.StreamWriter" Usage="System.IO.File.CreateText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier à ouvrir pour écriture.</param>
        <summary>Crée ou ouvre un fichier pour écrire du texte encodé en UTF-8. Si le fichier existe déjà, son contenu est remplacé.</summary>
        <returns>Élément <see cref="T:System.IO.StreamWriter" /> qui écrit dans le fichier spécifié en utilisant l'encodage UTF-8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est équivalente à la <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> surcharge de constructeur avec le `append` paramètre défini sur `false`. Si le fichier spécifié par `path` n’existe pas, il est créé. Si le fichier existe, son contenu est remplacé. Les threads supplémentaires sont autorisés à lire le fichier lorsqu’il est ouvert.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant crée un fichier pour écriture et la lecture de texte.  
  
 [!code-cpp[File CreateText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File CreateText/CPP/file createtext.cpp#1)]
 [!code-csharp[File CreateText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File CreateText/CS/file createtext.cs#1)]
 [!code-vb[File CreateText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File CreateText/VB/file createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides tels que définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public static void Decrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Decrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Decrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Decrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Decrypt(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Decrypt : string -&gt; unit" Usage="System.IO.File.Decrypt path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès qui décrit un fichier à déchiffrer.</param>
        <summary>Déchiffre un fichier qui a été chiffré par le compte actuel à l'aide de la méthode <see cref="M:System.IO.File.Encrypt(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.File.Decrypt%2A> méthode vous permet de déchiffrer un fichier qui a été chiffré à l’aide de la <xref:System.IO.File.Encrypt%2A> (méthode).  Le <xref:System.IO.File.Decrypt%2A> méthode peut déchiffrer que les fichiers qui ont été chiffrées à l’aide de compte d’utilisateur actuel.  
  
 Le <xref:System.IO.File.Decrypt%2A> méthode nécessite un accès exclusif au fichier qui est déchiffré et lève une exception si un autre processus utilise le fichier. Si le fichier n’est pas chiffré, <xref:System.IO.File.Decrypt%2A> retournera une valeur différente de zéro, ce qui indique la réussite.  
  
 Les deux le <xref:System.IO.File.Encrypt%2A> (méthode) et le <xref:System.IO.File.Decrypt%2A> méthode utilise le fournisseur de services de chiffrement (CSP) installé sur l’ordinateur et les clés de chiffrement de fichier du processus appelant la méthode.  
  
 Le système de fichiers doit être converti au format NTFS et le système d’exploitation actuel doivent être Windows NT ou version ultérieure.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.IO.File.Encrypt%2A> (méthode) et le <xref:System.IO.File.Decrypt%2A> (méthode) pour chiffrer et puis déchiffrer un fichier. Le fichier doit exister pour l’exemple fonctionne.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides tels que définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Un lecteur non valide a été spécifié.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier décrit par le paramètre <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier. Par exemple, le fichier chiffré est déjà ouvert.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Windows NT ou version ultérieure.</exception>
        <exception cref="T:System.NotSupportedException">Le système de fichiers n’est pas NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le paramètre <paramref name="path" /> a spécifié un fichier accessible en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
Le paramètre <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">autorisation de lire et écrire dans le fichier décrit par le <paramref name="path" /> paramètre. Action de sécurité : À la demande. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.File.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nom du fichier à supprimer. Les caractères génériques ne sont pas pris en charge.</param>
        <summary>Supprime le fichier spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spécifiez un nom de fichier avec les informations de chemin d’accès relatif ou absolu pour le `path` paramètre. Caractères génériques ne peuvent pas être inclus. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Si le fichier à supprimer n’existe pas, aucune exception n’est levée.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant copie des groupes de fichiers dans le dossier de sauvegarde C:\archives\2008 et puis les supprime du dossier source.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Le fichier spécifié est en cours d’utilisation.  
  
ou 
Un handle est ouvert sur le fichier, et le système d’exploitation est Windows XP ou une version antérieure. Ce handle ouvert peut être le résultat d’une énumération de répertoires et de fichiers. Pour plus d'informations, voir [Procédure : énumérer des répertoires et des fichiers](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.  
  
ou 
Le fichier est un fichier exécutable en cours d’utilisation.  
  
ou 
 <paramref name="path" /> est un répertoire.  
  
ou 
 <paramref name="path" /> a spécifié un fichier en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour supprimer le fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public static void Encrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Encrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Encrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Encrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Encrypt(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Encrypt : string -&gt; unit" Usage="System.IO.File.Encrypt path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès qui décrit un fichier à chiffrer.</param>
        <summary>Chiffre un fichier de sorte que seul le compte utilisé pour chiffrer le fichier peut le déchiffrer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.File.Encrypt%2A> méthode vous permet de chiffrer un fichier afin que seul le compte utilisé pour appeler cette méthode puisse le déchiffrer. Utilisez le <xref:System.IO.File.Decrypt%2A> méthode pour déchiffrer un fichier chiffré par le <xref:System.IO.File.Encrypt%2A> (méthode).  
  
 Le <xref:System.IO.File.Encrypt%2A> méthode nécessite un accès exclusif au fichier en cours de chiffrement et échoue si un autre processus utilise le fichier.  
  
 Les deux le <xref:System.IO.File.Encrypt%2A> (méthode) et le <xref:System.IO.File.Decrypt%2A> méthode utilise le fournisseur de services de chiffrement (CSP) installé sur l’ordinateur et les clés de chiffrement de fichier du processus appelant la méthode.  
  
 Cette méthode n’est pas disponible sur toutes les versions de Windows. Par exemple, il n’est pas disponible sur les éditions familiales.  
  
 Le système de fichiers doit être formaté en NTFS.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.IO.File.Encrypt%2A> (méthode) et le <xref:System.IO.File.Decrypt%2A> (méthode) pour chiffrer et puis déchiffrer un fichier. Le fichier doit exister pour l’exemple fonctionne.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides tels que définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Un lecteur non valide a été spécifié.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier décrit par le paramètre <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation actuel n’est pas Windows NT ou version ultérieure.</exception>
        <exception cref="T:System.NotSupportedException">Le système de fichiers n’est pas NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le paramètre <paramref name="path" /> a spécifié un fichier accessible en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
Le paramètre <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">autorisation de lire et écrire dans le fichier décrit par le <paramref name="path" /> paramètre. Action de sécurité : À la demande. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.IO.File.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier à vérifier.</param>
        <summary>Détermine si le fichier spécifié existe.</summary>
        <returns><see langword="true" /> si l'appelant a les autorisations requises et si <paramref name="path" /> contient le nom d'un fichier existant ; sinon, <see langword="false" />. Cette méthode retourne également <see langword="false" /> si <paramref name="path" /> est <see langword="null" />, un chemin d'accès non valide ou une chaîne de longueur nulle. Si l'appelant n'a pas les autorisations suffisantes pour lire le fichier spécifié, aucune exception n'est levée et la méthode retourne <see langword="false" />, indépendamment de l'existence de <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.File.Exists%2A> méthode ne doit pas être utilisée pour la validation du chemin d’accès, cette méthode vérifie simplement si le fichier spécifié dans `path` existe. En passant un chemin d’accès non valide à <xref:System.IO.File.Exists%2A> retourne `false`. Pour vérifier si le chemin d’accès contient des caractères non valides, vous pouvez appeler la <xref:System.IO.Path.GetInvalidPathChars%2A> méthode pour récupérer les caractères qui ne sont pas valides pour le système de fichiers. Vous pouvez également créer une expression régulière pour tester si le chemin d’accès est valide pour votre environnement. Pour obtenir des exemples de chemins d’accès acceptables, consultez <xref:System.IO.File>.  
  
 Pour vérifier l’existence d’un répertoire, consultez <xref:System.IO.Directory.Exists%2A?displayProperty=nameWithType>.  
  
 N’oubliez pas qu’un autre processus peut effectuer quelque chose avec le fichier entre le moment où vous appelez le <xref:System.IO.File.Exists%2A> (méthode) et effectuer une autre opération sur le fichier, telles que <xref:System.IO.File.Delete%2A>.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Si `path` décrit un répertoire, cette méthode retourne `false`. Les espaces à droite sont supprimés de la `path` paramètre avant de déterminer si le fichier existe.  
  
 Le <xref:System.IO.File.Exists%2A> retourne de la méthode `false` si une erreur se produit lors de la tentative déterminer si le fichier spécifié existe. Cela peut se produire dans les situations qui déclenchent des exceptions telles que la transmission d’un nom de fichier avec des caractères non valides ou trop de caractères, un disque défectueux ou manquant, ou si l’appelant n’a pas l’autorisation de lire le fichier.  
  
   
  
## Examples  
 L’exemple suivant détermine si un fichier existe.  
  
 [!code-csharp[File Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Exists/CS/program.cs#1)]
 [!code-vb[File Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Exists/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir du fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="M:System.IO.Directory.Exists(System.String)" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Security.AccessControl.FileSecurity" /> qui encapsule les entrées ACL pour un fichier spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.FileInfo.GetAccessControl%2A> méthodes pour récupérer l’accès à contrôlent les entrées de liste (ACL) pour un fichier spécifié.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string -&gt; System.Security.AccessControl.FileSecurity" Usage="System.IO.File.GetAccessControl path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès à un fichier contenant un objet <see cref="T:System.Security.AccessControl.FileSecurity" /> qui décrit les informations ACL du fichier.</param>
        <summary>Obtient un objet <see cref="T:System.Security.AccessControl.FileSecurity" /> qui encapsule les entrées ACL pour un fichier spécifié.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.FileSecurity" /> qui encapsule les règles de contrôle d'accès pour le fichier décrit par le paramètre <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.File.GetAccessControl%2A> méthode pour récupérer les entrées (ACL) pour un fichier.  
  
 Une liste ACL décrit les individus et/ou les groupes qui ont ou pas de droits à des actions spécifiques sur le fichier donné. Pour plus d'informations, consultez [Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Dans les environnements NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> et <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> sont accordées à l’utilisateur si l’utilisateur a <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> droits sur le dossier parent. Pour refuser <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> et <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, refuser <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> sur le répertoire parent.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.IO.File.GetAccessControl%2A> et <xref:System.IO.File.SetAccessControl%2A> méthodes pour ajouter et supprimer ensuite un accès contrôlent entrée de liste (ACL) à partir d’un fichier.  Vous devez entrer un compte d'utilisateur ou de groupe valide pour exécuter cet exemple.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Le fichier est introuvable.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le paramètre <paramref name="path" /> a spécifié un fichier accessible en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
Le paramètre <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour l’autorisation de lire la liste de contrôle d’accès. Action de sécurité : À la demande. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.FileSecurity" Usage="System.IO.File.GetAccessControl (path, includeSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès à un fichier contenant un objet <see cref="T:System.Security.AccessControl.FileSecurity" /> qui décrit les informations ACL du fichier.</param>
        <param name="includeSections">Une des valeurs <see cref="T:System.Security.AccessControl.AccessControlSections" /> qui spécifie le type d'informations ACL à recevoir.</param>
        <summary>Obtient un objet <see cref="T:System.Security.AccessControl.FileSecurity" /> qui encapsule le type spécifié des entrées ACL pour un fichier particulier.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.FileSecurity" /> qui encapsule les règles de contrôle d'accès pour le fichier décrit par le paramètre <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.File.GetAccessControl%2A> méthode pour récupérer les entrées (ACL) pour un fichier.  
  
 Une liste ACL décrit les individus et/ou les groupes qui ont ou pas de droits à des actions spécifiques sur le fichier donné. Pour plus d'informations, consultez [Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Dans les environnements NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> et <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> sont accordées à l’utilisateur si l’utilisateur a <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> droits sur le dossier parent. Pour refuser <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> et <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, refuser <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> sur le répertoire parent.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Le fichier est introuvable.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le paramètre <paramref name="path" /> a spécifié un fichier accessible en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
Le paramètre <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour l’autorisation de lire la liste de contrôle d’accès. Action de sécurité : À la demande. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.IO.FileAttributes GetAttributes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.IO.FileAttributes GetAttributes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAttributes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (path As String) As FileAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileAttributes GetAttributes(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAttributes : string -&gt; System.IO.FileAttributes" Usage="System.IO.File.GetAttributes path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileAttributes</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès au fichier.</param>
        <summary>Obtient l'élément <see cref="T:System.IO.FileAttributes" /> du fichier sur le chemin d'accès.</summary>
        <returns>Élément <see cref="T:System.IO.FileAttributes" /> du fichier sur le chemin d'accès.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre le `GetAttributes` et `SetAttributes` méthodes en appliquant la `Archive` et `Hidden` des attributs dans un fichier.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est vide, contient seulement des espaces blancs ou contient des caractères non valides.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" /> représente un fichier et n’est pas valide, comme sur un lecteur non mappé, ou le fichier est introuvable.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> représente un répertoire et n’est pas valide, comme sur un lecteur non mappé, ou le répertoire est introuvable.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire les fichiers. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTime : string -&gt; DateTime" Usage="System.IO.File.GetCreationTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier ou répertoire pour lequel obtenir les informations de date/heure de création.</param>
        <summary>Retourne la date/heure de création du fichier ou du répertoire spécifié.</summary>
        <returns>Structure <see cref="T:System.DateTime" /> à laquelle sont assignées la date et l'heure de création du fichier ou du répertoire spécifié. Cette valeur est exprimée en heure locale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode peut retourner une valeur inexacte, car elle utilise des fonctions natives dont les valeurs ne peuvent pas continuellement mis à jour par le système d’exploitation.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Si le fichier décrit dans le `path` paramètre n’existe pas, cette méthode retourne 12:00 minuit, le 1er janvier 1601 apr. J.C. (NOTRE ÈRE) Temps universel coordonné (UTC), ajusté à l’heure locale.  
  
 Les lecteurs NTFS peuvent mettre en cache d’informations sur un fichier, comme l’heure de création du fichier, pendant une courte période de temps. Par conséquent, il peut être nécessaire de définir explicitement l’heure de création d’un fichier si vous écrasez ou remplacez un fichier existant.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre `GetCreationTime`.  
  
 [!code-vb[System.IO.File.GetCreationTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides tels que définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir du fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTimeUtc : string -&gt; DateTime" Usage="System.IO.File.GetCreationTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier ou répertoire pour lequel obtenir les informations de date/heure de création.</param>
        <summary>Retourne la date et l'heure de création au format UTC (Temps universel coordonné) du fichier ou du répertoire spécifié.</summary>
        <returns>Structure <see cref="T:System.DateTime" /> à laquelle sont assignées la date et l'heure de création du fichier ou du répertoire spécifié. Cette valeur est exprimée en temps UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode peut retourner une valeur inexacte, car elle utilise des fonctions natives dont les valeurs ne peuvent pas continuellement mis à jour par le système d’exploitation.  
  
 Si le fichier décrit dans le `path` paramètre n’existe pas, cette méthode retourne 12:00 minuit, le 1er janvier 1601 apr. J.C. (NOTRE ÈRE) Temps d’universel coordonné (UTC).  
  
 Les lecteurs NTFS peuvent mettre en cache d’informations sur un fichier, comme l’heure de création du fichier, pendant une courte période de temps. Par conséquent, il peut être nécessaire de définir explicitement l’heure de création d’un fichier si vous écrasez ou remplacez un fichier existant.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.IO.File.GetCreationTimeUtc%2A> (méthode).  
  
 [!code-vb[System.IO.File.GetCreationTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides tels que définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir du fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTime : string -&gt; DateTime" Usage="System.IO.File.GetLastAccessTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier ou répertoire pour lequel obtenir les informations de date/heure d'accès.</param>
        <summary>Retourne la date/heure du dernier accès au fichier ou au répertoire spécifié.</summary>
        <returns>Structure <see cref="T:System.DateTime" /> définie avec la date et l'heure de dernier accès au fichier ou au répertoire spécifié. Cette valeur est exprimée en heure locale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode peut retourner une valeur inexacte, car elle utilise des fonctions natives dont les valeurs ne peuvent pas continuellement mis à jour par le système d’exploitation.  
  
 Si le fichier décrit dans le `path` paramètre n’existe pas, cette méthode retourne 12:00 minuit, le 1er janvier 1601 apr. J.C. (NOTRE ÈRE) Temps universel coordonné (UTC), ajusté à l’heure locale.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre `GetLastAccessTime`.  
  
 [!code-cpp[File GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastAccess/CPP/file getlastaccess.cpp#1)]
 [!code-csharp[File GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastAccess/CS/file getlastaccess.cs#1)]
 [!code-vb[File GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastAccess/VB/file getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides tels que définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir du fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTimeUtc : string -&gt; DateTime" Usage="System.IO.File.GetLastAccessTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier ou répertoire pour lequel obtenir les informations de date/heure d'accès.</param>
        <summary>Retourne la date/heure au format UTC (Temps universel coordonné) du dernier accès au fichier ou au répertoire spécifié.</summary>
        <returns>Structure <see cref="T:System.DateTime" /> définie avec la date et l'heure de dernier accès au fichier ou au répertoire spécifié. Cette valeur est exprimée en temps UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode peut retourner une valeur inexacte, car elle utilise des fonctions natives dont les valeurs ne peuvent pas continuellement mis à jour par le système d’exploitation.  
  
 Si le fichier décrit dans le `path` paramètre n’existe pas, cette méthode retourne 12:00 minuit, le 1er janvier 1601 apr. J.C. (NOTRE ÈRE) Temps d’universel coordonné (UTC).  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides tels que définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir du fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTime : string -&gt; DateTime" Usage="System.IO.File.GetLastWriteTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier ou répertoire pour lequel obtenir les informations de date/heure d'accès en écriture.</param>
        <summary>Retourne la date/heure du dernier accès en écriture au fichier ou au répertoire spécifié.</summary>
        <returns>Structure <see cref="T:System.DateTime" /> ayant pour valeur la date et l'heure de la dernière écriture dans le fichier ou le répertoire spécifié. Cette valeur est exprimée en heure locale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode peut retourner une valeur inexacte, car elle utilise des fonctions natives dont les valeurs ne peuvent pas continuellement mis à jour par le système d’exploitation. Chaque système d’exploitation gère l’heure de dernière écriture selon ses propres règles. Pour améliorer les performances, un système d’exploitation ne peut-être pas configuré la dernière valeur de temps d’écriture à l’heure exacte de la dernière opération d’écriture, mais peut lui affecter une approximation à la place.  
  
 Si le fichier décrit dans le `path` paramètre n’existe pas, cette méthode retourne 12:00 minuit, le 1er janvier 1601 apr. J.C. (NOTRE ÈRE) Temps universel coordonné (UTC), ajusté à l’heure locale.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre `GetLastWriteTime`.  
  
 [!code-cpp[File GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastWrite/CPP/file getlastwrite.cpp#1)]
 [!code-csharp[File GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastWrite/CS/file getlastwrite.cs#1)]
 [!code-vb[File GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastWrite/VB/file getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides tels que définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir du fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTimeUtc : string -&gt; DateTime" Usage="System.IO.File.GetLastWriteTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier ou répertoire pour lequel obtenir les informations de date/heure d'accès en écriture.</param>
        <summary>Retourne la date/heure au format UTC (Temps universel coordonné) de la dernière écriture dans le fichier ou le répertoire spécifié.</summary>
        <returns>Structure <see cref="T:System.DateTime" /> ayant pour valeur la date et l'heure de la dernière écriture dans le fichier ou le répertoire spécifié. Cette valeur est exprimée en temps UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette méthode peut retourner une valeur inexacte, car elle utilise des fonctions natives dont les valeurs ne peuvent pas continuellement mis à jour par le système d’exploitation. Chaque système d’exploitation gère l’heure de dernière écriture selon ses propres règles. Pour améliorer les performances, un système d’exploitation ne peut-être pas configuré la dernière valeur de temps d’écriture à l’heure exacte de la dernière opération d’écriture, mais peut lui affecter une approximation à la place.  
  
 Si le fichier décrit dans le `path` paramètre n’existe pas, cette méthode retourne 12:00 minuit, le 1er janvier 1601 apr. J.C. (NOTRE ÈRE) Temps d’universel coordonné (UTC).  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides tels que définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir du fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="static member Move : string * string -&gt; unit" Usage="System.IO.File.Move (sourceFileName, destFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nom du fichier à déplacer. Peut inclure un chemin d’accès absolu ou relatif.</param>
        <param name="destFileName">Nouveaux nom et chemin d’accès au fichier.</param>
        <summary>Déplace un fichier spécifié à un nouvel emplacement, en permettant de spécifier un nouveau nom.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fonctionne sur plusieurs volumes de disque, et il ne lève pas une exception si la source et la destination sont identiques. Notez que si vous essayez de remplacer un fichier en déplaçant un fichier du même nom dans ce répertoire, vous obtenez un <xref:System.IO.IOException>. Vous ne pouvez pas utiliser la méthode Move pour remplacer un fichier existant.  
  
 Le `sourceFileName` et `destFileName` arguments peuvent inclure des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Si vous essayez de déplacer un fichier sur les volumes de disque et si le fichier est en cours d’utilisation, le fichier est copié vers la destination, mais il n’est pas supprimé de la source.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant déplace un fichier.  
  
 [!code-cpp[File Move#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Move/CPP/file move.cpp#1)]
 [!code-csharp[File Move#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Move/CS/file move.cs#1)]
 [!code-vb[File Move#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Move/VB/file move.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le fichier de destination existe déjà.  
  
ou 
 <paramref name="sourceFileName" /> est introuvable.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceFileName" /> ou <paramref name="destFileName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceFileName" /> ou <paramref name="destFileName" /> est une chaîne de longueur nulle, contient seulement un espace ou contient des caractères non valides définis dans <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié dans <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="sourceFileName" /> ou <paramref name="destFileName" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir de <paramref name="sourceFileName" /> et l’écriture dans <paramref name="destFileName" />. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceFileName, string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceFileName, string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Move(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceFileName As String, destFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceFileName, System::String ^ destFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member Move : string * string * bool -&gt; unit" Usage="System.IO.File.Move (sourceFileName, destFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="destFileName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="overwrite" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">To be added.</param>
        <param name="destFileName">To be added.</param>
        <param name="overwrite">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre <see cref="T:System.IO.FileStream" /> sur le chemin d'accès spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="System.IO.File.Open (path, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Fichier à ouvrir.</param>
        <param name="mode">Valeur <see cref="T:System.IO.FileMode" /> qui spécifie si un fichier est créé s'il n'existe pas et détermine si le contenu des fichiers existants est conservé ou remplacé.</param>
        <summary>Ouvre un <see cref="T:System.IO.FileStream" /> sur le chemin spécifié avec un accès en lecture/écriture sans partage.</summary>
        <returns>Élément <see cref="T:System.IO.FileStream" /> ouvert dans le mode et le chemin d'accès spécifiés, avec un accès en lecture/écriture et non partagé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée un fichier temporaire et écrit du texte. L’exemple ouvre ensuite le fichier, à l’aide de T:System.IO.FileMode.Open ; Autrement dit, si le fichier existait pas, il ne serait pas créé.  
  
 [!code-cpp[File Open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open1/CPP/file open1.cpp#1)]
 [!code-csharp[File Open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open1/CS/file open1.cs#1)]
 [!code-vb[File Open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open1/VB/file open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un fichier en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.  
  
ou 
 <paramref name="mode" /> est <see cref="F:System.IO.FileMode.Create" /> et le fichier spécifié est un fichier masqué.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> a spécifié une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié dans <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire dans le fichier spécifié. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="System.IO.File.Open (path, mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Fichier à ouvrir.</param>
        <param name="mode">Valeur <see cref="T:System.IO.FileMode" /> qui spécifie si un fichier est créé s'il n'existe pas et détermine si le contenu des fichiers existants est conservé ou remplacé.</param>
        <param name="access">Valeur de <see cref="T:System.IO.FileAccess" /> spécifiant les opérations qui peuvent être effectuées sur le fichier.</param>
        <summary>Ouvre un <see cref="T:System.IO.FileStream" /> sur le chemin spécifié, avec le mode et l’accès spécifiés sans partage.</summary>
        <returns>Élément <see cref="T:System.IO.FileStream" /> non partagé qui fournit l'accès au fichier spécifié avec le mode et l'accès spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
   
  
## Examples  
 L’exemple suivant ouvre un fichier avec accès en lecture seule.  
  
 [!code-cpp[file open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open2/CPP/file open2.cpp#1)]
 [!code-csharp[file open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open2/CS/file open2.cs#1)]
 [!code-vb[file open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open2/VB/file open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
ou 
 <paramref name="access" /> a spécifié <see langword="Read" /> et <paramref name="mode" /> a spécifié <see langword="Create" />, <see langword="CreateNew" />, <see langword="Truncate" /> ou <see langword="Append" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un fichier qui est en lecture seule et <paramref name="access" /> n’est pas <see langword="Read" />.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.  
  
ou 
 <paramref name="mode" /> est <see cref="F:System.IO.FileMode.Create" /> et le fichier spécifié est un fichier masqué.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> ou <paramref name="access" /> a spécifié une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié dans <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire dans le fichier spécifié. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess, share As FileShare) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="System.IO.File.Open (path, mode, access, share)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Fichier à ouvrir.</param>
        <param name="mode">Valeur <see cref="T:System.IO.FileMode" /> qui spécifie si un fichier est créé s'il n'existe pas et détermine si le contenu des fichiers existants est conservé ou remplacé.</param>
        <param name="access">Valeur de <see cref="T:System.IO.FileAccess" /> spécifiant les opérations qui peuvent être effectuées sur le fichier.</param>
        <param name="share">Valeur de <see cref="T:System.IO.FileShare" /> spécifiant le type d'accès que les autres threads ont sur le fichier.</param>
        <summary>Ouvre un élément <see cref="T:System.IO.FileStream" /> sur le chemin d’accès spécifié, dans le mode spécifié avec accès en lecture, en écriture ou en lecture/écriture, et l’option de partage spécifiée.</summary>
        <returns>Ouvre un élément <see cref="T:System.IO.FileStream" /> sur le chemin d'accès spécifié, dans le mode spécifié avec accès en lecture, en écriture ou en lecture/écriture, et l'option de partage spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant ouvre un fichier avec accès en lecture seule et au partage de fichiers interdites.  
  
 [!code-cpp[file open3#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open3/CPP/file open3.cpp#1)]
 [!code-csharp[file open3#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open3/CS/file open3.cs#1)]
 [!code-vb[file open3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open3/VB/file open3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
ou 
 <paramref name="access" /> a spécifié <see langword="Read" /> et <paramref name="mode" /> a spécifié <see langword="Create" />, <see langword="CreateNew" />, <see langword="Truncate" /> ou <see langword="Append" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un fichier qui est en lecture seule et <paramref name="access" /> n’est pas <see langword="Read" />.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.  
  
ou 
 <paramref name="mode" /> est <see cref="F:System.IO.FileMode.Create" /> et le fichier spécifié est un fichier masqué.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> a spécifié une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié dans <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire dans le fichier spécifié. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenRead (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenRead(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenRead(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRead (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenRead(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member OpenRead : string -&gt; System.IO.FileStream" Usage="System.IO.File.OpenRead path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier à ouvrir pour lecture.</param>
        <summary>Ouvre un fichier existant pour y accéder en lecture.</summary>
        <returns>Élément <see cref="T:System.IO.FileStream" /> en lecture seule sur le chemin d'accès spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est équivalente à la <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> surcharge de constructeur avec un <xref:System.IO.FileMode> valeur <xref:System.IO.FileMode.Open>, un <xref:System.IO.FileAccess> valeur de <xref:System.IO.FileAccess.Read> et un <xref:System.IO.FileShare> valeur de <xref:System.IO.FileShare.Read>.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant ouvre un fichier en lecture.  
  
 [!code-cpp[file openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenRead/CPP/file openread.cpp#1)]
 [!code-csharp[file openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenRead/CS/file openread.cs#1)]
 [!code-vb[file openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenRead/VB/file openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié dans <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir du fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamReader OpenText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenText (path As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member OpenText : string -&gt; System.IO.StreamReader" Usage="System.IO.File.OpenText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier à ouvrir pour lecture.</param>
        <summary>Ouvre un fichier texte encodé en UTF-8 existant pour lecture.</summary>
        <returns>Élément <see cref="T:System.IO.StreamReader" /> sur le chemin d'accès spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est équivalente à la <xref:System.IO.StreamReader.%23ctor%28System.String%29> surcharge de constructeur.  
  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant ouvre un fichier texte pour la lecture.  
  
 [!code-cpp[file opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[file opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenText/CS/file opentext.cs#1)]
 [!code-vb[file opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides tels que définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié dans <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la lecture à partir du fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenWrite (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenWrite(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenWrite(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenWrite (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenWrite(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member OpenWrite : string -&gt; System.IO.FileStream" Usage="System.IO.File.OpenWrite path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier à ouvrir pour écriture.</param>
        <summary>Ouvre un fichier existant ou crée un nouveau fichier pour écriture.</summary>
        <returns>Objet <see cref="T:System.IO.FileStream" /> non partagé sur le chemin d'accès spécifié avec un accès <see cref="F:System.IO.FileAccess.Write" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est équivalente à la <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> surcharge de constructeur avec le mode de fichier défini sur <xref:System.IO.FileMode.OpenOrCreate>, l’accès à la valeur <xref:System.IO.FileAccess.Write>et le mode de partage défini sur <xref:System.IO.FileShare.None>.  
  
 Le <xref:System.IO.File.OpenWrite%2A> méthode ouvre un fichier si une existe déjà pour le chemin d’accès de fichier ou crée un nouveau fichier s’il n’existe pas. Pour un fichier existant, il n’ajoute pas le nouveau texte au texte existant. Au lieu de cela, il remplace les caractères existants par les nouveaux caractères. Si vous remplacez une chaîne plus longue (tel que « Il s’agit d’un test de la méthode OpenWrite ») avec une chaîne plus courte (par exemple, « exécuter deuxième »), le fichier contiendra une combinaison de chaînes (« deuxième passage de la méthode OpenWrite »).  
  
 Le `path` paramètre peut spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, utilisez le <xref:System.IO.Directory.GetCurrentDirectory%2A> (méthode).  
  
 Retourné <xref:System.IO.FileStream> ne prend pas en charge la lecture. Pour ouvrir un fichier pour lecture et en écriture, utilisez <xref:System.IO.File.Open%2A>.

 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant ouvre un fichier pour lire et écrire.  
  
 [!code-cpp[file openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[file openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[file openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.  
  
ou 
 <paramref name="path" /> a spécifié un fichier ou un répertoire en lecture seule.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadAllBytes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (path As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadAllBytes : string -&gt; byte[]" Usage="System.IO.File.ReadAllBytes path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier à ouvrir pour lecture.</param>
        <summary>Ouvre un fichier binaire, lit le contenu du fichier dans un tableau d'octets, puis ferme le fichier.</summary>
        <returns>Tableau d'octets contenant le contenu du fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné un chemin d’accès de fichier, cette méthode ouvre le fichier, lit le contenu du fichier dans un tableau d’octets, puis ferme le fichier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié dans <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;byte[]&gt; ReadAllBytesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;unsigned int8[]&gt; ReadAllBytesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllBytesAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;byte[]&gt;" Usage="System.IO.File.ReadAllBytesAsync (path, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Byte[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un fichier texte, lit toutes les lignes du fichier dans un tableau de chaînes, puis ferme le fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllLines (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadAllLines : string -&gt; string[]" Usage="System.IO.File.ReadAllLines path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier à ouvrir pour lecture.</param>
        <summary>Ouvre un fichier texte, lit toutes les lignes du fichier, puis ferme le fichier.</summary>
        <returns>Tableau de chaînes contenant toutes les lignes du fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ouvre un fichier, lit chaque ligne du fichier, puis ajoute chaque ligne en tant qu’élément d’un tableau de chaînes. Puis, il ferme le fichier. Une ligne est définie comme une séquence de caractères suivi d’un retour chariot ('\r'), un saut de ligne ('\n') ou un retour chariot suivi immédiatement d’une ligne du flux. La chaîne obtenue ne contient pas le retour chariot et/ou un saut de ligne final.  
  
 Cette méthode essaie de détecter automatiquement le codage d’un fichier en fonction de la présence de marques d’ordre d’octet. Les formats d’encodage UTF-8 et UTF-32 (big-endian et little-endian) peut être détectés.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.File.ReadAllLines%2A> méthode pour afficher le contenu d’un fichier. Dans cet exemple, un fichier est créé, si elle n’existe pas déjà, et texte est ajouté à ce dernier.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un fichier en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié dans <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllLines : string * System.Text.Encoding -&gt; string[]" Usage="System.IO.File.ReadAllLines (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Fichier à ouvrir pour lecture.</param>
        <param name="encoding">Encodage appliqué au contenu du fichier.</param>
        <summary>Ouvre un fichier, lit toutes les lignes du fichier avec l'encodage spécifié, puis ferme le fichier.</summary>
        <returns>Tableau de chaînes contenant toutes les lignes du fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ouvre un fichier, lit chaque ligne du fichier, puis ajoute chaque ligne en tant qu’élément d’un tableau de chaînes. Puis, il ferme le fichier. Une ligne est définie comme une séquence de caractères suivi d’un retour chariot ('\r'), un saut de ligne ('\n') ou un retour chariot suivi immédiatement d’une ligne du flux. La chaîne obtenue ne contient pas le retour chariot et/ou un saut de ligne final.  
  
 Cette méthode essaie de détecter automatiquement le codage d’un fichier en fonction de la présence de marques d’ordre d’octet. Les formats d’encodage UTF-8 et UTF-32 (big-endian et little-endian) peut être détectés.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.File.ReadAllLines%2A> méthode pour afficher le contenu d’un fichier. Dans cet exemple, un fichier est créé, si elle n’existe pas déjà, et texte est ajouté à ce dernier.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un fichier en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié dans <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllLinesAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string[]&gt;" Usage="System.IO.File.ReadAllLinesAsync (path, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllLinesAsync : string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string[]&gt;" Usage="System.IO.File.ReadAllLinesAsync (path, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un fichier texte, lit tout le texte du fichier dans une chaîne, puis ferme le fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string -&gt; string" Usage="System.IO.File.ReadAllText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier à ouvrir pour lecture.</param>
        <summary>Ouvre un fichier texte, lit tout le texte du fichier, puis ferme le fichier.</summary>
        <returns>Chaîne contenant la totalité du texte du fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ouvre un fichier, lit tout le texte dans le fichier et le retourne sous forme de chaîne. Puis, il ferme le fichier.
  
 Cette méthode essaie de détecter automatiquement le codage d’un fichier en fonction de la présence de marques d’ordre d’octet. Les formats d’encodage UTF-8 et UTF-32 (big-endian et little-endian) peut être détectés.  
  
 Utilisez le <xref:System.IO.File.ReadAllText%28System.String%2CSystem.Text.Encoding%29> surcharge de méthode lors de la lecture des fichiers qui peuvent contenir du texte importé, car les caractères non reconnus ne peut pas être lu correctement.  
  
 Le handle de fichier est toujours fermé par cette méthode, même si les exceptions sont levées.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.File.ReadAllText%2A> méthode pour afficher le contenu d’un fichier. Dans cet exemple, un fichier est créé, si elle n’existe pas déjà, et texte est ajouté à ce dernier.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un fichier en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié dans <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string * System.Text.Encoding -&gt; string" Usage="System.IO.File.ReadAllText (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Fichier à ouvrir pour lecture.</param>
        <param name="encoding">Encodage appliqué au contenu du fichier.</param>
        <summary>Ouvre un fichier, lit la totalité du texte du fichier avec l’encodage spécifié, puis ferme le fichier.</summary>
        <returns>Chaîne contenant la totalité du texte du fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ouvre un fichier, lit tout le texte dans le fichier et le retourne sous forme de chaîne. Puis, il ferme le fichier.
  
 Cette méthode essaie de détecter automatiquement le codage d’un fichier en fonction de la présence de marques d’ordre d’octet. Les formats d’encodage UTF-8 et UTF-32 (big-endian et little-endian) peut être détectés.  
  
 Le handle de fichier est toujours fermé par cette méthode, même si les exceptions sont levées.  
  
 Pour utiliser les paramètres d’encodage tels que configurés pour votre système d’exploitation, spécifiez la <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> propriété pour le `encoding` paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.File.ReadAllText%2A> méthode pour afficher le contenu d’un fichier. Dans cet exemple, un fichier est créé, si elle n’existe pas déjà, et texte est ajouté à ce dernier.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un fichier en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié dans <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Comment : lire et écrire dans un fichier de données créé récemment</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllTextAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="System.IO.File.ReadAllTextAsync (path, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllTextAsync : string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="System.IO.File.ReadAllTextAsync (path, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit les lignes d'un fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLines (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadLines : string -&gt; seq&lt;string&gt;" Usage="System.IO.File.ReadLines path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier à lire.</param>
        <summary>Lit les lignes d'un fichier.</summary>
        <returns>Toutes les lignes du fichier ou les lignes qui sont le résultat d'une requête.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.File.ReadLines%2A> et <xref:System.IO.File.ReadAllLines%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.File.ReadLines%2A>, vous pouvez commencer à énumérer la collection de chaînes avant que l’ensemble de la collection est retournée ; lorsque vous utilisez <xref:System.IO.File.ReadAllLines%2A>, vous devez attendre la totalité du tableau de chaînes être retourné avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec des fichiers très volumineux, <xref:System.IO.File.ReadLines%2A> peut s’avérer plus efficace.  
  
 Vous pouvez utiliser la <xref:System.IO.File.ReadLines%2A> méthode pour effectuer les opérations suivantes :  
  
-   Effectuer [LINQ to Objects](https://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) requêtes sur un fichier pour obtenir un ensemble filtré de ses lignes.  
  
-   Écrire la collection retournée de lignes dans un fichier avec le <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> (méthode), ou les ajouter à un fichier existant avec le <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> (méthode).  
  
-   Créez une instance remplie immédiatement d’une collection qui prend une <xref:System.Collections.Generic.IEnumerable%601> collection de chaînes à son constructeur, comme un <xref:System.Collections.Generic.IList%601> ou un <xref:System.Collections.Generic.Queue%601>.  
  
 Cette méthode utilise <xref:System.Text.Encoding.UTF8%2A> pour la valeur d’encodage.  
  
   
  
## Examples  
 L’exemple suivant lit les lignes d’un fichier à rechercher des lignes qui contiennent les chaînes spécifiées.  
  
 [!code-csharp[System.IO.File.ReadLines#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.readlines/cs/program.cs#1)]
 [!code-vb[System.IO.File.ReadLines#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.readlines/vb/program.vb#1)]  
  
 L’exemple suivant utilise la <xref:System.IO.File.ReadLines%2A> méthode dans une requête LINQ qui énumère tous les répertoires pour les fichiers qui ont une extension .txt, lit chaque ligne du fichier et affiche la ligne si elle contient la chaîne « Microsoft ».  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié par <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> spécifie un fichier qui est en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> est un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadLines : string * System.Text.Encoding -&gt; seq&lt;string&gt;" Usage="System.IO.File.ReadLines (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Fichier à lire.</param>
        <param name="encoding">Encodage appliqué au contenu du fichier.</param>
        <summary>Lit les lignes d'un fichier qui a un encodage spécifié.</summary>
        <returns>Toutes les lignes du fichier ou les lignes qui sont le résultat d'une requête.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour spécifier un encodage à utiliser de lire le fichier.  
  
 Le <xref:System.IO.File.ReadLines%2A> et <xref:System.IO.File.ReadAllLines%2A> méthodes diffèrent comme suit : Lorsque vous utilisez <xref:System.IO.File.ReadLines%2A>, vous pouvez démarrer d’énumérer la collection de chaînes avant que l’ensemble de la collection est retournée. Lorsque vous utilisez <xref:System.IO.File.ReadAllLines%2A>, vous devez attendre la totalité du tableau de chaînes être retourné avant que vous pouvez accéder au tableau. Par conséquent, lorsque vous travaillez avec des fichiers très volumineux, <xref:System.IO.File.ReadLines%2A> peut s’avérer plus efficace.  
  
 Vous pouvez utiliser la <xref:System.IO.File.ReadLines%2A> méthode pour effectuer les opérations suivantes :  
  
-   Effectuer [LINQ to Objects](https://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) requêtes sur un fichier pour obtenir un ensemble filtré de ses lignes.  
  
-   Écrire la collection retournée de lignes dans un fichier avec le <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> (méthode), ou les ajouter à un fichier existant avec le <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> (méthode).  
  
-   Créez une instance remplie immédiatement d’une collection qui prend une <xref:System.Collections.Generic.IEnumerable%601> collection de chaînes à son constructeur, comme un <xref:System.Collections.Generic.IList%601> ou un <xref:System.Collections.Generic.Queue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié par <paramref name="path" /> est introuvable.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> spécifie un fichier qui est en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> est un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Remplace le contenu d'un fichier spécifié par le contenu d'un autre fichier, en supprimant le fichier d'origine et en créant une sauvegarde du fichier remplacé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.File.Replace%2A> méthodes remplacent le contenu d’un fichier spécifié avec le contenu d’un autre fichier.  Ils créent également une sauvegarde du fichier qui a été remplacé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; unit" Usage="System.IO.File.Replace (sourceFileName, destinationFileName, destinationBackupFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nom d'un fichier qui remplace le fichier spécifié par <paramref name="destinationFileName" />.</param>
        <param name="destinationFileName">Nom du fichier à remplacer.</param>
        <param name="destinationBackupFileName">Nom du fichier de sauvegarde.</param>
        <summary>Remplace le contenu d'un fichier spécifié par le contenu d'un autre fichier, en supprimant le fichier d'origine et en créant une sauvegarde du fichier remplacé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.File.Replace%2A> méthode remplace le contenu d’un fichier spécifié par le contenu d’un autre fichier.  Il crée également une sauvegarde du fichier qui a été remplacé.  
  
 Si le `sourceFileName` et `destinationFileName` sont sur des volumes différents, cette méthode lève une exception. Si le `destinationBackupFileName` est à un autre volume à partir du fichier source, le fichier de sauvegarde doit être supprimé.  
  
 Passer `null` à la `destinationBackupFileName` paramètre si vous ne souhaitez pas créer une sauvegarde du fichier remplacé.  

 Si le `destinationBackupFileName` existe déjà elle sera remplacée par le contenu de la `destinationFileName` fichier.
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.IO.File.Replace%2A> méthode pour remplacer un fichier par un autre fichier et créer une sauvegarde du fichier remplacé.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin décrit par le paramètre <paramref name="destinationFileName" /> n’avait pas une forme conforme.  
  
ou 
Le chemin décrit par le paramètre <paramref name="destinationBackupFileName" /> n’avait pas une forme conforme.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="destinationFileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Un lecteur non valide a été spécifié.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier décrit par l’objet <see cref="T:System.IO.FileInfo" /> actuel est introuvable.  
  
ou 
Le fichier décrit par le paramètre <paramref name="destinationBackupFileName" /> est introuvable.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.  
  
ou 
Les paramètres <paramref name="sourceFileName" /> et <paramref name="destinationFileName" /> spécifient le même fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation est Windows 98 Deuxième Édition ou une version antérieure et le système de fichiers n’est pas NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le paramètre <paramref name="sourceFileName" /> ou <paramref name="destinationFileName" /> spécifie un fichier en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
Les paramètres sources ou de destination spécifient un répertoire au lieu d’un fichier.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour l’autorisation en écriture au fichier décrit par le <paramref name="destinationBackupFileName" /> paramètre le cas échéant. Action de sécurité : À la demande. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String, ignoreMetadataErrors As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * bool -&gt; unit" Usage="System.IO.File.Replace (sourceFileName, destinationFileName, destinationBackupFileName, ignoreMetadataErrors)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nom d'un fichier qui remplace le fichier spécifié par <paramref name="destinationFileName" />.</param>
        <param name="destinationFileName">Nom du fichier à remplacer.</param>
        <param name="destinationBackupFileName">Nom du fichier de sauvegarde.</param>
        <param name="ignoreMetadataErrors"><see langword="true" /> pour ignorer les erreurs de fusion (comme les attributs et les listes de contrôle d'accès) du fichier remplacé vers le fichier de remplacement ; sinon, <see langword="false" />.</param>
        <summary>Remplace le contenu d'un fichier spécifié par le contenu d'un autre fichier, en supprimant le fichier d'origine, en créant une sauvegarde du fichier remplacé et en ignorant éventuellement les erreurs de fusion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.File.Replace%2A> méthode remplace le contenu d’un fichier spécifié par le contenu d’un autre fichier.  Il crée également une sauvegarde du fichier qui a été remplacé.  
  
 Si le `sourceFileName` et `destinationFileName` sont sur des volumes différents, cette méthode lève une exception. Si le `destinationBackupFileName` est à un autre volume à partir du fichier source, le fichier de sauvegarde doit être supprimé.  
  
 Passer `null` à la `destinationBackupFileName` paramètre si vous ne souhaitez pas créer une sauvegarde du fichier remplacé.  

 Si le `destinationBackupFileName` existe déjà elle sera remplacée par le contenu de la `destinationFileName` fichier.
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.IO.File.Replace%2A> méthode pour remplacer un fichier par un autre fichier et créer une sauvegarde du fichier remplacé.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin décrit par le paramètre <paramref name="destinationFileName" /> n’avait pas une forme conforme.  
  
ou 
Le chemin décrit par le paramètre <paramref name="destinationBackupFileName" /> n’avait pas une forme conforme.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="destinationFileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Un lecteur non valide a été spécifié.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier décrit par l’objet <see cref="T:System.IO.FileInfo" /> actuel est introuvable.  
  
ou 
Le fichier décrit par le paramètre <paramref name="destinationBackupFileName" /> est introuvable.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.  
  
ou 
Les paramètres <paramref name="sourceFileName" /> et <paramref name="destinationFileName" /> spécifient le même fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation est Windows 98 Deuxième Édition ou une version antérieure et le système de fichiers n’est pas NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le paramètre <paramref name="sourceFileName" /> ou <paramref name="destinationFileName" /> spécifie un fichier en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
Les paramètres sources ou de destination spécifient un répertoire au lieu d’un fichier.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour l’autorisation en écriture au fichier décrit par le <paramref name="destinationBackupFileName" /> paramètre le cas échéant. Action de sécurité : À la demande. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAccessControl(System.String,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="static member SetAccessControl : string * System.Security.AccessControl.FileSecurity -&gt; unit" Usage="System.IO.File.SetAccessControl (path, fileSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Fichier dans lequel les entrées ACL doivent être ajoutées ou supprimées.</param>
        <param name="fileSecurity">Objet <see cref="T:System.Security.AccessControl.FileSecurity" /> qui décrit une entrée ACL à appliquer au fichier décrit par le paramètre <paramref name="path" />.</param>
        <summary>Applique les entrées de liste de contrôle d'accès (ACL) décrites par un objet <see cref="T:System.Security.AccessControl.FileSecurity" /> au répertoire spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.File.SetAccessControl%2A> méthode applique les entrées de contrôle d’accès (ACL) de liste à un fichier qui représente la liste ACL non héritée.  
  
> [!CAUTION]
>  La liste ACL spécifiée pour le `fileSecurity` paramètre remplace la liste ACL existante pour le fichier. Pour ajouter des autorisations pour un nouvel utilisateur, utilisez la <xref:System.IO.File.GetAccessControl%2A> méthode pour obtenir la liste ACL existante, modifiez-la et ensuite utiliser <xref:System.IO.File.SetAccessControl%2A> pour l’appliquer au fichier.  
  
 Une liste ACL décrit les individus et/ou les groupes qui ont ou pas de droits à des actions spécifiques sur le fichier donné. Pour plus d'informations, consultez [Comment : ajouter ou supprimer des entrées dans la liste de contrôle d'accès](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Le <xref:System.IO.File.SetAccessControl%2A> méthode persiste uniquement <xref:System.Security.AccessControl.FileSecurity> les objets qui ont été modifiées après la création d’objets.  Si un <xref:System.Security.AccessControl.FileSecurity> objet n’a pas été modifié, il ne sera pas conservé dans un fichier.  Par conséquent, il n’est pas possible de récupérer un <xref:System.Security.AccessControl.FileSecurity> de l’objet à partir d’un fichier et de réappliquer le même objet à un autre fichier.  
  
 Pour copier les informations ACL à partir d’un fichier vers un autre :  
  
1.  Utilisez le <xref:System.IO.File.GetAccessControl%2A> méthode pour récupérer le <xref:System.Security.AccessControl.FileSecurity> objet à partir du fichier source.  
  
2.  Créer un nouveau <xref:System.Security.AccessControl.FileSecurity> objet pour le fichier de destination.  
  
3.  Utilisez le <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> méthode de la source <xref:System.Security.AccessControl.FileSecurity> objet pour récupérer les informations ACL.  
  
4.  Utilisez le <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> méthode pour copier les informations récupérées à l’étape 3 vers la destination <xref:System.Security.AccessControl.FileSecurity> objet.  
  
5.  Définir la destination <xref:System.Security.AccessControl.FileSecurity> objet pour le fichier de destination à l’aide de la <xref:System.IO.File.SetAccessControl%2A> (méthode).  
  
 Dans les environnements NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> et <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> sont accordées à l’utilisateur si l’utilisateur a <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> droits sur le dossier parent. Pour refuser <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> et <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, refuser <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> sur le répertoire parent.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.IO.File.GetAccessControl%2A> et <xref:System.IO.File.SetAccessControl%2A> méthodes pour ajouter et supprimer ensuite un accès contrôlent entrée de liste (ACL) à partir d’un fichier.  Vous devez entrer un compte d'utilisateur ou de groupe valide pour exécuter cet exemple.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">Le paramètre <paramref name="path" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Le fichier est introuvable.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le paramètre <paramref name="path" /> a spécifié un fichier accessible en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
Le paramètre <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="fileSecurity" /> a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’autorisation d’accès au fichier. Action de sécurité : À la demande. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.Change" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetAttributes">
      <MemberSignature Language="C#" Value="public static void SetAttributes (string path, System.IO.FileAttributes fileAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAttributes(string path, valuetype System.IO.FileAttributes fileAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAttributes(System.String,System.IO.FileAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttributes(System::String ^ path, System::IO::FileAttributes fileAttributes);" />
      <MemberSignature Language="F#" Value="static member SetAttributes : string * System.IO.FileAttributes -&gt; unit" Usage="System.IO.File.SetAttributes (path, fileAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileAttributes" Type="System.IO.FileAttributes" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès au fichier.</param>
        <param name="fileAttributes">Combinaison d'opérations de bits des valeurs d'énumération.</param>
        <summary>Définit l'élément <see cref="T:System.IO.FileAttributes" /> spécifié du fichier sur le chemin d'accès spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Certains attributs de fichiers, tels que <xref:System.IO.FileAttributes.Hidden> et <xref:System.IO.FileAttributes.ReadOnly>, peuvent être combinées. Autres attributs, tels que <xref:System.IO.FileAttributes.Normal>, doit être utilisé seul.  
  
 Il n’est pas possible de modifier l’état de compression d’un <xref:System.IO.File> à l’aide de l’objet le <xref:System.IO.File.SetAttributes%2A> (méthode).  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant montre le `GetAttributes` et `SetAttributes` méthodes en appliquant la `Archive` et `Hidden` des attributs dans un fichier.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est vide, contient seulement des espaces blancs, contient des caractères non valides, ou l’attribut du fichier n’est pas valide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un fichier qui est en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberSignature Language="F#" Value="static member SetCreationTime : string * DateTime -&gt; unit" Usage="System.IO.File.SetCreationTime (path, creationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Fichier pour lequel définir les informations de date/heure de création.</param>
        <param name="creationTime">Élément <see cref="T:System.DateTime" /> contenant la valeur à affecter pour la date/heure de création de <paramref name="path" />. Cette valeur est exprimée en heure locale.</param>
        <summary>Définit la date/heure de création du fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Les lecteurs NTFS peuvent mettre en cache méta-informations de fichier, comme la durée de la création du fichier, pendant une courte période de temps. Par conséquent, il peut être nécessaire de définir explicitement l’heure de création d’un fichier si vous écrasez ou remplacez un fichier existant.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Le chemin spécifié est introuvable.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite pendant l’opération.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> spécifie une valeur en dehors de la plage de dates et/ou d’heures autorisées pour cette opération.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetCreationTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.File.SetCreationTimeUtc (path, creationTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Fichier pour lequel définir les informations de date/heure de création.</param>
        <param name="creationTimeUtc">Élément <see cref="T:System.DateTime" /> contenant la valeur à affecter pour la date/heure de création de <paramref name="path" />. Cette valeur est exprimée en temps UTC.</param>
        <summary>Définit la date/heure au format UTC (Temps universel coordonné) de création du fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Les lecteurs NTFS peuvent mettre en cache méta-informations de fichier, comme la durée de la création du fichier, pendant une courte période de temps. Par conséquent, il peut être nécessaire de définir explicitement l’heure de création d’un fichier si vous écrasez ou remplacez un fichier existant.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Le chemin spécifié est introuvable.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite pendant l’opération.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> spécifie une valeur en dehors de la plage de dates et/ou d’heures autorisées pour cette opération.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTime : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastAccessTime (path, lastAccessTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Fichier pour lequel définir les informations de date/heure d'accès.</param>
        <param name="lastAccessTime">Élément <see cref="T:System.DateTime" /> contenant la valeur à affecter pour la date/heure du dernier accès à <paramref name="path" />. Cette valeur est exprimée en heure locale.</param>
        <summary>Définit la date et l'heure du dernier accès au fichier spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant vérifie le système de fichiers pour le fichier spécifié, sa création si nécessaire, puis définit et obtient l’heure du dernier accès.  
  
 [!code-cpp[file setlastaccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastAccess/CPP/file setlastaccess.cpp#1)]
 [!code-csharp[file setlastaccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastAccess/CS/file setlastaccess.cs#1)]
 [!code-vb[file setlastaccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastAccess/VB/file setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le chemin spécifié est introuvable.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTime" /> spécifie une valeur qui n’est pas comprise dans la plage de dates ou d’heures autorisées pour cette opération.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastAccessTimeUtc (path, lastAccessTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Fichier pour lequel définir les informations de date/heure d'accès.</param>
        <param name="lastAccessTimeUtc">Élément <see cref="T:System.DateTime" /> contenant la valeur à affecter pour la date/heure du dernier accès à <paramref name="path" />. Cette valeur est exprimée en temps UTC.</param>
        <summary>Définit la date/heure au format UTC (Temps universel coordonné) du dernier accès au fichier spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le chemin spécifié est introuvable.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTimeUtc" /> spécifie une valeur qui n’est pas comprise dans la plage de dates ou d’heures autorisées pour cette opération.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTime : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastWriteTime (path, lastWriteTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Fichier pour lequel définir les informations de date/heure.</param>
        <param name="lastWriteTime">Élément <see cref="T:System.DateTime" /> contenant la valeur à affecter pour la date/heure du dernier accès en écriture à <paramref name="path" />. Cette valeur est exprimée en heure locale.</param>
        <summary>Définit la date/heure du dernier accès en écriture au fichier spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 L’exemple suivant vérifie le système de fichiers pour le fichier spécifié, la création du fichier si nécessaire, puis définit et obtient l’heure de dernière écriture du fichier.  
  
 [!code-cpp[file setlastwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastWrite/CPP/file setlastwrite.cpp#1)]
 [!code-csharp[file setlastwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastWrite/CS/file setlastwrite.cs#1)]
 [!code-vb[file setlastwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastWrite/VB/file setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le chemin spécifié est introuvable.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTime" /> spécifie une valeur qui n’est pas comprise dans la plage de dates ou d’heures autorisées pour cette opération.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastWriteTimeUtc (path, lastWriteTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Fichier pour lequel définir les informations de date/heure.</param>
        <param name="lastWriteTimeUtc">Élément <see cref="T:System.DateTime" /> contenant la valeur à affecter pour la date/heure du dernier accès en écriture à <paramref name="path" />. Cette valeur est exprimée en temps UTC.</param>
        <summary>Définit la date/heure au format UTC (Temps universel coordonné) de la dernière écriture dans le fichier spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `path` paramètre est autorisé à spécifier des informations de chemin d’accès relatif ou absolu. Informations de chemin d’accès relatif sont interprétées comme étant relatif du répertoire de travail actuel. Pour obtenir le répertoire de travail actuel, consultez <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Pour obtenir la liste des tâches d’e/s courantes, consultez [des tâches d’e/s courantes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le chemin spécifié est introuvable.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTimeUtc" /> spécifie une valeur qui n’est pas comprise dans la plage de dates ou d’heures autorisées pour cette opération.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour écrire dans le fichier spécifié. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Fichier et flux de données E/S</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Lire le texte à partir d’un fichier</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Comment : écrire du texte dans un fichier</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string path, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllBytes(string path, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytes(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (path As String, bytes As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ path, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member WriteAllBytes : string * byte[] -&gt; unit" Usage="System.IO.File.WriteAllBytes (path, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="path">Fichier dans lequel écrire.</param>
        <param name="bytes">Octets à écrire dans le fichier.</param>
        <summary>Crée un nouveau fichier, écrit le tableau d'octets spécifié dans le fichier, puis ferme le fichier. Si le fichier cible existe déjà, il est remplacé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné un tableau d’octets et un chemin d’accès de fichier, cette méthode ouvre le fichier spécifié, écrit le contenu du tableau d’octets dans le fichier, puis ferme le fichier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" /> ou le tableau d’octets est vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un fichier en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’accès en écriture à un fichier ou répertoire. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllBytesAsync (string path, byte[] bytes, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllBytesAsync(string path, unsigned int8[] bytes, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytesAsync(System.String,System.Byte[],System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllBytesAsync : string * byte[] * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllBytesAsync (path, bytes, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un fichier, écrit une ou plusieurs chaînes dans le fichier, puis ferme le fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * seq&lt;string&gt; -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">Fichier dans lequel écrire.</param>
        <param name="contents">Lignes à écrire dans le fichier.</param>
        <summary>Crée un fichier, écrit une collection de chaînes dans le fichier, puis ferme le fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement par défaut de la <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> méthode consiste à écrire les données en utilisant l’encodage UTF-8 sans marque d’ordre d’octet (BOM). S’il est nécessaire d’inclure un identificateur UTF-8, par exemple une marque d’ordre d’octet, au début d’un fichier, utilisez le <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29> surcharge de méthode avec <xref:System.Text.Encoding.UTF8%2A> encodage.  
  
 Si le fichier cible existe déjà, il est remplacé.  
  
 Vous pouvez utiliser cette méthode pour créer le contenu d’une classe de collection qui prend une <xref:System.Collections.Generic.IEnumerable%601> dans son constructeur, comme un <xref:System.Collections.Generic.List%601.%23ctor%2A>, <xref:System.Collections.Generic.HashSet%601.%23ctor%2A>, ou un <xref:System.Collections.Generic.SortedSet%601.%23ctor%2A> classe.  
  
   
  
## Examples  
 L’exemple suivant écrit les lignes sélectionnées à partir d’un exemple de fichier de données dans un fichier.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ou <paramref name="contents" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> spécifie un fichier qui est en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> est un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * string[] -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="path">Fichier dans lequel écrire.</param>
        <param name="contents">Tableau de chaînes à écrire dans le fichier.</param>
        <summary>Crée un nouveau fichier, écrit le tableau de chaînes spécifié dans le fichier, puis ferme le fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le fichier cible existe déjà, il est remplacé.  
  
 Le comportement par défaut de la <xref:System.IO.File.WriteAllLines%2A> méthode consiste à écrire les données à l’aide du codage UTF-8 sans marque d’ordre d’octet (BOM). S’il est nécessaire d’inclure un identificateur UTF-8, par exemple une marque d’ordre d’octet, au début d’un fichier, utilisez le <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.String%5B%5D%2CSystem.Text.Encoding%29> surcharge de méthode avec <xref:System.Text.Encoding.UTF8%2A> encodage.  
  
 Étant donné un tableau de chaînes et un chemin d’accès de fichier, cette méthode ouvre le fichier spécifié, écrit le tableau de chaînes dans le fichier, puis ferme le fichier.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.File.WriteAllLines%2A> méthode pour écrire du texte dans un fichier. Dans cet exemple, un fichier est créé, si elle n’existe pas déjà, et texte est ajouté à ce dernier.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ou <paramref name="contents" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un fichier en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’accès en écriture à un fichier ou répertoire. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * seq&lt;string&gt; * System.Text.Encoding -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Fichier dans lequel écrire.</param>
        <param name="contents">Lignes à écrire dans le fichier.</param>
        <param name="encoding">Encodage des caractères à utiliser.</param>
        <summary>Crée un fichier en utilisant l'encodage spécifié, écrit une collection de chaînes dans le fichier, puis ferme le fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le fichier cible existe déjà, il est remplacé.  
  
 Vous pouvez utiliser cette méthode pour créer un fichier qui contient les éléments suivants :  
  
-   Les résultats d’une [LINQ to Objects](https://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) interroger sur les lignes d’un fichier, tel qu’obtenu à l’aide de la <xref:System.IO.File.ReadLines%2A> (méthode).  
  
-   Le contenu d’une collection qui implémente un <xref:System.Collections.Generic.IEnumerable%601> de chaînes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par la méthode <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />, <paramref name="contents" /> ou <paramref name="encoding" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> spécifie un fichier qui est en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> est un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[],System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * string[] * System.Text.Encoding -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Fichier dans lequel écrire.</param>
        <param name="contents">Tableau de chaînes à écrire dans le fichier.</param>
        <param name="encoding">Objet <see cref="T:System.Text.Encoding" /> qui représente l'encodage des caractères appliqué au tableau de chaînes.</param>
        <summary>Crée un fichier, écrit le tableau de chaînes spécifié dans le fichier en utilisant l'encodage spécifié, puis ferme le fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le fichier cible existe déjà, il est remplacé.  
  
 Étant donné un tableau de chaînes et un chemin d’accès de fichier, cette méthode ouvre le fichier spécifié, écrit le tableau de chaînes dans le fichier à l’aide de l’encodage spécifié, puis ferme le fichier.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.File.WriteAllLines%2A> méthode pour écrire du texte dans un fichier. Dans cet exemple, un fichier est créé, si elle n’existe pas déjà, et texte est ajouté à ce dernier.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ou <paramref name="contents" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un fichier en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’accès en écriture à un fichier ou répertoire. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllLinesAsync : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllLinesAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllLinesAsync : string * seq&lt;string&gt; * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllLinesAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un nouveau fichier, écrit le contenu dans le fichier, puis ferme le fichier. Si le fichier cible existe déjà, il est remplacé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string -&gt; unit" Usage="System.IO.File.WriteAllText (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Fichier dans lequel écrire.</param>
        <param name="contents">Chaîne à écrire dans le fichier.</param>
        <summary>Crée un nouveau fichier, écrit la chaîne spécifiée dans le fichier, puis ferme le fichier. Si le fichier cible existe déjà, il est remplacé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise UTF-8 encodage sans marque ordre d’octet (BOM), par conséquent, à l’aide de la <xref:System.Text.Encoding.GetPreamble%2A> méthode retourne un tableau d’octets vide. S’il est nécessaire d’inclure un identificateur UTF-8, par exemple une marque d’ordre d’octet, au début d’un fichier, utilisez le <xref:System.IO.File.WriteAllText%28System.String%2CSystem.String%2CSystem.Text.Encoding%29> surcharge de méthode avec <xref:System.Text.Encoding.UTF8%2A> encodage.  
  
 Une chaîne et un chemin d’accès de fichier donnés, cette méthode ouvre le fichier spécifié, écrit la chaîne dans le fichier, puis ferme le fichier.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.File.WriteAllText%2A> méthode pour écrire du texte dans un fichier. Dans cet exemple, un fichier est créé, si elle n’existe pas déjà, et texte est ajouté à ce dernier.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" /> ou <paramref name="contents" /> est vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un fichier qui est en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’accès en écriture à un fichier ou répertoire. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * System.Text.Encoding -&gt; unit" Usage="System.IO.File.WriteAllText (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Fichier dans lequel écrire.</param>
        <param name="contents">Chaîne à écrire dans le fichier.</param>
        <param name="encoding">Encodage à appliquer à la chaîne.</param>
        <summary>Crée un nouveau fichier, écrit la chaîne spécifiée dans le fichier en utilisant l'encodage spécifié, puis ferme le fichier. Si le fichier cible existe déjà, il est remplacé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une chaîne et un chemin d’accès de fichier donnés, cette méthode ouvre le fichier spécifié, écrit la chaîne dans le fichier à l’aide de l’encodage spécifié, puis ferme le fichier. Le handle de fichier est toujours fermé par cette méthode, même si les exceptions sont levées.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.File.WriteAllText%2A> méthode pour écrire du texte dans un fichier. Dans cet exemple, un fichier est créé, si elle n’existe pas déjà, et texte est ajouté à ce dernier.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> est une chaîne de longueur nulle, contient seulement un espace, ou contient un ou plusieurs caractères non valides définis par <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> est <see langword="null" /> ou <paramref name="contents" /> est vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin et/ou le nom de fichier spécifiés dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S s’est produite lors de l’ouverture du fichier.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> a spécifié un fichier en lecture seule.  
  
ou 
Cette opération n'est pas prise en charge sur la plateforme actuelle.  
  
ou 
 <paramref name="path" /> a spécifié un répertoire.  
  
ou 
L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> a un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’accès en écriture à un fichier ou répertoire. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllTextAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllTextAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllTextAsync : string * string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllTextAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>