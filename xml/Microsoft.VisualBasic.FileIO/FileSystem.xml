<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileIO.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9aa809c9a73e4c1e92a5ae6180512f2ef966af36" /><Meta Name="ms.sourcegitcommit" Value="5ebd9691c6f7d50c4730e997fba69e54bdd7cc0c" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/17/2019" /><Meta Name="ms.locfileid" Value="65829814" /></Metadata><TypeSignature Language="C#" Value="public class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileIO.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
    <AssemblyVersion>10.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit des propriétés et des méthodes destinées à être utilisées avec les lecteurs, les fichiers et les répertoires.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem` objet.  
  
|À|Voir|  
|-|-|  
|Lire à partir d'un fichier texte|[Guide pratique pour lire des fichiers texte](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
|Lire à partir d’un fichier texte délimité|[Guide pratique pour lire des fichiers texte délimités par des virgules](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire un fichier texte de largeur fixe|[Guide pratique pour lire des fichiers texte de largeur fixe](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lire un fichier texte avec plusieurs formats|[Guide pratique pour lire des fichiers texte avec plusieurs formats](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
|Lire à partir d'un fichier binaire|[Guide pratique pour Lire des fichiers binaires](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
|Lire à partir d’un fichier texte avec un <xref:System.IO.StreamReader>|[Guide pratique pour Lire le texte à partir de fichiers avec un StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
|Écrire dans un fichier texte|[Guide pratique pour insérer du texte dans des fichiers](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Ajouter à un fichier texte|[Guide pratique pour Ajout à des fichiers de texte](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
|Écrire dans un fichier binaire|[Guide pratique pour Écrire dans des fichiers binaires](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
|Écrire dans des fichiers texte dans le **MyDocuments** directory|[Guide pratique pour Écrire du texte dans les fichiers dans le répertoire Mes Documents](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-in-the-my-documents-directory.md)|  
|Écrire dans un fichier texte avec un `StreamWriter`|[Guide pratique pour Écrire du texte dans des fichiers à l’aide de StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
|Copier des fichiers avec un modèle spécifique|[Guide pratique pour copier des fichiers avec un modèle spécifique dans un répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md)|  
|Copier un fichier dans le même répertoire|[Guide pratique pour créer une copie d’un fichier dans le même répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copier un fichier vers un autre répertoire|[Guide pratique pour créer une copie d’un fichier dans un autre répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
|Créez un fichier|[Guide pratique pour Créez un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-file.md)|  
|Supprimer un fichier|[Guide pratique pour Supprimer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
|Rechercher des fichiers avec un modèle spécifique|[Guide pratique pour rechercher des fichiers avec un modèle spécifique](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
|Déplacer un fichier|[Guide pratique pour déplacer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
|Renommer un fichier|[Guide pratique pour renommer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
|Copier un répertoire vers un autre répertoire|[Guide pratique pour copier un répertoire vers un autre répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
|Créer un répertoire|[Guide pratique pour Créez un répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
|Rechercher des sous-répertoires avec un modèle spécifique|[Guide pratique pour rechercher des sous-répertoires avec un modèle spécifique](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
|Obtenez la collection de fichiers dans un répertoire|[Guide pratique pour placer la collection de fichiers dans un répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Lire à partir de la **MyDocuments** directory|[Guide pratique pour Récupérer le contenu du répertoire Mes Documents](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-retrieve-the-contents-of-the-my-documents-directory.md)|  
|Analyser un chemin d’accès de fichier|[Guide pratique pour analyser des chemins](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Cet exemple vérifie pour déterminer si le dossier `C:\backup\logs` existe et vérifie ses propriétés.  
  
 [!code-vb[VbVbcnMyFileSystem#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#23)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
    <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objets (Visual Basic)</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystem ();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [Objets (Visual Basic)](~/docs/visual-basic/language-reference/objects/index.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CombinePath">
      <MemberSignature Language="C#" Value="public static string CombinePath (string baseDirectory, string relativePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CombinePath(string baseDirectory, string relativePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CombinePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CombinePath (baseDirectory As String, relativePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CombinePath(System::String ^ baseDirectory, System::String ^ relativePath);" />
      <MemberSignature Language="F#" Value="static member CombinePath : string * string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CombinePath (baseDirectory, relativePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseDirectory" Type="System.String" />
        <Parameter Name="relativePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseDirectory"><see langword="String" />. Premier chemin d’accès à combiner.</param>
        <param name="relativePath"><see langword="String" />. Deuxième chemin d’accès à combiner.</param>
        <summary>Combine deux chemins d’accès et retourne un chemin d’accès correctement mis en forme.</summary>
        <returns>La combinaison des chemins spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode supprime les espaces de marque de barre oblique excessive pour créer un chemin d’accès correctement mis en forme.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.CombinePath` (méthode).  
  
|À|Voir|  
|-|-|  
|Associer un nom de fichier et le chemin de répertoire|[Guide pratique pour Analyser des chemins en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Cet exemple combine un nom de fichier et le chemin de répertoire pour créer un chemin d’accès correctement mis en forme.  
  
 [!code-vb[VbRefFile#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#3)]  
  
 Cet exemple combine deux chemins d’accès pour créer un chemin d’accès correctement mis en forme.  
  
 [!code-vb[VbRefFile#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#4)]  
  
 Cet exemple retourne `C:\Dir1\Dir2\Dir4\Dir5\File.txt`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="baseDirectory" /> ou <paramref name="relativePath" /> sont des chemins d’accès incorrects.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie le contenu d’un répertoire vers un autre répertoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Le répertoire à copier.</param>
        <param name="destinationDirectoryName">L’emplacement vers lequel le contenu du répertoire doit être copié.</param>
        <summary>Copie le contenu d’un répertoire vers un autre répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie le contenu du répertoire source vers le répertoire cible. Si le répertoire cible n’existe pas, il est créé. Si un répertoire portant le même nom existe dans l’emplacement cible, le contenu des deux annuaires est fusionné. Vous pouvez spécifier un nouveau nom pour le répertoire pendant l’opération.  
  
 Lors de la copie des fichiers dans un répertoire, les exceptions peuvent être levées sont provoquées par un fichier spécifique. Lorsque ces exceptions sont levées, elles sont consolidées en une seule exception dont la propriété `Data` propriété comporte des entrées sous la forme d’un <xref:System.Collections.IDictionary> dans lequel le chemin d’accès du fichier ou répertoire est la clé et le message d’exception spécifique est contenu dans le valeur correspondante. Utilisez `For…Each` pour énumérer les entrées.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.CopyDirectory` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un répertoire|[Guide pratique pour Copier un répertoire vers un autre répertoire en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 L’exemple suivant copie le contenu du répertoire `TestDirectory1` dans `TestDirectory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#94)]  
  
 Remplacez `C:\TestDirectory1` et `C:\TestDirectory2` avec le chemin d’accès et le nom de l’annuaire que vous souhaitez copier et l’emplacement auquel vous souhaitez le copier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> est <see langword="Nothing" /> ou une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire source n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le chemin source et le chemin cible sont identiques.</exception>
        <exception cref="T:System.InvalidOperationException">L’opération est cyclique.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de dossier dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un fichier de destination existe mais n’est pas accessible.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Le répertoire à copier.</param>
        <param name="destinationDirectoryName">L’emplacement vers lequel le contenu du répertoire doit être copié.</param>
        <param name="showUI">Si vous souhaitez suivre visuellement la progression de l’opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Copie le contenu d’un répertoire vers un autre répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie le contenu du répertoire source vers le répertoire cible. Si le répertoire cible n’existe pas, il est créé. Si un répertoire portant le même nom existe dans l’emplacement cible, le contenu des deux annuaires est fusionné. Vous pouvez spécifier un nouveau nom pour le répertoire pendant l’opération.  
  
 Lors de la copie des fichiers dans un répertoire, les exceptions peuvent être levées sont provoquées par un fichier spécifique. Lorsque ces exceptions sont levées, elles sont consolidées en une seule exception dont la propriété `Data` propriété comporte des entrées sous la forme d’un <xref:System.Collections.IDictionary> dans lequel le chemin d’accès du fichier ou répertoire est la clé et le message d’exception spécifique est contenu dans le valeur correspondante. Utilisez `For…Each` pour énumérer les entrées.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.CopyDirectory` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un répertoire|[Guide pratique pour Copier un répertoire vers un autre répertoire en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 L’exemple suivant copie le contenu du répertoire `TestDirectory1` dans `TestDirectory2`, affichant la boîte de dialogue de progression et de toute boîte de dialogue d’erreur.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#92)]  
  
 Remplacez `C:\TestDirectory1` et `C:\TestDirectory2` avec le chemin d’accès et le nom de l’annuaire que vous souhaitez copier et l’emplacement auquel vous souhaitez le copier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> est <see langword="Nothing" /> ou une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire source n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le chemin source et le chemin cible sont identiques.</exception>
        <exception cref="T:System.InvalidOperationException">L’opération est cyclique.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de dossier dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un fichier de destination existe mais n’est pas accessible.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="ShowUI" /> a la valeur <see langword="UIOption.AllDialogs" /> et l’utilisateur annule l’opération, ou un ou plusieurs fichiers dans le répertoire ne peut pas être copiés.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Le répertoire à copier.</param>
        <param name="destinationDirectoryName">L’emplacement vers lequel le contenu du répertoire doit être copié.</param>
        <param name="overwrite"><see langword="True" /> Pour remplacer les fichiers existants ; sinon <see langword="False" />. La valeur par défaut est <see langword="False" />.</param>
        <summary>Copie le contenu d’un répertoire vers un autre répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie le contenu du répertoire source vers le répertoire cible. Si le répertoire cible n’existe pas, il est créé. Si un répertoire portant le même nom existe dans l’emplacement cible, le contenu des deux annuaires est fusionné. Vous pouvez spécifier un nouveau nom pour le répertoire pendant l’opération.  
  
 Lors de la copie des fichiers dans un répertoire, les exceptions peuvent être levées sont provoquées par un fichier spécifique, tel qu’un fichier existant au cours d’une fusion alors que `overwrite` est défini sur `False`. Lorsque ces exceptions sont levées, elles sont consolidées en une seule exception dont la propriété `Data` propriété comporte des entrées sous la forme d’un <xref:System.Collections.IDictionary> dans lequel le chemin d’accès du fichier ou répertoire est la clé et le message d’exception spécifique est contenu dans le valeur correspondante. Utilisez `For…Each` pour énumérer les entrées.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.CopyDirectory` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un répertoire|[Guide pratique pour Copier un répertoire vers un autre répertoire en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 L’exemple suivant copie le contenu du répertoire `TestDirectory1` dans `TestDirectory2`, en remplaçant les fichiers existants.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Remplacez `C:\TestDirectory1` et `C:\TestDirectory2` avec le chemin d’accès et le nom de l’annuaire que vous souhaitez copier et l’emplacement auquel vous souhaitez le copier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> est <see langword="Nothing" /> ou une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire source n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le chemin source et le chemin cible sont identiques.</exception>
        <exception cref="T:System.InvalidOperationException">L’opération est cyclique.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de dossier dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un fichier de destination existe mais n’est pas accessible.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Le répertoire à copier.</param>
        <param name="destinationDirectoryName">L’emplacement vers lequel le contenu du répertoire doit être copié.</param>
        <param name="showUI">Si vous souhaitez suivre visuellement la progression de l’opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Indique ce qu’il convient de faire si l’utilisateur clique sur **Annuler** pendant l’opération. La valeur par défaut est <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Copie le contenu d’un répertoire vers un autre répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie le contenu du répertoire source vers le répertoire cible. Si le répertoire cible n’existe pas, il est créé. Si un répertoire portant le même nom existe dans l’emplacement cible, le contenu des deux annuaires est fusionné. Vous pouvez spécifier un nouveau nom pour le répertoire pendant l’opération.  
  
 Lors de la copie des fichiers dans un répertoire, les exceptions peuvent être levées sont provoquées par un fichier spécifique. Lorsque ces exceptions sont levées, elles sont consolidées en une seule exception dont la propriété `Data` propriété comporte des entrées sous la forme d’un <xref:System.Collections.IDictionary> dans lequel le chemin d’accès du fichier ou répertoire est la clé et le message d’exception spécifique est contenu dans le valeur correspondante. Utilisez `For…Each` pour énumérer les entrées.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.CopyDirectory` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un répertoire|[Guide pratique pour Copier un répertoire vers un autre répertoire en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 L’exemple suivant copie le contenu du répertoire `TestDirectory1` dans `TestDirectory2`, affichant la boîte de dialogue de progression et de toute boîte de dialogue d’erreur et ne fait rien si l’utilisateur clique sur **Annuler** pendant l’opération.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#93)]  
  
 Remplacez `C:\TestDirectory1` et `C:\TestDirectory2` avec le chemin d’accès et le nom de l’annuaire que vous souhaitez copier et l’emplacement auquel vous souhaitez le copier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> est <see langword="Nothing" /> ou une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire source n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le chemin source et le chemin cible sont identiques.</exception>
        <exception cref="T:System.InvalidOperationException">L’opération est cyclique.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de dossier dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un fichier de destination existe mais n’est pas accessible.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="ShowUI" /> a la valeur <see langword="UIOption.AllDialogs" /> et l’utilisateur annule l’opération, ou un ou plusieurs fichiers dans le répertoire ne peut pas être copiés.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie un fichier vers un nouvel emplacement.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Le fichier doit être copié.</param>
        <param name="destinationFileName">L’emplacement vers lequel le fichier doit être copié.</param>
        <summary>Copie un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ne conserve pas les ACE (entrées de contrôle d’accès). Le fichier nouvellement créé hérite des ACE par défaut à partir du répertoire dans lequel il est créé.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un fichier dans le même répertoire.|[Guide pratique pour Créer une copie d’un fichier dans le même répertoire en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copier un fichier vers un autre répertoire.|[Guide pratique pour Créer une copie d’un fichier dans un autre répertoire en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` sans remplacer les fichiers existants.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` et le renomme `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> contient des informations de chemin d’accès.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> est <see langword="Nothing" /> ou une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n’est pas valide ou n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Un fichier dans le répertoire cible portant le même nom est en cours d’utilisation.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur n’a pas l’autorisation requise.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Le fichier doit être copié.</param>
        <param name="destinationFileName">L’emplacement vers lequel le fichier doit être copié.</param>
        <param name="showUI">Si vous souhaitez suivre visuellement la progression de l’opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Copie un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ne conserve pas les ACE (entrées de contrôle d’accès). Le fichier nouvellement créé hérite des ACE par défaut à partir du répertoire dans lequel il est créé.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un fichier dans le même répertoire.|[Guide pratique pour Créer une copie d’un fichier dans le même répertoire en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copier un fichier vers un autre répertoire.|[Guide pratique pour Créer une copie d’un fichier dans un autre répertoire en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` sans remplacer les fichiers existants.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` et le renomme `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> contient des informations de chemin d’accès.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> est <see langword="Nothing" /> ou une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n’est pas valide ou n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier de destination existe et <paramref name="overwrite" /> est défini sur <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur n’a pas l’autorisation requise.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Le fichier doit être copié.</param>
        <param name="destinationFileName">L’emplacement vers lequel le fichier doit être copié.</param>
        <param name="overwrite"><see langword="True" /> Si les fichiers existants doivent être remplacés ; sinon <see langword="False" />. La valeur par défaut est <see langword="False" />.</param>
        <summary>Copie un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ne conserve pas les ACE (entrées de contrôle d’accès). Le fichier nouvellement créé hérite des ACE par défaut à partir du répertoire dans lequel il est créé.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un fichier dans le même répertoire.|[Guide pratique pour Créer une copie d’un fichier dans le même répertoire en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copier un fichier vers un autre répertoire.|[Guide pratique pour Créer une copie d’un fichier dans un autre répertoire en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` sans remplacer les fichiers existants.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` et le renomme `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> contient des informations de chemin d’accès.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> est <see langword="Nothing" /> ou une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n’est pas valide ou n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier de destination existe et <paramref name="overwrite" /> est défini sur <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur n’a pas l’autorisation requise.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Le fichier doit être copié.</param>
        <param name="destinationFileName">L’emplacement vers lequel le fichier doit être copié.</param>
        <param name="showUI">Si vous souhaitez suivre visuellement la progression de l’opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Indique ce qu’il convient de faire si l’utilisateur clique sur **Annuler** pendant l’opération. La valeur par défaut est <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Copie un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ne conserve pas les ACE (entrées de contrôle d’accès). Le fichier nouvellement créé hérite des ACE par défaut à partir du répertoire dans lequel il est créé.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un fichier dans le même répertoire.|[Guide pratique pour Créer une copie d’un fichier dans le même répertoire en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copier un fichier vers un autre répertoire.|[Guide pratique pour Créer une copie d’un fichier dans un autre répertoire en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` sans remplacer les fichiers existants.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` et le renomme `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> contient des informations de chemin d’accès.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> est <see langword="Nothing" /> ou une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n’est pas valide ou n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier de destination existe et <paramref name="overwrite" /> est défini sur <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur n’a pas l’autorisation requise.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="UICancelOption" /> a la valeur <see langword="ThrowException" />et l’utilisateur a annulé l’opération ou une erreur d’e/s non spécifiée se produit.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static void CreateDirectory (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CreateDirectory(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateDirectory (directory As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDirectory(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Nom et emplacement du répertoire.</param>
        <summary>Crée un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le répertoire existe déjà, aucune exception n’est levée.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.CreateDirectory` (méthode).  
  
|À|Voir|  
|-|-|  
|Créer un répertoire|[Guide pratique pour Créez un répertoire en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
  
   
  
## Examples  
 Cet exemple crée le répertoire, `NewDirectory`, dans `C:\Documents and Settings\All Users\Documents`.  
  
 [!code-vb[VbVbcnMyFileSystem#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le format du nom du répertoire est incorrect. Par exemple, il contient des caractères interdits ou est uniquement un espace blanc.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le nom du répertoire est trop long.</exception>
        <exception cref="T:System.NotSupportedException">Le nom du répertoire est uniquement un signe deux-points ( :)).</exception>
        <exception cref="T:System.IO.IOException">Le répertoire parent du répertoire à créer est en lecture seule</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur n’a pas autorisé à créer le répertoire.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:System.IO.Directory.CreateDirectory(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le répertoire actif.</summary>
        <value>Le répertoire actif pour les opérations d’e/s de fichier.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CurrentDirectory` est une variable d’environnement système.  
  
   
  
## Examples  
 Cet exemple retourne le répertoire actif et l’affiche dans une boîte de message.  
  
 [!code-vb[VbVbcnMyFileSystem#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#18)]  
  
 Cet exemple définit le répertoire actuel `C:\TestDirectory`.  
  
 [!code-vb[VbVbcnMyFileSystem#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d’accès n’est pas valide.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur ne dispose pas des autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime un répertoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.DeleteDirectoryOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, onDirectoryNotEmpty As DeleteDirectoryOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.DeleteDirectoryOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, onDirectoryNotEmpty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="onDirectoryNotEmpty" Type="Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Parameters>
      <Docs>
        <param name="directory">Répertoire à supprimer.</param>
        <param name="onDirectoryNotEmpty">Spécifie l’action à entreprendre lorsqu’un répertoire à supprimer contient des fichiers ou répertoires. La valeur par défaut est <see langword="DeleteDirectoryOption.DeleteAllContents" />.</param>
        <summary>Supprime un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple supprime le répertoire `OldDirectory` uniquement si elle est vide.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, l’invitant à confirmer la suppression, mais n’envoie pas le contenu à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, les envoyer à la **Corbeille**, mais n’affiche ne pas la progression de l’opération.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d’accès est une chaîne de longueur nulle, est incorrect, contient uniquement des espaces blancs ou contient des caractères non valides (y compris les caractères génériques). Le chemin d’accès est un chemin d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n’existe pas ou est un fichier.</exception>
        <exception cref="T:System.IO.IOException">Un fichier dans le répertoire ou du sous-répertoire est en cours d’utilisation.</exception>
        <exception cref="T:System.NotSupportedException">Le nom du répertoire contient un signe deux-points ( :)).</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’a pas les autorisations requises.</exception>
        <exception cref="T:System.OperationCanceledException">L’utilisateur annule l’opération ou le répertoire ne peut pas être supprimé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="directory">Répertoire à supprimer.</param>
        <param name="showUI">Spécifie s’il faut suivre visuellement la progression de l’opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Spécifie si le fichier supprimé doit être ou non envoyé à la **Corbeille**. La valeur par défaut est <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Supprime un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `showUI` et `recycle` paramètres ne sont pas pris en charge dans les applications qui ne sont pas en mode utilisateur interactif, telles que les Services de Windows.  
  
   
  
## Examples  
 L’exemple supprime le répertoire `OldDirectory` uniquement si elle est vide.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, l’invitant à confirmer la suppression, mais n’envoie pas le contenu à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, les envoyer à la **Corbeille**, mais n’affiche ne pas la progression de l’opération.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d’accès est une chaîne de longueur nulle, est incorrect, contient uniquement des espaces blancs ou contient des caractères non valides (y compris les caractères génériques). Le chemin d’accès est un chemin d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n’existe pas ou est un fichier.</exception>
        <exception cref="T:System.IO.IOException">Un fichier dans le répertoire ou du sous-répertoire est en cours d’utilisation.</exception>
        <exception cref="T:System.NotSupportedException">Le nom du répertoire contient un signe deux-points ( :)).</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’a pas les autorisations requises.</exception>
        <exception cref="T:System.OperationCanceledException">L’utilisateur annule l’opération ou le répertoire ne peut pas être supprimé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="directory">Répertoire à supprimer.</param>
        <param name="showUI">Spécifie s’il faut suivre visuellement la progression de l’opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Spécifie si le fichier supprimé doit être ou non envoyé à la **Corbeille**. La valeur par défaut est <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Spécifie si une exception doit être levée quand l’utilisateur clique sur **Annuler**.</param>
        <summary>Supprime un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `showUI`, `recycle`, et `onUserCancel` paramètres ne sont pas pris en charge dans les applications qui ne sont pas en mode utilisateur interactif, telles que les Services de Windows.  
  
   
  
## Examples  
 L’exemple supprime le répertoire `OldDirectory` uniquement si elle est vide.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, l’invitant à confirmer la suppression, mais n’envoie pas le contenu à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, les envoyer à la **Corbeille**, mais n’affiche ne pas la progression de l’opération.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d’accès est une chaîne de longueur nulle, est incorrect, contient uniquement des espaces blancs ou contient des caractères non valides (y compris les caractères génériques). Le chemin d’accès est un chemin d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n’existe pas ou est un fichier.</exception>
        <exception cref="T:System.IO.IOException">Un fichier dans le répertoire ou du sous-répertoire est en cours d’utilisation.</exception>
        <exception cref="T:System.NotSupportedException">Le nom du répertoire contient un signe deux-points ( :)).</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’a pas les autorisations requises.</exception>
        <exception cref="T:System.OperationCanceledException">L’utilisateur annule l’opération ou le répertoire ne peut pas être supprimé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime un fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d’accès du fichier à supprimer.</param>
        <summary>Supprime un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.DeleteFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Pour supprimer un fichier|[Guide pratique pour Supprimer un fichier en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Cet exemple supprime le fichier `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Cet exemple supprime le fichier `Test.txt` et autorise l’utilisateur à confirmer que le fichier doit être supprimé.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Cet exemple supprime le fichier `Test.txt` et l’envoie à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d’accès n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il contient une barre oblique finale alors qu’un fichier doit être spécifié ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur n’est pas autorisé à supprimer le fichier ou le fichier est en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d’accès du fichier à supprimer.</param>
        <param name="showUI">Si vous souhaitez suivre visuellement la progression de l’opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Spécifie si le fichier supprimé doit être envoyé à la **Corbeille**. La valeur par défaut est <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Supprime un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `showUI` et `recycle` paramètres ne sont pas pris en charge dans les applications qui ne sont pas en mode utilisateur interactif, telles que les Services de Windows.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.DeleteFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Pour supprimer un fichier|[Guide pratique pour Supprimer un fichier en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Cet exemple supprime le fichier `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Cet exemple supprime le fichier `Test.txt` et autorise l’utilisateur à confirmer que le fichier doit être supprimé.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Cet exemple supprime le fichier `Test.txt` et l’envoie à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d’accès n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il contient une barre oblique finale alors qu’un fichier doit être spécifié ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur n’est pas autorisé à supprimer le fichier ou le fichier est en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d’accès du fichier à supprimer.</param>
        <param name="showUI">Si vous souhaitez suivre visuellement la progression de l’opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Spécifie si le fichier supprimé doit être envoyé à la **Corbeille**. La valeur par défaut est <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Spécifie si une exception est levée lorsque l’utilisateur annule l’opération. La valeur par défaut est <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Supprime un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `showUI`, `recycle`, et `onUserCancel` paramètres ne sont pas pris en charge dans les applications qui ne sont pas en mode utilisateur interactif, telles que les Services de Windows.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.DeleteFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Pour supprimer un fichier|[Guide pratique pour Supprimer un fichier en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Cet exemple supprime le fichier `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Cet exemple supprime le fichier `Test.txt` et autorise l’utilisateur à confirmer que le fichier doit être supprimé.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Cet exemple supprime le fichier `Test.txt` et l’envoie à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d’accès n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il contient une barre oblique finale alors qu’un fichier doit être spécifié ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur n’est pas autorisé à supprimer le fichier ou le fichier est en lecture seule.</exception>
        <exception cref="T:System.OperationCanceledException">L’utilisateur a annulé l’opération et <paramref name="onUserCancel" /> est défini sur <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public static bool DirectoryExists (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool DirectoryExists(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DirectoryExists (directory As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DirectoryExists(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member DirectoryExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Chemin d’accès du répertoire.</param>
        <summary>Retourne <see langword="True" /> si le répertoire spécifié existe.</summary>
        <returns><see langword="True" /> Si le répertoire existe ; sinon <see langword="False" />. Cette méthode retourne également <see langword="False" /> si le paramètre représente le nom et le chemin d’accès d’un fichier, et non un répertoire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple détermine si le répertoire `C:\backup\logs` existe et vérifie ses propriétés.  
  
 [!code-vb[VbRefFile#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Drives">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt; Drives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.DriveInfo&gt; Drives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Drives As ReadOnlyCollection(Of DriveInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ Drives { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Drives : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne une collection en lecture seule de tous les noms de lecteur disponible.</summary>
        <value>Une collection en lecture seule de tous les lecteurs disponibles en tant que <see cref="T:System.IO.DriveInfo" /> objets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne tous les lecteurs logiques.  
  
   
  
## Examples  
 Cet exemple affiche les noms de lecteur disponible dans une boîte de message.  
  
 [!code-vb[VbRefFile#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None" />
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public static bool FileExists (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool FileExists(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FileExists (file As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FileExists(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member FileExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FileExists file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d’accès du fichier.</param>
        <summary>Retourne <see langword="True" /> si le fichier spécifié existe.</summary>
        <returns>Retourne <see langword="True" /> si le fichier existe ; sinon, cette méthode retourne <see langword="False" />. Cette méthode retourne également <see langword="False" /> si le paramètre représente le chemin d’accès d’un répertoire au lieu d’un fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’application ne dispose pas des autorisations suffisantes pour lire le fichier spécifié, le `FileExists` méthode retourne `False`, indépendamment de l’existence du chemin d’accès ; la méthode ne lève pas une exception.  
  
   
  
## Examples  
 Cet exemple vérifie si le fichier `Check.txt` existe et fournit les informations contenues dans une boîte de message.  
  
 [!code-vb[VbRefFile#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom du fichier se termine par une barre oblique inverse (\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FindInFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une collection en lecture seule de chaînes représentant les noms des fichiers contenant le texte spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="directory">Le répertoire à rechercher.</param>
        <param name="containsText">Le texte de recherche.</param>
        <param name="ignoreCase"><see langword="True" /> Si la recherche doit respecter la casse ; sinon <see langword="False" />. La valeur par défaut est <see langword="True" />.</param>
        <param name="searchType">Si vous souhaitez inclure les sous-dossiers. La valeur par défaut est <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <summary>Retourne une collection en lecture seule de chaînes représentant les noms des fichiers contenant le texte spécifié.</summary>
        <returns>Collection en lecture seule des noms des fichiers contenant le texte spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection vide est retournée si aucun fichier correspondant au modèle spécifié n'est détecté.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.FindInFiles` (méthode).  
  
|À|Voir|  
|-|-|  
|Rechercher dans un répertoire pour les fichiers contenant une chaîne spécifique|[Procédure pas à pas : Manipulation de fichiers et de répertoires en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 Cet exemple recherche dans le répertoire `C:\TestDir` pour tous les fichiers contenant la chaîne `"sample string"` et affiche les résultats dans `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Pour pouvoir fonctionner, le projet doit contenir un `ListBox` nommé `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur nulle, il ne contient que des espaces blancs, il contient des caractères non valides ou il s’agit d’un chemin d’appareil (qui commence par <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire spécifié n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Le chemin d’accès du répertoire spécifié contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur ne dispose pas des autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] fileWildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption, ParamArray fileWildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ fileWildcards);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType, fileWildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="fileWildcards" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Le répertoire à rechercher.</param>
        <param name="containsText">Le texte de recherche.</param>
        <param name="ignoreCase"><see langword="True" /> Si la recherche doit respecter la casse ; sinon <see langword="False" />. La valeur par défaut est <see langword="True" />.</param>
        <param name="searchType">Si vous souhaitez inclure les sous-dossiers. La valeur par défaut est <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="fileWildcards">Modèle à mettre en correspondance.</param>
        <summary>Retourne une collection en lecture seule de chaînes représentant les noms des fichiers contenant le texte spécifié.</summary>
        <returns>Collection en lecture seule des noms des fichiers contenant le texte spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection vide est retournée si aucun fichier correspondant au modèle spécifié n'est détecté.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.FindInFiles` (méthode).  
  
|À|Voir|  
|-|-|  
|Rechercher dans un répertoire pour les fichiers contenant une chaîne spécifique|[Procédure pas à pas : Manipulation de fichiers et de répertoires en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 Cet exemple recherche dans le répertoire `C:\TestDir` pour tous les fichiers contenant la chaîne `"sample string"` et affiche les résultats dans `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Pour pouvoir fonctionner, le projet doit contenir un `ListBox` nommé `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur nulle, il ne contient que des espaces blancs, il contient des caractères non valides ou il s’agit d’un chemin d’appareil (qui commence par <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire spécifié n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Le chemin d’accès du répertoire spécifié contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur ne dispose pas des autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une collection de chaînes représentant les noms de chemin d’accès des sous-répertoires dans un répertoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Nom et chemin d’accès du répertoire.</param>
        <summary>Retourne une collection de chaînes représentant les noms de chemin d’accès des sous-répertoires dans un répertoire.</summary>
        <returns>Collection en lecture seule des noms de chemin d’accès des sous-répertoires dans le répertoire spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.GetDirectories` (méthode).  
  
|À|Voir|  
|-|-|  
|Liste des sous-répertoires avec un modèle spécifique|[Guide pratique pour Rechercher des sous-répertoires avec un modèle spécifique en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L’exemple suivant retourne tous les répertoires dans la structure de répertoires qui contiennent le mot `Logs` dans leurs noms et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 Cet exemple nécessite que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire spécifié n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur ne dispose pas des autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Nom et chemin d’accès du répertoire.</param>
        <param name="searchType">Si vous souhaitez inclure les sous-dossiers. La valeur par défaut est <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Modèle à faire correspondre les noms.</param>
        <summary>Retourne une collection de chaînes représentant les noms de chemin d’accès des sous-répertoires dans un répertoire.</summary>
        <returns>Collection en lecture seule des noms de chemin d’accès des sous-répertoires dans le répertoire spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le paramètre `wildcards` pour indiquer un modèle spécifique. Si vous souhaitez inclure le contenu des sous-répertoires dans la recherche, affectez la valeur `SearchAllSubDirectories` au paramètre `searchType`.  
  
 Une collection vide est retournée si aucun répertoire correspondant au modèle spécifié n’est détecté.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.GetDirectories` (méthode).  
  
|À|Voir|  
|-|-|  
|Liste des sous-répertoires avec un modèle spécifique|[Guide pratique pour Rechercher des sous-répertoires avec un modèle spécifique en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L’exemple suivant retourne tous les répertoires dans la structure de répertoires qui contiennent le mot `Logs` dans leurs noms et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 Cet exemple nécessite que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs des caractères génériques spécifiés sont <see langword="Nothing" />, une chaîne vide, ou contient uniquement des espaces.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire spécifié n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur ne dispose pas des autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetDirectoryInfo (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryInfo (directory As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetDirectoryInfo(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory"><see langword="String" />. Chemin d’accès du répertoire.</param>
        <summary>Retourne un <see cref="T:System.IO.DirectoryInfo" /> objet pour le chemin d’accès spécifié.</summary>
        <returns><see cref="T:System.IO.DirectoryInfo" /> objet pour le chemin d’accès spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le répertoire n’existe pas, une exception n'est pas levée tant que la première fois une propriété le <xref:System.IO.DirectoryInfo> objet est accessible.  
  
   
  
## Examples  
 Cet exemple obtient un <xref:System.IO.DirectoryInfo> objet pour le répertoire `C:\Documents and Settings` et affiche le répertoire heure de création du dernier accès et d’heure dernière heure d’écriture.  
  
 [!code-vb[VbRefFile#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Le chemin d’accès du répertoire contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetDriveInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DriveInfo GetDriveInfo (string drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDriveInfo (drive As String) As DriveInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DriveInfo ^ GetDriveInfo(System::String ^ drive);" />
      <MemberSignature Language="F#" Value="static member GetDriveInfo : string -&gt; System.IO.DriveInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DriveInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="drive">Lecteur à examiner.</param>
        <summary>Retourne un <see cref="T:System.IO.DriveInfo" /> objet pour le lecteur spécifié.</summary>
        <returns><see cref="T:System.IO.DriveInfo" /> objet pour le lecteur spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.DriveInfo> classe Modélise un lecteur et fournit des méthodes et propriétés pour demander des informations sur le lecteur. Utilisez <xref:System.IO.DriveInfo> pour déterminer les lecteurs disponibles et leur type. Vous pouvez également interroger la propriété pour déterminer la capacité et l’espace libre disponible sur le lecteur.  
  
   
  
## Examples  
 Cet exemple obtienne un <xref:System.IO.DriveInfo> objet pour le lecteur C et l’utilise pour afficher des informations sur le lecteur.  
  
 [!code-vb[VbRefFile#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#11)]  
  
 Pour plus d’informations sur les différents types de lecteurs, consultez <xref:System.IO.DriveType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="drive" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <altmember cref="T:System.IO.DriveType" />
      </Docs>
    </Member>
    <Member MemberName="GetFileInfo">
      <MemberSignature Language="C#" Value="public static System.IO.FileInfo GetFileInfo (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.FileInfo GetFileInfo(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileInfo (file As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileInfo ^ GetFileInfo(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member GetFileInfo : string -&gt; System.IO.FileInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d’accès du fichier.</param>
        <summary>Retourne un <see cref="T:System.IO.FileInfo" /> objet pour le fichier spécifié.</summary>
        <returns><see cref="T:System.IO.FileInfo" /> objet pour le fichier spécifié</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une exception n’est pas levée si le fichier n’existe pas ; au lieu de cela, elle est levée la première fois que les propriétés de l’objet sont accessibles.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.GetFileInfo` (méthode).  
  
|À|Voir|  
|-|-|  
|Déterminer le nom et le chemin d’accès d’un fichier|[Guide pratique pour Analyser des chemins en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Cet exemple récupère un <xref:System.IO.FileInfo?displayProperty=nameWithType> objet pour le fichier `MyLogFile.log` et l’utilise pour signaler le nom complet du fichier, heure du dernier accès et longueur.  
  
 [!code-vb[VbRefFile#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d'accès est mal formé. Par exemple, il contient des caractères non valides ou est uniquement un espace blanc. Nom de fichier est une marque de barre oblique de fin.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.NotSupportedException">Le chemin d’accès contient un signe deux-points au milieu de la chaîne.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès est trop long.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur ne dispose pas d’accès ACL (liste de contrôle d’accès) au fichier.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.FileInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une collection en lecture seule de chaînes représentant les noms des fichiers dans un répertoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Répertoire à rechercher.</param>
        <summary>Retourne une collection en lecture seule de chaînes représentant les noms des fichiers dans un répertoire.</summary>
        <returns>Collection en lecture seule des noms de fichiers à partir du répertoire spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection vide est retournée si aucun fichier correspondant au modèle spécifié n'est détecté.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.GetFiles` (méthode).  
  
|À|Voir|  
|-|-|  
|Obtenez la collection de fichiers dans un répertoire|[Guide pratique pour Obtenir la Collection de fichiers dans un répertoire en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Rechercher des fichiers avec un modèle spécifique dans un répertoire|[Guide pratique pour Rechercher des fichiers avec un modèle spécifique en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L’exemple suivant retourne tous les fichiers contenus dans le répertoire et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 Cet exemple nécessite que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 Cet exemple retourne tous les fichiers dans le répertoire avec l’extension `.txt` et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 Cet exemple nécessite que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> a la valeur <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Répertoire à rechercher n’existe pas.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="directory" /> pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur ne dispose pas des autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Répertoire à rechercher.</param>
        <param name="searchType">Si vous souhaitez inclure les sous-dossiers. La valeur par défaut est <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Modèle à mettre en correspondance.</param>
        <summary>Retourne une collection en lecture seule de chaînes représentant les noms des fichiers dans un répertoire.</summary>
        <returns>Collection en lecture seule des noms de fichiers à partir du répertoire spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection vide est retournée si aucun fichier correspondant au modèle spécifié n'est détecté.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.GetFiles` (méthode).  
  
|À|Voir|  
|-|-|  
|Obtenez la collection de fichiers dans un répertoire|[Guide pratique pour Obtenir la Collection de fichiers dans un répertoire en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Rechercher des fichiers avec un modèle spécifique dans un répertoire|[Guide pratique pour Rechercher des fichiers avec un modèle spécifique en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L’exemple suivant retourne tous les fichiers contenus dans le répertoire et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 Cet exemple nécessite que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 Cet exemple retourne tous les fichiers dans le répertoire avec l’extension `.txt` et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 Cet exemple nécessite que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> a la valeur <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Répertoire à rechercher n’existe pas.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="directory" /> pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur ne dispose pas des autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public static string GetName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetName : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Obligatoire. Chemin d’accès à analyser. <see langword="String" />.</param>
        <summary>Analyse le nom de fichier en dehors du chemin d’accès fourni.</summary>
        <returns>Le nom de fichier du chemin d’accès spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une opération de chaîne ; le `FileSystem` n’est pas examiné.  
  
 Le `GetName` méthode ignore une marque de barre oblique présente à la fin du chemin d’accès.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.GetFileName` (méthode).  
  
|À|Voir|  
|-|-|  
|Analyser un chemin d’accès de fichier|[Guide pratique pour Analyser des chemins en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 L’exemple suivant analyse un chemin d’accès de fichier et retourne le nom du fichier.  
  
 [!code-vb[VbVbcnMyFileSystem#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#21)]  
  
 Remplacez le chemin d’accès `C:\Testdirectory\Testfile` avec le chemin d’accès que vous souhaitez analyser.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParentPath">
      <MemberSignature Language="C#" Value="public static string GetParentPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetParentPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParentPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetParentPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParentPath : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès doit être examinée.</param>
        <summary>Retourne le chemin d’accès parent du chemin fourni.</summary>
        <returns>Le chemin d’accès parent du chemin fourni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une opération de chaîne ; le système de fichiers n’est pas examiné.  
  
   
  
## Examples  
 Cet exemple obtient le chemin d’accès parent pour `C:\Backups\Tmp\Test`.  
  
 [!code-vb[VbRefFile#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Chemin d’accès n’a pas un chemin d’accès parent, car il est un chemin d’accès racine.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> a la valeur <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un fichier temporaire de zéro octet nommé de manière unique sur le disque et retourne le chemin d’accès complet de ce fichier.</summary>
        <returns><see langword="String" /> contenant le chemin d’accès complet du fichier temporaire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour créer un fichier temporaire.  
  
   
  
## Examples  
 Cet exemple crée un fichier temporaire et retourne son chemin d’accès.  
  
 [!code-vb[VbVbcnMyFileSystem#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Déplace un répertoire d’un emplacement vers un autre.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Chemin d’accès du répertoire à déplacer.</param>
        <param name="destinationDirectoryName">Chemin d’accès du répertoire dans lequel le répertoire source est déplacé.</param>
        <summary>Déplace un répertoire d’un emplacement vers un autre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une tentative est effectuée pour déplacer un répertoire à l’intérieur d’un répertoire qui n’existe pas, la structure cible sera créée.  
  
   
  
## Examples  
 Cet exemple déplace `Directory1` dans `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Cet exemple déplace `Directory1` à l’intérieur de `Directory2`, en remplaçant le répertoire s’il existe déjà.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> est <see langword="Nothing" /> ou une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">La source est un répertoire racine ou le chemin d’accès source et le chemin cible sont identiques.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.InvalidOperationException">L’opération est cyclique.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur n’a pas l’autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Chemin d’accès du répertoire à déplacer.</param>
        <param name="destinationDirectoryName">Chemin d’accès du répertoire dans lequel le répertoire source est déplacé.</param>
        <param name="showUI">Spécifie s’il faut suivre visuellement la progression de l’opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Déplace un répertoire d’un emplacement vers un autre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une tentative est effectuée pour déplacer un répertoire à l’intérieur d’un répertoire qui n’existe pas, la structure cible sera créée.  
  
   
  
## Examples  
 Cet exemple déplace `Directory1` dans `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Cet exemple déplace `Directory1` à l’intérieur de `Directory2`, en remplaçant le répertoire s’il existe déjà.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> est <see langword="Nothing" /> ou une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire cible existe déjà et <paramref name="overwrite" /> est défini à <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.InvalidOperationException">L’opération est cyclique.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur n’a pas l’autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Chemin d’accès du répertoire à déplacer.</param>
        <param name="destinationDirectoryName">Chemin d’accès du répertoire dans lequel le répertoire source est déplacé.</param>
        <param name="overwrite"><see langword="True" /> Si les répertoires existants doivent être remplacés ; sinon <see langword="False" />. La valeur par défaut est <see langword="False" />.</param>
        <summary>Déplace un répertoire d’un emplacement vers un autre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une tentative est effectuée pour déplacer un répertoire à l’intérieur d’un répertoire qui n’existe pas, la structure cible sera créée.  
  
   
  
## Examples  
 Cet exemple déplace `Directory1` dans `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Cet exemple déplace `Directory1` à l’intérieur de `Directory2`, en remplaçant le répertoire s’il existe déjà.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> est <see langword="Nothing" /> ou une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire cible existe déjà et <paramref name="overwrite" /> est défini à <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.InvalidOperationException">L’opération est cyclique.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur n’a pas l’autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Chemin d’accès du répertoire à déplacer.</param>
        <param name="destinationDirectoryName">Chemin d’accès du répertoire dans lequel le répertoire source est déplacé.</param>
        <param name="showUI">Spécifie s’il faut suivre visuellement la progression de l’opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Spécifie si une exception est levée lorsque l’utilisateur annule l’opération. La valeur par défaut est <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Déplace un répertoire d’un emplacement vers un autre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une tentative est effectuée pour déplacer un répertoire à l’intérieur d’un répertoire qui n’existe pas, la structure cible sera créée.  
  
   
  
## Examples  
 Cet exemple déplace `Directory1` dans `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Cet exemple déplace `Directory1` à l’intérieur de `Directory2`, en remplaçant le répertoire s’il existe déjà.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> est <see langword="Nothing" /> ou une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n’existe pas.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="onUserCancel" /> a la valeur <see langword="ThrowException" /> et un sous-répertoire du fichier ne peut pas être copié.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="onUserCancel" /> a la valeur <see langword="ThrowException" />et l’utilisateur annule l’opération, ou ne peut pas effectuer l’opération.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.InvalidOperationException">L’opération est cyclique.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur n’a pas l’autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Déplace un fichier vers un nouvel emplacement.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Chemin d’accès du fichier à déplacer.</param>
        <param name="destinationFileName">Chemin d’accès du répertoire dans lequel le fichier doit être déplacé.</param>
        <summary>Déplace un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la structure cible n’existe pas, il est créé.  
  
 Le `MoveFile` méthode conserve les ACE (entrées de contrôle d’accès) uniquement lors du déplacement du fichier dans le même volume. Cela inclut les ACE héritées, qui deviennent des entrées directes déplacé (direct ACE ont priorité sur les ACE héritées). Si un fichier est déplacé entre les volumes, les ACE ne seront pas copiés.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.MoveFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Déplacer un fichier|[Guide pratique pour Déplacer un fichier dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2` et le renomme `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n’est pas valide ou n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation par un autre processus, ou une erreur d’e/s se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Chemin d’accès du fichier à déplacer.</param>
        <param name="destinationFileName">Chemin d’accès du répertoire dans lequel le fichier doit être déplacé.</param>
        <param name="showUI">Spécifie s’il faut suivre visuellement la progression de l’opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Déplace un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la structure cible n’existe pas, il est créé.  
  
 Le `MoveFile` méthode conserve les ACE (entrées de contrôle d’accès) uniquement lors du déplacement du fichier dans le même volume. Cela inclut les ACE héritées, qui deviennent des entrées directes déplacé (direct ACE ont priorité sur les ACE héritées). Si un fichier est déplacé entre les volumes, les ACE ne seront pas copiés.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.MoveFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Déplacer un fichier|[Guide pratique pour Déplacer un fichier dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2` et le renomme `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n’est pas valide ou n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation par un autre processus, ou une erreur d’e/s se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Chemin d’accès du fichier à déplacer.</param>
        <param name="destinationFileName">Chemin d’accès du répertoire dans lequel le fichier doit être déplacé.</param>
        <param name="overwrite"><see langword="True" /> Pour remplacer les fichiers existants ; sinon <see langword="False" />. La valeur par défaut est <see langword="False" />.</param>
        <summary>Déplace un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la structure cible n’existe pas, il est créé.  
  
 Le `MoveFile` méthode conserve les ACE (entrées de contrôle d’accès) uniquement lors du déplacement du fichier dans le même volume. Cela inclut les ACE héritées, qui deviennent des entrées directes déplacé (direct ACE ont priorité sur les ACE héritées). Si un fichier est déplacé entre les volumes, les ACE ne seront pas copiés.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.MoveFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Déplacer un fichier|[Guide pratique pour Déplacer un fichier dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2` et le renomme `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n’est pas valide ou n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation par un autre processus, ou une erreur d’e/s se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Chemin d’accès du fichier à déplacer.</param>
        <param name="destinationFileName">Chemin d’accès du répertoire dans lequel le fichier doit être déplacé.</param>
        <param name="showUI">Spécifie s’il faut suivre visuellement la progression de l’opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Spécifie si une exception est levée lorsque l’utilisateur annule l’opération. La valeur par défaut est <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Déplace un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la structure cible n’existe pas, il est créé.  
  
 Le `MoveFile` méthode conserve les ACE (entrées de contrôle d’accès) uniquement lors du déplacement du fichier dans le même volume. Cela inclut les ACE héritées, qui deviennent des entrées directes déplacé (direct ACE ont priorité sur les ACE héritées). Si un fichier est déplacé entre les volumes, les ACE ne seront pas copiés.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.MoveFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Déplacer un fichier|[Guide pratique pour Déplacer un fichier dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2` et le renomme `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n’est pas valide ou n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation par un autre processus, ou une erreur d’e/s se produit.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="onUserCancel" /> a la valeur <see langword="ThrowException" />et que l’utilisateur a annulé l’opération ou une erreur d’e/s non spécifiée se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFieldParser">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Le <see langword="OpenTextFieldParser" /> méthode vous permet de créer un <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> objet, qui permet d’analyser facilement et efficacement les fichiers texte structurés, tels que les journaux. Le <see langword="TextFieldParser" /> objet peut être utilisé pour lire des fichiers délimités et à largeur fixe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Le fichier à ouvrir avec le <see langword="TextFieldParser" />.</param>
        <summary>La méthode <see langword="OpenTextFieldParser" /> vous permet de créer un objet <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> et d’analyser ainsi efficacement et facilement les fichiers texte structurés, comme les journaux. Le <see langword="TextFieldParser" /> objet peut être utilisé pour lire des fichiers délimités et à largeur fixe.</summary>
        <returns><see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> pour lire le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.OpenTextFieldParser` (méthode).  
  
|À|Voir|  
|-|-|  
|Lire à partir d’un fichier texte délimité|[Guide pratique pour Lire des fichiers texte délimité par des virgules en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire un fichier texte de largeur fixe|[Guide pratique pour Lire des fichiers texte de largeur fixe en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lire un fichier texte avec plusieurs formats|[Guide pratique pour Lire des fichiers texte avec plusieurs Formats en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Cet exemple ouvre le `TextFieldParser.reader` et l’utilise pour lire à partir de `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> a la valeur <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation par un autre processus, ou une erreur d’e/s se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Une ligne ne peut pas être analysée à l’aide du format spécifié. Le message d’exception spécifie la ligne qui provoque l’exception, tandis que la propriété <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> est assignée au texte contenu dans la ligne.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Décrit un ensemble d’autorisations de sécurité appliquées au code. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray fieldWidths As Integer()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * int[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, fieldWidths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Le fichier à ouvrir avec le <see langword="TextFieldParser" />.</param>
        <param name="fieldWidths">Largeur des champs.</param>
        <summary>Le <see langword="OpenTextFieldParser" /> méthode vous permet de créer un <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> objet, qui permet d’analyser facilement et efficacement les fichiers texte structurés, tels que les journaux. Le <see langword="TextFieldParser" /> objet peut être utilisé pour lire des fichiers délimités et à largeur fixe.</summary>
        <returns><see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> pour lire le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.OpenTextFieldParser` (méthode).  
  
|À|Voir|  
|-|-|  
|Lire à partir d’un fichier texte délimité|[Guide pratique pour Lire des fichiers texte délimité par des virgules en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire un fichier texte de largeur fixe|[Guide pratique pour Lire des fichiers texte de largeur fixe en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lire un fichier texte avec plusieurs formats|[Guide pratique pour Lire des fichiers texte avec plusieurs Formats en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Cet exemple ouvre le `TextFieldParser.reader` et l’utilise pour lire à partir de `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> a la valeur <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation par un autre processus, ou une erreur d’e/s se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Une ligne ne peut pas être analysée à l’aide du format spécifié. Le message d’exception spécifie la ligne qui provoque l’exception, tandis que la propriété <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> est assignée au texte contenu dans la ligne.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Décrit un ensemble d’autorisations de sécurité appliquées au code. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray delimiters As String()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * string[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, delimiters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Le fichier à ouvrir avec le <see langword="TextFieldParser" />.</param>
        <param name="delimiters">Séparateurs de champs.</param>
        <summary>Le <see langword="OpenTextFieldParser" /> méthode vous permet de créer un <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> objet, qui permet d’analyser facilement et efficacement les fichiers texte structurés, tels que les journaux. Le <see langword="TextFieldParser" /> objet peut être utilisé pour lire des fichiers délimités et à largeur fixe.</summary>
        <returns><see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> pour lire le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.OpenTextFieldParser` (méthode).  
  
|À|Voir|  
|-|-|  
|Lire à partir d’un fichier texte délimité|[Guide pratique pour Lire des fichiers texte délimité par des virgules en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire un fichier texte de largeur fixe|[Guide pratique pour Lire des fichiers texte de largeur fixe en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lire un fichier texte avec plusieurs formats|[Guide pratique pour Lire des fichiers texte avec plusieurs Formats en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Cet exemple ouvre le `TextFieldParser.reader` et l’utilise pour lire à partir de `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> a la valeur <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation par un autre processus, ou une erreur d’e/s se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Une ligne ne peut pas être analysée à l’aide du format spécifié. Le message d’exception spécifie la ligne qui provoque l’exception, tandis que la propriété <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> est assignée au texte contenu dans la ligne.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Décrit un ensemble d’autorisations de sécurité appliquées au code. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileReader">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un <see cref="T:System.IO.StreamReader" /> objet à lire à partir d’un fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileReader (file As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Fichier à lire.</param>
        <summary>Ouvre un <see cref="T:System.IO.StreamReader" /> objet à lire à partir d’un fichier.</summary>
        <returns><see cref="T:System.IO.StreamReader" /> objet à lire à partir du fichier</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Seuls les fichiers texte peuvent être lus avec un <xref:System.IO.StreamReader>.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.OpenTextFileReader` (méthode).  
  
|À|Voir|  
|-|-|  
|Ouvrir un fichier avec un <xref:System.IO.StreamReader>|[Guide pratique pour Lire le texte à partir de fichiers avec un StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 Cet exemple ouvre le fichier `Testfile.txt`, lit une ligne à partir de celui-ci et l’affiche dans un `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom de fichier se termine par une barre oblique inverse (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier spécifié.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour lire à partir du fichier.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Fichier à lire.</param>
        <param name="encoding">L’encodage à utiliser pour le contenu du fichier. Valeur par défaut est ASCII.</param>
        <summary>Ouvre un <see cref="T:System.IO.StreamReader" /> objet à lire à partir d’un fichier.</summary>
        <returns><see cref="T:System.IO.StreamReader" /> objet à lire à partir du fichier</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Seuls les fichiers texte peuvent être lus avec un <xref:System.IO.StreamReader>.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.OpenTextFileReader` (méthode).  
  
|À|Voir|  
|-|-|  
|Ouvrir un fichier avec un <xref:System.IO.StreamReader>|[Guide pratique pour Lire le texte à partir de fichiers avec un StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 Cet exemple ouvre le fichier `Testfile.txt`, lit une ligne à partir de celui-ci et l’affiche dans un `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom de fichier se termine par une barre oblique inverse (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossible de trouver le fichier spécifié.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour lire à partir du fichier.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileWriter">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un <see cref="T:System.IO.StreamWriter" /> objet à écrire dans le fichier spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileWriter (file As String, append As Boolean) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Fichier dans lequel écrire.</param>
        <param name="append"><see langword="True" /> à ajouter au contenu du fichier ; <see langword="False" /> pour remplacer le contenu du fichier. La valeur par défaut est <see langword="False" />.</param>
        <summary>Ouvre un <see cref="T:System.IO.StreamWriter" /> objet à écrire dans le fichier spécifié.</summary>
        <returns><see cref="T:System.IO.StreamWriter" /> objet à écrire dans le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `OpenTextFileWriter` méthode ouvre et initialise un flux de données pour un fichier et renvoie ensuite le <xref:System.IO.StreamWriter> objet pour ce flux. Vous pouvez écrire dans le flux de données autant de fois que nécessaire et puis le fermer lorsque vous avez terminé.  
  
> [!NOTE]
>  Vous devez appeler la <xref:System.IO.StreamWriter.Close%2A> méthode sur le <xref:System.IO.StreamWriter> objet pour vous assurer que toutes les données sont correctement écrites dans le flux sous-jacent.  
  
 Si vous écrivez uniquement quelques chaînes dans un fichier, il peut être plus simple d’utiliser le <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> (méthode).  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.OpenTextFileWriter` (méthode).  
  
|À|Voir|  
|-|-|  
|Écrire du texte dans un fichier avec un `StreamWriter`|[Guide pratique pour Écrire du texte dans des fichiers à l’aide de StreamWriter dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 Cet exemple ouvre un <xref:System.IO.StreamWriter> avec la `My.Computer.FileSystem.OpenTextFileWriter` (méthode) et l’utilise pour écrire une chaîne dans un fichier texte avec le `WriteLine` méthode de la `StreamWriter` classe.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.ArgumentException">Le nom de fichier se termine par une barre oblique de fin.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool * System.Text.Encoding -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Fichier dans lequel écrire.</param>
        <param name="append"><see langword="True" /> à ajouter au contenu dans le fichier ; <see langword="False" /> pour remplacer le contenu du fichier. La valeur par défaut est <see langword="False" />.</param>
        <param name="encoding">Encodage à utiliser pour l’écriture dans le fichier. Valeur par défaut est ASCII.</param>
        <summary>Ouvre un <see cref="T:System.IO.StreamWriter" /> à écrire dans le fichier spécifié.</summary>
        <returns><see cref="T:System.IO.StreamWriter" /> objet à écrire dans le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `OpenTextFileWriter` méthode ouvre et initialise un flux de données pour un fichier et renvoie ensuite le <xref:System.IO.StreamWriter> objet pour ce flux. Vous pouvez écrire dans le flux de données autant de fois que nécessaire et puis le fermer lorsque vous avez terminé.  
  
> [!NOTE]
>  Vous devez appeler la <xref:System.IO.StreamWriter.Close%2A> méthode sur le <xref:System.IO.StreamWriter> objet pour vous assurer que toutes les données sont correctement écrites dans le flux sous-jacent.  
  
 Si vous écrivez uniquement quelques chaînes dans un fichier, il peut être plus simple d’utiliser le <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> (méthode).  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.OpenTextFileWriter` (méthode).  
  
|À|Voir|  
|-|-|  
|Écrire du texte dans un fichier avec un `StreamWriter`|[Guide pratique pour Écrire du texte dans des fichiers à l’aide de StreamWriter dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 Cet exemple ouvre un <xref:System.IO.StreamWriter> avec la `My.Computer.FileSystem.OpenTextFileWriter` (méthode) et l’utilise pour écrire une chaîne dans un fichier texte avec le `WriteLine` méthode de la `StreamWriter` classe.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.ArgumentException">Le nom de fichier se termine par une barre oblique de fin.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int8[] ReadAllBytes(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (file As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllBytes : string -&gt; byte[]" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Fichier à lire.</param>
        <summary>Retourne le contenu d’un fichier sous la forme d’un tableau d’octets.</summary>
        <returns><see langword="Byte" /> tableau qui contient le contenu du fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ReadAllBytes` méthode de la `My.Computer.FileSystem` objet vous permet de lire à partir d’un fichier binaire. Le contenu du fichier est retourné comme un tableau d’octets.  
  
 Ne vous basez pas sur le nom d'un fichier pour en déterminer le contenu. Par exemple, le fichier Form1.vb peut ne pas être un fichier source Visual Basic. Vérifiez toutes les entrées avant d'utiliser les données dans votre application.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.ReadAllBytes` (méthode).  
  
|À|Voir|  
|-|-|  
|Lire à partir d'un fichier binaire|[Guide pratique pour Lire des fichiers binaires en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
  
   
  
## Examples  
 Cet exemple lit à partir du fichier `C:/Documents and Settings/selfportrait.jpg.`  
  
 [!code-vb[VbVbcnMyFileSystem#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> a la valeur <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation par un autre processus, ou une erreur d’e/s se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n’est pas suffisamment de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne le contenu d’un fichier texte comme un <see langword="String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (file As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d’accès du fichier à lire.</param>
        <summary>Retourne le contenu d’un fichier texte comme un <see langword="String" />.</summary>
        <returns><see langword="String" /> contenant le contenu du fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode `ReadAllText` de l'objet `My.Computer.FileSystem` vous permet de lire un fichier texte. Le contenu du fichier est retourné sous forme de chaîne.  
  
 L’encodage du fichier peut être spécifié si le contenu du fichier dans un encodage ASCII ou UTF-8. Si vous lisez à partir d’un fichier avec des caractères étendus, vous devez spécifier l’encodage du fichier à l’aide d’une autre surcharge de la <xref:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText%2A> (méthode).  
  
 Ne vous basez pas sur le nom d'un fichier pour en déterminer le contenu. Par exemple, le fichier Form1.vb peut ne pas être un fichier source Visual Basic. Vérifiez toutes les entrées avant d'utiliser les données dans votre application.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.ReadAllText` (méthode).  
  
|À|Voir|  
|-|-|  
|Lire à partir d'un fichier texte|[Guide pratique pour Lire des fichiers texte dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Cet exemple lit le contenu de `Test.txt` dans une chaîne puis l’affiche dans une boîte de message.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Cet exemple lit le contenu du fichier ASCII `Test.txt` dans une chaîne puis l’affiche dans une boîte de message.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> a la valeur <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation par un autre processus, ou une erreur d’e/s se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n’est pas suffisamment de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string * System.Text.Encoding -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d’accès du fichier à lire.</param>
        <param name="encoding">Encodage de caractères à utiliser lors de la lecture du fichier. Valeur par défaut est UTF-8.</param>
        <summary>Retourne le contenu d’un fichier texte comme un <see langword="String" />.</summary>
        <returns><see langword="String" /> contenant le contenu du fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode `ReadAllText` de l'objet `My.Computer.FileSystem` vous permet de lire un fichier texte. Le contenu du fichier est retourné sous forme de chaîne.  
  
 L’encodage du fichier peut être spécifié si le contenu du fichier dans un encodage ASCII ou UTF-8. Si vous lisez à partir d’un fichier avec des caractères étendus, vous devez spécifier l’encodage du fichier.  
  
 Ne vous basez pas sur le nom d'un fichier pour en déterminer le contenu. Par exemple, le fichier Form1.vb peut ne pas être un fichier source Visual Basic. Vérifiez toutes les entrées avant d'utiliser les données dans votre application.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.ReadAllText` (méthode).  
  
|À|Voir|  
|-|-|  
|Lire à partir d'un fichier texte|[Guide pratique pour Lire des fichiers texte dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Cet exemple lit le contenu de `Test.txt` dans une chaîne puis l’affiche dans une boîte de message.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Cet exemple lit le contenu du fichier ASCII `Test.txt` dans une chaîne puis l’affiche dans une boîte de message.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> a la valeur <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation par un autre processus, ou une erreur d’e/s se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n’est pas suffisamment de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="RenameDirectory">
      <MemberSignature Language="C#" Value="public static void RenameDirectory (string directory, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameDirectory(string directory, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameDirectory (directory As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameDirectory(System::String ^ directory, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory (directory, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Chemin d’accès et nom du répertoire à renommer.</param>
        <param name="newName">Nouveau nom de répertoire.</param>
        <summary>Renomme un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne peut pas être utilisée pour déplacer un répertoire ; utiliser le `MoveDirectory` méthode pour déplacer et renommer le répertoire.  
  
   
  
## Examples  
 Cet exemple renomme la `Test` répertoire à `SecondTest`.  
  
 [!code-vb[VbVbcnMyFileSystem#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newName" /> contient des informations de chemin d’accès.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> a la valeur <see langword="Nothing" />.  
  
ou 
 <paramref name="newName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Il existe un fichier ou répertoire existant portant le nom spécifié dans <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur n’a pas l’autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory" />
      </Docs>
    </Member>
    <Member MemberName="RenameFile">
      <MemberSignature Language="C#" Value="public static void RenameFile (string file, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameFile(string file, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameFile (file As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameFile(System::String ^ file, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameFile (file, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Fichier à renommer.</param>
        <param name="newName">Nouveau nom de fichier.</param>
        <summary>Renomme un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne peut pas être utilisée pour déplacer un fichier. Utilisez la méthode <xref:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile%2A> pour déplacer et renommer le fichier.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.RenameFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Renommer un fichier|[Guide pratique pour Renommer un fichier en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
  
   
  
## Examples  
 Cet exemple renomme le fichier `Test.txt` à `SecondTest.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#1)]  
  
 Modification «`C:\Test.txt`» pour le chemin d’accès et le nom du fichier que vous souhaitez renommer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newName" /> contient des informations relatives au chemin d’accès ou se termine par une barre oblique inverse (\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> a la valeur <see langword="Nothing" />.  
  
ou 
 <paramref name="newName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le répertoire n’existe pas.</exception>
        <exception cref="T:System.IO.IOException">Il existe un fichier ou répertoire existant portant le nom spécifié dans <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’utilisateur n’a pas l’autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string file, byte[] data, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes(System.String,System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (file As String, data As Byte(), append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ file, cli::array &lt;System::Byte&gt; ^ data, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllBytes : string * byte[] * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes (file, data, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Chemin d’accès et nom du fichier dans lequel écrire.</param>
        <param name="data">Données à écrire dans le fichier.</param>
        <param name="append"><see langword="True" /> à ajouter au contenu du fichier ; <see langword="False" /> pour remplacer le contenu du fichier. La valeur par défaut est <see langword="False" />.</param>
        <summary>Écrit des données dans un fichier binaire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le chemin d’accès spécifié, à l’exclusion du nom de fichier n’est pas valide, un <xref:System.IO.DirectoryNotFoundException> exception sera levée. Si le chemin d’accès est valide, mais le fichier n’existe pas, le fichier est créé.  
  
> [!NOTE]
>  Le `WriteAllBytes` méthode ouvre un fichier, écrit dedans, puis ferme ce dernier. Code qui utilise le `WriteAllBytes` méthode est plus simple que le code qui utilise un <xref:System.IO.BinaryWriter> objet. Toutefois, si vous ajoutez des données dans un fichier à l’aide d’une boucle, une <xref:System.IO.BinaryWriter> objet peut offrir de meilleures performances, car vous devez uniquement ouvrir et fermer le fichier une seule fois.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.WriteAllBytes` (méthode).  
  
|À|Voir|  
|-|-|  
|Écrire dans un fichier binaire|[Guide pratique pour Écrire dans des fichiers binaires en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
  
   
  
## Examples  
 Cet exemple ajoute le tableau de données `CustomerData` au fichier `CollectedData`.  
  
 [!code-vb[VbVbcnMyFileSystem#50](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> a la valeur <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation par un autre processus, ou une erreur d’e/s se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n’est pas suffisamment de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit du texte dans un fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (file As String, text As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Fichier dans lequel écrire.</param>
        <param name="text">Texte à écrire dans le fichier.</param>
        <param name="append"><see langword="True" /> à ajouter au contenu du fichier ; <see langword="False" /> pour remplacer le contenu du fichier.</param>
        <summary>Écrit du texte dans un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’encodage UTF-8 est utilisé pour écrire dans le fichier. Pour spécifier un encodage différent, utilisez une autre surcharge de la <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> (méthode).  
  
 Si le fichier spécifié n’existe pas, il est créé.  
  
 Si l’encodage spécifié ne correspond pas au codage existant du fichier, le codage spécifié est ignoré.  
  
> [!NOTE]
>  Le `WriteAllText` méthode ouvre un fichier, écrit dedans, puis ferme ce dernier. Code qui utilise le `WriteAllText` méthode est plus simple que le code qui utilise un <xref:System.IO.StreamWriter> objet. Toutefois, si vous ajoutez des chaînes dans un fichier à l’aide d’une boucle, une <xref:System.IO.StreamWriter> objet peut offrir de meilleures performances, car vous devez uniquement ouvrir et fermer le fichier une seule fois. Pour plus d'informations, voir la méthode <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.WriteAllText` (méthode).  
  
|À|Voir|  
|-|-|  
|Écrire du texte dans un fichier|[Guide pratique pour Écrire du texte dans des fichiers en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Ajouter du texte dans un fichier|[Guide pratique pour Ajout à des fichiers texte dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 Cet exemple écrit la ligne `"This is new text to be added."` au fichier `Test.txt`, remplace le texte existant dans le fichier.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 Cet exemple écrit les noms des fichiers dans le `Documents and Settings` dossier `FileList.txt`, insère un retour chariot entre chacun d’eux pour une meilleure lisibilité.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> a la valeur <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation par un autre processus, ou une erreur d’e/s se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n’est pas suffisamment de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool * System.Text.Encoding -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Fichier dans lequel écrire.</param>
        <param name="text">Texte à écrire dans le fichier.</param>
        <param name="append"><see langword="True" /> à ajouter au contenu du fichier ; <see langword="False" /> pour remplacer le contenu du fichier.</param>
        <param name="encoding">Le codage à utiliser lors de l’écriture dans le pour fichier.</param>
        <summary>Écrit du texte dans un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le fichier spécifié n’existe pas, il est créé.  
  
 Si l’encodage spécifié ne correspond pas au codage existant du fichier, le codage spécifié est ignoré.  
  
> [!NOTE]
>  Le `WriteAllText` méthode ouvre un fichier, écrit dedans, puis ferme ce dernier. Code qui utilise le `WriteAllText` méthode est plus simple que le code qui utilise un <xref:System.IO.StreamWriter> objet. Toutefois, si vous ajoutez des chaînes dans un fichier à l’aide d’une boucle, une <xref:System.IO.StreamWriter> objet peut offrir de meilleures performances, car vous devez uniquement ouvrir et fermer le fichier une seule fois. Pour plus d'informations, voir la méthode <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.WriteAllText` (méthode).  
  
|À|Voir|  
|-|-|  
|Écrire du texte dans un fichier|[Guide pratique pour Écrire du texte dans des fichiers en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Ajouter du texte dans un fichier|[Guide pratique pour Ajout à des fichiers texte dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 Cet exemple écrit la ligne `"This is new text to be added."` au fichier `Test.txt`, remplace le texte existant dans le fichier.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 Cet exemple écrit les noms des fichiers dans le `Documents and Settings` dossier `FileList.txt`, insère un retour chariot entre chacun d’eux pour une meilleure lisibilité.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> a la valeur <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d’utilisation par un autre processus, ou une erreur d’e/s se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou répertoire dans le chemin d’accès contient un signe deux-points ( :)) ou est dans un format non valide.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n’est pas suffisamment de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur ne dispose pas des autorisations nécessaires pour afficher le chemin d’accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
  </Members>
</Type>
