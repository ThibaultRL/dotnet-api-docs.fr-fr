<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileIO.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d1e0c04b5245a93699d8ea4005cf9c2bff263e76" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36727623" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileIO.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit des propriétés et des méthodes destinées à être utilisées avec les lecteurs, les fichiers et les répertoires.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem` objet.  
  
|À|Voir|  
|-|-|  
|Lire à partir d'un fichier texte|[Guide pratique : lire à partir de fichiers texte](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
|Lire à partir d’un fichier texte délimité|[Guide pratique : lire des fichiers texte délimités par des virgules](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire un fichier texte de largeur fixe|[Guide pratique : lire des fichiers texte de largeur fixe](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lire à partir d’un fichier texte avec plusieurs formats|[Guide pratique : lire des fichiers texte avec plusieurs formats](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
|Lire à partir d'un fichier binaire|[Guide pratique : lire des fichiers binaires](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
|Lire à partir d’un fichier texte avec un <xref:System.IO.StreamReader>|[Guide pratique : lire le texte des fichiers avec un StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
|Écrire dans un fichier texte|[Guide pratique : insérer du texte dans des fichiers](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Ajouter à un fichier texte|[Guide pratique : effectuer un ajout à des fichiers texte](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
|Écrire dans un fichier binaire|[Guide pratique : écrire dans des fichiers binaires](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
|Écrire dans des fichiers texte dans le **Mes documents** Active|[Guide pratique : insérer du texte dans les fichiers du répertoire Mes Documents](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-in-the-my-documents-directory.md)|  
|Écrire dans un fichier texte avec un `StreamWriter`|[Guide pratique : écrire du texte dans des fichiers à l'aide de Streamwriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
|Copier des fichiers avec un modèle spécifique|[Guide pratique : copier des fichiers avec un modèle spécifique dans un répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md)|  
|Copier un fichier dans le même répertoire|[Guide pratique : créer une copie d'un fichier dans le même répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copier un fichier vers un autre répertoire|[Guide pratique : créer une copie d'un fichier dans un autre répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
|Créer un fichier|[Guide pratique : créer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-file.md)|  
|Supprimer un fichier|[Guide pratique : supprimer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
|Rechercher des fichiers avec un modèle spécifique|[Guide pratique : rechercher des fichiers avec un modèle spécifique](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
|Déplacer un fichier|[Guide pratique : déplacer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
|Renommer un fichier|[Guide pratique : renommer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
|Copier un répertoire vers un autre répertoire|[Guide pratique : copier un répertoire vers un autre répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
|Créer un répertoire|[Guide pratique : créer un répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
|Rechercher des sous-répertoires avec un modèle spécifique|[Guide pratique pour rechercher des sous-répertoires avec un modèle spécifique](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
|Obtenir la collection des fichiers dans un répertoire|[Guide pratique pour placer la collection de fichiers dans un répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Lire à partir de la **Mes documents** Active|[Guide pratique : récupérer le contenu du répertoire Mes Documents](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-retrieve-the-contents-of-the-my-documents-directory.md)|  
|Analyser un chemin d’accès de fichier|[Guide pratique pour analyser des chemins](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Cet exemple montre comment pour déterminer si le dossier `C:\backup\logs` existe et vérifie ses propriétés.  
  
 [!code-vb[VbVbcnMyFileSystem#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#23)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystem ();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [Objets (Visual Basic)](http://msdn.microsoft.com/library/651c73e4-dca8-402b-9c6b-e3902b3a3f4b)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CombinePath">
      <MemberSignature Language="C#" Value="public static string CombinePath (string baseDirectory, string relativePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CombinePath(string baseDirectory, string relativePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CombinePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CombinePath (baseDirectory As String, relativePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CombinePath(System::String ^ baseDirectory, System::String ^ relativePath);" />
      <MemberSignature Language="F#" Value="static member CombinePath : string * string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CombinePath (baseDirectory, relativePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseDirectory" Type="System.String" />
        <Parameter Name="relativePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseDirectory">
          <see langword="String" />. Premier chemin d'accès à combiner.</param>
        <param name="relativePath">
          <see langword="String" />. Deuxième chemin d'accès à combiner.</param>
        <summary>Associe deux chemins d'accès et retourne un chemin d'accès correctement mis en forme.</summary>
        <returns>Combinaison des chemins d'accès spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode supprime les caractères de barre oblique excédentaires-pour créer un chemin d’accès au format correct.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.CombinePath` (méthode).  
  
|À|Voir|  
|-|-|  
|Associer un nom de fichier et le chemin de répertoire|[Comment : analyser des chemins d’accès dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Cet exemple associe un nom de chemin d’accès et de répertoire pour créer un chemin d’accès au format correct.  
  
 [!code-vb[VbRefFile#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#3)]  
  
 Cet exemple combine deux chemins d’accès pour créer un chemin d’accès au format correct.  
  
 [!code-vb[VbRefFile#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#4)]  
  
 Cet exemple retourne `C:\Dir1\Dir2\Dir4\Dir5\File.txt`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseDirectory" /> ou <paramref name="relativePath" /> sont des chemins d'accès incorrects.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie le contenu d'un répertoire dans un autre répertoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Répertoire à copier.</param>
        <param name="destinationDirectoryName">Emplacement dans lequel le contenu du répertoire doit être copié.</param>
        <summary>Copie le contenu d'un répertoire dans un autre répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie le contenu du répertoire source vers le répertoire cible. Si le répertoire cible n’existe pas, il est créé. Si un répertoire portant le même nom existe dans l’emplacement cible, le contenu des deux annuaires est fusionné. Vous pouvez spécifier un nouveau nom pour le répertoire pendant l’opération.  
  
 Lors de la copie des fichiers dans un répertoire, exceptions peuvent être levées qui sont provoquées par un fichier spécifique. Lorsque ces exceptions sont levées, elles sont consolidées en une seule exception dont `Data` propriété comporte des entrées sous la forme d’une <xref:System.Collections.IDictionary> dans laquelle le chemin d’accès du fichier ou répertoire est la clé et le message d’exception spécifique est contenu dans le valeur correspondante. Utilisez `For…Each` pour énumérer les entrées.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.CopyDirectory` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un répertoire|[Comment : copier un répertoire vers un autre répertoire dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 L’exemple suivant copie le contenu du répertoire `TestDirectory1` dans `TestDirectory2`, remplaçant les fichiers existants.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Remplacez `C:\TestDirectory1` et `C:\TestDirectory2` avec le chemin d’accès et le nom du répertoire à copier et l’emplacement auquel vous souhaitez le copier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire source n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le chemin source et le chemin cible sont identiques.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un fichier de destination existe mais est inaccessible.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Répertoire à copier.</param>
        <param name="destinationDirectoryName">Emplacement dans lequel le contenu du répertoire doit être copié.</param>
        <param name="showUI">Indique si un suivi visuel de l'avancement de l'opération est nécessaire. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Copie le contenu d'un répertoire dans un autre répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie le contenu du répertoire source vers le répertoire cible. Si le répertoire cible n’existe pas, il est créé. Si un répertoire portant le même nom existe dans l’emplacement cible, le contenu des deux annuaires est fusionné. Vous pouvez spécifier un nouveau nom pour le répertoire pendant l’opération.  
  
 Lors de la copie des fichiers dans un répertoire, exceptions peuvent être levées qui sont provoquées par un fichier spécifique. Lorsque ces exceptions sont levées, elles sont consolidées en une seule exception dont `Data` propriété comporte des entrées sous la forme d’une <xref:System.Collections.IDictionary> dans laquelle le chemin d’accès du fichier ou répertoire est la clé et le message d’exception spécifique est contenu dans le valeur correspondante. Utilisez `For…Each` pour énumérer les entrées.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.CopyDirectory` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un répertoire|[Comment : copier un répertoire vers un autre répertoire dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 L’exemple suivant copie le contenu du répertoire `TestDirectory1` dans `TestDirectory2`, remplaçant les fichiers existants.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Remplacez `C:\TestDirectory1` et `C:\TestDirectory2` avec le chemin d’accès et le nom du répertoire à copier et l’emplacement auquel vous souhaitez le copier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire source n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le chemin source et le chemin cible sont identiques.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un fichier de destination existe mais est inaccessible.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="ShowUI" /> a la valeur <see langword="UIOption.AllDialogs" /> et l'utilisateur annule l'opération, ou un ou plusieurs fichiers du répertoire ne peuvent pas être copiés.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Répertoire à copier.</param>
        <param name="destinationDirectoryName">Emplacement dans lequel le contenu du répertoire doit être copié.</param>
        <param name="overwrite">
          <see langword="True" /> pour remplacer les fichiers existants ; sinon, <see langword="False" />. La valeur par défaut est <see langword="False" />.</param>
        <summary>Copie le contenu d'un répertoire dans un autre répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie le contenu du répertoire source vers le répertoire cible. Si le répertoire cible n’existe pas, il est créé. Si un répertoire portant le même nom existe dans l’emplacement cible, le contenu des deux annuaires est fusionné. Vous pouvez spécifier un nouveau nom pour le répertoire pendant l’opération.  
  
 Lors de la copie des fichiers dans un répertoire, exceptions peuvent être levées qui sont provoquées par un fichier spécifique, tel qu’un fichier existant au cours d’une fusion alors que `overwrite` a la valeur `False`. Lorsque ces exceptions sont levées, elles sont consolidées en une seule exception dont `Data` propriété comporte des entrées sous la forme d’une <xref:System.Collections.IDictionary> dans laquelle le chemin d’accès du fichier ou répertoire est la clé et le message d’exception spécifique est contenu dans le valeur correspondante. Utilisez `For…Each` pour énumérer les entrées.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.CopyDirectory` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un répertoire|[Comment : copier un répertoire vers un autre répertoire dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 L’exemple suivant copie le contenu du répertoire `TestDirectory1` dans `TestDirectory2`, remplaçant les fichiers existants.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Remplacez `C:\TestDirectory1` et `C:\TestDirectory2` avec le chemin d’accès et le nom du répertoire à copier et l’emplacement auquel vous souhaitez le copier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire source n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le chemin source et le chemin cible sont identiques.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un fichier de destination existe mais est inaccessible.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Répertoire à copier.</param>
        <param name="destinationDirectoryName">Emplacement dans lequel le contenu du répertoire doit être copié.</param>
        <param name="showUI">Indique si un suivi visuel de l'avancement de l'opération est nécessaire. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Indique ce qu’il convient de faire si l’utilisateur clique sur **Annuler** pendant l’opération. La valeur par défaut est <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Copie le contenu d'un répertoire dans un autre répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie le contenu du répertoire source vers le répertoire cible. Si le répertoire cible n’existe pas, il est créé. Si un répertoire portant le même nom existe dans l’emplacement cible, le contenu des deux annuaires est fusionné. Vous pouvez spécifier un nouveau nom pour le répertoire pendant l’opération.  
  
 Lors de la copie des fichiers dans un répertoire, exceptions peuvent être levées qui sont provoquées par un fichier spécifique. Lorsque ces exceptions sont levées, elles sont consolidées en une seule exception dont `Data` propriété comporte des entrées sous la forme d’une <xref:System.Collections.IDictionary> dans laquelle le chemin d’accès du fichier ou répertoire est la clé et le message d’exception spécifique est contenu dans le valeur correspondante. Utilisez `For…Each` pour énumérer les entrées.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.CopyDirectory` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un répertoire|[Comment : copier un répertoire vers un autre répertoire dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 L’exemple suivant copie le contenu du répertoire `TestDirectory1` dans `TestDirectory2`, remplaçant les fichiers existants.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Remplacez `C:\TestDirectory1` et `C:\TestDirectory2` avec le chemin d’accès et le nom du répertoire à copier et l’emplacement auquel vous souhaitez le copier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire source n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le chemin source et le chemin cible sont identiques.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un fichier de destination existe mais est inaccessible.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="ShowUI" /> a la valeur <see langword="UIOption.AllDialogs" /> et l'utilisateur annule l'opération, ou un ou plusieurs fichiers du répertoire ne peuvent pas être copiés.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie un fichier vers un nouvel emplacement.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Fichier à copier.</param>
        <param name="destinationFileName">Emplacement vers lequel le fichier doit être copié.</param>
        <summary>Copie un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ne conserve pas l’ACE (entrées de contrôle d’accès). Le fichier nouvellement créé hérite des ACE par défaut à partir du répertoire dans lequel il est créé.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un fichier dans le même répertoire.|[Comment : créer une copie d’un fichier dans le même répertoire dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copier un fichier vers un autre répertoire.|[Comment : créer une copie d’un fichier dans un autre répertoire dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` sans remplacer les fichiers existants.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Remplacez les chemins d’accès de fichier avec les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` et le renomme `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Remplacez les chemins d’accès de fichier avec les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contient des informations de chemin d’accès.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Un fichier du répertoire cible portant le même nom est en cours d'utilisation.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la possibilité d’accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Fichier à copier.</param>
        <param name="destinationFileName">Emplacement vers lequel le fichier doit être copié.</param>
        <param name="showUI">Indique si un suivi visuel de l'avancement de l'opération est nécessaire. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Copie un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ne conserve pas l’ACE (entrées de contrôle d’accès). Le fichier nouvellement créé hérite des ACE par défaut à partir du répertoire dans lequel il est créé.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un fichier dans le même répertoire.|[Comment : créer une copie d’un fichier dans le même répertoire dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copier un fichier vers un autre répertoire.|[Comment : créer une copie d’un fichier dans un autre répertoire dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` sans remplacer les fichiers existants.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Remplacez les chemins d’accès de fichier avec les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` et le renomme `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Remplacez les chemins d’accès de fichier avec les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contient des informations de chemin d’accès.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier de destination existe et <paramref name="overwrite" /> a la valeur <see langword="False" /> ().</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la possibilité d’accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Fichier à copier.</param>
        <param name="destinationFileName">Emplacement vers lequel le fichier doit être copié.</param>
        <param name="overwrite">
          <see langword="True" /> si les fichiers existants doivent être remplacés ; sinon, <see langword="False" />. La valeur par défaut est <see langword="False" />.</param>
        <summary>Copie un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ne conserve pas l’ACE (entrées de contrôle d’accès). Le fichier nouvellement créé hérite des ACE par défaut à partir du répertoire dans lequel il est créé.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un fichier dans le même répertoire.|[Comment : créer une copie d’un fichier dans le même répertoire dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copier un fichier vers un autre répertoire.|[Comment : créer une copie d’un fichier dans un autre répertoire dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` sans remplacer les fichiers existants.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Remplacez les chemins d’accès de fichier avec les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` et le renomme `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Remplacez les chemins d’accès de fichier avec les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contient des informations de chemin d’accès.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier de destination existe et <paramref name="overwrite" /> a la valeur <see langword="False" /> ().</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la possibilité d’accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CopyFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Fichier à copier.</param>
        <param name="destinationFileName">Emplacement vers lequel le fichier doit être copié.</param>
        <param name="showUI">Indique si un suivi visuel de l'avancement de l'opération est nécessaire. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Indique ce qu’il convient de faire si l’utilisateur clique sur **Annuler** pendant l’opération. La valeur par défaut est <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Copie un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ne conserve pas l’ACE (entrées de contrôle d’accès). Le fichier nouvellement créé hérite des ACE par défaut à partir du répertoire dans lequel il est créé.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Copier un fichier dans le même répertoire.|[Comment : créer une copie d’un fichier dans le même répertoire dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copier un fichier vers un autre répertoire.|[Comment : créer une copie d’un fichier dans un autre répertoire dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` sans remplacer les fichiers existants.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Remplacez les chemins d’accès de fichier avec les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` et le renomme `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Remplacez les chemins d’accès de fichier avec les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contient des informations de chemin d’accès.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier de destination existe et <paramref name="overwrite" /> a la valeur <see langword="False" /> ().</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="UICancelOption" /> a la valeur <see langword="ThrowException" /> et l'utilisateur a annulé l'opération ou une erreur d'E/S non spécifiée s'est produit.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la possibilité d’accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static void CreateDirectory (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CreateDirectory(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateDirectory (directory As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDirectory(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Nom et emplacement du répertoire.</param>
        <summary>Crée un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le répertoire existe déjà, aucune exception n’est levée.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.CreateDirectory` (méthode).  
  
|À|Voir|  
|-|-|  
|Créer un répertoire|[Comment : créer un répertoire dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
  
   
  
## Examples  
 Cet exemple crée le répertoire, `NewDirectory`, dans `C:\Documents and Settings\All Users\Documents`.  
  
 [!code-vb[VbVbcnMyFileSystem#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le format du nom du répertoire est incorrect. Par exemple, il contient des caractères non valides ou se compose uniquement d'espace blanc.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le nom de répertoire est trop long.</exception>
        <exception cref="T:System.NotSupportedException">Le nom du répertoire se compose uniquement du signe deux-points (:).</exception>
        <exception cref="T:System.IO.IOException">Le répertoire parent du répertoire à créer est en lecture seule.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'est pas autorisé à créer le répertoire.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:System.IO.Directory.CreateDirectory(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le répertoire actif.</summary>
        <value>Répertoire actif pour les opérations d'E/S de fichier.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CurrentDirectory` est une variable d’environnement système.  
  
   
  
## Examples  
 Cet exemple retourne le répertoire actif et l’affiche dans une boîte de message.  
  
 [!code-vb[VbVbcnMyFileSystem#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#18)]  
  
 Cet exemple définit le répertoire actuel `C:\TestDirectory`.  
  
 [!code-vb[VbVbcnMyFileSystem#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d'accès n'est pas valide.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime un répertoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.DeleteDirectoryOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, onDirectoryNotEmpty As DeleteDirectoryOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.DeleteDirectoryOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, onDirectoryNotEmpty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="onDirectoryNotEmpty" Type="Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Parameters>
      <Docs>
        <param name="directory">Répertoire à supprimer.</param>
        <param name="onDirectoryNotEmpty">Spécifie l'opération à effectuer lorsqu'un répertoire à supprimer contient des fichiers ou des répertoires. La valeur par défaut est <see langword="DeleteDirectoryOption.DeleteAllContents" />.</param>
        <summary>Supprime un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple supprime le répertoire `OldDirectory` uniquement s’il est vide.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, demandant à l’utilisateur à confirmer la suppression, mais n’envoie pas le contenu à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, en les envoyant à la **Corbeille**, mais n’affiche ne pas la progression de l’opération.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d'accès est une chaîne de longueur nulle, est incorrect, se compose uniquement d'espace blanc ou contient des caractères incorrects (y compris des caractères génériques). Le chemin d’accès est un chemin d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas ou est un fichier.</exception>
        <exception cref="T:System.IO.IOException">Un fichier du répertoire ou du sous-répertoire est en cours d'utilisation.</exception>
        <exception cref="T:System.NotSupportedException">Le nom de répertoire contient un signe deux points (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises.</exception>
        <exception cref="T:System.OperationCanceledException">L'utilisateur annule l'opération ou le répertoire ne peut pas être supprimé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="directory">Répertoire à supprimer.</param>
        <param name="showUI">Spécifie s'il faut effectuer un suivi visuel de l'avancement de l'opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Spécifie si le fichier supprimé doit être ou non envoyé à la **Corbeille**. La valeur par défaut est <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Supprime un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `showUI` et `recycle` paramètres ne sont pas pris en charge dans les applications qui ne sont pas utilisateur interactif, telles que les Services Windows.  
  
   
  
## Examples  
 L’exemple supprime le répertoire `OldDirectory` uniquement s’il est vide.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, demandant à l’utilisateur à confirmer la suppression, mais n’envoie pas le contenu à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, en les envoyant à la **Corbeille**, mais n’affiche ne pas la progression de l’opération.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d'accès est une chaîne de longueur nulle, est incorrect, se compose uniquement d'espace blanc ou contient des caractères incorrects (y compris des caractères génériques). Le chemin d’accès est un chemin d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas ou est un fichier.</exception>
        <exception cref="T:System.IO.IOException">Un fichier du répertoire ou du sous-répertoire est en cours d'utilisation.</exception>
        <exception cref="T:System.NotSupportedException">Le nom de répertoire contient un signe deux points (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises.</exception>
        <exception cref="T:System.OperationCanceledException">L'utilisateur annule l'opération ou le répertoire ne peut pas être supprimé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory (directory, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="directory">Répertoire à supprimer.</param>
        <param name="showUI">Spécifie s'il faut effectuer un suivi visuel de l'avancement de l'opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Spécifie si le fichier supprimé doit être ou non envoyé à la **Corbeille**. La valeur par défaut est <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Spécifie si une exception doit être levée quand l’utilisateur clique sur **Annuler**.</param>
        <summary>Supprime un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `showUI`, `recycle`, et `onUserCancel` paramètres ne sont pas pris en charge dans les applications qui ne sont pas utilisateur interactif, telles que les Services Windows.  
  
   
  
## Examples  
 L’exemple supprime le répertoire `OldDirectory` uniquement s’il est vide.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, demandant à l’utilisateur à confirmer la suppression, mais n’envoie pas le contenu à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, en les envoyant à la **Corbeille**, mais n’affiche ne pas la progression de l’opération.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d'accès est une chaîne de longueur nulle, est incorrect, se compose uniquement d'espace blanc ou contient des caractères incorrects (y compris des caractères génériques). Le chemin d’accès est un chemin d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas ou est un fichier.</exception>
        <exception cref="T:System.IO.IOException">Un fichier du répertoire ou du sous-répertoire est en cours d'utilisation.</exception>
        <exception cref="T:System.NotSupportedException">Le nom de répertoire contient un signe deux points (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises.</exception>
        <exception cref="T:System.OperationCanceledException">L'utilisateur annule l'opération ou le répertoire ne peut pas être supprimé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime un fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d'accès du fichier à supprimer.</param>
        <summary>Supprime un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.DeleteFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Pour supprimer un fichier|[Comment : supprimer un fichier dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Cet exemple supprime le fichier `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Cet exemple supprime le fichier `Test.txt` et autorise l’utilisateur à confirmer que le fichier doit être supprimé.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Cet exemple supprime le fichier `Test.txt` et l’envoie à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d’accès n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il contient une barre oblique finale alors qu’un fichier doit être spécifié ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d'utilisation.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation nécessaire pour supprimer le fichier ou le fichier est en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d'accès du fichier à supprimer.</param>
        <param name="showUI">Indique si un suivi visuel de l'avancement de l'opération est nécessaire. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Spécifie si le fichier supprimé doit être envoyé à la **Corbeille**. La valeur par défaut est <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Supprime un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `showUI` et `recycle` paramètres ne sont pas pris en charge dans les applications qui ne sont pas utilisateur interactif, telles que les Services Windows.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.DeleteFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Pour supprimer un fichier|[Comment : supprimer un fichier dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Cet exemple supprime le fichier `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Cet exemple supprime le fichier `Test.txt` et autorise l’utilisateur à confirmer que le fichier doit être supprimé.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Cet exemple supprime le fichier `Test.txt` et l’envoie à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d’accès n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il contient une barre oblique finale alors qu’un fichier doit être spécifié ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d'utilisation.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation nécessaire pour supprimer le fichier ou le fichier est en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile (file, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d'accès du fichier à supprimer.</param>
        <param name="showUI">Indique si un suivi visuel de l'avancement de l'opération est nécessaire. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Spécifie si le fichier supprimé doit être envoyé à la **Corbeille**. La valeur par défaut est <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Spécifie si oui ou non une exception est levée lorsque l'utilisateur annule l'opération. La valeur par défaut est <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Supprime un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `showUI`, `recycle`, et `onUserCancel` paramètres ne sont pas pris en charge dans les applications qui ne sont pas utilisateur interactif, telles que les Services Windows.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.DeleteFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Pour supprimer un fichier|[Comment : supprimer un fichier dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Cet exemple supprime le fichier `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Cet exemple supprime le fichier `Test.txt` et autorise l’utilisateur à confirmer que le fichier doit être supprimé.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Cet exemple supprime le fichier `Test.txt` et l’envoie à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d’accès n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il contient une barre oblique finale alors qu’un fichier doit être spécifié ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d'utilisation.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation nécessaire pour supprimer le fichier ou le fichier est en lecture seule.</exception>
        <exception cref="T:System.OperationCanceledException">L'utilisateur a annulé l'opération et <paramref name="onUserCancel" /> a la valeur <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public static bool DirectoryExists (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool DirectoryExists(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DirectoryExists (directory As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DirectoryExists(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member DirectoryExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Chemin d'accès du répertoire.</param>
        <summary>Retourne la valeur <see langword="True" /> si le répertoire spécifié existe.</summary>
        <returns>
          <see langword="True" /> si le répertoire existe ; sinon <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple détermine si le répertoire `C:\backup\logs` existe et vérifie ses propriétés.  
  
 [!code-vb[VbRefFile#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Drives">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt; Drives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.DriveInfo&gt; Drives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Drives As ReadOnlyCollection(Of DriveInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ Drives { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Drives : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne une collection en lecture seule de tous les noms de lecteurs disponibles.</summary>
        <value>Collection en lecture seule de tous les lecteurs disponibles en tant qu'objets <see cref="T:System.IO.DriveInfo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne tous les lecteurs logiques.  
  
   
  
## Examples  
 Cet exemple affiche les noms de lecteur disponible dans une boîte de message.  
  
 [!code-vb[VbRefFile#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None" />
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public static bool FileExists (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool FileExists(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FileExists (file As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FileExists(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member FileExists : string -&gt; bool" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FileExists file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d'accès du fichier.</param>
        <summary>Retourne la valeur <see langword="True" /> si le fichier spécifié existe.</summary>
        <returns>Retourne <see langword="True" /> si le fichier existe ; sinon, cette méthode retourne <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’application ne dispose pas des autorisations suffisantes pour lire le fichier spécifié, la `FileExists` méthode retourne `False`, indépendamment de l’existence du chemin ; la méthode ne lève pas une exception.  
  
   
  
## Examples  
 Cet exemple vérifie si le fichier `Check.txt` existe et fournit les informations dans une boîte de message.  
  
 [!code-vb[VbRefFile#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom du fichier se termine par une barre oblique inverse (\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FindInFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une collection en lecture seule de chaînes qui représentent le nom des fichiers contenant le texte spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="directory">Répertoire dans lequel effectuer la recherche.</param>
        <param name="containsText">Texte de la recherche.</param>
        <param name="ignoreCase">
          <see langword="True" /> si la recherche doit respecter la casse ; sinon, <see langword="False" />. La valeur par défaut est <see langword="True" />.</param>
        <param name="searchType">Inclure, ou non, les sous-dossiers. La valeur par défaut est <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <summary>Retourne une collection en lecture seule de chaînes qui représentent le nom des fichiers contenant le texte spécifié.</summary>
        <returns>Collection en lecture seule des noms des fichiers contenant le texte spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection vide est retournée si aucun fichier correspondant au modèle spécifié n'est détecté.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.FindInFiles` (méthode).  
  
|À|Voir|  
|-|-|  
|Rechercher des fichiers contenant une chaîne spécifique dans un répertoire|[Procédure pas à pas : manipulation de fichiers et de répertoires en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 Cet exemple recherche dans le répertoire `C:\TestDir` des fichiers contenant la chaîne `"sample string"` et affiche les résultats dans `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Afin de fonctionner, le projet doit contenir un `ListBox` nommé `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur nulle, il ne contient que des espaces blancs, il contient des caractères non valides ou il s’agit d’un chemin d’appareil (qui commence par <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le dossier spécifié n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Le chemin d'accès du répertoire spécifié contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] fileWildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption, ParamArray fileWildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ fileWildcards);" />
      <MemberSignature Language="F#" Value="static member FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles (directory, containsText, ignoreCase, searchType, fileWildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="fileWildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Répertoire dans lequel effectuer la recherche.</param>
        <param name="containsText">Texte de la recherche.</param>
        <param name="ignoreCase">
          <see langword="True" /> si la recherche doit respecter la casse ; sinon, <see langword="False" />. La valeur par défaut est <see langword="True" />.</param>
        <param name="searchType">Inclure, ou non, les sous-dossiers. La valeur par défaut est <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="fileWildcards">Modèle auquel correspondre.</param>
        <summary>Retourne une collection en lecture seule de chaînes qui représentent le nom des fichiers contenant le texte spécifié.</summary>
        <returns>Collection en lecture seule des noms des fichiers contenant le texte spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection vide est retournée si aucun fichier correspondant au modèle spécifié n'est détecté.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.FindInFiles` (méthode).  
  
|À|Voir|  
|-|-|  
|Rechercher des fichiers contenant une chaîne spécifique dans un répertoire|[Procédure pas à pas : manipulation de fichiers et de répertoires en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 Cet exemple recherche dans le répertoire `C:\TestDir` des fichiers contenant la chaîne `"sample string"` et affiche les résultats dans `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Afin de fonctionner, le projet doit contenir un `ListBox` nommé `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur nulle, il ne contient que des espaces blancs, il contient des caractères non valides ou il s’agit d’un chemin d’appareil (qui commence par <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le dossier spécifié n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Le chemin d'accès du répertoire spécifié contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une collection de chaînes représentant les chemins d'accès de sous-répertoires présents dans un répertoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Nom et chemin d'accès du répertoire.</param>
        <summary>Retourne une collection de chaînes représentant les chemins d'accès de sous-répertoires présents dans un répertoire.</summary>
        <returns>Collection en lecture seule des noms de chemin d'accès des sous-répertoires dans le répertoire spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.GetDirectories` (méthode).  
  
|À|Voir|  
|-|-|  
|Répertorier les sous-répertoires avec un modèle spécifique|[Comment : rechercher des sous-répertoires avec un modèle spécifique dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L’exemple suivant retourne tous les répertoires dans la structure de répertoires qui contiennent le mot `Logs` dans leurs noms et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 Cet exemple suppose que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le dossier spécifié n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Nom et chemin d'accès du répertoire.</param>
        <param name="searchType">Inclure, ou non, les sous-dossiers. La valeur par défaut est <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Modèle permettant d'établir une correspondance entre les noms.</param>
        <summary>Retourne une collection de chaînes représentant les chemins d'accès de sous-répertoires présents dans un répertoire.</summary>
        <returns>Collection en lecture seule des noms de chemin d'accès des sous-répertoires dans le répertoire spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le paramètre `wildcards` pour indiquer un modèle spécifique. Si vous souhaitez inclure le contenu des sous-répertoires dans la recherche, affectez la valeur `SearchAllSubDirectories` au paramètre `searchType`.  
  
 Une collection vide est retournée si aucun répertoire correspondant au modèle spécifié n’est détecté.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.GetDirectories` (méthode).  
  
|À|Voir|  
|-|-|  
|Répertorier les sous-répertoires avec un modèle spécifique|[Comment : rechercher des sous-répertoires avec un modèle spécifique dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L’exemple suivant retourne tous les répertoires dans la structure de répertoires qui contiennent le mot `Logs` dans leurs noms et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 Cet exemple suppose que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs des caractères génériques spécifiés ont une valeur <see langword="Nothing" />, une chaîne vide ou contiennent uniquement des espaces.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le dossier spécifié n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetDirectoryInfo (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryInfo (directory As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetDirectoryInfo(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">
          <see langword="String" />. Chemin d'accès du répertoire.</param>
        <summary>Retourne un objet <see cref="T:System.IO.DirectoryInfo" /> pour le fichier spécifié.</summary>
        <returns>Objet <see cref="T:System.IO.DirectoryInfo" /> pour le chemin spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le répertoire n’existe pas, une exception n'est pas levée tant que la première fois une propriété le <xref:System.IO.DirectoryInfo> objet est accessible.  
  
   
  
## Examples  
 Cet exemple obtient un <xref:System.IO.DirectoryInfo> objet pour le répertoire `C:\Documents and Settings` et affiche l’annuaire heure de création du dernier accès et d’heure dernier temps d’écriture.  
  
 [!code-vb[VbRefFile#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Le chemin d'accès du répertoire contient un signe deux-points (:) ou n'a pas un format valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetDriveInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DriveInfo GetDriveInfo (string drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDriveInfo (drive As String) As DriveInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DriveInfo ^ GetDriveInfo(System::String ^ drive);" />
      <MemberSignature Language="F#" Value="static member GetDriveInfo : string -&gt; System.IO.DriveInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DriveInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="drive">Lecteur à examiner.</param>
        <summary>Retourne un objet <see cref="T:System.IO.DriveInfo" /> pour le fichier spécifié.</summary>
        <returns>Objet <see cref="T:System.IO.DriveInfo" /> pour le lecteur spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.IO.DriveInfo> classe Modélise un lecteur et fournit des méthodes et propriétés pour demander des informations sur le lecteur. Utilisez <xref:System.IO.DriveInfo> pour déterminer les lecteurs disponibles et leur type. Vous pouvez également interroger la propriété pour déterminer la capacité et l’espace libre disponible sur le lecteur.  
  
   
  
## Examples  
 Cet exemple obtienne un <xref:System.IO.DriveInfo> objet pour le lecteur C et l’utilise pour afficher des informations sur le lecteur.  
  
 [!code-vb[VbRefFile#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#11)]  
  
 Pour plus d’informations sur les différents types de disque, consultez <xref:System.IO.DriveType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="drive" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <altmember cref="T:System.IO.DriveType" />
      </Docs>
    </Member>
    <Member MemberName="GetFileInfo">
      <MemberSignature Language="C#" Value="public static System.IO.FileInfo GetFileInfo (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.FileInfo GetFileInfo(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileInfo (file As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileInfo ^ GetFileInfo(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member GetFileInfo : string -&gt; System.IO.FileInfo" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d'accès du fichier.</param>
        <summary>Retourne un objet <see cref="T:System.IO.FileInfo" /> pour le fichier spécifié.</summary>
        <returns>Objet <see cref="T:System.IO.FileInfo" /> pour le fichier spécifié</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une exception n’est pas levée si le fichier n’existe pas ; au lieu de cela, elle sera levée la première fois que les propriétés de l’objet sont accessibles.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.GetFileInfo` (méthode).  
  
|À|Voir|  
|-|-|  
|Déterminer le nom et le chemin d’accès d’un fichier|[Comment : analyser des chemins d’accès dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Cet exemple récupère un <xref:System.IO.FileInfo?displayProperty=nameWithType> objet pour le fichier `MyLogFile.log` et l’utilise pour signaler le nom complet, heure du dernier accès et la longueur du fichier.  
  
 [!code-vb[VbRefFile#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d'accès est mal formé. Par exemple, il contient des caractères non valides ou se compose uniquement d'espace blanc. Le nom du fichier contient une marque de barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.NotSupportedException">Le chemin d'accès contient le signe deux-points au milieu de la chaîne.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès est trop long.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'accès ACL (liste de contrôle d'accès) au fichier.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.FileInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une collection en lecture seule de chaînes qui représentent le nom des fichiers d'un répertoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Répertoire dans lequel effectuer la recherche.</param>
        <summary>Retourne une collection en lecture seule de chaînes qui représentent le nom des fichiers d'un répertoire.</summary>
        <returns>Collection en lecture seule de noms de fichiers issus du répertoire spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection vide est retournée si aucun fichier correspondant au modèle spécifié n'est détecté.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.GetFiles` (méthode).  
  
|À|Voir|  
|-|-|  
|Obtenir la collection des fichiers dans un répertoire|[Comment : placer la Collection de fichiers dans un répertoire dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Rechercher des fichiers avec un modèle spécifique dans un répertoire|[Comment : rechercher des fichiers avec un modèle spécifique dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L’exemple suivant retourne tous les fichiers contenus dans le répertoire et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 Cet exemple suppose que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 Cet exemple retourne tous les fichiers dans le répertoire avec l’extension `.txt` et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 Cet exemple suppose que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le dossier à rechercher n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="directory" /> pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetFiles (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Répertoire dans lequel effectuer la recherche.</param>
        <param name="searchType">Inclure, ou non, les sous-dossiers. La valeur par défaut est <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Modèle auquel correspondre.</param>
        <summary>Retourne une collection en lecture seule de chaînes qui représentent le nom des fichiers d'un répertoire.</summary>
        <returns>Collection en lecture seule de noms de fichiers issus du répertoire spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection vide est retournée si aucun fichier correspondant au modèle spécifié n'est détecté.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.GetFiles` (méthode).  
  
|À|Voir|  
|-|-|  
|Obtenir la collection des fichiers dans un répertoire|[Comment : placer la Collection de fichiers dans un répertoire dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Rechercher des fichiers avec un modèle spécifique dans un répertoire|[Comment : rechercher des fichiers avec un modèle spécifique dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L’exemple suivant retourne tous les fichiers contenus dans le répertoire et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 Cet exemple suppose que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 Cet exemple retourne tous les fichiers dans le répertoire avec l’extension `.txt` et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 Cet exemple suppose que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le dossier à rechercher n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="directory" /> pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public static string GetName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetName : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Obligatoire. Chemin d'accès à analyser. <see langword="String" />.</param>
        <summary>Analyse le nom du fichier à partir du chemin d'accès fourni.</summary>
        <returns>Nom de fichier à partir du chemin d'accès spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une opération de chaîne ; le `FileSystem` n’est pas examiné.  
  
 Le `GetName` méthode ignore une barre oblique qui se produisent à la fin du chemin d’accès.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.GetFileName` (méthode).  
  
|À|Voir|  
|-|-|  
|Analyser un chemin d’accès de fichier|[Comment : analyser des chemins d’accès dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 L’exemple suivant analyse un chemin d’accès de fichier et retourne le nom du fichier.  
  
 [!code-vb[VbVbcnMyFileSystem#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#21)]  
  
 Remplacez le chemin d’accès `C:\Testdirectory\Testfile` avec le chemin d’accès que vous souhaitez analyser.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParentPath">
      <MemberSignature Language="C#" Value="public static string GetParentPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetParentPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParentPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetParentPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParentPath : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès à examiner.</param>
        <summary>Retourne le chemin d'accès parent du chemin d'accès fourni.</summary>
        <returns>Chemin d'accès parent du chemin d'accès fourni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une opération de chaîne ; le système de fichiers n’est pas examiné.  
  
   
  
## Examples  
 Cet exemple obtient le chemin d’accès parent pour `C:\Backups\Tmp\Test`.  
  
 [!code-vb[VbRefFile#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d'accès n'a pas de chemin parent car il s'agit d'un chemin d'accès racine.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un fichier temporaire de zéro octet nommé de manière unique sur le disque et retourne le chemin d'accès complet de ce fichier.</summary>
        <returns>
          <see langword="String" /> contenant le chemin d'accès complet du fichier temporaire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour créer un fichier temporaire.  
  
   
  
## Examples  
 Cet exemple crée un fichier temporaire et retourne son chemin d’accès.  
  
 [!code-vb[VbVbcnMyFileSystem#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Déplace un répertoire d'un emplacement à l'autre.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Chemin d'accès au répertoire à déplacer.</param>
        <param name="destinationDirectoryName">Chemin d'accès au répertoire dans lequel le répertoire source est déplacé.</param>
        <summary>Déplace un répertoire d'un emplacement à l'autre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une tentative est faite pour déplacer un répertoire à l’intérieur d’un répertoire qui n’existe pas, la structure cible sera créée.  
  
   
  
## Examples  
 Cet exemple déplace `Directory1` dans `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Cet exemple déplace `Directory1` à l’intérieur de `Directory2`, remplaçant le répertoire s’il existe déjà.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">La source est un répertoire racine ou le chemin source et le chemin cible sont identiques.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Chemin d'accès au répertoire à déplacer.</param>
        <param name="destinationDirectoryName">Chemin d'accès au répertoire dans lequel le répertoire source est déplacé.</param>
        <param name="showUI">Spécifie s'il faut effectuer un suivi visuel de l'avancement de l'opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Déplace un répertoire d'un emplacement à l'autre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une tentative est faite pour déplacer un répertoire à l’intérieur d’un répertoire qui n’existe pas, la structure cible sera créée.  
  
   
  
## Examples  
 Cet exemple déplace `Directory1` dans `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Cet exemple déplace `Directory1` à l’intérieur de `Directory2`, remplaçant le répertoire s’il existe déjà.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire cible existe déjà et <paramref name="overwrite" /> est défini à <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Chemin d'accès au répertoire à déplacer.</param>
        <param name="destinationDirectoryName">Chemin d'accès au répertoire dans lequel le répertoire source est déplacé.</param>
        <param name="overwrite">
          <see langword="True" /> si les répertoires existants doivent être remplacés ; sinon, <see langword="False" />. La valeur par défaut est <see langword="False" />.</param>
        <summary>Déplace un répertoire d'un emplacement à l'autre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une tentative est faite pour déplacer un répertoire à l’intérieur d’un répertoire qui n’existe pas, la structure cible sera créée.  
  
   
  
## Examples  
 Cet exemple déplace `Directory1` dans `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Cet exemple déplace `Directory1` à l’intérieur de `Directory2`, remplaçant le répertoire s’il existe déjà.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire cible existe déjà et <paramref name="overwrite" /> est défini à <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Chemin d'accès au répertoire à déplacer.</param>
        <param name="destinationDirectoryName">Chemin d'accès au répertoire dans lequel le répertoire source est déplacé.</param>
        <param name="showUI">Spécifie s'il faut effectuer un suivi visuel de l'avancement de l'opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Spécifie si oui ou non une exception est levée lorsque l'utilisateur annule l'opération. La valeur par défaut est <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Déplace un répertoire d'un emplacement à l'autre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une tentative est faite pour déplacer un répertoire à l’intérieur d’un répertoire qui n’existe pas, la structure cible sera créée.  
  
   
  
## Examples  
 Cet exemple déplace `Directory1` dans `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Cet exemple déplace `Directory1` à l’intérieur de `Directory2`, remplaçant le répertoire s’il existe déjà.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="onUserCancel" /> a la valeur <see langword="ThrowException" /> et un sous-répertoire du fichier ne peut pas être copié.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="onUserCancel" /> a la valeur <see langword="ThrowException" /> et l'utilisateur annule l'opération ou l'opération ne peut pas être effectuée.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Déplace un fichier vers un nouvel emplacement.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Chemin d'accès au fichier à déplacer.</param>
        <param name="destinationFileName">Chemin d'accès au répertoire dans lequel le fichier doit être déplacé.</param>
        <summary>Déplace un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la structure cible n’existe pas, il est créé.  
  
 Le `MoveFile` méthode conserve ACE (entrées de contrôle d’accès) uniquement lors du déplacement du fichier dans le même volume. Cela inclut les héritées, qui deviennent des entrées directes déplacé (direct ACE ont priorité sur héritées). Si un fichier est déplacé entre des volumes, les entrées ne seront pas copiées.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.MoveFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Déplacer un fichier|[Comment : déplacer un fichier dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2` et le renomme `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la possibilité d’accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Chemin d'accès au fichier à déplacer.</param>
        <param name="destinationFileName">Chemin d'accès au répertoire dans lequel le fichier doit être déplacé.</param>
        <param name="showUI">Spécifie s'il faut effectuer un suivi visuel de l'avancement de l'opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Déplace un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la structure cible n’existe pas, il est créé.  
  
 Le `MoveFile` méthode conserve ACE (entrées de contrôle d’accès) uniquement lors du déplacement du fichier dans le même volume. Cela inclut les héritées, qui deviennent des entrées directes déplacé (direct ACE ont priorité sur héritées). Si un fichier est déplacé entre des volumes, les entrées ne seront pas copiées.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.MoveFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Déplacer un fichier|[Comment : déplacer un fichier dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2` et le renomme `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la possibilité d’accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Chemin d'accès au fichier à déplacer.</param>
        <param name="destinationFileName">Chemin d'accès au répertoire dans lequel le fichier doit être déplacé.</param>
        <param name="overwrite">
          <see langword="True" /> pour remplacer les fichiers existants ; sinon, <see langword="False" />. La valeur par défaut est <see langword="False" />.</param>
        <summary>Déplace un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la structure cible n’existe pas, il est créé.  
  
 Le `MoveFile` méthode conserve ACE (entrées de contrôle d’accès) uniquement lors du déplacement du fichier dans le même volume. Cela inclut les héritées, qui deviennent des entrées directes déplacé (direct ACE ont priorité sur héritées). Si un fichier est déplacé entre des volumes, les entrées ne seront pas copiées.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.MoveFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Déplacer un fichier|[Comment : déplacer un fichier dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2` et le renomme `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la possibilité d’accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="static member MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.MoveFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Chemin d'accès au fichier à déplacer.</param>
        <param name="destinationFileName">Chemin d'accès au répertoire dans lequel le fichier doit être déplacé.</param>
        <param name="showUI">Spécifie s'il faut effectuer un suivi visuel de l'avancement de l'opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Spécifie si oui ou non une exception est levée lorsque l'utilisateur annule l'opération. La valeur par défaut est <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Déplace un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la structure cible n’existe pas, il est créé.  
  
 Le `MoveFile` méthode conserve ACE (entrées de contrôle d’accès) uniquement lors du déplacement du fichier dans le même volume. Cela inclut les héritées, qui deviennent des entrées directes déplacé (direct ACE ont priorité sur héritées). Si un fichier est déplacé entre des volumes, les entrées ne seront pas copiées.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.MoveFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Déplacer un fichier|[Comment : déplacer un fichier dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2` et le renomme `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="onUserCancel" /> a la valeur <see langword="ThrowException" /> et l'utilisateur a annulé l'opération ou une erreur d'E/S non spécifiée s'est produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la possibilité d’accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFieldParser">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>La méthode <see langword="OpenTextFieldParser" /> vous permet de créer un objet <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> et d'analyser ainsi efficacement et facilement les fichiers texte structurés, comme les journaux. L'objet <see langword="TextFieldParser" /> peut être utilisé pour lire des fichiers délimités et à largeur fixe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Fichier à ouvrir avec <see langword="TextFieldParser" />.</param>
        <summary>La méthode <see langword="OpenTextFieldParser" /> vous permet de créer un objet <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> et d’analyser ainsi efficacement et facilement les fichiers texte structurés, comme les journaux. L'objet <see langword="TextFieldParser" /> peut être utilisé pour lire des fichiers délimités et à largeur fixe.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> pour lire le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.OpenTextFieldParser` (méthode).  
  
|À|Voir|  
|-|-|  
|Lire à partir d’un fichier texte délimité|[Comment : lire des fichiers texte délimité par des virgules dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire un fichier texte de largeur fixe|[Comment : lire des fichiers texte de largeur fixe dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lire à partir d’un fichier texte avec plusieurs formats|[Comment : lire des fichiers texte avec plusieurs Formats dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Cet exemple ouvre le `TextFieldParser.reader` et l’utilise pour lire à partir de `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Une ligne ne peut pas être analysée avec le format spécifié. Le message d’exception spécifie la ligne qui provoque l’exception, tandis que la propriété <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> est assignée au texte contenu dans la ligne.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Décrit un ensemble d’autorisations de sécurité appliquées au code. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray fieldWidths As Integer()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * int[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, fieldWidths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Fichier à ouvrir avec <see langword="TextFieldParser" />.</param>
        <param name="fieldWidths">Largeur des champs.</param>
        <summary>La méthode <see langword="OpenTextFieldParser" /> vous permet de créer un objet <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> et d'analyser ainsi efficacement et facilement les fichiers texte structurés, comme les journaux. L'objet <see langword="TextFieldParser" /> peut être utilisé pour lire des fichiers délimités et à largeur fixe.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> pour lire le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.OpenTextFieldParser` (méthode).  
  
|À|Voir|  
|-|-|  
|Lire à partir d’un fichier texte délimité|[Comment : lire des fichiers texte délimité par des virgules dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire un fichier texte de largeur fixe|[Comment : lire des fichiers texte de largeur fixe dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lire à partir d’un fichier texte avec plusieurs formats|[Comment : lire des fichiers texte avec plusieurs Formats dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Cet exemple ouvre le `TextFieldParser.reader` et l’utilise pour lire à partir de `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Une ligne ne peut pas être analysée avec le format spécifié. Le message d’exception spécifie la ligne qui provoque l’exception, tandis que la propriété <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> est assignée au texte contenu dans la ligne.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Décrit un ensemble d’autorisations de sécurité appliquées au code. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray delimiters As String()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="static member OpenTextFieldParser : string * string[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser (file, delimiters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Fichier à ouvrir avec <see langword="TextFieldParser" />.</param>
        <param name="delimiters">Séparateurs de champs.</param>
        <summary>La méthode <see langword="OpenTextFieldParser" /> vous permet de créer un objet <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> et d'analyser ainsi efficacement et facilement les fichiers texte structurés, comme les journaux. L'objet <see langword="TextFieldParser" /> peut être utilisé pour lire des fichiers délimités et à largeur fixe.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> pour lire le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.OpenTextFieldParser` (méthode).  
  
|À|Voir|  
|-|-|  
|Lire à partir d’un fichier texte délimité|[Comment : lire des fichiers texte délimité par des virgules dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire un fichier texte de largeur fixe|[Comment : lire des fichiers texte de largeur fixe dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lire à partir d’un fichier texte avec plusieurs formats|[Comment : lire des fichiers texte avec plusieurs Formats dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Cet exemple ouvre le `TextFieldParser.reader` et l’utilise pour lire à partir de `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Une ligne ne peut pas être analysée avec le format spécifié. Le message d’exception spécifie la ligne qui provoque l’exception, tandis que la propriété <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> est assignée au texte contenu dans la ligne.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Décrit un ensemble d’autorisations de sécurité appliquées au code. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileReader">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un objet <see cref="T:System.IO.StreamReader" /> à lire à partir d'un fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileReader (file As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Fichier à lire.</param>
        <summary>Ouvre un objet <see cref="T:System.IO.StreamReader" /> à lire à partir d'un fichier.</summary>
        <returns>Objet <see cref="T:System.IO.StreamReader" /> à lire à partir du fichier</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Seuls les fichiers texte peuvent être lus avec un <xref:System.IO.StreamReader>.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.OpenTextFileReader` (méthode).  
  
|À|Voir|  
|-|-|  
|Ouvrir un fichier avec un <xref:System.IO.StreamReader>|[Comment : lire le texte à partir de fichiers avec un StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 Cet exemple ouvre le fichier `Testfile.txt`, il lit une ligne et affiche la ligne dans un `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom de fichier se termine par une barre oblique inverse (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié est introuvable.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour lire le fichier.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Fichier à lire.</param>
        <param name="encoding">Encodage à utiliser pour le contenu du fichier. La valeur par défaut est ASCII.</param>
        <summary>Ouvre un objet <see cref="T:System.IO.StreamReader" /> à lire à partir d'un fichier.</summary>
        <returns>Objet <see cref="T:System.IO.StreamReader" /> à lire à partir du fichier</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Seuls les fichiers texte peuvent être lus avec un <xref:System.IO.StreamReader>.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.OpenTextFileReader` (méthode).  
  
|À|Voir|  
|-|-|  
|Ouvrir un fichier avec un <xref:System.IO.StreamReader>|[Comment : lire le texte à partir de fichiers avec un StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 Cet exemple ouvre le fichier `Testfile.txt`, il lit une ligne et affiche la ligne dans un `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom de fichier se termine par une barre oblique inverse (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié est introuvable.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour lire le fichier.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileWriter">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un objet <see cref="T:System.IO.StreamWriter" /> à écrire dans le fichier spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileWriter (file As String, append As Boolean) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Fichier dans lequel écrire.</param>
        <param name="append">
          <see langword="True" /> pour ajouter au contenu du fichier ; <see langword="False" /> pour remplacer le contenu du fichier. La valeur par défaut est <see langword="False" />.</param>
        <summary>Ouvre un objet <see cref="T:System.IO.StreamWriter" /> à écrire dans le fichier spécifié.</summary>
        <returns>Objet <see cref="T:System.IO.StreamWriter" /> à écrire dans le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `OpenTextFileWriter` méthode ouvre et initialise un flux de données pour un fichier et retourne ensuite le <xref:System.IO.StreamWriter> objet pour ce flux de données. Vous pouvez écrire dans le flux de données aussi souvent que nécessaire et fermez-le lorsque vous avez terminé.  
  
> [!NOTE]
>  Vous devez appeler la <xref:System.IO.StreamWriter.Close%2A> méthode sur le <xref:System.IO.StreamWriter> objet pour vous assurer que toutes les données sont correctement écrites dans le flux sous-jacent.  
  
 Si vous écrivez uniquement quelques chaînes dans un fichier, il peut être plus simple d’utiliser le <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> (méthode).  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.OpenTextFileWriter` (méthode).  
  
|À|Voir|  
|-|-|  
|Écrire du texte dans un fichier avec un `StreamWriter`|[Comment : écrire du texte dans des fichiers à l’aide de StreamWriter dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 Cet exemple ouvre un <xref:System.IO.StreamWriter> avec la `My.Computer.FileSystem.OpenTextFileWriter` (méthode) et l’utilise pour écrire une chaîne dans un fichier texte avec le `WriteLine` méthode de la `StreamWriter` classe.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom de fichier se termine par une barre oblique finale.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member OpenTextFileWriter : string * bool * System.Text.Encoding -&gt; System.IO.StreamWriter" Usage="Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter (file, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Fichier dans lequel écrire.</param>
        <param name="append">
          <see langword="True" /> pour ajouter au contenu du fichier  ; <see langword="False" /> pour remplacer le contenu du fichier. La valeur par défaut est <see langword="False" />.</param>
        <param name="encoding">Encodage à utiliser lors de l'écriture dans le fichier. La valeur par défaut est ASCII.</param>
        <summary>Ouvre un <see cref="T:System.IO.StreamWriter" /> pour écrire dans le fichier spécifié.</summary>
        <returns>Objet <see cref="T:System.IO.StreamWriter" /> à écrire dans le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `OpenTextFileWriter` méthode ouvre et initialise un flux de données pour un fichier et retourne ensuite le <xref:System.IO.StreamWriter> objet pour ce flux de données. Vous pouvez écrire dans le flux de données aussi souvent que nécessaire et fermez-le lorsque vous avez terminé.  
  
> [!NOTE]
>  Vous devez appeler la <xref:System.IO.StreamWriter.Close%2A> méthode sur le <xref:System.IO.StreamWriter> objet pour vous assurer que toutes les données sont correctement écrites dans le flux sous-jacent.  
  
 Si vous écrivez uniquement quelques chaînes dans un fichier, il peut être plus simple d’utiliser le <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> (méthode).  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.OpenTextFileWriter` (méthode).  
  
|À|Voir|  
|-|-|  
|Écrire du texte dans un fichier avec un `StreamWriter`|[Comment : écrire du texte dans des fichiers à l’aide de StreamWriter dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 Cet exemple ouvre un <xref:System.IO.StreamWriter> avec la `My.Computer.FileSystem.OpenTextFileWriter` (méthode) et l’utilise pour écrire une chaîne dans un fichier texte avec le `WriteLine` méthode de la `StreamWriter` classe.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom de fichier se termine par une barre oblique finale.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int8[] ReadAllBytes(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (file As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllBytes : string -&gt; byte[]" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Fichier à lire.</param>
        <summary>Retourne le contenu d'un fichier sous la forme d'un tableau d'octets.</summary>
        <returns>Tableau <see langword="Byte" /> contenant le contenu du fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ReadAllBytes` méthode de la `My.Computer.FileSystem` objet vous permet de lire à partir d’un fichier binaire. Le contenu du fichier est retourné en tant que tableau d’octets.  
  
 Ne vous basez pas sur le nom d'un fichier pour en déterminer le contenu. Par exemple, le fichier Form1.vb peut ne pas être un fichier source Visual Basic. Vérifiez toutes les entrées avant d'utiliser les données dans votre application.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.ReadAllBytes` (méthode).  
  
|À|Voir|  
|-|-|  
|Lire à partir d'un fichier binaire|[Comment : lire des fichiers binaires dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
  
   
  
## Examples  
 Cet exemple lit à partir du fichier `C:/Documents and Settings/selfportrait.jpg.`  
  
 [!code-vb[VbVbcnMyFileSystem#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n'y a pas assez de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne le contenu d'un fichier texte sous forme de <see langword="String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (file As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d'accès du fichier à lire.</param>
        <summary>Retourne le contenu d'un fichier texte sous forme de <see langword="String" />.</summary>
        <returns>
          <see langword="String" /> contenant le contenu du fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode `ReadAllText` de l'objet `My.Computer.FileSystem` vous permet de lire un fichier texte. Le contenu du fichier est retourné sous forme de chaîne.  
  
 L’encodage du fichier peut être spécifié si le contenu du fichier dans un encodage ASCII ou UTF-8. Si vous lisez à partir d’un fichier avec des caractères étendus, vous devez spécifier l’encodage du fichier à l’aide d’une autre surcharge de la <xref:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText%2A> (méthode).  
  
 Ne vous basez pas sur le nom d'un fichier pour en déterminer le contenu. Par exemple, le fichier Form1.vb peut ne pas être un fichier source Visual Basic. Vérifiez toutes les entrées avant d'utiliser les données dans votre application.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.ReadAllText` (méthode).  
  
|À|Voir|  
|-|-|  
|Lire à partir d'un fichier texte|[Comment : lire des fichiers texte dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Cet exemple lit le contenu de `Test.txt` dans une chaîne puis l’affiche dans une boîte de message.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Cet exemple lit le contenu du fichier ASCII `Test.txt` dans une chaîne puis l’affiche dans une boîte de message.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n'y a pas assez de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string * System.Text.Encoding -&gt; string" Usage="Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d'accès du fichier à lire.</param>
        <param name="encoding">Encodage de caractères à utiliser pour la lecture du fichier. La valeur par défaut est UTF-8.</param>
        <summary>Retourne le contenu d'un fichier texte sous forme de <see langword="String" />.</summary>
        <returns>
          <see langword="String" /> contenant le contenu du fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode `ReadAllText` de l'objet `My.Computer.FileSystem` vous permet de lire un fichier texte. Le contenu du fichier est retourné sous forme de chaîne.  
  
 L’encodage du fichier peut être spécifié si le contenu du fichier dans un encodage ASCII ou UTF-8. Si vous lisez à partir d’un fichier avec des caractères étendus, vous devez spécifier l’encodage du fichier.  
  
 Ne vous basez pas sur le nom d'un fichier pour en déterminer le contenu. Par exemple, le fichier Form1.vb peut ne pas être un fichier source Visual Basic. Vérifiez toutes les entrées avant d'utiliser les données dans votre application.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.ReadAllText` (méthode).  
  
|À|Voir|  
|-|-|  
|Lire à partir d'un fichier texte|[Comment : lire des fichiers texte dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Cet exemple lit le contenu de `Test.txt` dans une chaîne puis l’affiche dans une boîte de message.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Cet exemple lit le contenu du fichier ASCII `Test.txt` dans une chaîne puis l’affiche dans une boîte de message.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n'y a pas assez de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="RenameDirectory">
      <MemberSignature Language="C#" Value="public static void RenameDirectory (string directory, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameDirectory(string directory, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameDirectory (directory As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameDirectory(System::String ^ directory, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameDirectory : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory (directory, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Chemin d'accès et nom du répertoire à renommer.</param>
        <param name="newName">Nouveau nom du répertoire.</param>
        <summary>Renomme un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne peut pas être utilisée pour déplacer un répertoire ; Utilisez la `MoveDirectory` méthode pour déplacer et renommer le répertoire.  
  
   
  
## Examples  
 Cet exemple renomme la `Test` répertoire `SecondTest`.  
  
 [!code-vb[VbVbcnMyFileSystem#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> contient des informations de chemin d’accès.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est <see langword="Nothing" />.  - ou - <paramref name="newName" /> est <see langword="Nothing" /> ou est une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Un fichier ou répertoire existe avec le nom spécifié dans <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory" />
      </Docs>
    </Member>
    <Member MemberName="RenameFile">
      <MemberSignature Language="C#" Value="public static void RenameFile (string file, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameFile(string file, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameFile (file As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameFile(System::String ^ file, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="static member RenameFile : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.RenameFile (file, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Fichier à renommer.</param>
        <param name="newName">Nouveau nom du fichier.</param>
        <summary>Renomme un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne peut pas être utilisée pour déplacer un fichier. Utilisez la méthode <xref:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile%2A> pour déplacer et renommer le fichier.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.RenameFile` (méthode).  
  
|À|Voir|  
|-|-|  
|Renommer un fichier|[Comment : renommer un fichier dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
  
   
  
## Examples  
 Cet exemple renomme le fichier `Test.txt` à `SecondTest.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#1)]  
  
 Modification de «`C:\Test.txt`» pour le chemin d’accès et le nom du fichier que vous souhaitez renommer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> contient des informations relatives au chemin d’accès ou se termine par une barre oblique inverse (\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.  - ou - <paramref name="newName" /> est <see langword="Nothing" /> ou est une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le répertoire n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Un fichier ou répertoire existe avec le nom spécifié dans <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string file, byte[] data, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes(System.String,System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (file As String, data As Byte(), append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ file, cli::array &lt;System::Byte&gt; ^ data, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllBytes : string * byte[] * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes (file, data, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Chemin d'accès et nom du fichier dans lequel écrire.</param>
        <param name="data">Données à écrire dans le fichier.</param>
        <param name="append">
          <see langword="True" /> pour ajouter au contenu du fichier  ; <see langword="False" /> pour remplacer le contenu du fichier. La valeur par défaut est <see langword="False" />.</param>
        <summary>Écrit des données dans un fichier binaire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le chemin d’accès spécifié, à l’exclusion du nom de fichier n’est pas valide, un <xref:System.IO.DirectoryNotFoundException> exception sera levée. Si le chemin d’accès est valide, mais le fichier n’existe pas, le fichier est créé.  
  
> [!NOTE]
>  Le `WriteAllBytes` méthode ouvre un fichier, écrit, puis le ferme. Le code qui utilise le `WriteAllBytes` méthode est plus simple que le code qui utilise un <xref:System.IO.BinaryWriter> objet. Toutefois, si vous ajoutez des données dans un fichier à l’aide d’une boucle, une <xref:System.IO.BinaryWriter> objet peut offrir de meilleures performances, car vous ne devez ouvrir et fermer le fichier une seule fois.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.WriteAllBytes` (méthode).  
  
|À|Voir|  
|-|-|  
|Écrire dans un fichier binaire|[Comment : écrire des fichiers binaires dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
  
   
  
## Examples  
 Cet exemple ajoute le tableau de données `CustomerData` dans le fichier `CollectedData`.  
  
 [!code-vb[VbVbcnMyFileSystem#50](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n'y a pas assez de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit du texte dans un fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (file As String, text As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Fichier dans lequel écrire.</param>
        <param name="text">Texte à écrire dans le fichier.</param>
        <param name="append">
          <see langword="True" /> pour ajouter au contenu du fichier ; <see langword="False" /> pour remplacer le contenu du fichier.</param>
        <summary>Écrit du texte dans un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’encodage UTF-8 est utilisé pour écrire dans le fichier. Pour spécifier un autre encodage, utilisez une autre surcharge de la <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> (méthode).  
  
 Si le fichier spécifié n’existe pas, il est créé.  
  
 Si l’encodage spécifié ne correspond pas au codage existant du fichier, le codage spécifié est ignoré.  
  
> [!NOTE]
>  Le `WriteAllText` méthode ouvre un fichier, écrit, puis le ferme. Le code qui utilise le `WriteAllText` méthode est plus simple que le code qui utilise un <xref:System.IO.StreamWriter> objet. Toutefois, si vous ajoutez des chaînes à un fichier à l’aide d’une boucle, une <xref:System.IO.StreamWriter> objet peut offrir de meilleures performances, car vous ne devez ouvrir et fermer le fichier une seule fois. Pour plus d'informations, voir la méthode <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.WriteAllText` (méthode).  
  
|À|Voir|  
|-|-|  
|Écrire du texte dans un fichier|[Comment : écrire du texte dans des fichiers en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Ajouter du texte dans un fichier|[Comment : ajouter des fichiers texte dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 Cet exemple écrit la ligne `"This is new text to be added."` dans le fichier `Test.txt`, remplace le texte existant dans le fichier.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 Cet exemple écrit les noms des fichiers dans le `Documents and Settings` dossier `FileList.txt`, insère un retour chariot entre chacun d’eux pour une meilleure lisibilité.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n'y a pas assez de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * bool * System.Text.Encoding -&gt; unit" Usage="Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText (file, text, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Fichier dans lequel écrire.</param>
        <param name="text">Texte à écrire dans le fichier.</param>
        <param name="append">
          <see langword="True" /> pour ajouter au contenu du fichier ; <see langword="False" /> pour remplacer le contenu du fichier.</param>
        <param name="encoding">Encodage à utiliser lors de l'écriture dans le fichier.</param>
        <summary>Écrit du texte dans un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le fichier spécifié n’existe pas, il est créé.  
  
 Si l’encodage spécifié ne correspond pas au codage existant du fichier, le codage spécifié est ignoré.  
  
> [!NOTE]
>  Le `WriteAllText` méthode ouvre un fichier, écrit, puis le ferme. Le code qui utilise le `WriteAllText` méthode est plus simple que le code qui utilise un <xref:System.IO.StreamWriter> objet. Toutefois, si vous ajoutez des chaînes à un fichier à l’aide d’une boucle, une <xref:System.IO.StreamWriter> objet peut offrir de meilleures performances, car vous ne devez ouvrir et fermer le fichier une seule fois. Pour plus d'informations, voir la méthode <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.WriteAllText` (méthode).  
  
|À|Voir|  
|-|-|  
|Écrire du texte dans un fichier|[Comment : écrire du texte dans des fichiers en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Ajouter du texte dans un fichier|[Comment : ajouter des fichiers texte dans Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 Cet exemple écrit la ligne `"This is new text to be added."` dans le fichier `Test.txt`, remplace le texte existant dans le fichier.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 Cet exemple écrit les noms des fichiers dans le `Documents and Settings` dossier `FileList.txt`, insère un retour chariot entre chacun d’eux pour une meilleure lisibilité.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n'y a pas assez de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
  </Members>
</Type>