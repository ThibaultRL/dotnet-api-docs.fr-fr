<Type Name="FileSystemProxy" FullName="Microsoft.VisualBasic.MyServices.FileSystemProxy">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b39e2d4e276a6de5946493f9da171f9c6a74cae8" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39906725" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystemProxy" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FileSystemProxy extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.MyServices.FileSystemProxy" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemProxy" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemProxy" />
  <TypeSignature Language="F#" Value="type FileSystemProxy = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit des propriétés et des méthodes destinées à être utilisées avec les lecteurs, les fichiers et les répertoires.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem` objet.  
  
|À|Voir|  
|--------|---------|  
|Lire à partir d'un fichier texte|[Guide pratique : lire à partir de fichiers texte](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
|Lire à partir d’un fichier texte délimité|[Guide pratique : lire des fichiers texte délimités par des virgules](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire un fichier texte de largeur fixe|[Guide pratique : lire des fichiers texte de largeur fixe](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lire un fichier texte avec plusieurs formats|[Guide pratique : lire des fichiers texte avec plusieurs formats](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
|Lire à partir d'un fichier binaire|[Guide pratique : lire des fichiers binaires](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
|Lire à partir d’un fichier texte avec un <xref:System.IO.StreamReader>|[Guide pratique : lire le texte des fichiers avec un StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
|Écrire dans un fichier texte|[Guide pratique : insérer du texte dans des fichiers](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Ajouter à un fichier texte|[Guide pratique : effectuer un ajout à des fichiers texte](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
|Écrire dans un fichier binaire|[Guide pratique : écrire dans des fichiers binaires](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
|Écrire dans des fichiers texte dans le **MyDocuments** directory|[Guide pratique : insérer du texte dans les fichiers du répertoire Mes Documents](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-in-the-my-documents-directory.md)|  
|Écrire dans un fichier texte avec un `StreamWriter`|[Guide pratique : écrire du texte dans des fichiers à l'aide de Streamwriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
|Copier des fichiers avec un modèle spécifique|[Guide pratique : copier des fichiers avec un modèle spécifique dans un répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md)|  
|Copier un fichier dans le même répertoire|[Guide pratique : créer une copie d'un fichier dans le même répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copier un fichier vers un autre répertoire|[Guide pratique : créer une copie d'un fichier dans un autre répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
|Créez un fichier|[Guide pratique : créer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-file.md)|  
|Supprimer un fichier|[Guide pratique : supprimer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
|Rechercher des fichiers avec un modèle spécifique|[Guide pratique : rechercher des fichiers avec un modèle spécifique](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
|Déplacer un fichier|[Guide pratique : déplacer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
|Renommer un fichier|[Guide pratique : renommer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
|Copier un répertoire vers un autre répertoire|[Guide pratique : copier un répertoire vers un autre répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
|Créer un répertoire|[Guide pratique : créer un répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
|Rechercher des sous-répertoires avec un modèle spécifique|[Guide pratique pour rechercher des sous-répertoires avec un modèle spécifique](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
|Obtenez la collection de fichiers dans un répertoire|[Guide pratique pour placer la collection de fichiers dans un répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Lire à partir de la **MyDocuments** directory|[Guide pratique : récupérer le contenu du répertoire Mes Documents](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-retrieve-the-contents-of-the-my-documents-directory.md)|  
|Analyser un chemin d’accès de fichier|[Guide pratique pour analyser des chemins](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Cet exemple vérifie pour déterminer si le dossier `C:\backup\logs` existe et vérifie ses propriétés.  
  
 [!code-vb[VbVbcnMyFileSystem#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#23)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
  </Docs>
  <Members>
    <Member MemberName="CombinePath">
      <MemberSignature Language="C#" Value="public string CombinePath (string baseDirectory, string relativePath);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string CombinePath(string baseDirectory, string relativePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CombinePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CombinePath (baseDirectory As String, relativePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ CombinePath(System::String ^ baseDirectory, System::String ^ relativePath);" />
      <MemberSignature Language="F#" Value="member this.CombinePath : string * string -&gt; string" Usage="fileSystemProxy.CombinePath (baseDirectory, relativePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseDirectory" Type="System.String" />
        <Parameter Name="relativePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseDirectory">
          <see langword="String" />. Premier chemin d'accès à combiner.</param>
        <param name="relativePath">
          <see langword="String" />. Deuxième chemin d'accès à combiner.</param>
        <summary>Associe deux chemins d'accès et retourne un chemin d'accès correctement mis en forme.</summary>
        <returns>Combinaison des chemins d'accès spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode supprime les espaces de marque de barre oblique excessive pour créer un chemin d’accès correctement mis en forme.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CombinePath` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Associer un nom de fichier et le chemin de répertoire|[Guide pratique pour analyser des chemins](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Cet exemple combine un nom de fichier et le chemin de répertoire pour créer un chemin d’accès correctement mis en forme.  
  
 [!code-vb[VbRefFile#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#3)]  
  
 Cet exemple combine deux chemins d’accès pour créer un chemin d’accès correctement mis en forme.  
  
 [!code-vb[VbRefFile#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#4)]  
  
 Cet exemple retourne `C:\Dir1\Dir2\Dir4\Dir5\File.txt`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseDirectory" /> ou <paramref name="relativePath" /> sont des chemins d'accès incorrects.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie un répertoire dans un autre répertoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Répertoire à copier.</param>
        <param name="destinationDirectoryName">Emplacement vers lequel le répertoire doit être copié.</param>
        <summary>Copie un répertoire dans un autre répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie le contenu du répertoire, ainsi que le répertoire lui-même. Si le répertoire cible n’existe pas, il est créé. Si un répertoire portant le même nom existe dans l’emplacement cible, le contenu des deux annuaires est fusionné. Vous pouvez spécifier un nouveau nom pour le répertoire pendant l’opération.  
  
 Lors de la copie des fichiers dans un répertoire, les exceptions peuvent être levées sont provoquées par un fichier spécifique. Lorsque ces exceptions sont levées, elles sont consolidées en une seule exception dont la propriété `Data` propriété comporte des entrées sous la forme d’un <xref:System.Collections.IDictionary> dans lequel le chemin d’accès du fichier ou répertoire est la clé et le message d’exception spécifique est contenu dans le valeur correspondante. Utilisez `For…Each` pour énumérer les entrées.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyDirectory` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Copier un répertoire|[Guide pratique : copier un répertoire vers un autre répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 L’exemple suivant copie le répertoire `TestDirectory1` dans `TestDirectory2`, en remplaçant les fichiers existants.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Remplacez `C:\TestDirectory1` et `C:\TestDirectory2` avec le chemin d’accès et le nom de l’annuaire que vous souhaitez copier et l’emplacement auquel vous souhaitez le copier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire source n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le chemin source et le chemin cible sont identiques.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un fichier de destination existe mais est inaccessible.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Répertoire à copier.</param>
        <param name="destinationDirectoryName">Emplacement vers lequel le répertoire doit être copié.</param>
        <param name="showUI">Indique si un suivi visuel de l'avancement de l'opération est nécessaire. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Copie un répertoire dans un autre répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie le contenu du répertoire, ainsi que le répertoire lui-même. Si le répertoire cible n’existe pas, il est créé. Si un répertoire portant le même nom existe dans l’emplacement cible, le contenu des deux annuaires est fusionné. Vous pouvez spécifier un nouveau nom pour le répertoire pendant l’opération.  
  
 Lors de la copie des fichiers dans un répertoire, les exceptions peuvent être levées sont provoquées par un fichier spécifique. Lorsque ces exceptions sont levées, elles sont consolidées en une seule exception dont la propriété `Data` propriété comporte des entrées sous la forme d’un <xref:System.Collections.IDictionary> dans lequel le chemin d’accès du fichier ou répertoire est la clé et le message d’exception spécifique est contenu dans le valeur correspondante. Utilisez `For…Each` pour énumérer les entrées.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyDirectory` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Copier un répertoire|[Guide pratique : copier un répertoire vers un autre répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 L’exemple suivant copie le répertoire `TestDirectory1` dans `TestDirectory2`, en remplaçant les fichiers existants.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Remplacez `C:\TestDirectory1` et `C:\TestDirectory2` avec le chemin d’accès et le nom de l’annuaire que vous souhaitez copier et l’emplacement auquel vous souhaitez le copier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire source n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le chemin source et le chemin cible sont identiques.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un fichier de destination existe mais est inaccessible.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="ShowUI" /> a la valeur <see langword="UIOption.AllDialogs" /> et l'utilisateur annule l'opération, ou un ou plusieurs fichiers du répertoire ne peuvent pas être copiés.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string * bool -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Répertoire à copier.</param>
        <param name="destinationDirectoryName">Emplacement vers lequel le répertoire doit être copié.</param>
        <param name="overwrite">
          <see langword="True" /> pour remplacer les fichiers existants ; sinon, <see langword="False" />. La valeur par défaut est <see langword="False" />.</param>
        <summary>Copie un répertoire dans un autre répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie le contenu du répertoire, ainsi que le répertoire lui-même. Si le répertoire cible n’existe pas, il est créé. Si un répertoire portant le même nom existe dans l’emplacement cible, le contenu des deux annuaires est fusionné. Vous pouvez spécifier un nouveau nom pour le répertoire pendant l’opération.  
  
 Lors de la copie des fichiers dans un répertoire, les exceptions peuvent être levées sont provoquées par un fichier spécifique, tel qu’un fichier existant au cours d’une fusion alors que `overwrite` est défini sur `False`. Lorsque ces exceptions sont levées, elles sont consolidées en une seule exception dont la propriété `Data` propriété comporte des entrées sous la forme d’un <xref:System.Collections.IDictionary> dans lequel le chemin d’accès du fichier ou répertoire est la clé et le message d’exception spécifique est contenu dans le valeur correspondante. Utilisez `For…Each` pour énumérer les entrées.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyDirectory` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Copier un répertoire|[Guide pratique : copier un répertoire vers un autre répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 L’exemple suivant copie le répertoire `TestDirectory1` dans `TestDirectory2`, en remplaçant les fichiers existants.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Remplacez `C:\TestDirectory1` et `C:\TestDirectory2` avec le chemin d’accès et le nom de l’annuaire que vous souhaitez copier et l’emplacement auquel vous souhaitez le copier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire source n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le chemin source et le chemin cible sont identiques.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un fichier de destination existe mais est inaccessible.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Répertoire à copier.</param>
        <param name="destinationDirectoryName">Emplacement vers lequel le répertoire doit être copié.</param>
        <param name="showUI">Indique si un suivi visuel de l'avancement de l'opération est nécessaire. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Indique ce qu’il convient de faire si l’utilisateur clique sur **Annuler** pendant l’opération. La valeur par défaut est <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Copie un répertoire dans un autre répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie le contenu du répertoire, ainsi que le répertoire lui-même. Si le répertoire cible n’existe pas, il est créé. Si un répertoire portant le même nom existe dans l’emplacement cible, le contenu des deux annuaires est fusionné. Vous pouvez spécifier un nouveau nom pour le répertoire pendant l’opération.  
  
 Lors de la copie des fichiers dans un répertoire, les exceptions peuvent être levées sont provoquées par un fichier spécifique. Lorsque ces exceptions sont levées, elles sont consolidées en une seule exception dont la propriété `Data` propriété comporte des entrées sous la forme d’un <xref:System.Collections.IDictionary> dans lequel le chemin d’accès du fichier ou répertoire est la clé et le message d’exception spécifique est contenu dans le valeur correspondante. Utilisez `For…Each` pour énumérer les entrées.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyDirectory` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Copier un répertoire|[Guide pratique : copier un répertoire vers un autre répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 L’exemple suivant copie le répertoire `TestDirectory1` dans `TestDirectory2`, en remplaçant les fichiers existants.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Remplacez `C:\TestDirectory1` et `C:\TestDirectory2` avec le chemin d’accès et le nom de l’annuaire que vous souhaitez copier et l’emplacement auquel vous souhaitez le copier.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> ou <paramref name="sourceDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire source n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le chemin source et le chemin cible sont identiques.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un fichier de destination existe mais est inaccessible.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="ShowUI" /> a la valeur <see langword="UIOption.AllDialogs" /> et l'utilisateur annule l'opération, ou un ou plusieurs fichiers du répertoire ne peuvent pas être copiés.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie un fichier vers un nouvel emplacement.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Fichier à copier.</param>
        <param name="destinationFileName">Emplacement vers lequel le fichier doit être copié.</param>
        <summary>Copie un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ne conserve pas les ACE (entrées de contrôle d’accès). Le fichier nouvellement créé hérite des ACE par défaut à partir du répertoire dans lequel il est créé.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyFile` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Copier un fichier dans le même répertoire.|[Guide pratique : créer une copie d'un fichier dans le même répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copier un fichier vers un autre répertoire.|[Guide pratique : créer une copie d'un fichier dans un autre répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` sans remplacer les fichiers existants.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` et le renomme `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contient des informations de chemin d’accès.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Un fichier du répertoire cible portant le même nom est en cours d'utilisation.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Fichier à copier.</param>
        <param name="destinationFileName">Emplacement vers lequel le fichier doit être copié.</param>
        <param name="showUI">Indique si un suivi visuel de l'avancement de l'opération est nécessaire. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Copie un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ne conserve pas les ACE (entrées de contrôle d’accès). Le fichier nouvellement créé hérite des ACE par défaut à partir du répertoire dans lequel il est créé.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyFile` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Copier un fichier dans le même répertoire.|[Guide pratique : créer une copie d'un fichier dans le même répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copier un fichier vers un autre répertoire.|[Guide pratique : créer une copie d'un fichier dans un autre répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` sans remplacer les fichiers existants.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` et le renomme `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contient des informations de chemin d’accès.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier de destination existe et <paramref name="overwrite" /> a la valeur <see langword="False" /> ().</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string * bool -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Fichier à copier.</param>
        <param name="destinationFileName">Emplacement vers lequel le fichier doit être copié.</param>
        <param name="overwrite">
          <see langword="True" /> si les fichiers existants doivent être remplacés ; sinon, <see langword="False" />. La valeur par défaut est <see langword="False" />.</param>
        <summary>Copie un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ne conserve pas les ACE (entrées de contrôle d’accès). Le fichier nouvellement créé hérite des ACE par défaut à partir du répertoire dans lequel il est créé.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyFile` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Copier un fichier dans le même répertoire.|[Guide pratique : créer une copie d'un fichier dans le même répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copier un fichier vers un autre répertoire.|[Guide pratique : créer une copie d'un fichier dans un autre répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` sans remplacer les fichiers existants.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` et le renomme `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contient des informations de chemin d’accès.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier de destination existe et <paramref name="overwrite" /> a la valeur <see langword="False" /> ().</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Fichier à copier.</param>
        <param name="destinationFileName">Emplacement vers lequel le fichier doit être copié.</param>
        <param name="showUI">Indique si un suivi visuel de l'avancement de l'opération est nécessaire. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Indique ce qu’il convient de faire si l’utilisateur clique sur **Annuler** pendant l’opération. La valeur par défaut est <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Copie un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` ne conserve pas les ACE (entrées de contrôle d’accès). Le fichier nouvellement créé hérite des ACE par défaut à partir du répertoire dans lequel il est créé.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CopyFile` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Copier un fichier dans le même répertoire.|[Guide pratique : créer une copie d'un fichier dans le même répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copier un fichier vers un autre répertoire.|[Guide pratique : créer une copie d'un fichier dans un autre répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` sans remplacer les fichiers existants.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 Cet exemple copie le fichier `Test.txt` dans le répertoire `TestFiles2` et le renomme `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Remplacez les chemins d’accès de fichier par les chemins d’accès que vous souhaitez utiliser dans votre code.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contient des informations de chemin d’accès.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> ou <paramref name="sourceFileName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier de destination existe et <paramref name="overwrite" /> a la valeur <see langword="False" /> ().</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="UICancelOption" /> a la valeur <see langword="ThrowException" /> et l'utilisateur a annulé l'opération ou une erreur d'E/S non spécifiée s'est produit.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public void CreateDirectory (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CreateDirectory(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDirectory (directory As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDirectory(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.CreateDirectory : string -&gt; unit" Usage="fileSystemProxy.CreateDirectory directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Nom et emplacement du répertoire.</param>
        <summary>Crée un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le répertoire existe déjà, aucune exception n’est levée.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.CreateDirectory` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Créer un répertoire|[Guide pratique : créer un répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
  
   
  
## Examples  
 Cet exemple crée le répertoire, `NewDirectory`, dans `C:\Documents and Settings\All Users\Documents`.  
  
 [!code-vb[VbVbcnMyFileSystem#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le format du nom du répertoire est incorrect. Par exemple, il contient des caractères non valides ou se compose uniquement d'espace blanc.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le nom de répertoire est trop long.</exception>
        <exception cref="T:System.NotSupportedException">Le nom du répertoire se compose uniquement du signe deux-points (:).</exception>
        <exception cref="T:System.IO.IOException">Le répertoire parent du répertoire à créer est en lecture seule.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'est pas autorisé à créer le répertoire.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:System.IO.Directory.CreateDirectory(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.MyServices.FileSystemProxy.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="Microsoft.VisualBasic.MyServices.FileSystemProxy.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le répertoire actif.</summary>
        <value>Répertoire actif pour les opérations d'E/S de fichier.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CurrentDirectory` est une variable d’environnement système.  
  
   
  
## Examples  
 Cet exemple retourne le répertoire actif et l’affiche dans une boîte de message.  
  
 [!code-vb[VbVbcnMyFileSystem#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#18)]  
  
 Cet exemple définit le répertoire actuel `C:\TestDirectory`.  
  
 [!code-vb[VbVbcnMyFileSystem#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin d'accès n'est pas valide.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime un répertoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.DeleteDirectoryOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (directory As String, onDirectoryNotEmpty As DeleteDirectoryOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="F#" Value="member this.DeleteDirectory : string * Microsoft.VisualBasic.FileIO.DeleteDirectoryOption -&gt; unit" Usage="fileSystemProxy.DeleteDirectory (directory, onDirectoryNotEmpty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="onDirectoryNotEmpty" Type="Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Parameters>
      <Docs>
        <param name="directory">Répertoire à supprimer.</param>
        <param name="onDirectoryNotEmpty">Spécifie l'opération à effectuer lorsqu'un répertoire à supprimer contient des fichiers ou des répertoires. La valeur par défaut est <see langword="DeleteDirectoryOption.DeleteAllContents" />.</param>
        <summary>Supprime un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple supprime le répertoire `OldDirectory` uniquement si elle est vide.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, l’invitant à confirmer la suppression, mais n’envoie pas le contenu à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, les envoyer à la **Corbeille**, mais n’affiche ne pas la progression de l’opération.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d'accès est une chaîne de longueur nulle, est incorrect, se compose uniquement d'espace blanc ou contient des caractères incorrects (y compris des caractères génériques). Le chemin d’accès est un chemin d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas ou est un fichier.</exception>
        <exception cref="T:System.IO.IOException">Un fichier du répertoire ou du sous-répertoire est en cours d'utilisation.</exception>
        <exception cref="T:System.NotSupportedException">Le nom de répertoire contient un signe deux points (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises.</exception>
        <exception cref="T:System.OperationCanceledException">L'utilisateur annule l'opération ou le répertoire ne peut pas être supprimé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="member this.DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="fileSystemProxy.DeleteDirectory (directory, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="directory">Répertoire à supprimer.</param>
        <param name="showUI">Spécifie s'il faut effectuer un suivi visuel de l'avancement de l'opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Spécifie si le fichier supprimé doit être ou non envoyé à la **Corbeille**. La valeur par défaut est <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Supprime un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `showUI` et `recycle` paramètres ne sont pas pris en charge dans les applications qui ne sont pas en mode utilisateur interactif, telles que les Services de Windows.  
  
   
  
## Examples  
 L’exemple supprime le répertoire `OldDirectory` uniquement si elle est vide.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, l’invitant à confirmer la suppression, mais n’envoie pas le contenu à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, les envoyer à la **Corbeille**, mais n’affiche ne pas la progression de l’opération.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d'accès est une chaîne de longueur nulle, est incorrect, se compose uniquement d'espace blanc ou contient des caractères incorrects (y compris des caractères génériques). Le chemin d’accès est un chemin d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas ou est un fichier.</exception>
        <exception cref="T:System.IO.IOException">Un fichier du répertoire ou du sous-répertoire est en cours d'utilisation.</exception>
        <exception cref="T:System.NotSupportedException">Le nom de répertoire contient un signe deux points (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises.</exception>
        <exception cref="T:System.OperationCanceledException">L'utilisateur annule l'opération ou le répertoire ne peut pas être supprimé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.DeleteDirectory (directory, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="directory">Répertoire à supprimer.</param>
        <param name="showUI">Spécifie s'il faut effectuer un suivi visuel de l'avancement de l'opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Spécifie si le fichier supprimé doit être ou non envoyé à la **Corbeille**. La valeur par défaut est <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Spécifie si une exception doit être levée quand l’utilisateur clique sur **Annuler**.</param>
        <summary>Supprime un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `showUI`, `recycle`, et `onUserCancel` paramètres ne sont pas pris en charge dans les applications qui ne sont pas en mode utilisateur interactif, telles que les Services de Windows.  
  
   
  
## Examples  
 L’exemple supprime le répertoire `OldDirectory` uniquement si elle est vide.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, l’invitant à confirmer la suppression, mais n’envoie pas le contenu à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Cet exemple supprime le répertoire `OldDirectory` et tout son contenu, les envoyer à la **Corbeille**, mais n’affiche ne pas la progression de l’opération.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d'accès est une chaîne de longueur nulle, est incorrect, se compose uniquement d'espace blanc ou contient des caractères incorrects (y compris des caractères génériques). Le chemin d’accès est un chemin d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas ou est un fichier.</exception>
        <exception cref="T:System.IO.IOException">Un fichier du répertoire ou du sous-répertoire est en cours d'utilisation.</exception>
        <exception cref="T:System.NotSupportedException">Le nom de répertoire contient un signe deux points (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations requises.</exception>
        <exception cref="T:System.OperationCanceledException">L'utilisateur annule l'opération ou le répertoire ne peut pas être supprimé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime un fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteFile(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.DeleteFile : string -&gt; unit" Usage="fileSystemProxy.DeleteFile file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d'accès du fichier à supprimer.</param>
        <summary>Supprime un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.DeleteFile` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Pour supprimer un fichier|[Guide pratique : supprimer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Cet exemple supprime le fichier `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Cet exemple supprime le fichier `Test.txt` et autorise l’utilisateur à confirmer que le fichier doit être supprimé.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Cet exemple supprime le fichier `Test.txt` et l’envoie à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d’accès n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il contient une barre oblique finale alors qu’un fichier doit être spécifié ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d'utilisation.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation nécessaire pour supprimer le fichier ou le fichier est en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="member this.DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="fileSystemProxy.DeleteFile (file, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d'accès du fichier à supprimer.</param>
        <param name="showUI">Indique si un suivi visuel de l'avancement de l'opération est nécessaire. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Spécifie si le fichier supprimé doit être envoyé à la **Corbeille**. La valeur par défaut est <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Supprime un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `showUI` et `recycle` paramètres ne sont pas pris en charge dans les applications qui ne sont pas en mode utilisateur interactif, telles que les Services de Windows.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.DeleteFile` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Pour supprimer un fichier|[Guide pratique : supprimer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Cet exemple supprime le fichier `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Cet exemple supprime le fichier `Test.txt` et autorise l’utilisateur à confirmer que le fichier doit être supprimé.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Cet exemple supprime le fichier `Test.txt` et l’envoie à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d’accès n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il contient une barre oblique finale alors qu’un fichier doit être spécifié ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d'utilisation.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation nécessaire pour supprimer le fichier ou le fichier est en lecture seule.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.DeleteFile (file, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d'accès du fichier à supprimer.</param>
        <param name="showUI">Indique si un suivi visuel de l'avancement de l'opération est nécessaire. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Spécifie si le fichier supprimé doit être envoyé à la **Corbeille**. La valeur par défaut est <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Spécifie si oui ou non une exception est levée lorsque l'utilisateur annule l'opération. La valeur par défaut est <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Supprime un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `showUI`, `recycle`, et `onUserCancel` paramètres ne sont pas pris en charge dans les applications qui ne sont pas en mode utilisateur interactif, telles que les Services de Windows.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.DeleteFile` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Pour supprimer un fichier|[Guide pratique : supprimer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Cet exemple supprime le fichier `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Cet exemple supprime le fichier `Test.txt` et autorise l’utilisateur à confirmer que le fichier doit être supprimé.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Cet exemple supprime le fichier `Test.txt` et l’envoie à la **Corbeille**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d’accès n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il contient une barre oblique finale alors qu’un fichier doit être spécifié ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est en cours d'utilisation.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation nécessaire pour supprimer le fichier ou le fichier est en lecture seule.</exception>
        <exception cref="T:System.OperationCanceledException">L'utilisateur a annulé l'opération et <paramref name="onUserCancel" /> a la valeur <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public bool DirectoryExists (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance bool DirectoryExists(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DirectoryExists (directory As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DirectoryExists(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.DirectoryExists : string -&gt; bool" Usage="fileSystemProxy.DirectoryExists directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Chemin d'accès du répertoire.</param>
        <summary>Retourne la valeur <see langword="True" /> si le répertoire spécifié existe.</summary>
        <returns>
          <see langword="True" /> si le répertoire existe ; sinon <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple détermine si le répertoire `C:\backup\logs` existe et vérifie ses propriétés.  
  
 [!code-vb[VbRefFile#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Drives">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt; Drives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.DriveInfo&gt; Drives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.MyServices.FileSystemProxy.Drives" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Drives As ReadOnlyCollection(Of DriveInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ Drives { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Drives : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;" Usage="Microsoft.VisualBasic.MyServices.FileSystemProxy.Drives" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne une collection en lecture seule de tous les noms de lecteurs disponibles.</summary>
        <value>Collection en lecture seule de tous les lecteurs disponibles en tant qu'objets <see cref="T:System.IO.DriveInfo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne tous les lecteurs logiques.  
  
   
  
## Examples  
 Cet exemple affiche les noms de lecteur disponible dans une boîte de message.  
  
 [!code-vb[VbRefFile#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public bool FileExists (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance bool FileExists(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileExists (file As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool FileExists(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.FileExists : string -&gt; bool" Usage="fileSystemProxy.FileExists file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d'accès du fichier.</param>
        <summary>Retourne la valeur <see langword="True" /> si le fichier spécifié existe.</summary>
        <returns>Retourne <see langword="True" /> si le fichier existe ; sinon, cette méthode retourne <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’application ne dispose pas des autorisations suffisantes pour lire le fichier spécifié, le `FileExists` méthode retourne `False`, indépendamment de l’existence du chemin d’accès ; la méthode ne lève pas une exception.  
  
   
  
## Examples  
 Cet exemple vérifie si le fichier `Check.txt` existe et fournit les informations contenues dans une boîte de message.  
  
 [!code-vb[VbRefFile#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom du fichier se termine par une barre oblique inverse (\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FindInFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une collection en lecture seule de chaînes qui représentent le nom des fichiers contenant le texte spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType);" />
      <MemberSignature Language="F#" Value="member this.FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.FindInFiles (directory, containsText, ignoreCase, searchType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="directory">Répertoire dans lequel effectuer la recherche.</param>
        <param name="containsText">Texte de la recherche.</param>
        <param name="ignoreCase">
          <see langword="True" /> si la recherche doit respecter la casse ; sinon, <see langword="False" />. La valeur par défaut est <see langword="True" />.</param>
        <param name="searchType">Inclure, ou non, les sous-dossiers. La valeur par défaut est <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <summary>Retourne une collection en lecture seule de chaînes qui représentent le nom des fichiers contenant le texte spécifié.</summary>
        <returns>Collection en lecture seule des noms des fichiers contenant le texte spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection vide est retournée si aucun fichier correspondant au modèle spécifié n'est détecté.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.FindInFiles` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Rechercher dans un répertoire pour les fichiers contenant une chaîne spécifique|[Procédure pas à pas : manipulation de fichiers et de répertoires en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 Cet exemple recherche dans le répertoire `C:\TestDir` pour tous les fichiers contenant la chaîne `"sample string"` et affiche les résultats dans `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Pour pouvoir fonctionner, le projet doit contenir un `ListBox` nommé `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur nulle, il ne contient que des espaces blancs, il contient des caractères non valides ou il s’agit d’un chemin d’appareil (qui commence par <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le dossier spécifié n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Le chemin d'accès du répertoire spécifié contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] fileWildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption, ParamArray fileWildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ fileWildcards);" />
      <MemberSignature Language="F#" Value="member this.FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.FindInFiles (directory, containsText, ignoreCase, searchType, fileWildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="fileWildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Répertoire dans lequel effectuer la recherche.</param>
        <param name="containsText">Texte de la recherche.</param>
        <param name="ignoreCase">
          <see langword="True" /> si la recherche doit respecter la casse ; sinon, <see langword="False" />. La valeur par défaut est <see langword="True" />.</param>
        <param name="searchType">Inclure, ou non, les sous-dossiers. La valeur par défaut est <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="fileWildcards">Modèle auquel correspondre.</param>
        <summary>Retourne une collection en lecture seule de chaînes qui représentent le nom des fichiers contenant le texte spécifié.</summary>
        <returns>Collection en lecture seule des noms des fichiers contenant le texte spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection vide est retournée si aucun fichier correspondant au modèle spécifié n'est détecté.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.FindInFiles` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Rechercher dans un répertoire pour les fichiers contenant une chaîne spécifique|[Procédure pas à pas : manipulation de fichiers et de répertoires en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 Cet exemple recherche dans le répertoire `C:\TestDir` pour tous les fichiers contenant la chaîne `"sample string"` et affiche les résultats dans `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Pour pouvoir fonctionner, le projet doit contenir un `ListBox` nommé `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur nulle, il ne contient que des espaces blancs, il contient des caractères non valides ou il s’agit d’un chemin d’appareil (qui commence par <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le dossier spécifié n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Le chemin d'accès du répertoire spécifié contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une collection de chaînes représentant les chemins d'accès de sous-répertoires présents dans un répertoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetDirectories directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Nom et chemin d'accès du répertoire.</param>
        <summary>Retourne une collection de chaînes représentant les chemins d'accès de sous-répertoires présents dans un répertoire.</summary>
        <returns>Collection en lecture seule des noms de chemin d'accès des sous-répertoires dans le répertoire spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.GetDirectories` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Liste des sous-répertoires avec un modèle spécifique|[Guide pratique pour rechercher des sous-répertoires avec un modèle spécifique](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L’exemple suivant retourne tous les répertoires dans la structure de répertoires qui contiennent le mot `Logs` dans leurs noms et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 Cet exemple nécessite que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le dossier spécifié n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDirectories(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetDirectories (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Nom et chemin d'accès du répertoire.</param>
        <param name="searchType">Inclure, ou non, les sous-dossiers. La valeur par défaut est <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Modèle permettant d'établir une correspondance entre les noms.</param>
        <summary>Retourne une collection de chaînes représentant les chemins d'accès de sous-répertoires présents dans un répertoire.</summary>
        <returns>Collection en lecture seule des noms de chemin d'accès des sous-répertoires dans le répertoire spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le paramètre `wildcards` pour indiquer un modèle spécifique. Si vous souhaitez inclure le contenu des sous-répertoires dans la recherche, affectez la valeur `SearchAllSubDirectories` au paramètre `searchType`.  
  
 Une collection vide est retournée si aucun répertoire correspondant au modèle spécifié n’est détecté.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.GetDirectories` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Liste des sous-répertoires avec un modèle spécifique|[Guide pratique pour rechercher des sous-répertoires avec un modèle spécifique](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L’exemple suivant retourne tous les répertoires dans la structure de répertoires qui contiennent le mot `Logs` dans leurs noms et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 Cet exemple nécessite que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs des caractères génériques spécifiés ont une valeur <see langword="Nothing" />, une chaîne vide ou contiennent uniquement des espaces.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le dossier spécifié n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryInfo">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo GetDirectoryInfo (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDirectoryInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectoryInfo (directory As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ GetDirectoryInfo(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.GetDirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="fileSystemProxy.GetDirectoryInfo directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">
          <see langword="String" />. Chemin d'accès du répertoire.</param>
        <summary>Retourne un objet <see cref="T:System.IO.DirectoryInfo" /> pour le fichier spécifié.</summary>
        <returns>Objet <see cref="T:System.IO.DirectoryInfo" /> pour le chemin spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le répertoire n’existe pas, une exception n'est pas levée tant que la première fois une propriété le <xref:System.IO.DirectoryInfo> objet est accessible.  
  
   
  
## Examples  
 Cet exemple obtient un <xref:System.IO.DirectoryInfo> objet pour le répertoire `C:\Documents and Settings` et affiche le répertoire heure de création du dernier accès et d’heure dernière heure d’écriture.  
  
 [!code-vb[VbRefFile#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Le chemin d'accès du répertoire contient un signe deux-points (:) ou n'a pas un format valide.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetDriveInfo">
      <MemberSignature Language="C#" Value="public System.IO.DriveInfo GetDriveInfo (string drive);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDriveInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDriveInfo (drive As String) As DriveInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DriveInfo ^ GetDriveInfo(System::String ^ drive);" />
      <MemberSignature Language="F#" Value="member this.GetDriveInfo : string -&gt; System.IO.DriveInfo" Usage="fileSystemProxy.GetDriveInfo drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DriveInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="drive">Lecteur à examiner.</param>
        <summary>Retourne un objet <see cref="T:System.IO.DriveInfo" /> pour le fichier spécifié.</summary>
        <returns>Objet <see cref="T:System.IO.DriveInfo" /> pour le lecteur spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.DriveInfo> classe Modélise un lecteur et fournit des méthodes et propriétés pour demander des informations sur le lecteur. Utilisez <xref:System.IO.DriveInfo> pour déterminer les lecteurs disponibles et leur type. Vous pouvez également interroger la propriété pour déterminer la capacité et l’espace libre disponible sur le lecteur.  
  
   
  
## Examples  
 Cet exemple obtienne un <xref:System.IO.DriveInfo> objet pour le lecteur C et l’utilise pour afficher des informations sur le lecteur.  
  
 [!code-vb[VbRefFile#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#11)]  
  
 Pour plus d’informations sur les différents types de lecteurs, consultez <xref:System.IO.DriveType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="drive" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <altmember cref="T:System.IO.DriveType" />
      </Docs>
    </Member>
    <Member MemberName="GetFileInfo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo GetFileInfo (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.FileInfo GetFileInfo(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetFileInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileInfo (file As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ GetFileInfo(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.GetFileInfo : string -&gt; System.IO.FileInfo" Usage="fileSystemProxy.GetFileInfo file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d'accès du fichier.</param>
        <summary>Retourne un objet <see cref="T:System.IO.FileInfo" /> pour le fichier spécifié.</summary>
        <returns>Objet <see cref="T:System.IO.FileInfo" /> pour le fichier spécifié</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une exception n’est pas levée si le fichier n’existe pas ; au lieu de cela, elle est levée la première fois que les propriétés de l’objet sont accessibles.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.GetFileInfo` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Déterminer le nom et le chemin d’accès d’un fichier|[Guide pratique pour analyser des chemins](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Cet exemple récupère un <xref:System.IO.FileInfo?displayProperty=nameWithType> objet pour le fichier `MyLogFile.log` et l’utilise pour signaler le nom complet du fichier, heure du dernier accès et longueur.  
  
 [!code-vb[VbRefFile#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d'accès est mal formé. Par exemple, il contient des caractères non valides ou se compose uniquement d'espace blanc. Le nom du fichier contient une marque de barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.NotSupportedException">Le chemin d'accès contient le signe deux-points au milieu de la chaîne.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès est trop long.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'accès ACL (liste de contrôle d'accès) au fichier.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.FileInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une collection en lecture seule de chaînes qui représentent le nom des fichiers d'un répertoire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetFiles directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Répertoire dans lequel effectuer la recherche.</param>
        <summary>Retourne une collection en lecture seule de chaînes qui représentent le nom des fichiers d'un répertoire.</summary>
        <returns>Collection en lecture seule de noms de fichiers issus du répertoire spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection vide est retournée si aucun fichier correspondant au modèle spécifié n'est détecté.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.GetFiles` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Obtenez la collection de fichiers dans un répertoire|[Guide pratique pour placer la collection de fichiers dans un répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Rechercher des fichiers avec un modèle spécifique dans un répertoire|[Guide pratique : rechercher des fichiers avec un modèle spécifique](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L’exemple suivant retourne tous les fichiers contenus dans le répertoire et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 Cet exemple nécessite que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 Cet exemple retourne tous les fichiers dans le répertoire avec l’extension `.txt` et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 Cet exemple nécessite que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le dossier à rechercher n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="directory" /> pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetFiles(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetFiles (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Répertoire dans lequel effectuer la recherche.</param>
        <param name="searchType">Inclure, ou non, les sous-dossiers. La valeur par défaut est <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Modèle auquel correspondre.</param>
        <summary>Retourne une collection en lecture seule de chaînes qui représentent le nom des fichiers d'un répertoire.</summary>
        <returns>Collection en lecture seule de noms de fichiers issus du répertoire spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une collection vide est retournée si aucun fichier correspondant au modèle spécifié n'est détecté.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.GetFiles` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Obtenez la collection de fichiers dans un répertoire|[Guide pratique pour placer la collection de fichiers dans un répertoire](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Rechercher des fichiers avec un modèle spécifique dans un répertoire|[Guide pratique : rechercher des fichiers avec un modèle spécifique](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 L’exemple suivant retourne tous les fichiers contenus dans le répertoire et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 Cet exemple nécessite que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 Cet exemple retourne tous les fichiers dans le répertoire avec l’extension `.txt` et les ajoute à `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 Cet exemple nécessite que vous avez un `ListBox` nommé `ListBox1` sur votre formulaire.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le dossier à rechercher n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="directory" /> pointe vers un fichier existant.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas les autorisations nécessaires.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public string GetName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string GetName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.GetName : string -&gt; string" Usage="fileSystemProxy.GetName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Obligatoire. Chemin d'accès à analyser. <see langword="String" />.</param>
        <summary>Analyse le nom du fichier à partir du chemin d'accès fourni.</summary>
        <returns>Nom de fichier à partir du chemin d'accès spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une opération de chaîne ; le `FileSystem` n’est pas examiné.  
  
 Le `GetName` méthode ignore une marque de barre oblique présente à la fin du chemin d’accès.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.GetFileName` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Analyser un chemin d’accès de fichier|[Guide pratique pour analyser des chemins](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 L’exemple suivant analyse un chemin d’accès de fichier et retourne le nom du fichier.  
  
 [!code-vb[VbVbcnMyFileSystem#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#21)]  
  
 Remplacez le chemin d’accès `C:\Testdirectory\Testfile` avec le chemin d’accès que vous souhaitez analyser.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParentPath">
      <MemberSignature Language="C#" Value="public string GetParentPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string GetParentPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetParentPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParentPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetParentPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.GetParentPath : string -&gt; string" Usage="fileSystemProxy.GetParentPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d'accès à examiner.</param>
        <summary>Retourne le chemin d'accès parent du chemin d'accès fourni.</summary>
        <returns>Chemin d'accès parent du chemin d'accès fourni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une opération de chaîne ; le système de fichiers n’est pas examiné.  
  
   
  
## Examples  
 Cet exemple obtient le chemin d’accès parent pour `C:\Backups\Tmp\Test`.  
  
 [!code-vb[VbRefFile#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d'accès n'a pas de chemin parent car il s'agit d'un chemin d'accès racine.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="member this.GetTempFileName : unit -&gt; string" Usage="fileSystemProxy.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un fichier temporaire de zéro octet nommé de manière unique sur le disque et retourne le chemin d'accès complet de ce fichier.</summary>
        <returns>
          <see langword="String" /> contenant le chemin d'accès complet du fichier temporaire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour créer un fichier temporaire.  
  
   
  
## Examples  
 Cet exemple crée un fichier temporaire et retourne son chemin d’accès.  
  
 [!code-vb[VbVbcnMyFileSystem#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Déplace un répertoire d'un emplacement à l'autre.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Chemin d'accès au répertoire à déplacer.</param>
        <param name="destinationDirectoryName">Chemin d'accès au répertoire dans lequel le répertoire source est déplacé.</param>
        <summary>Déplace un répertoire d'un emplacement à l'autre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une tentative est effectuée pour déplacer un répertoire à l’intérieur d’un répertoire qui n’existe pas, la structure cible sera créée.  
  
   
  
## Examples  
 Cet exemple déplace `Directory1` dans `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Cet exemple déplace `Directory1` à l’intérieur de `Directory2`, en remplaçant le répertoire s’il existe déjà.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">La source est un répertoire racine ou le chemin source et le chemin cible sont identiques.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Chemin d'accès au répertoire à déplacer.</param>
        <param name="destinationDirectoryName">Chemin d'accès au répertoire dans lequel le répertoire source est déplacé.</param>
        <param name="showUI">Spécifie s'il faut effectuer un suivi visuel de l'avancement de l'opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Déplace un répertoire d'un emplacement à l'autre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une tentative est effectuée pour déplacer un répertoire à l’intérieur d’un répertoire qui n’existe pas, la structure cible sera créée.  
  
   
  
## Examples  
 Cet exemple déplace `Directory1` dans `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Cet exemple déplace `Directory1` à l’intérieur de `Directory2`, en remplaçant le répertoire s’il existe déjà.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire cible existe déjà et <paramref name="overwrite" /> est défini à <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string * bool -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Chemin d'accès au répertoire à déplacer.</param>
        <param name="destinationDirectoryName">Chemin d'accès au répertoire dans lequel le répertoire source est déplacé.</param>
        <param name="overwrite">
          <see langword="True" /> si les répertoires existants doivent être remplacés ; sinon, <see langword="False" />. La valeur par défaut est <see langword="False" />.</param>
        <summary>Déplace un répertoire d'un emplacement à l'autre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une tentative est effectuée pour déplacer un répertoire à l’intérieur d’un répertoire qui n’existe pas, la structure cible sera créée.  
  
   
  
## Examples  
 Cet exemple déplace `Directory1` dans `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Cet exemple déplace `Directory1` à l’intérieur de `Directory2`, en remplaçant le répertoire s’il existe déjà.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire cible existe déjà et <paramref name="overwrite" /> est défini à <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Chemin d'accès au répertoire à déplacer.</param>
        <param name="destinationDirectoryName">Chemin d'accès au répertoire dans lequel le répertoire source est déplacé.</param>
        <param name="showUI">Spécifie s'il faut effectuer un suivi visuel de l'avancement de l'opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Spécifie si oui ou non une exception est levée lorsque l'utilisateur annule l'opération. La valeur par défaut est <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Déplace un répertoire d'un emplacement à l'autre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une tentative est effectuée pour déplacer un répertoire à l’intérieur d’un répertoire qui n’existe pas, la structure cible sera créée.  
  
   
  
## Examples  
 Cet exemple déplace `Directory1` dans `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Cet exemple déplace `Directory1` à l’intérieur de `Directory2`, en remplaçant le répertoire s’il existe déjà.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il s’agit d’une chaîne de longueur null ; il ne contient que des espaces blancs ; il contient des caractères non valides ; il s’agit d’un chemin d’accès d’appareil (commençant par \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> ou <paramref name="destinationDirectoryName" /> est <see langword="Nothing" /> ou représente une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="onUserCancel" /> a la valeur <see langword="ThrowException" /> et un sous-répertoire du fichier ne peut pas être copié.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="onUserCancel" /> a la valeur <see langword="ThrowException" /> et l'utilisateur annule l'opération ou l'opération ne peut pas être effectuée.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.InvalidOperationException">L'opération est cyclique.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Déplace un fichier vers un nouvel emplacement.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Chemin d'accès au fichier à déplacer.</param>
        <param name="destinationFileName">Chemin d'accès au répertoire dans lequel le fichier doit être déplacé.</param>
        <summary>Déplace un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la structure cible n’existe pas, il est créé.  
  
 Le `MoveFile` méthode conserve les ACE (entrées de contrôle d’accès) uniquement lors du déplacement du fichier dans le même volume. Cela inclut les ACE héritées, qui deviennent des entrées directes déplacé (direct ACE ont priorité sur les ACE héritées). Si un fichier est déplacé entre les volumes, les ACE ne seront pas copiés.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.MoveFile` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Déplacer un fichier|[Guide pratique : déplacer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2` et le renomme `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Chemin d'accès au fichier à déplacer.</param>
        <param name="destinationFileName">Chemin d'accès au répertoire dans lequel le fichier doit être déplacé.</param>
        <param name="showUI">Spécifie s'il faut effectuer un suivi visuel de l'avancement de l'opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Déplace un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la structure cible n’existe pas, il est créé.  
  
 Le `MoveFile` méthode conserve les ACE (entrées de contrôle d’accès) uniquement lors du déplacement du fichier dans le même volume. Cela inclut les ACE héritées, qui deviennent des entrées directes déplacé (direct ACE ont priorité sur les ACE héritées). Si un fichier est déplacé entre les volumes, les ACE ne seront pas copiés.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.MoveFile` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Déplacer un fichier|[Guide pratique : déplacer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2` et le renomme `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string * bool -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Chemin d'accès au fichier à déplacer.</param>
        <param name="destinationFileName">Chemin d'accès au répertoire dans lequel le fichier doit être déplacé.</param>
        <param name="overwrite">
          <see langword="True" /> pour remplacer les fichiers existants ; sinon, <see langword="False" />. La valeur par défaut est <see langword="False" />.</param>
        <summary>Déplace un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la structure cible n’existe pas, il est créé.  
  
 Le `MoveFile` méthode conserve les ACE (entrées de contrôle d’accès) uniquement lors du déplacement du fichier dans le même volume. Cela inclut les ACE héritées, qui deviennent des entrées directes déplacé (direct ACE ont priorité sur les ACE héritées). Si un fichier est déplacé entre les volumes, les ACE ne seront pas copiés.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.MoveFile` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Déplacer un fichier|[Guide pratique : déplacer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2` et le renomme `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Chemin d'accès au fichier à déplacer.</param>
        <param name="destinationFileName">Chemin d'accès au répertoire dans lequel le fichier doit être déplacé.</param>
        <param name="showUI">Spécifie s'il faut effectuer un suivi visuel de l'avancement de l'opération. La valeur par défaut est <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Spécifie si oui ou non une exception est levée lorsque l'utilisateur annule l'opération. La valeur par défaut est <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Déplace un fichier vers un nouvel emplacement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la structure cible n’existe pas, il est créé.  
  
 Le `MoveFile` méthode conserve les ACE (entrées de contrôle d’accès) uniquement lors du déplacement du fichier dans le même volume. Cela inclut les ACE héritées, qui deviennent des entrées directes déplacé (direct ACE ont priorité sur les ACE héritées). Si un fichier est déplacé entre les volumes, les ACE ne seront pas copiés.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.MoveFile` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Déplacer un fichier|[Guide pratique : déplacer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Cet exemple déplace le fichier `Test.txt` de `TestDir1` à `TestDir2` et le renomme `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier source n'est pas valide ou n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="onUserCancel" /> a la valeur <see langword="ThrowException" /> et l'utilisateur a annulé l'opération ou une erreur d'E/S non spécifiée s'est produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Contrôle la capacité à accéder à toutes les variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Contrôle la possibilité d’accéder aux variables de Registre. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Contrôle les autorisations relatives aux interfaces utilisateur et au Presse-papiers. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFieldParser">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>La méthode <see langword="OpenTextFieldParser" /> vous permet de créer un objet <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> et d'analyser ainsi efficacement et facilement les fichiers texte structurés, comme les journaux. L'objet <see langword="TextFieldParser" /> peut être utilisé pour lire des fichiers délimités et à largeur fixe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFieldParser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFieldParser (file As String) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="fileSystemProxy.OpenTextFieldParser file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Fichier à ouvrir avec <see langword="TextFieldParser" />.</param>
        <summary>La méthode <see langword="OpenTextFieldParser" /> vous permet de créer un objet <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> et d'analyser ainsi efficacement et facilement les fichiers texte structurés, comme les journaux. L'objet <see langword="TextFieldParser" /> peut être utilisé pour lire des fichiers délimités et à largeur fixe.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> pour lire le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.OpenTextFieldParser` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Lire à partir d’un fichier texte délimité|[Guide pratique : lire des fichiers texte délimités par des virgules](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire un fichier texte de largeur fixe|[Guide pratique : lire des fichiers texte de largeur fixe](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lire un fichier texte avec plusieurs formats|[Guide pratique : lire des fichiers texte avec plusieurs formats](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Cet exemple ouvre le `TextFieldParser.reader` et l’utilise pour lire à partir de `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Une ligne ne peut pas être analysée avec le format spécifié. Le message d’exception spécifie la ligne qui provoque l’exception, tandis que la propriété <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> est assignée au texte contenu dans la ligne.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Décrit un ensemble d’autorisations de sécurité appliquées au code. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFieldParser(System.String,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFieldParser (file As String, ParamArray fieldWidths As Integer()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFieldParser : string * int[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="fileSystemProxy.OpenTextFieldParser (file, fieldWidths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Fichier à ouvrir avec <see langword="TextFieldParser" />.</param>
        <param name="fieldWidths">Largeur des champs.</param>
        <summary>La méthode <see langword="OpenTextFieldParser" /> vous permet de créer un objet <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> et d'analyser ainsi efficacement et facilement les fichiers texte structurés, comme les journaux. L'objet <see langword="TextFieldParser" /> peut être utilisé pour lire des fichiers délimités et à largeur fixe.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> pour lire le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.OpenTextFieldParser` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Lire à partir d’un fichier texte délimité|[Guide pratique : lire des fichiers texte délimités par des virgules](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire un fichier texte de largeur fixe|[Guide pratique : lire des fichiers texte de largeur fixe](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lire un fichier texte avec plusieurs formats|[Guide pratique : lire des fichiers texte avec plusieurs formats](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Cet exemple ouvre le `TextFieldParser.reader` et l’utilise pour lire à partir de `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Une ligne ne peut pas être analysée avec le format spécifié. Le message d’exception spécifie la ligne qui provoque l’exception, tandis que la propriété <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> est assignée au texte contenu dans la ligne.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Décrit un ensemble d’autorisations de sécurité appliquées au code. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFieldParser(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFieldParser (file As String, ParamArray delimiters As String()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFieldParser : string * string[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="fileSystemProxy.OpenTextFieldParser (file, delimiters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Fichier à ouvrir avec <see langword="TextFieldParser" />.</param>
        <param name="delimiters">Séparateurs de champs.</param>
        <summary>La méthode <see langword="OpenTextFieldParser" /> vous permet de créer un objet <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> et d'analyser ainsi efficacement et facilement les fichiers texte structurés, comme les journaux. L'objet <see langword="TextFieldParser" /> peut être utilisé pour lire des fichiers délimités et à largeur fixe.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> pour lire le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.OpenTextFieldParser` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Lire à partir d’un fichier texte délimité|[Guide pratique : lire des fichiers texte délimités par des virgules](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Lire un fichier texte de largeur fixe|[Guide pratique : lire des fichiers texte de largeur fixe](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Lire un fichier texte avec plusieurs formats|[Guide pratique : lire des fichiers texte avec plusieurs formats](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Cet exemple ouvre le `TextFieldParser.reader` et l’utilise pour lire à partir de `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Une ligne ne peut pas être analysée avec le format spécifié. Le message d’exception spécifie la ligne qui provoque l’exception, tandis que la propriété <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> est assignée au texte contenu dans la ligne.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Décrit un ensemble d’autorisations de sécurité appliquées au code. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileReader">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un objet <see cref="T:System.IO.StreamReader" /> à lire à partir d'un fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenTextFileReader (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamReader OpenTextFileReader(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileReader(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFileReader (file As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileReader : string -&gt; System.IO.StreamReader" Usage="fileSystemProxy.OpenTextFileReader file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Fichier à lire.</param>
        <summary>Ouvre un objet <see cref="T:System.IO.StreamReader" /> à lire à partir d'un fichier.</summary>
        <returns>Objet <see cref="T:System.IO.StreamReader" /> à lire à partir du fichier</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Seuls les fichiers texte peuvent être lus avec un <xref:System.IO.StreamReader>.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.OpenTextFileReader` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Ouvrir un fichier avec un <xref:System.IO.StreamReader>|[Guide pratique : lire le texte des fichiers avec un StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 Cet exemple ouvre le fichier `Testfile.txt`, lit une ligne à partir de celui-ci et l’affiche dans un `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom de fichier se termine par une barre oblique inverse (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié est introuvable.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour lire le fichier.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenTextFileReader (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileReader(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="fileSystemProxy.OpenTextFileReader (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Fichier à lire.</param>
        <param name="encoding">Encodage à utiliser pour le contenu du fichier. La valeur par défaut est ASCII.</param>
        <summary>Ouvre un objet <see cref="T:System.IO.StreamReader" /> à lire à partir d'un fichier.</summary>
        <returns>Objet <see cref="T:System.IO.StreamReader" /> à lire à partir du fichier</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Seuls les fichiers texte peuvent être lus avec un <xref:System.IO.StreamReader>.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.OpenTextFileReader` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Ouvrir un fichier avec un <xref:System.IO.StreamReader>|[Guide pratique : lire le texte des fichiers avec un StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 Cet exemple ouvre le fichier `Testfile.txt`, lit une ligne à partir de celui-ci et l’affiche dans un `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom de fichier se termine par une barre oblique inverse (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié est introuvable.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour lire le fichier.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileWriter">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un objet <see cref="T:System.IO.StreamWriter" /> à écrire dans le fichier spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter OpenTextFileWriter (string file, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFileWriter (file As String, append As Boolean) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileWriter : string * bool -&gt; System.IO.StreamWriter" Usage="fileSystemProxy.OpenTextFileWriter (file, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Fichier dans lequel écrire.</param>
        <param name="append">
          <see langword="True" /> pour ajouter au contenu du fichier ; <see langword="False" /> pour remplacer le contenu du fichier. La valeur par défaut est <see langword="False" />.</param>
        <summary>Ouvre un objet <see cref="T:System.IO.StreamWriter" /> à écrire dans le fichier spécifié.</summary>
        <returns>Objet <see cref="T:System.IO.StreamWriter" /> à écrire dans le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `OpenTextFileWriter` méthode ouvre et initialise un flux de données pour un fichier et renvoie ensuite le <xref:System.IO.StreamWriter> objet pour ce flux. Vous pouvez écrire dans le flux de données autant de fois que nécessaire et puis le fermer lorsque vous avez terminé.  
  
> [!NOTE]
>  Vous devez appeler la <xref:System.IO.StreamWriter.Close%2A> méthode sur le <xref:System.IO.StreamWriter> objet pour vous assurer que toutes les données sont correctement écrites dans le flux sous-jacent.  
  
 Si vous écrivez uniquement quelques chaînes dans un fichier, il peut être plus simple d’utiliser le <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText%2A> (méthode).  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.OpenTextFileWriter` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Écrire du texte dans un fichier avec un `StreamWriter`|[Guide pratique : écrire du texte dans des fichiers à l'aide de Streamwriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 Cet exemple ouvre un <xref:System.IO.StreamWriter> avec la `My.Computer.FileSystem.OpenTextFileWriter` (méthode) et l’utilise pour écrire une chaîne dans un fichier texte avec le `WriteLine` méthode de la `StreamWriter` classe.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom de fichier se termine par une barre oblique finale.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter OpenTextFileWriter (string file, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileWriter : string * bool * System.Text.Encoding -&gt; System.IO.StreamWriter" Usage="fileSystemProxy.OpenTextFileWriter (file, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Fichier dans lequel écrire.</param>
        <param name="append">
          <see langword="True" /> pour ajouter au contenu du fichier  ; <see langword="False" /> pour remplacer le contenu du fichier. La valeur par défaut est <see langword="False" />.</param>
        <param name="encoding">Encodage à utiliser lors de l'écriture dans le fichier. La valeur par défaut est ASCII.</param>
        <summary>Ouvre un <see cref="T:System.IO.StreamWriter" /> pour écrire dans le fichier spécifié.</summary>
        <returns>Objet <see cref="T:System.IO.StreamWriter" /> à écrire dans le fichier spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `OpenTextFileWriter` méthode ouvre et initialise un flux de données pour un fichier et renvoie ensuite le <xref:System.IO.StreamWriter> objet pour ce flux. Vous pouvez écrire dans le flux de données autant de fois que nécessaire et puis le fermer lorsque vous avez terminé.  
  
> [!NOTE]
>  Vous devez appeler la <xref:System.IO.StreamWriter.Close%2A> méthode sur le <xref:System.IO.StreamWriter> objet pour vous assurer que toutes les données sont correctement écrites dans le flux sous-jacent.  
  
 Si vous écrivez uniquement quelques chaînes dans un fichier, il peut être plus simple d’utiliser le <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText%2A> (méthode).  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.OpenTextFileWriter` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Écrire du texte dans un fichier avec un `StreamWriter`|[Guide pratique : écrire du texte dans des fichiers à l'aide de Streamwriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 Cet exemple ouvre un <xref:System.IO.StreamWriter> avec la `My.Computer.FileSystem.OpenTextFileWriter` (méthode) et l’utilise pour écrire une chaîne dans un fichier texte avec le `WriteLine` méthode de la `StreamWriter` classe.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom de fichier se termine par une barre oblique finale.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public byte[] ReadAllBytes (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance unsigned int8[] ReadAllBytes(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAllBytes (file As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.ReadAllBytes : string -&gt; byte[]" Usage="fileSystemProxy.ReadAllBytes file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Fichier à lire.</param>
        <summary>Retourne le contenu d'un fichier sous la forme d'un tableau d'octets.</summary>
        <returns>Tableau <see langword="Byte" /> contenant le contenu du fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ReadAllBytes` méthode de la `My.Computer.FileSystem` objet vous permet de lire à partir d’un fichier binaire. Le contenu du fichier est retourné comme un tableau d’octets.  
  
 Ne vous basez pas sur le nom d'un fichier pour en déterminer le contenu. Par exemple, le fichier Form1.vb peut ne pas être un fichier source Visual Basic. Vérifiez toutes les entrées avant d'utiliser les données dans votre application.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.ReadAllBytes` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Lire à partir d'un fichier binaire|[Guide pratique : lire des fichiers binaires](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
  
   
  
## Examples  
 Cet exemple lit à partir du fichier `C:/Documents and Settings/selfportrait.jpg.`  
  
 [!code-vb[VbVbcnMyFileSystem#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n'y a pas assez de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne le contenu d'un fichier texte sous forme de <see langword="String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public string ReadAllText (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadAllText(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAllText (file As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadAllText(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.ReadAllText : string -&gt; string" Usage="fileSystemProxy.ReadAllText file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d'accès du fichier à lire.</param>
        <summary>Retourne le contenu d'un fichier texte sous forme de <see langword="String" />.</summary>
        <returns>
          <see langword="String" /> contenant le contenu du fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode `ReadAllText` de l'objet `My.Computer.FileSystem` vous permet de lire un fichier texte. Le contenu du fichier est retourné sous forme de chaîne.  
  
 L’encodage du fichier peut être spécifié si le contenu du fichier dans un encodage ASCII ou UTF-8. Si vous lisez à partir d’un fichier avec des caractères étendus, vous devez spécifier l’encodage du fichier à l’aide d’une autre surcharge de la <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText%2A> (méthode).  
  
 Ne vous basez pas sur le nom d'un fichier pour en déterminer le contenu. Par exemple, le fichier Form1.vb peut ne pas être un fichier source Visual Basic. Vérifiez toutes les entrées avant d'utiliser les données dans votre application.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.ReadAllText` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Lire à partir d'un fichier texte|[Guide pratique : lire à partir de fichiers texte](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Cet exemple lit le contenu de `Test.txt` dans une chaîne puis l’affiche dans une boîte de message.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Cet exemple lit le contenu du fichier ASCII `Test.txt` dans une chaîne puis l’affiche dans une boîte de message.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n'y a pas assez de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText(System.String)" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public string ReadAllText (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadAllText(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.ReadAllText : string * System.Text.Encoding -&gt; string" Usage="fileSystemProxy.ReadAllText (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Nom et chemin d'accès du fichier à lire.</param>
        <param name="encoding">Encodage de caractères à utiliser pour la lecture du fichier. La valeur par défaut est UTF-8.</param>
        <summary>Retourne le contenu d'un fichier texte sous forme de <see langword="String" />.</summary>
        <returns>
          <see langword="String" /> contenant le contenu du fichier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode `ReadAllText` de l'objet `My.Computer.FileSystem` vous permet de lire un fichier texte. Le contenu du fichier est retourné sous forme de chaîne.  
  
 L’encodage du fichier peut être spécifié si le contenu du fichier dans un encodage ASCII ou UTF-8. Si vous lisez à partir d’un fichier avec des caractères étendus, vous devez spécifier l’encodage du fichier.  
  
 Ne vous basez pas sur le nom d'un fichier pour en déterminer le contenu. Par exemple, le fichier Form1.vb peut ne pas être un fichier source Visual Basic. Vérifiez toutes les entrées avant d'utiliser les données dans votre application.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.ReadAllText` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Lire à partir d'un fichier texte|[Guide pratique : lire à partir de fichiers texte](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Cet exemple lit le contenu de `Test.txt` dans une chaîne puis l’affiche dans une boîte de message.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Cet exemple lit le contenu du fichier ASCII `Test.txt` dans une chaîne puis l’affiche dans une boîte de message.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n'y a pas assez de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="RenameDirectory">
      <MemberSignature Language="C#" Value="public void RenameDirectory (string directory, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void RenameDirectory(string directory, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.RenameDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RenameDirectory (directory As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RenameDirectory(System::String ^ directory, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="member this.RenameDirectory : string * string -&gt; unit" Usage="fileSystemProxy.RenameDirectory (directory, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Chemin d'accès et nom du répertoire à renommer.</param>
        <param name="newName">Nouveau nom du répertoire.</param>
        <summary>Renomme un répertoire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne peut pas être utilisée pour déplacer un répertoire ; utiliser le `MoveDirectory` méthode pour déplacer et renommer le répertoire.  
  
   
  
## Examples  
 Cet exemple renomme la `Test` répertoire à `SecondTest`.  
  
 [!code-vb[VbVbcnMyFileSystem#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> contient des informations de chemin d’accès.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> est <see langword="Nothing" />.  
  
- ou - 
 <paramref name="newName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le répertoire n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Un fichier ou répertoire existe avec le nom spécifié dans <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="RenameFile">
      <MemberSignature Language="C#" Value="public void RenameFile (string file, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void RenameFile(string file, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.RenameFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RenameFile (file As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RenameFile(System::String ^ file, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="member this.RenameFile : string * string -&gt; unit" Usage="fileSystemProxy.RenameFile (file, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Fichier à renommer.</param>
        <param name="newName">Nouveau nom du fichier.</param>
        <summary>Renomme un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne peut pas être utilisée pour déplacer un fichier. Utilisez la méthode <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile%2A> pour déplacer et renommer le fichier.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.RenameFile` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Renommer un fichier|[Guide pratique : renommer un fichier](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
  
   
  
## Examples  
 Cet exemple renomme le fichier `Test.txt` à `SecondTest.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#1)]  
  
 Modification «`C:\Test.txt`» pour le chemin d’accès et le nom du fichier que vous souhaitez renommer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> contient des informations relatives au chemin d’accès ou se termine par une barre oblique inverse (\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.  
  
- ou - 
 <paramref name="newName" /> est soit <see langword="Nothing" /> soit une chaîne vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Un fichier ou répertoire existe avec le nom spécifié dans <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SpecialDirectories">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy SpecialDirectories { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy SpecialDirectories" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.MyServices.FileSystemProxy.SpecialDirectories" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SpecialDirectories As SpecialDirectoriesProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::MyServices::SpecialDirectoriesProxy ^ SpecialDirectories { Microsoft::VisualBasic::MyServices::SpecialDirectoriesProxy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SpecialDirectories : Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy" Usage="Microsoft.VisualBasic.MyServices.FileSystemProxy.SpecialDirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet qui fournit des propriétés pour accéder aux répertoires communément référencés.</summary>
        <value>Cette propriété retourne l'objet <see cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" /> de l'ordinateur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple retourne le chemin d’accès de fichier pour le répertoire de l’utilisateur bureau et l’affiche.  
  
 [!code-vb[VbVbcnMyFileSystem#80](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#80)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public void WriteAllBytes (string file, byte[] data, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllBytes(System.String,System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAllBytes (file As String, data As Byte(), append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAllBytes(System::String ^ file, cli::array &lt;System::Byte&gt; ^ data, bool append);" />
      <MemberSignature Language="F#" Value="member this.WriteAllBytes : string * byte[] * bool -&gt; unit" Usage="fileSystemProxy.WriteAllBytes (file, data, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Chemin d'accès et nom du fichier dans lequel écrire.</param>
        <param name="data">Données à écrire dans le fichier.</param>
        <param name="append">
          <see langword="True" /> pour ajouter au contenu du fichier  ; <see langword="False" /> pour remplacer le contenu du fichier. La valeur par défaut est <see langword="False" />.</param>
        <summary>Écrit des données dans un fichier binaire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le chemin d’accès spécifié, à l’exclusion du nom de fichier n’est pas valide, un <xref:System.IO.DirectoryNotFoundException> exception sera levée. Si le chemin d’accès est valide, mais le fichier n’existe pas, le fichier est créé.  
  
> [!NOTE]
>  Le `WriteAllBytes` méthode ouvre un fichier, écrit dedans, puis ferme ce dernier. Code qui utilise le `WriteAllBytes` méthode est plus simple que le code qui utilise un <xref:System.IO.BinaryWriter> objet. Toutefois, si vous ajoutez des données dans un fichier à l’aide d’une boucle, une <xref:System.IO.BinaryWriter> objet peut offrir de meilleures performances, car vous devez uniquement ouvrir et fermer le fichier une seule fois.  
  
 Le tableau suivant répertorie un exemple de tâche impliquant la `My.Computer.FileSystem.WriteAllBytes` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Écrire dans un fichier binaire|[Guide pratique : écrire dans des fichiers binaires](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
  
   
  
## Examples  
 Cet exemple ajoute le tableau de données `CustomerData` au fichier `CollectedData`.  
  
 [!code-vb[VbVbcnMyFileSystem#50](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n'y a pas assez de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit du texte dans un fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public void WriteAllText (string file, string text, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void WriteAllText(string file, string text, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAllText (file As String, text As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAllText(System::String ^ file, System::String ^ text, bool append);" />
      <MemberSignature Language="F#" Value="member this.WriteAllText : string * string * bool -&gt; unit" Usage="fileSystemProxy.WriteAllText (file, text, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Fichier dans lequel écrire.</param>
        <param name="text">Texte à écrire dans le fichier.</param>
        <param name="append">
          <see langword="True" /> pour ajouter au contenu du fichier ; <see langword="False" /> pour remplacer le contenu du fichier. La valeur par défaut est <see langword="False" />.</param>
        <summary>Écrit du texte dans un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’encodage UTF-8 est utilisé pour écrire dans le fichier. Pour spécifier un encodage différent, utilisez une autre surcharge de la <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText%2A> (méthode).  
  
 Si le fichier spécifié n’existe pas, il est créé.  
  
 Si l’encodage spécifié ne correspond pas au codage existant du fichier, le codage spécifié est ignoré.  
  
> [!NOTE]
>  Le `WriteAllText` méthode ouvre un fichier, écrit dedans, puis ferme ce dernier. Code qui utilise le `WriteAllText` méthode est plus simple que le code qui utilise un <xref:System.IO.StreamWriter> objet. Toutefois, si vous ajoutez des chaînes dans un fichier à l’aide d’une boucle, une <xref:System.IO.StreamWriter> objet peut offrir de meilleures performances, car vous devez uniquement ouvrir et fermer le fichier une seule fois. Pour plus d'informations, voir la méthode <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter%2A>.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.WriteAllText` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Écrire du texte dans un fichier|[Guide pratique : insérer du texte dans des fichiers](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Ajouter du texte dans un fichier|[Guide pratique : effectuer un ajout à des fichiers texte](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 Cet exemple écrit la ligne `"This is new text to be added."` au fichier `Test.txt`, remplace le texte existant dans le fichier.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 Cet exemple écrit les noms des fichiers dans le `Documents and Settings` dossier `FileList.txt`, insère un retour chariot entre chacun d’eux pour une meilleure lisibilité.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n'y a pas assez de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText(System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public void WriteAllText (string file, string text, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText(System.String,System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAllText(System::String ^ file, System::String ^ text, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.WriteAllText : string * string * bool * System.Text.Encoding -&gt; unit" Usage="fileSystemProxy.WriteAllText (file, text, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Fichier dans lequel écrire.</param>
        <param name="text">Texte à écrire dans le fichier.</param>
        <param name="append">
          <see langword="True" /> pour ajouter au contenu du fichier ; <see langword="False" /> pour remplacer le contenu du fichier. La valeur par défaut est <see langword="False" />.</param>
        <param name="encoding">Encodage à utiliser lors de l'écriture dans le fichier. La valeur par défaut est UTF-8.</param>
        <summary>Écrit du texte dans un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le fichier spécifié n’existe pas, il est créé.  
  
 Si l’encodage spécifié ne correspond pas au codage existant du fichier, le codage spécifié est ignoré.  
  
> [!NOTE]
>  Le `WriteAllText` méthode ouvre un fichier, écrit dedans, puis ferme ce dernier. Code qui utilise le `WriteAllText` méthode est plus simple que le code qui utilise un <xref:System.IO.StreamWriter> objet. Toutefois, si vous ajoutez des chaînes dans un fichier à l’aide d’une boucle, une <xref:System.IO.StreamWriter> objet peut offrir de meilleures performances, car vous devez uniquement ouvrir et fermer le fichier une seule fois. Pour plus d'informations, voir la méthode <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter%2A>.  
  
 Le tableau suivant répertorie des exemples de tâches impliquant la `My.Computer.FileSystem.WriteAllText` (méthode).  
  
|À|Voir|  
|--------|---------|  
|Écrire du texte dans un fichier|[Guide pratique : insérer du texte dans des fichiers](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Ajouter du texte dans un fichier|[Guide pratique : effectuer un ajout à des fichiers texte](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 Cet exemple écrit la ligne `"This is new text to be added."` au fichier `Test.txt`, remplace le texte existant dans le fichier.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 Cet exemple écrit les noms des fichiers dans le `Documents and Settings` dossier `FileList.txt`, insère un retour chariot entre chacun d’eux pour une meilleure lisibilité.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide pour l’une des raisons suivantes : il correspond à une chaîne de longueur nulle ; il ne contient que des espaces blancs ; il comporte des caractères non valides ; il représente un chemin d’appareil (commençant par \\\\.\\) ; il se termine par une barre oblique finale.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> est <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est utilisé par un autre processus ou une erreur d'E/S se produit.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d'accès dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.NotSupportedException">Un nom de fichier ou de dossier du chemin d'accès contient un signe deux-points (:) ou n'a pas un format correct.</exception>
        <exception cref="T:System.OutOfMemoryException">Il n'y a pas assez de mémoire pour écrire la chaîne dans la mémoire tampon.</exception>
        <exception cref="T:System.Security.SecurityException">L'utilisateur n'a pas les autorisations nécessaires pour afficher le chemin d'accès.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Contrôle la possibilité d’accéder aux fichiers et dossiers. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
  </Members>
</Type>