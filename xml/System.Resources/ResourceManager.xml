<Type Name="ResourceManager" FullName="System.Resources.ResourceManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="286d9bad190bd861714d3d477429bef42297085b" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66007230" /></Metadata><TypeSignature Language="C#" Value="public class ResourceManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ResourceManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ResourceManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceManager" />
  <TypeSignature Language="F#" Value="type ResourceManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-1.0;netstandard-1.1;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
      <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un gestionnaire de ressources qui facilite l'accès aux ressources spécifiques à une culture au moment de l'exécution.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 Le <xref:System.Resources.ResourceManager> classe récupère les ressources à partir d’un fichier .resources binaire qui est incorporé dans un assembly ou d’un fichier .resources. Si une application a été localisée et les ressources localisées ont été déployés en [assemblys satellites](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md), il recherche des ressources spécifiques à la culture, fournit des ressources de secours lorsqu’une ressource localisée n’existe pas et prend en charge des ressources sérialisation.  
  
 Pour plus d’informations sur la création et la gestion des ressources dans les applications de bureau et [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, consultez les sections suivantes :  
  
-   [Applications de bureau](#desktop)  
  
    -   [Création de ressources](#creating_resources)  
  
    -   [Instanciation d’un objet ResourceManager](#instantiating)  
  
    -   [ResourceManager et les ressources spécifiques à la Culture](#CultureSpecific)  
  
    -   [Récupération de ressources](#retrieving)  
  
    -   [Gestion des MissingManifestResourceException et MissingSatelliteAssemblyException Exceptions](#exception)  
  
    -   [Contrôle de version de ressource](#versioning)  
  
    -   [\<satelliteassemblies > nœud de fichier de Configuration](#config)  
  
-   [Applications du Windows Store](#ws)  
  
<a name="desktop"></a>   
## <a name="desktop-apps"></a>Applications de bureau  
 Pour les applications de bureau, le <xref:System.Resources.ResourceManager> classe récupère les ressources à partir de fichiers de ressources binaires (.resources). En règle générale, un compilateur de langage ou la [Assembly Linker (AL.exe)](~/docs/framework/tools/al-exe-assembly-linker.md) incorpore ces fichiers de ressources dans un assembly. Vous pouvez également utiliser un <xref:System.Resources.ResourceManager> objet pour récupérer des ressources directement à partir d’un fichier .resources qui n’est pas incorporé dans un assembly, en appelant le <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> (méthode).  
  
> [!CAUTION]
>  À l’aide de fichiers .resources autonomes dans une application ASP.NET interrompt le déploiement XCOPY, étant donné que les ressources restent verrouillées jusqu'à ce qu’elles soient libérées explicitement par le <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> (méthode). Si vous souhaitez déployer des ressources avec vos applications ASP.NET, vous devez compiler vos fichiers .resources en assemblys satellites.  
  
 Dans une application basée sur les ressources, un fichier .resources contient les ressources de la culture par défaut dont les ressources sont utilisées si aucune ressource spécifiques à la culture ne peut être trouvé. Par exemple, si la culture par défaut d’une application est anglais (en), les ressources de langue anglaise sont utilisées chaque fois que la ressource localisée ne peut pas être trouvée pour une culture spécifique, telles que l’anglais (États-Unis) (en-US) ou Français (France) (fr-FR). En règle générale, les ressources pour la culture par défaut sont incorporés dans l’assembly d’application principale et les ressources pour d’autres cultures localisées sont incorporés dans des assemblys satellites. Les assemblys satellites contiennent uniquement les ressources. Ils ont le même nom de fichier racine en tant que l’assembly principal et une extension. resources.dll. Pour les applications dont les assemblys ne sont pas inscrits dans le global assembly cache, les assemblys satellites sont stockés dans un sous-répertoire d’application dont le nom correspond à la culture de l’assembly.  
  
<a name="creating_resources"></a>   
### <a name="creating-resources"></a>Création de ressources  
 Lorsque vous développez une application basée sur les ressources, vous stockez des informations sur les ressources dans les fichiers texte (fichiers qui ont une extension .txt ou .restext) ou XML (fichiers qui ont une extension .resx). Vous pouvez ensuite compiler les fichiers texte ou XML avec le [Resource File Generator (Resgen.exe)](~/docs/framework/tools/resgen-exe-resource-file-generator.md) pour créer un fichier .resources binaire. Vous pouvez ensuite incorporer le fichier .resources résultant dans un fichier exécutable ou une bibliothèque à l’aide d’une option du compilateur comme `/resources` pour les compilateurs c# et Visual Basic, ou vous pouvez incorporer dans un assembly satellite à l’aide de le. Si vous incluez un fichier .resx dans votre projet Visual Studio, Visual Studio gère la compilation et l’incorporation de la valeur par défaut et les ressources localisées automatiquement dans le cadre du processus de génération.  
  
 Dans l’idéal, vous devez créer les ressources pour chaque langage de votre application prend en charge, ou au moins pour un sous-ensemble significatif pour chaque langue. Les noms de fichiers .resources binaires suivent la convention d’affectation de noms *basename*. *cultureName*.resources, où *basename* est le nom de l’application ou le nom d’une classe, en fonction du niveau de détail souhaité. Le <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType> propriété est utilisée pour déterminer *cultureName*. Une ressource pour la culture par défaut de l’application doit être nommée *basename*.resources.  
  
 Par exemple, supposons qu’un assembly comporte plusieurs ressources dans un fichier de ressources qui porte le nom de base MyResources. Ces fichiers de ressources doivent avoir des noms tels que MyResources.ja-JP.Resources pour la culture Japonais (Japon), MyResources.de.resources pour la culture allemande, MyResources-CHS.Resources pour la culture chinois simplifiée, et MyResources-be.resources s’agit de la culture Français (Belgique). Le fichier de ressources par défaut doit être nommé MyResources.resources. Les fichiers de ressources spécifiques à une culture sont généralement livrés dans les assemblys satellites pour chaque culture. Le fichier de ressources par défaut doit être incorporé dans l’assembly principal de l’application.  
  
 Notez que [Assembly Linker](~/docs/framework/tools/al-exe-assembly-linker.md) permet de ressources d’être marquées comme privées, mais vous devez toujours les marquer comme public afin d’être accessibles par d’autres assemblys. (Car un assembly satellite ne contient aucun code, les ressources qui sont marqués comme privés ne sont pas disponibles à votre application via un mécanisme quelconque.)  
  
 Pour plus d’informations sur la création, empaquetage et déploiement de ressources, consultez les articles [Creating Resource Files](~/docs/framework/resources/creating-resource-files-for-desktop-apps.md), [création d’assemblys satellites](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md), et [empaquetage et déploiement Ressources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
<a name="instantiating"></a>   
### <a name="instantiating-a-resourcemanager-object"></a>Instanciation d’un objet ResourceManager  
 Vous instanciez un <xref:System.Resources.ResourceManager> objet qui Récupère les ressources à partir d’un fichier .resources incorporé en appelant une de ses surcharges de constructeur de classe. Ce couple étroitement une <xref:System.Resources.ResourceManager> objet avec un fichier .resources particulier et associés localisées des fichiers .resources en assemblys satellites.  
  
 Les deux constructeurs couramment appelées sont :  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> recherche des ressources en fonction de deux éléments d’information que vous fournissez : le nom de base du fichier .resources et l’assembly dans lequel réside le fichier .resources par défaut. Le nom de base inclut le nom racine et espace de noms du fichier .resources, sans son extension ou la culture. Notez que les fichiers .resources qui sont compilés à partir de la ligne de commande généralement n’incluent pas un espace de noms, tandis que les fichiers .resources qui sont créés dans l’environnement Visual Studio. Par exemple, si un fichier de ressources est nommé MyCompany.StringResources.resources et <xref:System.Resources.ResourceManager> constructeur est appelé à partir d’une méthode statique nommée `Example.Main`, le code suivant instancie un <xref:System.Resources.ResourceManager> objet qui peut récupérer des ressources à partir de la. fichier de ressources :  
  
     [!code-csharp[Conceptual.Resources.Retrieving#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#1)]
     [!code-vb[Conceptual.Resources.Retrieving#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#1)]  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> recherche des ressources dans des assemblys satellites en fonction des informations à partir d’un objet de type. Nom qualifié complet du type correspond au nom de base du fichier .resources sans son extension de nom de fichier. Applications de bureau qui sont créées à l’aide du Concepteur de ressources Visual Studio, Visual Studio crée une classe wrapper dont le nom qualifié complet est le même que le nom de la racine du fichier .resources. Par exemple, si un fichier de ressources est nommé MyCompany.StringResources.resources et il existe une classe wrapper nommée `MyCompany.StringResources`, le code suivant instancie un <xref:System.Resources.ResourceManager> objet qui peut récupérer des ressources à partir du fichier .resources :  
  
     [!code-csharp[Conceptual.Resources.Retrieving#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#2)]
     [!code-vb[Conceptual.Resources.Retrieving#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#2)]  
  
 Si les ressources appropriées ne peut pas être trouvées, l’appel de constructeur crée un valide <xref:System.Resources.ResourceManager> objet. Toutefois, la tentative d’extraction d’une ressource lève un <xref:System.Resources.MissingManifestResourceException> exception. Pour plus d’informations sur le traitement avec l’exception, consultez le [MissingManifestResourceException de gestion et les Exceptions de MissingSatelliteAssembly](#exception) section plus loin dans cet article.  
  
 L’exemple suivant montre comment instancier un <xref:System.Resources.ResourceManager> objet. Il contient le code source pour un fichier exécutable nommé ShowTime.exe. Il inclut également le fichier texte suivant, nommé Strings.txt qui contient une ressource de chaîne unique, `TimeHeader`:  
  
```  
TimeHeader=The current time is  
```  
  
 Vous pouvez utiliser un fichier de commandes pour générer le fichier de ressources et de l’incorporer dans le fichier exécutable. Voici le fichier de commandes pour générer un fichier exécutable à l’aide du compilateur c# :  
  
```  
  
resgen strings.txt  
csc ShowTime.cs /resource:strings.resources  
  
```  
  
 Pour le compilateur Visual Basic, vous pouvez utiliser le fichier de commandes suivant :  
  
```  
  
resgen strings.txt  
vbc ShowTime.vb /resource:strings.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showtime.cs#1)]
 [!code-vb[System.Resources.ResourceManager.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showtime.vb#1)]  
  
<a name="CultureSpecific"></a>   
### <a name="resourcemanager-and-culture-specific-resources"></a>ResourceManager et les ressources spécifiques à la Culture  
 Une application localisée nécessite des ressources à déployer, comme indiqué dans l’article [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md). Si les assemblys sont correctement configurés, le Gestionnaire de ressources détermine les ressources à récupérer en fonction du thread actif <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> propriété. (Cette propriété retourne également culture d’interface utilisateur du thread actif.) Par exemple, si une application est compilée avec les ressources par défaut en langue anglaise dans l’assembly principal et avec les ressources de langue Français et russe dans deux assemblys satellites et le <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> propriété est définie sur fr-FR, le Gestionnaire des ressources récupère le Français ressources.  
  
 Vous pouvez définir le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> propriété explicitement ou implicitement. La façon dont vous la définissez détermine comment la <xref:System.Resources.ResourceManager> objet récupère les ressources selon culture :  
  
-   Si vous définissez explicitement le <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> propriété à une culture spécifique, le Gestionnaire de ressources est toujours extrait les ressources pour cette culture, quel que soit le langage de navigateur ou système d’exploitation de l’utilisateur. Considérez une application qui est compilée avec les ressources de langue anglaise par défaut et trois assemblys satellites qui contiennent des ressources pour l’anglais (États-Unis), Français (France) et russe (Russie). Si le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> propriété est définie sur fr-FR, le <xref:System.Resources.ResourceManager> objet récupère toujours les ressources Français (France), même si l’utilisateur d’exploitation langue du système n’est pas Français. Assurez-vous qu’il s’agit du comportement souhaité avant de définir explicitement la propriété.  
  
     Dans les applications ASP.NET, vous devez définir le <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> propriété explicitement, car il est peu probable que le paramètre du serveur corresponde aux demandes entrantes des clients. Une application ASP.NET peut définir le <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> langue acceptée de propriété explicitement au navigateur de l’utilisateur.  
  
     Définir explicitement le <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> propriété définit la culture d’interface utilisateur actuelle pour ce thread. Il n’affecte pas la culture d’interface utilisateur actuelle de tous les autres threads dans une application.  
  
-   Vous pouvez définir la culture d’interface utilisateur de tous les threads dans un domaine d’application en assignant un <xref:System.Globalization.CultureInfo> objet qui représente cette culture à la méthode statique <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> propriété.  
  
-   Si vous ne définissez pas explicitement la culture d’interface utilisateur en cours et que vous ne définissez pas une culture par défaut pour le domaine d’application actuel, le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété est définie implicitement par le Windows `GetUserDefaultUILanguage` (fonction). Cette fonction est fournie par l’utilisateur Interface multilingue (MUI), ce qui permet à l’utilisateur définir la langue par défaut. Si la langue d’interface utilisateur n’est pas définie par l’utilisateur, la valeur par défaut est la langue système installé, ce qui est la langue des ressources de système d’exploitation.  
  
 L’exemple « Hello world » simple suivant définit explicitement la culture d’interface utilisateur actuelle. Elle contient des ressources pour les trois cultures : Anglais (États-Unis) ou en-US, Français (France) ou fr-FR et russe (Russie) ou ru-RU. Les ressources en-US sont contenus dans un fichier texte nommé Greetings.txt :  
  
```  
HelloString=Hello world!  
```  
  
 Contenus dans un fichier texte nommé Greetings.fr les ressources fr-FR-FR.txt :  
  
```  
HelloString=Salut tout le monde!  
```  
  
 Les ressources de ru-RU sont contenus dans un fichier texte nommé Greetings.ru-RU.txt :  
  
```  
HelloString=Всем привет!  
```  
  
 Voici le code source pour l’exemple (Example.vb pour la version de Visual Basic) ou Example.cs pour la version c# :  
  
 [!code-csharp[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.currentculture/cs/example.cs#1)]
 [!code-vb[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.currentculture/vb/example.vb#1)]  
  
 Pour compiler cet exemple, créez un fichier de commandes (.bat) qui contient les commandes suivantes et exécutez-le à partir de l’invite de commandes. Si vous utilisez c#, spécifiez `csc` au lieu de `vbc` et `Example.cs` au lieu de `Example.vb`.  
  
```  
resgen Greetings.txt   
vbc Example.vb /resource:Greetings.resources  
  
resgen Greetings.fr-FR.txt  
Md fr-FR  
al /embed:Greetings.fr-FR.resources /culture:fr-FR /out:fr-FR\Example.resources.dll  
  
resgen Greetings.ru-RU.txt  
Md ru-RU  
al /embed:Greetings.ru-RU.resources /culture:ru-RU /out:ru-RU\Example.resources.dll  
```  
  
<a name="retrieving"></a>   
### <a name="retrieving-resources"></a>Récupération de ressources  
 Vous appelez le <xref:System.Resources.ResourceManager.GetObject%28System.String%29> et <xref:System.Resources.ResourceManager.GetString%28System.String%29> méthodes pour accéder à une ressource spécifique. Vous pouvez également appeler le <xref:System.Resources.ResourceManager.GetStream%28System.String%29> méthode pour récupérer des ressources sous la forme d’un tableau d’octets. Par défaut, dans une application qui a localisée des ressources, ces méthodes retournent la ressource pour la culture déterminée par la culture d’interface utilisateur actuelle du thread qui a effectué l’appel. Consultez la section précédente, [ResourceManager et les ressources spécifiques à la Culture](#CultureSpecific), pour plus d’informations sur la façon dont la culture d’interface utilisateur actuelle d’un thread est définie. Si le Gestionnaire de ressources ne peut pas trouver la ressource pour la culture d’interface utilisateur du thread actif, il utilise un processus de secours pour récupérer la ressource spécifiée. Si le Gestionnaire de ressources ne peut pas trouver toutes les ressources localisées, il utilise les ressources de la culture par défaut. Pour plus d’informations sur les règles de secours, consultez la section « Processus de secours » de l’article [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
> [!NOTE]
>  Si le fichier .resources spécifié dans le <xref:System.Resources.ResourceManager> constructeur de classe est introuvable, la tentative d’extraction d’une ressource lève un <xref:System.Resources.MissingManifestResourceException> ou <xref:System.Resources.MissingSatelliteAssemblyException> exception. Pour plus d’informations sur le traitement avec l’exception, consultez le [MissingManifestResourceException de gestion et les Exceptions de MissingSatelliteAssemblyException](#exception) section plus loin dans cette rubrique.  
  
 L’exemple suivant utilise la <xref:System.Resources.ResourceManager.GetString%2A> méthode pour récupérer des ressources spécifiques à la culture. Il se compose de ressources compilés à partir de fichiers .txt pour l’anglais (en), Français (France) (fr-FR) et russe (Russie) (ru-RU) cultures. L’exemple modifie la culture actuelle et la culture d’interface utilisateur actuelle pour l’anglais (États-Unis), Français (France), russe (Russie) et suédois (Suède). Il appelle ensuite la <xref:System.Resources.ResourceManager.GetString%2A> méthode pour récupérer la chaîne localisée, qui s’affiche avec le jour actuel et le mois. Notez que la sortie affiche la chaîne localisée appropriée, sauf lorsque la culture d’interface utilisateur actuelle est suédois (Suède). Étant donné que les ressources de langue suédoise ne sont pas disponibles, l’application utilise à la place les ressources de la culture par défaut, qui est l’anglais.  
  
 L’exemple nécessite les fichiers de ressources texte répertoriés dans le tableau suivant. Chacun a une ressource de chaîne unique nommée `DateStart`.  
  
|culture|Nom de fichier|Nom de la ressource|Valeur de la ressource|  
|-------------|---------------|-------------------|--------------------|  
|fr-FR|DateStrings.txt|`DateStart`|Nous sommes|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 Voici le code source pour l’exemple (ShowDate.vb pour la version de Visual Basic) ou ShowDate.cs pour la version c# du code.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 Pour compiler cet exemple, créez un fichier de commandes qui contient les commandes suivantes et exécutez-le à partir de l’invite de commandes. Si vous utilisez c#, spécifiez `csc` au lieu de `vbc` et `showdate.cs` au lieu de `showdate.vb`.  
  
```  
  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
  
```  
  
 Il existe deux façons de récupérer les ressources d’une culture spécifique autre que la culture d’interface utilisateur actuelle :  
  
-   Vous pouvez appeler la <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>, <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>, ou <xref:System.Resources.ResourceManager.GetStream%28System.String%2CSystem.Globalization.CultureInfo%29> méthode pour récupérer une ressource pour une culture spécifique. Si une ressource localisée ne peut pas être trouvée, le Gestionnaire de ressources utilise le processus de secours pour localiser une ressource appropriée.  
  
-   Vous pouvez appeler la <xref:System.Resources.ResourceManager.GetResourceSet%2A> méthode pour obtenir un <xref:System.Resources.ResourceSet> objet qui représente les ressources pour une culture particulière. Dans l’appel de méthode, vous pouvez déterminer si le Gestionnaire de ressources détecte les cultures de parent s’il est impossible de trouver des ressources localisées, ou si elle simplement revient aux ressources de la culture par défaut. Vous pouvez ensuite utiliser le <xref:System.Resources.ResourceSet> méthodes pour accéder aux ressources (localisées pour cette culture) par nom, ou pour énumérer les ressources dans le jeu.  
  
<a name="exception"></a>   
### <a name="handling-missingmanifestresourceexception-and-missingsatelliteassemblyexception-exceptions"></a>Gestion des MissingManifestResourceException et MissingSatelliteAssemblyException Exceptions  
 Si vous essayez d’extraire une ressource spécifique, mais que le Gestionnaire de ressources ne peut pas trouver que ressource et soit aucune culture par défaut a été défini ou Impossible de localiser les ressources de la culture par défaut, le Gestionnaire de ressources lève un <xref:System.Resources.MissingManifestResourceException> exception si elle s’attend à trouver les ressources dans l’assembly principal ou un <xref:System.Resources.MissingSatelliteAssemblyException> si elle s’attend à trouver les ressources dans un assembly satellite. Notez que l’exception est levée lorsque vous appelez une méthode de récupération des ressources telles que <xref:System.Resources.ResourceManager.GetString%2A> ou <xref:System.Resources.ResourceManager.GetObject%2A>, et pas lorsque vous instanciez un <xref:System.Resources.ResourceManager> objet.  
  
 L’exception est généralement levée dans les conditions suivantes :  
  
-   L’assembly de fichier ou satellite de ressources approprié n’existe pas. Si le Gestionnaire de ressources attend des ressources par défaut de l’application d’être incorporés dans l’assembly d’application principale, ils sont absents. Si le <xref:System.Resources.NeutralResourcesLanguageAttribute> attribut indique que les ressources de l’application par défaut se trouvent dans un assembly satellite, que l’assembly ne peut pas être trouvé. Lorsque vous compilez votre application, assurez-vous que les ressources sont incorporées dans l’assembly principal ou que l’assembly satellite nécessaire est généré et est nommé de manière appropriée. Son nom doit prendre la forme *appName*. resources.dll et il doivent se trouver dans un répertoire nommé d’après la culture dont les ressources qu’il contient.  
  
-   Votre application n’a pas par défaut ou une culture neutre défini. Ajouter le <xref:System.Resources.NeutralResourcesLanguageAttribute> attribut dans un fichier de code source ou au fichier projet informations fichier (AssemblyInfo.vb pour une application Visual Basic) ou AssemblyInfo.cs pour une application c#.  
  
-   Le `baseName` paramètre dans le <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> constructeur ne spécifie pas le nom d’un fichier .resources. Le nom doit contenir, espace de noms qualifié complet du fichier de ressources, mais pas son extension de nom de fichier. En règle générale, les fichiers de ressources qui sont créés dans Visual Studio incluent des espaces de noms, mais n’est pas le cas des fichiers de ressources qui sont créés et compilés à l’invite de commandes. Vous pouvez déterminer les noms des fichiers .resources incorporés en compilant et exécutant l’utilitaire suivant. Il s’agit d’une application console qui accepte le nom d’un assembly principal ou un assembly satellite en tant que paramètre de ligne de commande. Il affiche les chaînes qui doivent être fournies en tant que le `baseName` paramètre afin que le Gestionnaire de ressources peut identifier correctement la ressource.  
  
     [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
     [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 Si vous ne modifiez pas explicitement la culture actuelle de votre application, vous devez également vous rappeler que le Gestionnaire des ressources récupère un ensemble de ressources en fonction de la valeur de la <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété et non le <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriété. En règle générale, si vous modifiez une valeur, vous devez également modifier l’autre.  
  
<a name="versioning"></a>   
### <a name="resource-versioning"></a>Contrôle de version de ressource  
 Étant donné que l’assembly principal qui contient des ressources d’une application par défaut est distinct à partir d’assemblys satellites de l’application, vous pouvez libérer une nouvelle version de votre assembly principal sans avoir à redéployer les assemblys satellites. Vous utilisez le <xref:System.Resources.SatelliteContractVersionAttribute> attribut à utiliser des assemblys satellites existants et indiquer au Gestionnaire de ressources ne pas de les redéployer avec une nouvelle version de votre assembly principal,  
  
 Pour plus d’informations sur la prise en charge le contrôle de version pour les assemblys satellites, consultez l’article [récupération de ressources](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md).  
  
<a name="config"></a>   
### <a name="satelliteassemblies-configuration-file-node"></a>\<satelliteassemblies > nœud de fichier de Configuration  
 Pour les fichiers exécutables qui sont déployés et exécutés à partir d’un site Web (fichiers .exe HREF), le <xref:System.Resources.ResourceManager> objet peut détecter les assemblys satellites sur le web, ce qui peut nuire aux performances de votre application. Pour éliminer le problème de performances, vous pouvez limiter cette détection pour les assemblys satellites que vous avez déployé avec votre application. Pour ce faire, vous créez un `<satelliteassemblies>` nœud dans le fichier de configuration de votre application pour spécifier que vous avez déployé un ensemble spécifique de cultures pour votre application et que le <xref:System.Resources.ResourceManager> objet ne doit pas tenter de détecter une culture qui n’est pas répertoriée dans ce nœud.  
  
> [!NOTE]
>  L’alternative recommandée à la création d’un `<satelliteassemblies>` nœud consiste à utiliser le [du manifeste de déploiement ClickOnce](https://msdn.microsoft.com/library/8457e615-e3b6-4990-8dcf-11bc590e4e9b) fonctionnalité.  
  
 Dans le fichier de configuration de votre application, créez une section similaire à ce qui suit :  
  
```  
<?xml version ="1.0"?>  
<configuration>  
    <satelliteassemblies>  
        <assembly name="MainAssemblyName, Version=versionNumber, Culture=neutral, PublicKeyToken=null|yourPublicKeyToken">  
            <culture>cultureName1</culture>  
            <culture>cultureName2</culture>  
            <culture>cultureName3</culture>  
        </assembly>  
    </satelliteassemblies>  
</configuration>  
```  
  
 Modifiez ces informations de configuration comme suit :  
  
-   Spécifiez un ou plusieurs `<assembly>` nœuds pour chaque assembly principal que vous déployez, où chaque nœud spécifie un nom d’assembly qualifié complet. Spécifiez le nom de votre assembly principal à la place de *MainAssemblyName*et spécifiez le `Version`, `PublicKeyToken`, et `Culture` valeurs d’attribut qui correspondent à votre assembly principal.  
  
     Pour le `Version` d’attribut, spécifiez le numéro de version de votre assembly. Par exemple, la première version de votre assembly peut être le numéro de version 1.0.0.0.  
  
     Pour le `PublicKeyToken` d’attribut, spécifiez le mot clé `null` si vous n’êtes pas connecté votre assembly avec un nom fort, ou spécifiez votre jeton de clé publique si vous avez signé votre assembly.  
  
     Pour le `Culture` d’attribut, spécifiez le mot clé `neutral` pour désigner l’assembly principal et forcer le <xref:System.Resources.ResourceManager> classe à détecter uniquement les cultures répertoriées dans le `<culture>` nœuds.  
  
     Pour plus d’informations sur les noms d’assembly qualifiés complets, consultez l’article [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md). Pour plus d’informations sur les assemblys avec nom fort, consultez l’article [création et assemblys avec nom fort](~/docs/framework/app-domains/create-and-use-strong-named-assemblies.md).  
  
-   Spécifiez un ou plusieurs `<culture>` nœuds avec un nom de culture spécifiques, telles que « fr-FR », ou un nom de culture neutre, tels que « fr ».  
  
 Si les ressources sont nécessaires pour un assembly non répertorié sous le `<satelliteassemblies>` nœud, la <xref:System.Resources.ResourceManager> classe détecte les cultures à l’aide de règles de détection standard.  
  
<a name="ws"></a>   
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>Applications [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]  
  
> [!IMPORTANT]
>  Bien que le <xref:System.Resources.ResourceManager> classe est prise en charge dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, nous ne recommandons pas son utilisation. Utilisez cette classe uniquement lorsque vous développez [!INCLUDE[net_portable](~/includes/net-portable-md.md)] projets qui peuvent être utilisés avec [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications. Pour récupérer des ressources à partir de [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] , les applications utilisent le [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) classe à la place.  
  
 Pour [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, la <xref:System.Resources.ResourceManager> classe récupère les ressources à partir des fichiers de package resource index (PRI). Un seul fichier PRI (le fichier package d’application PRI) contient les ressources pour la culture par défaut et les cultures de localisé. Vous utilisez l’utilitaire MakePRI pour créer un fichier PRI un ou plusieurs fichiers de ressources qui sont au format de ressources (.resw) XML. Pour les ressources qui sont inclus dans un projet Visual Studio, Visual Studio gère le processus de création et l’empaquetage du fichier PRI automatiquement. Vous pouvez ensuite utiliser le .NET Framework <xref:System.Resources.ResourceManager> classe pour accéder aux ressources de l’application ou d’une bibliothèque.  
  
 Vous pouvez instancier un <xref:System.Resources.ResourceManager> de l’objet pour un [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] application dans la même façon que vous le feriez pour une application de bureau.  
  
 Les ressources pour une culture particulière accessible puis en passant le nom de la ressource à récupérer à le <xref:System.Resources.ResourceManager.GetString%28System.String%29> (méthode). Par défaut, cette méthode retourne la ressource pour la culture déterminée par la culture d’interface utilisateur actuelle du thread qui a effectué l’appel. Vous pouvez également récupérer les ressources pour une culture spécifique en passant le nom de la ressource et un <xref:System.Globalization.CultureInfo> objet qui représente la culture dont la ressource doit être récupérée à le <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> (méthode). Si la ressource pour la culture d’interface utilisateur actuelle ou la culture spécifiée est introuvable, le Gestionnaire de ressources utilise une liste de secours de langue de l’interface utilisateur pour localiser une ressource appropriée.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser une culture explicite et la culture d’interface utilisateur actuelle implicite pour obtenir des ressources de type chaîne à partir d’un assembly principal et un assembly satellite. Pour plus d’informations, consultez la section « Emplacements de répertoire d’assemblys satellites pas installé dans le Global Assembly Cache » de la [création d’assemblys satellites](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) rubrique.  
  
 Pour exécuter cet exemple :  
  
1.  Dans le répertoire d’application, créez un fichier nommé rmc.txt qui contient les chaînes de ressources suivantes :  
  
    ```  
  
    day=Friday  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
2.  Utilisez le [Resource File Generator](~/docs/framework/tools/resgen-exe-resource-file-generator.md) pour générer le fichier de ressources rmc.resources à partir du fichier d’entrée rmc.txt comme suit :  
  
    ```  
    resgen rmc.txt  
    ```  
  
3.  Créez un sous-répertoire du répertoire d’application et nommez-le « es-MX ». Il s’agit du nom de culture de l’assembly satellite que vous allez créer dans les trois étapes suivantes.  
  
4.  Créez un fichier nommé rmc.es-MX.txt dans le répertoire es-MX qui contient les chaînes de ressources suivantes :  
  
    ```  
  
    day=Viernes  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
5.  Utilisez le [Resource File Generator](~/docs/framework/tools/resgen-exe-resource-file-generator.md) pour générer le fichier de ressources rmc.es-MX.resources à partir du fichier d’entrée rmc.es-MX.txt comme suit :  
  
    ```  
    resgen rmc.es-MX.txt  
    ```  
  
6.  Supposons que le nom de fichier pour cet exemple est rmc.vb ou rmc.cs. Copiez le code source suivant dans un fichier. Ensuite, compilez-le et incorporer le fichier de ressources d’assembly principal, rmc.resources, dans l’assembly exécutable. Si vous utilisez le compilateur Visual Basic, la syntaxe est :  
  
    ```  
    vbc rmc.vb /resource:rmc.resources  
    ```  
  
     La syntaxe correspondante pour le compilateur c# est :  
  
    ```  
    csc /resource:rmc.resources rmc.cs  
    ```  
  
7.  Utilisez le [Assembly Linker](~/docs/framework/tools/al-exe-assembly-linker.md) pour créer un assembly satellite. Si le nom de base de l’application est rmc, le nom de l’assembly satellite doit être rmc.resources.dll. L’assembly satellite doit être créé dans le répertoire es-MX. Si es-MX est le répertoire actif, utilisez cette commande :  
  
    ```  
    al /embed:rmc.es-MX.resources /c:es-MX /out:rmc.resources.dll   
    ```  
  
8.  Exécutez rmc.exe pour obtenir et afficher les chaînes de ressource incorporée.  
  
 [!code-csharp[ResourceManager_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ResourceManager_Class/cs/rmc.cs#1)]
 [!code-vb[ResourceManager_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ResourceManager_Class/vb/rmc.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <altmember cref="T:System.Globalization.CultureInfo" />
    <altmember cref="P:System.Globalization.CultureInfo.CurrentUICulture" />
    <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
    <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ressources dans les Applications</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceManager" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ResourceManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ResourceManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceManager" /> avec des valeurs par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est utile uniquement si vous écrivez votre propre classe qui dérive de la <xref:System.Resources.ResourceManager> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (Type resourceSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type resourceSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resourceSource As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(Type ^ resourceSource);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : Type -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager resourceSource" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="resourceSource" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="resourceSource">Type à partir duquel le gestionnaire de ressources dérive toutes les informations utilisées pour la recherche des fichiers .resources.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceManager" /> qui recherche des ressources dans les assemblys satellites en fonction d'informations provenant de l'objet de type spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Applications de bureau  
 Applications de bureau, le Gestionnaire de ressources utilise le `resourceSource` paramètre pour charger un fichier de ressources particulier comme suit :  
  
-   Si le <xref:System.Resources.NeutralResourcesLanguageAttribute> attribut n’est pas utilisé pour indiquer que les ressources de la culture par défaut se trouvent dans un assembly satellite, le Gestionnaire de ressources suppose que le fichier de ressources pour la culture par défaut se trouve dans le même assembly que le type spécifié par le `resourceSource` paramètre.  
  
-   Le Gestionnaire de ressources suppose que le fichier de ressources par défaut a le même nom de base que le type spécifié par le `resourceSource` paramètre.  
  
-   Le Gestionnaire de ressources utilise la valeur par défaut <xref:System.Resources.ResourceSet> classe pour manipuler le fichier de ressources.  
  
 Par exemple, le Gestionnaire de ressources étant donné un type nommé MyCompany.MyProduct.MyType, recherche un fichier .resources nommé MyCompany.MyProduct.MyType.resources dans l’assembly qui définit MyType.  
  
 Dans Visual Studio, le Concepteur de ressources génère automatiquement le code qui définit un `internal` (en c#) ou `Friend` (en Visual Basic) de classe dont le nom est le même que le nom de base du fichier .resources pour la culture par défaut. Cela rend possible instancier un <xref:System.Resources.ResourceManager> de l’objet et le coupler avec un ensemble particulier de ressources en obtenant un objet de type dont le nom correspond au nom de la ressource, car tant que la classe est visible par le compilateur, les ressources doivent être en tant que bien. Par exemple, si un fichier .resources nommé Resource1, l’instruction suivante instancie un <xref:System.Resources.ResourceManager> objet pour gérer le fichier .resources nommé Resource1 :  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/ctor1.cs#2)]  
  
 Si vous n’utilisez pas Visual Studio, vous pouvez créer une classe sans membres dont les nom et espace de noms sont les mêmes que celui du fichier .resources par défaut. Cet exemple en fournit une illustration.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>Applications [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]  
  
> [!IMPORTANT]
>  Bien que le <xref:System.Resources.ResourceManager> classe est prise en charge dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, nous ne recommandons pas son utilisation. Utilisez cette classe uniquement lorsque vous développez [!INCLUDE[net_portable](~/includes/net-portable-md.md)] projets qui peuvent être utilisés avec [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications. Pour récupérer des ressources à partir de [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] , les applications utilisent le [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) classe à la place.  
  
 Dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, <xref:System.Resources.ResourceManager> utilise le `resourceSource` paramètre déduire l’assembly, nom de base et l’espace de noms dans lequel les éléments de ressource peuvent être situés dans le fichier de l’index (PRI) de ressource de package de l’application. Par exemple, étant donné un type nommé MyCompany.MyProduct.MyType est défini dans `MyAssembly`, le Gestionnaire de ressources ressemble pour une ressource de jeu identificateur nommé MyAssembly et recherche une étendue MyCompany.MyProduct.MyType au sein de cet ensemble de ressources. Le Gestionnaire de ressources recherche les éléments de ressource dans le contexte par défaut (la culture actuelle, le paramètre de contraste élevé actuel et ainsi de suite) au sein de cette étendue.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> constructeur pour instancier un <xref:System.Resources.ResourceManager> objet. Il se compose de ressources compilés à partir de fichiers .txt pour l’anglais (en), Français (France) (fr-FR) et russe (Russie) (ru-RU) cultures. L’exemple modifie la culture actuelle et la culture d’interface utilisateur actuelle pour l’anglais (États-Unis), Français (France), russe (Russie) et suédois (Suède). Il appelle ensuite la <xref:System.Resources.ResourceManager.GetString%28System.String%29> méthode pour récupérer la chaîne localisée, qui affiche un message d’accueil qui dépend de l’heure du jour.  
  
 L’exemple nécessite trois fichiers de ressources texte, comme indiqué dans le tableau suivant. Chaque fichier inclut des ressources de type chaîne nommées `Morning`, `Afternoon`, et `Evening`.  
  
|culture|Nom de fichier|Nom de la ressource|Valeur de la ressource|  
|-------------|---------------|-------------------|--------------------|  
|fr-FR|GreetingResources.txt|`Morning`|Bonjour|  
|fr-FR|GreetingResources.txt|`Afternoon`|Bonne après-midi|  
|fr-FR|GreetingResources.txt|`Evening`|Bonsoir|  
|fr-FR|GreetingResources.fr-FR.txt|`Morning`|Bonjour|  
|fr-FR|GreetingResources.fr-FR.txt|`Afternoon`|Bonjour|  
|fr-FR|GreetingResources.fr-FR.txt|`Evening`|Bonsoir|  
|ru-RU|GreetingResources.ru-RU.txt|`Morning`|Доброе утро|  
|ru-RU|GreetingResources.ru-RU.txt|`Afternoon`|ДОБРЫЙ ДЕНЬ|  
|ru-RU|GreetingResources.ru-RU.txt|`Evening`|ДОБРЫЙ ВЕЧЕР|  
  
 Vous pouvez utiliser le fichier de commandes suivantes pour compiler l’exemple Visual Basic et de créer un fichier exécutable nommé Greet.exe. Pour compiler avec c#, remplacez le nom du compilateur `vbc` à `csc` et l’extension de fichier à partir de `.vb` à `.cs`.  
  
```  
  
resgen GreetingResources.txt  
vbc Greet.vb /resource: GreetingResources.resources  
  
md fr-FR  
resgen GreetingResources.fr-FR.txt  
al /out:fr-FR\Greet.resources.dll /culture:fr-FR /embed: GreetingResources.fr-FR.resources   
  
md ru-RU  
resgen GreetingResources.ru-RU.txt  
al /out:ru-RU\Greet.resources.dll /culture:ru-RU /embed: GreetingResources.ru-RU.resources  
  
```  
  
 Voici le code source pour l’exemple (ShowDate.vb pour la version de Visual Basic) ou ShowDate.cs pour la version c# du code.  
  
 [!code-csharp[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/greet.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/greet.vb#3)]  
  
 En plus de définir une classe d’application nommé `Example`, le code source définit une classe interne dont le nom, `GreetingResources`, est le même que le nom de base des fichiers de ressources. Cela rend possible instancier correctement un <xref:System.Resources.ResourceManager> objet en appelant le <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> constructeur.  
  
 Notez que la sortie affiche localisée correcte de type chaîne, sauf lorsque la culture d’interface utilisateur actuelle est suédois (Suède), auquel cas il utilise les ressources de langue anglaise. Étant donné que les ressources de langue suédoise ne sont pas disponibles, l’application utilise les ressources de la culture par défaut, comme défini par le <xref:System.Resources.NeutralResourcesLanguageAttribute> d’attribut, à la place.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="resourceSource" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : string * System.Reflection.Assembly -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager (baseName, assembly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="baseName">Le nom racine du fichier de ressources sans son extension, mais avec un nom quelconque d'espace de noms qualifié complet. Par exemple, le nom de la racine pour le fichier de ressources nommé MyApplication.MyResource.en-US.resources est MyApplication.MyResource.</param>
        <param name="assembly">Assembly principal des ressources.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceManager" /> qui recherche les ressources contenues dans les fichiers portant le nom racine spécifié dans l'assembly donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Applications de bureau  
 Applications de bureau, les fichiers de ressources spécifiques à la culture doivent être contenus dans les assemblys satellites et fichier de ressources de la culture par défaut doit être contenu dans l’assembly principal. Un assembly satellite est supposé pour contenir des ressources pour une culture spécifiée dans le manifeste de cet assembly et est chargé en fonction des besoins.  
  
> [!NOTE]
>  Pour récupérer des ressources à partir des fichiers .resources directement au lieu de les récupérer à partir des assemblys, vous devez appeler la <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> méthode au lieu de cela pour instancier un <xref:System.Resources.ResourceManager> objet.  
  
 Si le fichier de ressources identifié par `baseName` est introuvable dans `assembly`, la méthode instancie un <xref:System.Resources.ResourceManager> objet, mais la tentative d’extraction d’une ressource spécifique lève une exception, généralement <xref:System.Resources.MissingManifestResourceException>. Pour plus d’informations sur le diagnostic de la cause de l’exception, consultez la section « Gestion des the MissingManifestResourceException (Exception) » de la <xref:System.Resources.ResourceManager> rubrique de la classe.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>Applications [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]  
  
> [!IMPORTANT]
>  Bien que le <xref:System.Resources.ResourceManager> classe est prise en charge dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, nous ne recommandons pas son utilisation. Utilisez cette classe uniquement lorsque vous développez [!INCLUDE[net_portable](~/includes/net-portable-md.md)] projets qui peuvent être utilisés avec [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications. Pour récupérer des ressources à partir de [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] , les applications utilisent le [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) classe à la place.  
  
 Dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, le Gestionnaire de ressources utilise le nom simple du `assembly` paramètre pour rechercher une ressource correspondant défini dans le fichier de l’index (PRI) de ressource de package de l’application. Le `baseName` paramètre est utilisé pour rechercher un élément de ressource dans le jeu de ressources. Par exemple, le nom de racine pour PortableLibrary1.Resource1.de-de.Resources est PortableLibrary1.Resource1.  
  
   
  
## Examples  
 L’exemple suivant utilise une simple application « Hello World » non localisé pour illustrer le <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> constructeur. Voici le contenu d’un fichier texte nommé ExampleResources.txt. Quand l’application est compilée, la ressource est incorporée dans l’assembly d’application principale.  
  
```  
Greeting=Hello  
```  
  
 Le fichier texte peut être converti dans un fichier de ressources binaire à l’aide de la [Resource File Generator (ResGen.exe)](~/docs/framework/tools/resgen-exe-resource-file-generator.md) à la commande invite de commandes comme suit :  
  
```  
resgen ExampleResources.txt  
```  
  
 L’exemple suivant fournit le code exécutable qui instancie un <xref:System.Resources.ResourceManager> objet, invite l’utilisateur à entrer un nom et affiche un message d’accueil.  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/example.cs#1)]
 [!code-vb[System.Resources.ResourceManager.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/example.vb#1)]  
  
 Il peut être compilé dans Visual Basic à l’aide de la commande suivante :  
  
```  
vbc Example.vb /resource:ExampleResources.resources  
```  
  
 ou en utilisant la commande suivante de commande en c# :  
  
```  
csc Example.cs /resource:ExampleResources.resources  
```  
  
 Notez que l’exemple récupère une référence à l’assembly qui contient le fichier de ressources en passant un type défini dans cet assembly à la `typeof` (fonction) (en c#) ou le `GetType` fonctionner (Visual Basic) et en récupérant la valeur de son <xref:System.Type.Assembly%2A?displayProperty=nameWithType>propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="baseName" /> ou <paramref name="assembly" /> est <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Ce constructeur utilise fourni par le système <see cref="T:System.Resources.ResourceSet" /> implémentation. Pour utiliser un format de fichier de ressources personnalisé, vous devez dériver de la <see cref="T:System.Resources.ResourceSet" /> classe, substituez le <see cref="M:System.Resources.ResourceSet.GetDefaultReader" /> et <see cref="M:System.Resources.ResourceSet.GetDefaultWriter" /> méthodes et passe de type à la <see cref="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" /> constructeur. L’aide d’un <see cref="T:System.Resources.ResourceSet" /> peut être utile pour le contrôle de ressource mise en cache de la stratégie ou prenant en charge votre propre format de fichier de ressources, mais n’est généralement pas nécessaire.</para></block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly, Type ^ usingResourceSet);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : string * System.Reflection.Assembly * Type -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager (baseName, assembly, usingResourceSet)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="usingResourceSet" Type="System.Type" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="baseName">Le nom racine du fichier de ressources sans son extension, mais avec un nom quelconque d'espace de noms qualifié complet. Par exemple, le nom de la racine pour le fichier de ressources nommé MyApplication.MyResource.en-US.resources est MyApplication.MyResource.</param>
        <param name="assembly">Assembly principal des ressources.</param>
        <param name="usingResourceSet">Type de <see cref="T:System.Resources.ResourceSet" /> personnalisé. Si la valeur est <see langword="null" />, l'objet <see cref="T:System.Resources.ResourceSet" /> d'exécution par défaut est utilisé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Resources.ResourceManager" /> qui utilise une classe <see cref="T:System.Resources.ResourceSet" /> spécifiée pour rechercher les ressources contenues dans les fichiers portant le nom racine spécifié dans l'assembly donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les fichiers de ressources spécifiques à la culture doivent être contenus dans les assemblys satellites et fichier de ressources de la culture par défaut doit être contenu dans l’assembly principal. Un assembly satellite est supposé pour contenir des ressources pour une culture spécifiée dans le manifeste de cet assembly et est chargé en fonction des besoins.  
  
> [!NOTE]
>  Pour récupérer des ressources à partir des fichiers .resources directement au lieu de les récupérer à partir des assemblys, vous devez appeler la <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> méthode au lieu de cela pour instancier un <xref:System.Resources.ResourceManager> objet.  
  
 Si le fichier de ressources identifié par `baseName` est introuvable dans `assembly`, la méthode instancie un <xref:System.Resources.ResourceManager> objet, mais la tentative d’extraction d’une ressource spécifique lève une exception, généralement <xref:System.Resources.MissingManifestResourceException>. Pour plus d’informations sur le diagnostic de la cause de l’exception, consultez la section « Gestion des the MissingManifestResourceException (Exception) » de la <xref:System.Resources.ResourceManager> rubrique de la classe.  
  
> [!NOTE]
>  Le `usingResourceSet` paramètre est utilisé pour prendre en charge votre propre format de ressource et sera couramment `null`. Ceci diffère d’un constructeur qui accepte un <xref:System.Type> uniquement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="usingResourceset" /> n'est pas une classe dérivée de <see cref="T:System.Resources.ResourceSet" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="baseName" /> ou <paramref name="assembly" /> est <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Ce constructeur vous permet de spécifier un <see cref="T:System.Resources.ResourceSet" /> implémentation. Si vous ne souhaitez pas un spécifique <see cref="T:System.Resources.ResourceSet" /> implémentation serait mais utiliser un format de fichier de ressources personnalisé, vous devez dériver de la <see cref="T:System.Resources.ResourceSet" /> classe, substituez le <see cref="M:System.Resources.ResourceSet.GetDefaultReader" /> et <see cref="M:System.Resources.ResourceSet.GetDefaultWriter" /> méthodes et étape de type à ce constructeur.</para></block>
      </Docs>
    </Member>
    <Member MemberName="BaseName">
      <MemberSignature Language="C#" Value="public virtual string BaseName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseName" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.BaseName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseName : string" Usage="System.Resources.ResourceManager.BaseName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom racine des fichiers de ressources dans lesquels <see cref="T:System.Resources.ResourceManager" /> recherche les ressources.</summary>
        <value>Nom racine des fichiers de ressources dans lesquels <see cref="T:System.Resources.ResourceManager" /> recherche les ressources.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.BaseName%2A> propriété reflète le nom de l’espace de noms qualifié complet et le nom de ressource racine du fichier de ressources, sans son extension de nom de fichier ou de la culture. Par exemple, si le fichier de ressources par défaut d’une application est nommé `SampleApps.StringResources.resources`, la valeur de la <xref:System.Resources.ResourceManager.BaseName%2A> propriété est « SampleApps.StringResources ». Si le fichier de ressources par défaut d’une application est nommé `SampleApps.StringResources.en-US.resources` et est incorporé dans un assembly satellite, la valeur de la <xref:System.Resources.ResourceManager.BaseName%2A> propriété est toujours « SampleApps.StringResources ».  
  
> [!IMPORTANT]
>  Le <xref:System.Resources.ResourceManager.BaseName%2A> valeur de propriété d’un fichier de ressources qui est compilé et incorporé à partir de la ligne de commande n’inclut pas un espace de noms, sauf si vous incluez explicitement une lors de la compilation du fichier. En revanche, le <xref:System.Resources.ResourceManager.BaseName%2A> valeur de propriété d’un fichier de ressources qui est compilé et incorporé dans l’environnement Visual Studio, généralement n’inclut pas le nom d’espace de noms par défaut.  
  
 Le <xref:System.Resources.ResourceManager.BaseName%2A> valeur de propriété est identique à la chaîne passée à la <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> ou <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29> constructeur lorsque vous instanciez un <xref:System.Resources.ResourceManager> instance.  
  
   
  
## Examples  
 Vous pouvez déterminer les noms des fichiers .resources incorporés en compilant et exécutant l’utilitaire suivant. Il s’agit d’une application console qui accepte le nom d’un assembly principal ou un assembly satellite en tant que paramètre de ligne de commande. Il affiche les chaînes qui doivent être fournies en tant que le `baseName` paramètre de la <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> ou <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29> constructeur afin que le Gestionnaire de ressources peut identifier correctement la ressource.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
 [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseNameField">
      <MemberSignature Language="C#" Value="protected string BaseNameField;" />
      <MemberSignature Language="ILAsm" Value=".field family string BaseNameField" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.BaseNameField" />
      <MemberSignature Language="VB.NET" Value="Protected BaseNameField As String " />
      <MemberSignature Language="C++ CLI" Value="protected: System::String ^ BaseNameField;" />
      <MemberSignature Language="F#" Value="val mutable BaseNameField : string" Usage="System.Resources.ResourceManager.BaseNameField" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie le nom racine des fichiers de ressources dans lesquels <see cref="T:System.Resources.ResourceManager" /> recherche les ressources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.BaseNameField> champ est utile uniquement si vous écrivez votre propre classe qui dérive de la <xref:System.Resources.ResourceManager> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateFileBasedResourceManager">
      <MemberSignature Language="C#" Value="public static System.Resources.ResourceManager CreateFileBasedResourceManager (string baseName, string resourceDir, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Resources.ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.CreateFileBasedResourceManager(System.String,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFileBasedResourceManager (baseName As String, resourceDir As String, usingResourceSet As Type) As ResourceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Resources::ResourceManager ^ CreateFileBasedResourceManager(System::String ^ baseName, System::String ^ resourceDir, Type ^ usingResourceSet);" />
      <MemberSignature Language="F#" Value="static member CreateFileBasedResourceManager : string * string * Type -&gt; System.Resources.ResourceManager" Usage="System.Resources.ResourceManager.CreateFileBasedResourceManager (baseName, resourceDir, usingResourceSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="resourceDir" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="usingResourceSet" Type="System.Type" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="baseName">Nom racine des ressources. Ainsi, le nom racine du fichier de ressources « MyResource.en-US.resources » est « MyResource ».</param>
        <param name="resourceDir">Nom du répertoire dans lequel rechercher les ressources. <paramref name="resourceDir" /> peut être un chemin d'accès absolu ou un chemin d'accès relatif du répertoire de l'application.</param>
        <param name="usingResourceSet">Type de <see cref="T:System.Resources.ResourceSet" /> personnalisé. Si la valeur est <see langword="null" />, l'objet <see cref="T:System.Resources.ResourceSet" /> d'exécution par défaut est utilisé.</param>
        <summary>Retourne un objet <see cref="T:System.Resources.ResourceManager" /> qui recherche les ressources dans un répertoire spécifique, plutôt que dans le manifeste d'assembly.</summary>
        <returns>Nouvelle instance d'un gestionnaire de ressources qui recherche les ressources dans le répertoire spécifié plutôt que dans un manifeste d'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne un gestionnaire de ressources qui Récupère les ressources à partir d’un fichier .resources qui n’est pas incorporé dans un assembly. Vous pouvez utiliser cette <xref:System.Resources.ResourceManager> objet pour charger les ressources d’une page ASP.NET ou pour tester un <xref:System.Resources.ResourceSet> implémentation.  Pour obtenir un exemple qui Récupère les ressources à partir d’un fichier .resources, consultez le [récupération de ressources](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md) article.  
  
 Cette méthode vous permet de spécifier un <xref:System.Resources.ResourceSet> implémentation. Si vous ne souhaitez pas un spécifique <xref:System.Resources.ResourceSet> implémentation, mais vous souhaitez utiliser un format de fichier de ressource personnalisée, vous devez dériver de la <xref:System.Resources.ResourceSet> classe, substituez le <xref:System.Resources.ResourceSet.GetDefaultReader%2A> et <xref:System.Resources.ResourceSet.GetDefaultWriter%2A> méthodes et étape de type à ce constructeur.  
  
> [!CAUTION]
>  À l’aide de fichiers .resources autonomes dans une application ASP.NET interrompt le déploiement XCOPY, étant donné que les ressources restent verrouillées jusqu'à ce qu’elles soient libérées explicitement par le <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> (méthode). Si vous souhaitez déployer des ressources avec vos applications ASP.NET, compilez vos fichiers .resources en assemblys satellites.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="baseName" /> ou <paramref name="resourceDir" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FallbackLocation">
      <MemberSignature Language="C#" Value="protected System.Resources.UltimateResourceFallbackLocation FallbackLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Resources.UltimateResourceFallbackLocation FallbackLocation" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.FallbackLocation" />
      <MemberSignature Language="VB.NET" Value="Protected Property FallbackLocation As UltimateResourceFallbackLocation" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Resources::UltimateResourceFallbackLocation FallbackLocation { System::Resources::UltimateResourceFallbackLocation get(); void set(System::Resources::UltimateResourceFallbackLocation value); };" />
      <MemberSignature Language="F#" Value="member this.FallbackLocation : System.Resources.UltimateResourceFallbackLocation with get, set" Usage="System.Resources.ResourceManager.FallbackLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.UltimateResourceFallbackLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'emplacement à partir duquel récupérer les ressources de secours par défaut.</summary>
        <value>L'une des valeurs d'énumération qui spécifie où le gestionnaire de ressources peut rechercher les ressources de secours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.FallbackLocation%2A> propriété est utile uniquement si vous écrivez votre propre classe qui dérive de la <xref:System.Resources.ResourceManager> classe.  
  
 Vous pouvez utiliser le <xref:System.Resources.NeutralResourcesLanguageAttribute> attribut pour informer le Gestionnaire de ressources où trouver la culture par défaut pour une application : dans l’assembly principal (par défaut) ou dans un assembly satellite.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Resources.UltimateResourceFallbackLocation" />
        <altmember cref="T:System.Resources.NeutralResourcesLanguageAttribute" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetage et déploiement de ressources</related>
      </Docs>
    </Member>
    <Member MemberName="GetNeutralResourcesLanguage">
      <MemberSignature Language="C#" Value="protected static System.Globalization.CultureInfo GetNeutralResourcesLanguage (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Globalization.CultureInfo GetNeutralResourcesLanguage(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetNeutralResourcesLanguage(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetNeutralResourcesLanguage (a As Assembly) As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Globalization::CultureInfo ^ GetNeutralResourcesLanguage(System::Reflection::Assembly ^ a);" />
      <MemberSignature Language="F#" Value="static member GetNeutralResourcesLanguage : System.Reflection.Assembly -&gt; System.Globalization.CultureInfo" Usage="System.Resources.ResourceManager.GetNeutralResourcesLanguage a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="a">Assembly pour lequel retourner des informations spécifiques à la culture.</param>
        <summary>Retourne des informations spécifiques à la culture pour les ressources par défaut de l'assembly principal en récupérant la valeur de l'attribut <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> sur un assembly spécifié.</summary>
        <returns>Culture de l'attribut <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" />, si détecté ; sinon, la culture dite indifférente.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne la valeur de la ressource non-chaîne spécifiée pour la culture actuelle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetObject : string -&gt; obj&#xA;override this.GetObject : string -&gt; obj" Usage="resourceManager.GetObject name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la ressource à obtenir.</param>
        <summary>Retourne la valeur de la ressource non-chaîne spécifiée.</summary>
        <returns>Valeur de la ressource localisée pour les paramètres de culture actuels de l'appelant. Si un ensemble de ressources approprié existe, mais <paramref name="name" /> est introuvable, la méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.GetObject%2A> méthode est utilisée pour récupérer des ressources. Ceux-ci incluent des valeurs qui appartiennent aux types de données primitifs comme <xref:System.Int32> ou <xref:System.Double>, bitmaps (comme un <xref:System.Drawing.Bitmap?displayProperty=nameWithType> objet), ou personnaliser les objets sérialisés. En règle générale, l’objet retourné doit être casté (en c#) ou converti (en Visual Basic) en objet du type approprié.  
  
 La ressource retournée est localisée pour la culture d’interface utilisateur du thread actuel, qui est défini par le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété. Si la ressource n’est pas localisée pour cette culture, le Gestionnaire de ressources utilise les règles de secours pour charger une ressource appropriée. Si aucun ensemble de ressources localisées n’est trouvée, le <xref:System.Resources.ResourceManager> revient sur les ressources de la culture par défaut. Si un ensemble de ressources pour la culture par défaut est introuvable, la méthode lève un <xref:System.Resources.MissingManifestResourceException> exception ou, si le jeu de ressources est censé résider dans un assembly satellite, un <xref:System.Resources.MissingSatelliteAssemblyException> exception. Si le Gestionnaire de ressources peut charger une ressource appropriée définie mais ne peut pas trouver une ressource nommée `name`, la méthode retourne `null`.  
  
 Le <xref:System.Resources.ResourceManager.IgnoreCase%2A> propriété détermine si la comparaison de `name` avec les noms de ressources respecte la casse (par défaut) ou le respect de la casse.  
  
> [!CAUTION]
>  Cette méthode peut lever des exceptions plus que celles répertoriées. Cela peut se produire une des raisons sont que si une méthode qui appelle cette méthode lève une exception.  Par exemple, un <xref:System.IO.FileLoadException> exception peut être levée si une erreur a été lors du déploiement ou de l’installation d’un assembly satellite, ou un <xref:System.Runtime.Serialization.SerializationException> exception peut être levée si un type défini par l’utilisateur lève une exception définie par l’utilisateur lorsque le type est désérialisé.  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Si vous appelez le <xref:System.Resources.ResourceManager.GetObject%2A> méthode plusieurs fois avec le même `name` paramètre, ne dépendent pas de la méthode retournant une référence au même objet à chaque appel. Il s’agit, car le <xref:System.Resources.ResourceManager.GetObject%2A> méthode peut retourner une référence à un objet de ressource existant dans un cache, ou il peut recharger la ressource et retourner une référence à un nouvel objet de ressource.  
  
   
  
## Examples  
 L’exemple suivant utilise la méthode <xref:System.Resources.ResourceManager.GetObject%28System.String%29> pour désérialiser un objet personnalisé. L’exemple inclut un fichier de code source nommé UIElements.cs (UIElements.vb si vous utilisez Visual Basic) qui définit la structure suivante nommée `PersonTable`. Cette structure est ensuite utilisée par une routine d’affichage de table générale qui affiche les noms localisés des colonnes de table. Notez que la structure `PersonTable` est marquée avec l’attribut <xref:System.SerializableAttribute> .  
  
 [!code-csharp[Conceptual.Resources.Retrieving#6](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example.cs#6)]
 [!code-vb[Conceptual.Resources.Retrieving#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#6)]  
  
 Le code ci-dessous provient d’un fichier CreateResources.cs (CreateResources.vb pour Visual Basic). Il crée un fichier de ressources XML nommé UIResources.resx qui stocke un titre de table ainsi qu’un objet `PersonTable` qui contient des informations relatives à une application localisée en anglais.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#7](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example1.cs#7)]
 [!code-vb[Conceptual.Resources.Retrieving#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#7)]  
  
 Le code suivant, qui provient d’un fichier de code source nommé GetObject.cs (ou GetObject.vb), récupère ensuite les ressources et les affiche dans la console.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#8](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example2.cs#8)]
 [!code-vb[Conceptual.Resources.Retrieving#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example2.vb#8)]  
  
 Vous pouvez créer le fichier et les assemblys de ressources nécessaires, puis lancer l’application en exécutant le fichier de commandes suivant. Vous devez utiliser l’option `/r` pour fournir à Resgen.exe une référence à UIElements.dll qui lui permet d’accéder aux informations relatives à la structure `PersonTable` . Si vous utilisez C#, remplacez le nom du compilateur `vbc` par `csc`et modifiez l’extension `.vb` en `.cs`.  
  
```  
  
vbc /t:library UIElements.vb  
vbc CreateResources.vb /r:UIElements.dll  
CreateResources  
  
resgen UIResources.resx  /r:UIElements.dll  
vbc GetObject.vb /r:UIElements.dll /resource:UIResources.resources  
  
GetObject.exe  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Aucun ensemble de ressources localisées pouvant être utilisé n'a été trouvé et il n'existe pas de ressources pour la culture par défaut. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Les ressources de la culture par défaut résident dans un assembly satellite qui est introuvable. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String)" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetage et déploiement de ressources</related>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetObject : string * System.Globalization.CultureInfo -&gt; obj&#xA;override this.GetObject : string * System.Globalization.CultureInfo -&gt; obj" Usage="resourceManager.GetObject (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la ressource à obtenir.</param>
        <param name="culture">Culture pour laquelle la ressource doit être localisée. Si la ressource n'est pas localisée pour cette culture, le gestionnaire de ressources utilise les règles de secours pour localiser une ressource appropriée.  
  
Si cette valeur est <see langword="null" />, l'objet <see cref="T:System.Globalization.CultureInfo" /> est obtenu en utilisant la propriété <see cref="P:System.Globalization.CultureInfo.CurrentUICulture" />.</param>
        <summary>Obtient la valeur de la ressource non-chaîne spécifiée localisée pour la culture spécifiée.</summary>
        <returns>Valeur de la ressource localisée pour la culture spécifiée. Si un ensemble de ressources approprié existe, mais <paramref name="name" /> est introuvable, la méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> méthode est utilisée pour récupérer des ressources. Ceux-ci incluent des valeurs qui appartiennent aux types de données primitifs comme <xref:System.Int32> ou <xref:System.Double>, bitmaps (comme un <xref:System.Drawing.Bitmap?displayProperty=nameWithType> objet), ou personnaliser les objets sérialisés. En règle générale, l’objet retourné doit être casté (en c#) ou converti (en Visual Basic) en objet du type approprié.  
  
 La ressource retournée est localisée pour la culture spécifiée par `culture`, ou pour la culture spécifiée par le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété si `culture` est `null`. Si la ressource n’est pas localisée pour cette culture, le Gestionnaire de ressources utilise les règles de secours pour charger une ressource appropriée. Si aucun ensemble de ressources localisées n’est trouvé, le Gestionnaire de ressources revient sur les ressources de la culture par défaut. Si un ensemble de ressources pour la culture par défaut est introuvable, la méthode lève un <xref:System.Resources.MissingManifestResourceException> exception ou, si le jeu de ressources est censé résider dans un assembly satellite, un <xref:System.Resources.MissingSatelliteAssemblyException> exception. Si le Gestionnaire de ressources peut charger une ressource appropriée définie mais ne peut pas trouver une ressource nommée `name`, la méthode retourne `null`.  
  
 Le <xref:System.Resources.ResourceManager.IgnoreCase%2A> propriété détermine si la comparaison de `name` avec les noms de ressources respecte la casse (par défaut) ou le respect de la casse.  
  
> [!CAUTION]
>  Cette méthode peut lever des exceptions plus que celles répertoriées. Cela peut se produire une des raisons sont que si une méthode qui appelle cette méthode lève une exception.  Par exemple, un <xref:System.IO.FileLoadException> exception peut être levée si une erreur a été lors du déploiement ou de l’installation d’un assembly satellite, ou un <xref:System.Runtime.Serialization.SerializationException> exception peut être levée si un type défini par l’utilisateur lève une exception définie par l’utilisateur lorsque le type est désérialisé.  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Si vous appelez le <xref:System.Resources.ResourceManager.GetObject%2A> méthode plusieurs fois avec le même `name` paramètre, ne dépendent pas de la méthode retournant une référence au même objet à chaque appel. Il s’agit, car le <xref:System.Resources.ResourceManager.GetObject%2A> méthode peut retourner une référence à un objet de ressource existant dans un cache, ou il peut recharger la ressource et retourner une référence à un nouvel objet de ressource.  
  
   
  
## Examples  
 L’exemple suivant utilise la méthode <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> pour désérialiser un objet personnalisé. L’exemple inclut un fichier de code source nommé NumberInfo.cs (NumberInfo.vb si vous utilisez Visual Basic) qui définit la structure suivante nommée `Numbers`. Cette structure est destinée à être utilisée par une simple application de formation qui enseigne aux participants d’énonciation en langue anglaise pour compter jusqu'à dix en anglais. Notez que le `Numbers` classe est marquée avec le <xref:System.SerializableAttribute> attribut.  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/numberinfo.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/numberinfo.vb#1)]  
  
 Le code source suivant à partir d’un fichier nommé CreateResources.cs (CreateResources.vb pour Visual Basic) crée des fichiers de ressources XML pour l’anglais par défaut, ainsi que pour les langues Français, portugais et russe.  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/createresources.cs#2)]
 [!code-vb[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/createresources.vb#2)]  
  
 Les ressources sont consommées par l’application suivante, qui définit la culture d’interface utilisateur actuelle pour le Français (France), portugais (Brésil) ou le russe (Russie). Il appelle le <xref:System.Resources.ResourceManager.GetObject%28System.String%29> méthode pour obtenir un `Numbers` objet qui contient des nombres localisés et <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> méthode pour obtenir un `Numbers` objet qui contient des nombres de langue anglaise. Il affiche ensuite les nombres impairs à l’aide de la culture d’interface utilisateur actuelle et la langue anglaise. Le fichier de code source est nommé ShowNumbers.cs (ShowNumbers.vb).  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/shownumbers.cs#3)]
 [!code-vb[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/shownumbers.vb#3)]  
  
 Vous pouvez utiliser le fichier de commandes suivant pour générer et exécuter la version Visual Basic de l’exemple. Si vous utilisez c#, remplacez `vbc` avec `csc`et remplacez le `.vb` extension avec `.cs`.  
  
```  
  
vbc /t:library NumberInfo.vb  
  
vbc CreateResources.vb /r:NumberInfo.dll  
CreateResources  
  
resgen NumberResources.resx /r:NumberInfo.dll  
  
resgen NumberResources.fr.resx /r:Numberinfo.dll  
Md fr  
al /embed:NumberResources.fr.resources /culture:fr /t:lib /out:fr\ShowNumbers.resources.dll  
  
resgen NumberResources.pt.resx  /r:Numberinfo.dll  
Md pt  
al /embed:NumberResources.pt.resources /culture:pt /t:lib /out:pt\ShowNumbers.resources.dll  
  
resgen NumberResources.ru.resx /r:Numberinfo.dll  
Md ru  
al /embed:NumberResources.ru.resources /culture:ru /t:lib /out:ru\ShowNumbers.resources.dll  
  
vbc ShowNumbers.vb /r:NumberInfo.dll /resource:NumberResources.resources  
ShowNumbers.exe  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Aucun ensemble de ressources pouvant être utilisé n'a été trouvé et il n'existe pas de ressources de culture par défaut. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Les ressources de la culture par défaut résident dans un assembly satellite qui est introuvable. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <threadsafe>Le <see cref="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" /> méthode est thread-safe.</threadsafe>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetage et déploiement de ressources</related>
      </Docs>
    </Member>
    <Member MemberName="GetResourceFileName">
      <MemberSignature Language="C#" Value="protected virtual string GetResourceFileName (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetResourceFileName(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceFileName(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResourceFileName (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetResourceFileName(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetResourceFileName : System.Globalization.CultureInfo -&gt; string&#xA;override this.GetResourceFileName : System.Globalization.CultureInfo -&gt; string" Usage="resourceManager.GetResourceFileName culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Objet de culture pour lequel un nom de fichier de ressources est construit.</param>
        <summary>Génère le nom du fichier de ressources pour l'objet <see cref="T:System.Globalization.CultureInfo" /> donné.</summary>
        <returns>Nom qui peut être utilisé pour un fichier de ressources de l'objet <see cref="T:System.Globalization.CultureInfo" /> donné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.GetResourceFileName%2A> méthode est utile uniquement si vous écrivez votre propre classe qui dérive de la <xref:System.Resources.ResourceManager> classe.  
  
 Cette méthode utilise le <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType> propriété en tant que partie du nom de fichier pour toutes les cultures autres que la culture dite indifférente. Cette méthode ne recherche pas dans le manifeste d’assembly ou tactile le disque et est utilisée uniquement pour construire un nom de fichier de ressources (approprié pour le passer à la <xref:System.Resources.ResourceReader> constructeur) ou un nom d’objet blob de ressource de manifeste.  
  
 Une classe dérivée peut substituer cette méthode pour rechercher une autre extension, tel que ». ResX », ou un schéma de complètement différent pour nommer les fichiers de ressources. Notez que la méthode peut être utilisée pour personnaliser le nom du fichier de ressources dans un assembly satellite et ne pas pour personnaliser le nom de l’assembly satellite lui-même.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">Internationalisation et localisation d’applications .NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetResourceSet">
      <MemberSignature Language="C#" Value="public virtual System.Resources.ResourceSet GetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Resources.ResourceSet GetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Resources::ResourceSet ^ GetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="F#" Value="abstract member GetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet&#xA;override this.GetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet" Usage="resourceManager.GetResourceSet (culture, createIfNotExists, tryParents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="tryParents" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Culture dont les ressources doivent être récupérées.</param>
        <param name="createIfNotExists"><see langword="true" /> pour charger le jeu de ressources, s'il n'a pas encore été chargé, sinon <see langword="false" />.</param>
        <param name="tryParents"><see langword="true" /> pour utiliser le secours pour les ressources pour charger une ressource appropriée si l'ensemble de ressources est introuvable ; <see langword="false" /> pour ignorer le processus de secours.</param>
        <summary>Récupère la ressource définie pour une culture particulière.</summary>
        <returns>Ensemble de ressources pour la culture spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le jeu de ressources qui est retourné représente les ressources localisées pour la culture spécifiée. Si les ressources n’ont pas été localisées pour cette culture et `tryParents` est `true`, <xref:System.Resources.ResourceManager.GetResourceSet%2A> utilise des règles de secours pour charger une ressource appropriée. Si `tryParents` est `false` et un ensemble de ressources de culture spécifique est introuvable, la méthode retourne `null`. Pour plus d’informations sur les ressources de secours, consultez la section « Le processus de secours » dans le [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) article.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Resources.ResourceManager.GetResourceSet%2A> méthode pour récupérer des ressources spécifiques à la culture pour la culture Français (France). Il énumère toutes les ressources dans le jeu de ressources. Il contient le code source pour un fichier exécutable nommé ShowNumbers.exe. Il inclut également le fichier deux texte suivant qui contiennent les noms de nombres. La première, NumberResources.txt, contient les noms des nombres de 1 à 10 en langue anglaise :  
  
```  
  
one=one  
two=two  
three=three  
four=four  
five=five  
six=six  
seven=seven  
eight=eight  
nine=nine  
ten=ten  
  
```  
  
 La seconde, NumberResources.fr-fr.txt, contient les noms des nombres à partir d’un à quatre dans la langue Français :  
  
```  
  
one=un  
two=deux  
three=trois  
four=quatre  
  
```  
  
 Vous pouvez utiliser un fichier de commandes pour générer les fichiers de ressources, incorporer le fichier de ressources de langue anglaise dans le fichier exécutable et créer un assembly satellite pour les ressources de langue Français. Voici le fichier de commandes pour générer un fichier exécutable à l’aide du compilateur Visual Basic :  
  
```  
  
resgen NumberResources.txt  
vbc shownumbers.vb /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
```  
  
 Pour le compilateur c#, vous pouvez utiliser le fichier de commandes suivant :  
  
```  
  
resgen NumberResources.txt  
csc shownumbers.cs /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/cs/shownumbers.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/vb/shownumbers.vb#1)]  
  
 Notez que si vous modifiez la valeur de la `createIfNotExists` l’argument de `false`, l’appel de méthode retourne `null`, étant donné que le Gestionnaire de ressources n’a pas encore chargé les ressources de langue Français.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="culture" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException"><paramref name="tryParents" /> est <see langword="true" />, aucun ensemble de ressources n'est trouvé et il n'existe pas de ressources de culture par défaut.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">Internationalisation et localisation d’applications .NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteContractVersion">
      <MemberSignature Language="C#" Value="protected static Version GetSatelliteContractVersion (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Version GetSatelliteContractVersion(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetSatelliteContractVersion(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetSatelliteContractVersion (a As Assembly) As Version" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static Version ^ GetSatelliteContractVersion(System::Reflection::Assembly ^ a);" />
      <MemberSignature Language="F#" Value="static member GetSatelliteContractVersion : System.Reflection.Assembly -&gt; Version" Usage="System.Resources.ResourceManager.GetSatelliteContractVersion a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="a">Assembly dont vous recherchez l'attribut <see cref="T:System.Resources.SatelliteContractVersionAttribute" />.</param>
        <summary>Retourne la version spécifiée par l'attribut <see cref="T:System.Resources.SatelliteContractVersionAttribute" /> dans l'assembly donné.</summary>
        <returns>Version de contrat satellite de l'assembly donné ou <see langword="null" />, si aucune version n'est trouvée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur le versioning des assemblys satellites, consultez le <xref:System.Resources.SatelliteContractVersionAttribute> rubrique de référence.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.Version" /> trouvé dans l'assembly <paramref name="a" /> n'est pas valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="a" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un objet de flux de mémoire non managé à partir d'une ressource spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetStream : string -&gt; System.IO.UnmanagedMemoryStream" Usage="resourceManager.GetStream name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Nom d'une ressource.</param>
        <summary>Retourne un objet de flux de mémoire non managé à partir de la ressource spécifiée.</summary>
        <returns>Objet de flux de mémoire non managé qui représente une ressource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.GetStream%2A> méthode prend le nom d’une ressource qui est stocké en tant qu’un <xref:System.IO.MemoryStream> d’objet, obtient la valeur de la <xref:System.Object> ressource et retourne un <xref:System.IO.UnmanagedMemoryStream> objet. Elle nécessite que vous travaillez directement avec un flux d’octets, ce qui est ensuite converti en un objet. Cette méthode est principalement utile pour des raisons de performances : Récupération d’une ressource comme un flux d’octets au lieu d’un objet explicit peut améliorer les performances.  
  
 La ressource retournée est localisée pour la culture d’interface utilisateur du thread actuel, qui est défini par le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété. Si la ressource n’est pas localisée pour cette culture, le Gestionnaire de ressources utilise les règles de secours pour charger une ressource appropriée. Si aucun ensemble de ressources localisées n’est trouvée, le <xref:System.Resources.ResourceManager> revient sur les ressources de la culture par défaut. Si un ensemble de ressources pour la culture par défaut est introuvable, la méthode lève un <xref:System.Resources.MissingManifestResourceException> exception ou, si le jeu de ressources est censé résider dans un assembly satellite, un <xref:System.Resources.MissingSatelliteAssemblyException> exception. Si le Gestionnaire de ressources peut charger une ressource appropriée définie mais ne peut pas trouver une ressource nommée `name`, la méthode retourne `null`.  
  
 Le <xref:System.Resources.ResourceManager.IgnoreCase%2A> propriété détermine si la comparaison de `name` avec les noms de ressources respecte la casse (par défaut) ou le respect de la casse.  
  
   
  
## Examples  
 L’exemple suivant utilise la méthode <xref:System.Resources.ResourceManager.GetStream%28System.String%29> pour récupérer une image bitmap qui s’affiche dans la fenêtre de démarrage à l’ouverture d’une application. Les éléments suivants de source de code à partir d’un fichier nommé CreateResources.cs (pour c#) ou CreateResources.vb (pour Visual Basic) génère un fichier .resx nommé AppResources.resx qui contient l’image sérialisée. Dans cet exemple, l’image est chargée à partir d’un fichier SplashScreen.jpg. Vous pouvez remplacer ce nom de fichier par votre image.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#4](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/createresources.cs#4)]
 [!code-vb[Conceptual.Resources.Retrieving#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/createresources.vb#4)]  
  
 Le code suivant à partir d’un fichier nommé GetStream.cs (pour c#) ou GetStream.vb (pour Visual Basic), puis récupère la ressource et affiche l’image dans un <xref:System.Windows.Forms.PictureBox?displayProperty=nameWithType> contrôle.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#5](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/getstream.cs#5)]
 [!code-vb[Conceptual.Resources.Retrieving#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/getstream.vb#5)]  
  
 Vous pouvez utiliser le fichier de commandes suivant pour générer l’exemple C#. Pour Visual Basic, remplacez `csc` par `vbc`, et modifiez l’extension du fichier de code source `.cs` en `.vb`. 
  
```  
  
csc CreateResources.cs  
CreateResources  
  
resgen AppResources.resx  
  
csc GetStream.cs /resource:AppResources.resources  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La valeur de la ressource spécifiée n'est pas un objet <see cref="T:System.IO.MemoryStream" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Aucun ensemble de ressources pouvant être utilisé n'a été trouvé et il n'existe pas de ressources par défaut. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Les ressources de la culture par défaut résident dans un assembly satellite qui est introuvable. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String, culture As CultureInfo) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.GetStream : string * System.Globalization.CultureInfo -&gt; System.IO.UnmanagedMemoryStream" Usage="resourceManager.GetStream (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Nom d'une ressource.</param>
        <param name="culture">Objet spécifiant la culture à utiliser pour la recherche de ressource. Si <paramref name="culture" /> est <see langword="null" />, la culture du thread actuel est utilisée.</param>
        <summary>Retourne un objet de flux de mémoire non managé à partir de la ressource spécifiée, à l'aide de la culture spécifiée.</summary>
        <returns>Objet de flux de mémoire non managé qui représente une ressource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.GetStream%2A> méthode prend le nom d’une ressource qui est stocké en tant qu’un <xref:System.IO.MemoryStream> d’objet, obtient la valeur de la <xref:System.Object> ressource et retourne un <xref:System.IO.UnmanagedMemoryStream> objet. Elle nécessite que vous travaillez directement avec un flux d’octets, ce qui est ensuite converti en un objet. Cette méthode est principalement utile pour des raisons de performances : Récupération d’une ressource comme un flux d’octets au lieu d’un objet explicit peut améliorer les performances.  
  
 La ressource retournée est localisée pour la culture spécifiée par `culture`, ou pour la culture spécifiée par le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété si `culture` est `null`. Si la ressource n’est pas localisée pour cette culture, le Gestionnaire de ressources utilise les règles de secours pour charger une ressource appropriée. Si aucun ensemble de ressources localisées n’est trouvée, le <xref:System.Resources.ResourceManager> revient sur les ressources de la culture par défaut. Si un ensemble de ressources pour la culture par défaut est introuvable, la méthode lève un <xref:System.Resources.MissingManifestResourceException> exception ou, si le jeu de ressources est censé résider dans un assembly satellite, un <xref:System.Resources.MissingSatelliteAssemblyException> exception. Si le Gestionnaire de ressources peut charger une ressource appropriée définie mais ne peut pas trouver une ressource nommée `name`, la méthode retourne `null`.  
  
 Le <xref:System.Resources.ResourceManager.IgnoreCase%2A> propriété détermine si la comparaison de `name` avec les noms de ressources respecte la casse (par défaut) ou le respect de la casse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La valeur de la ressource spécifiée n'est pas un objet <see cref="T:System.IO.MemoryStream" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Aucun ensemble de ressources pouvant être utilisé n'a été trouvé et il n'existe pas de ressources par défaut. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Les ressources de la culture par défaut résident dans un assembly satellite qui est introuvable. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne la ressource de chaîne spécifiée pour la culture spécifiée ou la culture d'interface utilisateur actuelle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetString : string -&gt; string&#xA;override this.GetString : string -&gt; string" Usage="resourceManager.GetString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la ressource à récupérer.</param>
        <summary>Retourne la valeur de la ressource de chaîne spécifiée.</summary>
        <returns>Valeur de la ressource localisée pour la culture d'interface utilisateur actuelle de l'appelant, ou <see langword="null" /> si <paramref name="name" /> est introuvable dans un ensemble de ressources.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Applications de bureau  
 Dans les applications de bureau, la ressource retournée est localisée pour la culture d’interface utilisateur du thread actuel, tel que défini par le <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété. Si la ressource n’a pas été localisée pour cette culture, le Gestionnaire de ressources effectue la recherche d’une ressource en suivant les étapes décrites dans la section « Processus de secours pour les ressources » de la [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) article. Si aucun ensemble de ressources localisées n’est trouvé, le Gestionnaire de ressources revient sur les ressources de la culture par défaut. Si le Gestionnaire de ressources ne peut pas charger le jeu de ressources de la culture par défaut, la méthode lève un <xref:System.Resources.MissingManifestResourceException> exception ou, si le jeu de ressources est censé résider dans un assembly satellite, un <xref:System.Resources.MissingSatelliteAssemblyException> exception. Si le Gestionnaire de ressources peut charger une ressource appropriée définie mais ne peut pas trouver une ressource nommée `name`, la méthode retourne `null`.  
  
 Le <xref:System.Resources.ResourceManager.IgnoreCase%2A> propriété détermine si la comparaison de `name` avec les noms de ressources respecte la casse (par défaut) ou le respect de la casse.  
  
> [!CAUTION]
>  Cette méthode peut lever des exceptions plus que celles répertoriées. Cela peut se produire une des raisons sont que si une méthode qui appelle cette méthode lève une exception.  Par exemple, un <xref:System.IO.FileLoadException> exception peut être levée si une erreur a été lors du déploiement ou de l’installation d’un assembly satellite, ou un <xref:System.Runtime.Serialization.SerializationException> exception peut être levée si un type défini par l’utilisateur lève une exception définie par l’utilisateur lorsque le type est désérialisé.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>Applications [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]  
  
> [!IMPORTANT]
>  Bien que le <xref:System.Resources.ResourceManager> classe est prise en charge dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, nous ne recommandons pas son utilisation. Utilisez cette classe uniquement lorsque vous développez [!INCLUDE[net_portable](~/includes/net-portable-md.md)] projets qui peuvent être utilisés avec [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications. Pour récupérer des ressources à partir de [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] , les applications utilisent le [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) classe à la place.  
  
 Dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, le <xref:System.Resources.ResourceManager.GetString%28System.String%29> méthode retourne la valeur de la `name` chaîne de ressource localisée pour les paramètres de culture de l’interface utilisateur actuelle de l’appelant. La liste des cultures est dérivée de la liste de langue du système d’exploitation par défaut l’interface utilisateur. Si le Gestionnaire de ressources ne peut pas correspondre `name`, la méthode retourne `null`.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Resources.ResourceManager.GetString%2A> méthode pour récupérer des ressources spécifiques à la culture. Il se compose de ressources compilés à partir de fichiers .txt pour l’anglais (en), Français (France) (fr-FR) et russe (Russie) (ru-RU) cultures. L’exemple modifie la culture actuelle et la culture d’interface utilisateur actuelle pour l’anglais (États-Unis), Français (France), russe (Russie) et suédois (Suède). Il appelle ensuite la <xref:System.Resources.ResourceManager.GetString%2A> méthode pour récupérer la chaîne localisée, qui s’affiche avec le jour actuel et le mois. Notez que la sortie affiche la chaîne localisée appropriée, sauf lorsque la culture d’interface utilisateur actuelle est suédois (Suède). Étant donné que les ressources de langue suédoise ne sont pas disponibles, l’application utilise à la place les ressources de la culture par défaut, qui est l’anglais. L’exemple nécessite les fichiers de ressources texte répertoriés dans le tableau suivant. Chacun a une ressource de chaîne unique nommée `DateStart`.  
  
|culture|Nom de fichier|Nom de la ressource|Valeur de la ressource|  
|-------------|---------------|-------------------|--------------------|  
|fr-FR|DateStrings.txt|`DateStart`|Nous sommes|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 Vous pouvez utiliser le fichier de commandes suivantes pour compiler l’exemple c#. Pour Visual Basic, remplacez `csc` par `vbc`, et modifiez l’extension du fichier de code source `.cs` en `.vb`.  
  
```  
resgen DateStrings.txt  
csc showdate.cs /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 Voici le code source pour l’exemple (ShowDate.vb pour la version de Visual Basic) ou ShowDate.cs pour la version c#.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La valeur de la ressource spécifiée n'est pas une chaîne.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Aucun ensemble de ressources pouvant être utilisé n'a été trouvé et il n'existe pas de ressources pour la culture par défaut. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Les ressources de la culture par défaut résident dans un assembly satellite qui est introuvable. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <threadsafe>Le <see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> méthode est thread-safe.</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetage et déploiement de ressources</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eca16922-1c46-4f68-aefe-e7a12283641f">Récupération de ressources dans des assemblys satellites</related>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetString : string * System.Globalization.CultureInfo -&gt; string&#xA;override this.GetString : string * System.Globalization.CultureInfo -&gt; string" Usage="resourceManager.GetString (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la ressource à récupérer.</param>
        <param name="culture">Objet qui représente la culture pour laquelle la ressource est localisée.</param>
        <summary>Retourne la valeur de la ressource de type chaîne localisée pour la culture spécifiée.</summary>
        <returns>Valeur de la ressource localisée pour la culture spécifiée, ou <see langword="null" /> si <paramref name="name" /> est introuvable dans un ensemble de ressources.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Applications de bureau  
 Applications de bureau, si `culture` est `null`, le <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> méthode utilise la culture actuelle de l’interface utilisateur obtenue à partir de la <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriété.  
  
 La ressource retournée est localisée pour la culture spécifiée par le `culture` paramètre. Si la ressource n’a pas été localisée pour `culture`, le Gestionnaire de ressources tente de détecter une ressource en suivant les étapes décrites dans la section « Processus de secours pour les ressources » de la [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) rubrique. Si aucun ensemble de ressources n’est trouvé, le Gestionnaire de ressources revient sur les ressources de la culture par défaut. Si le Gestionnaire de ressources ne peut pas charger le jeu de ressources de la culture par défaut, la méthode lève un <xref:System.Resources.MissingManifestResourceException> exception ou, si le jeu de ressources est censé résider dans un assembly satellite, un <xref:System.Resources.MissingSatelliteAssemblyException> exception. Si le Gestionnaire de ressources peut charger une ressource appropriée définie mais ne peut pas trouver une ressource nommée `name`, la méthode retourne `null`.  
  
 Le <xref:System.Resources.ResourceManager.IgnoreCase%2A> propriété détermine si la comparaison de `name` avec les noms de ressources respecte la casse (par défaut) ou le respect de la casse.  
  
> [!CAUTION]
>  Cette méthode peut lever des exceptions plus que celles répertoriées. Cela peut se produire une des raisons sont que si une méthode qui appelle cette méthode lève une exception.  Par exemple, un <xref:System.IO.FileLoadException> exception peut être levée si une erreur a été lors du déploiement ou de l’installation d’un assembly satellite, ou un <xref:System.Runtime.Serialization.SerializationException> exception peut être levée si un type défini par l’utilisateur lève une exception définie par l’utilisateur lorsque le type est désérialisé.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>Applications [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]  
  
> [!IMPORTANT]
>  Bien que le <xref:System.Resources.ResourceManager> classe est prise en charge dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, nous ne recommandons pas son utilisation. Utilisez cette classe uniquement lorsque vous développez [!INCLUDE[net_portable](~/includes/net-portable-md.md)] projets qui peuvent être utilisés avec [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications. Pour récupérer des ressources à partir de [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] , les applications utilisent le [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) classe à la place.  
  
 Dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, le <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> méthode retourne la valeur de la `name` chaîne de ressource localisée pour la culture spécifiée par le `culture` paramètre. Si la ressource n’est pas localisée pour le `culture` culture, la recherche utilise l’ensemble du [!INCLUDE[win8](~/includes/win8-md.md)] liste de secours de langue et s’arrête après la recherche dans la culture par défaut. Si le Gestionnaire de ressources ne peut pas correspondre `name`, la méthode retourne `null`.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> méthode pour récupérer des ressources spécifiques à la culture. Culture par défaut de cet exemple est anglais (en), et il inclut des assemblys satellites pour le Français (France) (fr-FR) et russe (Russie) (ru-RU) cultures. L’exemple modifie la culture actuelle et la culture d’interface utilisateur actuelle en russe (Russie) avant d’appeler <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>. Il appelle ensuite la <xref:System.Resources.ResourceManager.GetString%2A> (méthode) et le <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> méthode et passe <xref:System.Globalization.CultureInfo> objets qui représentent les cultures de suédois (Suède) et le Français (France) à chaque méthode. Dans la sortie, le mois et le jour du mois, ainsi que la chaîne qui précède les apparaissent dans Français, étant donné que le <xref:System.Resources.ResourceManager.GetString%2A> méthode est en mesure de récupérer la ressource de langue Français. Toutefois, lorsque la culture suédois (Suède) est utilisée, le mois et le jour du mois apparaissent dans suédois, bien que la chaîne qui précède les est en anglais. Il s’agit, car le Gestionnaire de ressources ne peut pas rechercher des ressources de langue suédoise localisée, afin qu’elle retourne une ressource pour la culture par défaut à la place.  
  
 L’exemple nécessite les fichiers de ressources texte répertoriés dans le tableau suivant. Chacun a une ressource de chaîne unique nommée `DateStart`.  
  
|culture|Nom de fichier|Nom de la ressource|Valeur de la ressource|  
|-------------|---------------|-------------------|--------------------|  
|fr-FR|DateStrings.txt|`DateStart`|Nous sommes|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 Vous pouvez utiliser le fichier de commandes suivantes pour compiler l’exemple Visual Basic. Pour compiler en c#, changez `vbc` à `csc`et changez l’extension du fichier de code source à partir de `.vb` à `.cs`.  
  
```  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 Voici le code source pour l’exemple (ShowDate.vb pour la version de Visual Basic) ou ShowDate.cs pour la version c#.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate2.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La valeur de la ressource spécifiée n'est pas une chaîne.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Aucun ensemble de ressources pouvant être utilisé n'a été trouvé et il n'existe pas de ressources pour une culture par défaut. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Les ressources de la culture par défaut résident dans un assembly satellite qui est introuvable. Pour plus d'informations sur la gestion de cette exception, consultez la section « Gestion des exceptions MissingManifestResourceException et MissingSatelliteAssemblyException » dans la rubrique de la classe <see cref="T:System.Resources.ResourceManager" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <threadsafe>Le <see cref="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" /> méthode est thread-safe.</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetage et déploiement de ressources</related>
      </Docs>
    </Member>
    <Member MemberName="HeaderVersionNumber">
      <MemberSignature Language="C#" Value="public static readonly int HeaderVersionNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 HeaderVersionNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeaderVersionNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int HeaderVersionNumber;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeaderVersionNumber : int" Usage="System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie la version des en-têtes de fichier de ressources que l'implémentation actuelle de <see cref="T:System.Resources.ResourceManager" /> peut interpréter et obtenir.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreCase">
      <MemberSignature Language="C#" Value="public virtual bool IgnoreCase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.IgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IgnoreCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IgnoreCase { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreCase : bool with get, set" Usage="System.Resources.ResourceManager.IgnoreCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le gestionnaire de ressources autorise les recherches de ressources ne respectant pas la casse dans les méthodes <see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> et <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" />.</summary>
        <value><see langword="true" /> pour ignorer la casse pendant la recherche de ressources ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la valeur de la <xref:System.Resources.ResourceManager.IgnoreCase%2A> est propriété `false`, une ressource portant le nom « Ressource » n’est pas équivalente à la ressource portant le nom « resource ». Si <xref:System.Resources.ResourceManager.IgnoreCase%2A> est `true`, une ressource portant le nom « Ressource » est équivalente à la ressource portant le nom « resource ». Notez, cependant, que quand <xref:System.Resources.ResourceManager.IgnoreCase%2A> est `true`, le <xref:System.Resources.ResourceManager.GetString%2A?displayProperty=nameWithType> et <xref:System.Resources.ResourceManager.GetObject%2A?displayProperty=nameWithType> méthodes effectuent des comparaisons de chaînes respectant la casse à l’aide de la culture dite indifférente. L’avantage est que les résultats des comparaisons de chaînes respectant la casse effectuées par ces méthodes sont les mêmes sur tous les ordinateurs, quel que soit la culture. L’inconvénient est que les résultats ne sont pas cohérentes avec les règles de casse de toutes les cultures.  
  
 Par exemple, l’alphabet turc possède deux versions du caractère i : une avec un point et l’autre sans point. En turc, le caractère I (Unicode 0049) est considéré comme la version majuscule d’un caractère différent ı (Unicode 0131). Le caractère i (Unicode 0069) est considéré comme la version en minuscules d’un autre caractère (Unicode 0130). En fonction de ces règles de casse, une comparaison de chaînes respectant la casse des caractères i (Unicode 0069) et I (Unicode 0049) doit échouer pour la culture « tr-TR » (turc en Turquie). Toutefois, étant donné que la comparaison est effectuée à l’aide de règles de casse de la culture dite indifférente si <xref:System.Resources.ResourceManager.IgnoreCase%2A> est `true`, cette comparaison réussit.  
  
> [!NOTE]
>  Pour des raisons de performances, il est préférable de toujours spécifier la casse pour les noms de ressource. Paramètre <xref:System.Resources.ResourceManager.IgnoreCase%2A> à `true` peut entraîner une augmentation significative dans la plage de travail et une baisse significative des performances.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalGetResourceSet">
      <MemberSignature Language="C#" Value="protected virtual System.Resources.ResourceSet InternalGetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Resources.ResourceSet InternalGetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function InternalGetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Resources::ResourceSet ^ InternalGetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="F#" Value="abstract member InternalGetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet&#xA;override this.InternalGetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet" Usage="resourceManager.InternalGetResourceSet (culture, createIfNotExists, tryParents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="tryParents" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Objet de culture à rechercher.</param>
        <param name="createIfNotExists"><see langword="true" /> pour charger le jeu de ressources, s'il n'a pas encore été chargé, sinon <see langword="false" />.</param>
        <param name="tryParents"><see langword="true" /> pour vérifier les objets <see cref="T:System.Globalization.CultureInfo" /> parents si l'ensemble de ressources ne peut pas être chargé ; sinon, <see langword="false" />.</param>
        <summary>Fournit l'implémentation utilisée pour rechercher un jeu de ressources.</summary>
        <returns>Ensemble de ressources spécifié.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">L'assembly principal ne contient aucun fichier .resources et ce fichier qui est requis pour rechercher une ressource.</exception>
        <exception cref="T:System.ExecutionEngineException">Une erreur interne s'est produite dans le runtime.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">L'assembly satellite associé à <paramref name="culture" />n'a pas pu être localisé.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <block subset="none" type="overrides"><para>Cette méthode termine tout le travail nécessaire pour trouver une ressource définie et peut être récursive et réentrant. En d’autres termes, cette méthode peut charger un assembly et le déclencheur une <see cref="E:System.AppDomain.AssemblyLoad" /> événement, qui rappelle ensuite un <see cref="T:System.Resources.ResourceManager" /> objet n’a pas été complètement initialisé. Pour éviter des verrous supplémentaires, cette méthode n’est pas thread-safe. Le <see cref="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />, <see cref="M:System.Resources.ResourceManager.GetString(System.String)" />, et <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" /> méthodes effectuent la synchronisation requise.</para></block>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">Internationalisation et localisation d’applications .NET</related>
      </Docs>
    </Member>
    <Member MemberName="MagicNumber">
      <MemberSignature Language="C#" Value="public static readonly int MagicNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 MagicNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MagicNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MagicNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int MagicNumber;" />
      <MemberSignature Language="F#" Value=" staticval mutable MagicNumber : int" Usage="System.Resources.ResourceManager.MagicNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient le nombre utilisé pour identifier les fichiers de ressources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur est définie sur 0xBEEFCACE. Les quatre premiers octets du format de fichier système par défaut contiennent un entier signé 32 bits au format little-endian (voir <xref:System.Text.Encoding>).  
  
 Si le <xref:System.Resources.ResourceManager.MagicNumber> est trouvé, les octets après ce sera un numéro de version pour un <xref:System.Resources.ResourceManager> en-tête, suivi d’un nombre indiquant le nombre d’octets doit être ignoré pour passer cet en-tête. Le numéro suivant indique la version de la <xref:System.Resources.ResourceManager> qui a créé l’en-tête, suivi d’informations sur la version spécifique.  
  
 Le numéro de version pour l’implémentation actuelle est un. Les octets sont une chaîne préfixée par sa longueur contenant le nom d’un <xref:System.Resources.IResourceReader>, ce qui peut lire ce fichier.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MainAssembly">
      <MemberSignature Language="C#" Value="protected System.Reflection.Assembly MainAssembly;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Reflection.Assembly MainAssembly" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MainAssembly" />
      <MemberSignature Language="VB.NET" Value="Protected MainAssembly As Assembly " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Reflection::Assembly ^ MainAssembly;" />
      <MemberSignature Language="F#" Value="val mutable MainAssembly : System.Reflection.Assembly" Usage="System.Resources.ResourceManager.MainAssembly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie l'assembly principal qui contient les ressources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Resources.ResourceManager.MainAssembly> champ est utile uniquement si vous écrivez votre propre classe qui dérive de la <xref:System.Resources.ResourceManager> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllResources">
      <MemberSignature Language="C#" Value="public virtual void ReleaseAllResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseAllResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.ReleaseAllResources" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReleaseAllResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseAllResources();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseAllResources : unit -&gt; unit&#xA;override this.ReleaseAllResources : unit -&gt; unit" Usage="resourceManager.ReleaseAllResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indique au gestionnaire de ressources d'appeler la méthode <see cref="M:System.Resources.ResourceSet.Close" /> sur tous les objets <see cref="T:System.Resources.ResourceSet" /> et de libérer toutes les ressources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode réduit la plage de travail dans une application en cours d’exécution. Toute recherche de ressources futures sur ce <xref:System.Resources.ResourceManager> objet sera coûteuse que la première recherche car le Gestionnaire de ressources doit rechercher et charger les ressources. Cela peut être utile dans certains scénarios de threads complexes, où la création d’un nouveau <xref:System.Resources.ResourceManager> objet est le comportement approprié.  
  
> [!NOTE]
>  En commençant par le .NET Framework version 2.0, le <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> méthode n’est pas thread-safe par rapport au <xref:System.Resources.ResourceManager.GetObject%2A>, <xref:System.Resources.ResourceManager.GetString%2A>, et <xref:System.Resources.ResourceManager.GetStream%2A> operations. L’avantage de cette modification est une amélioration des performances pour plusieurs threads qui accèdent aux ressources. Toutefois, si vous appelez le <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> méthode dans un thread tout en récupérant une ressource dans un autre thread, l’opération d’obtention peut lever une <xref:System.ObjectDisposedException> exception.  
  
 Vous pouvez également utiliser cette méthode dans les situations où les instances gérées pour les ressources créées par le Gestionnaire de ressources actuel doivent être libérées de façon déterministe, sans attendre que le Gestionnaire de ressources sont complètement hors de portée et le garbage collector.  
  
> [!NOTE]
>  Appel de cette méthode ne décharge pas les assemblys satellites. Pour décharger des assemblys satellites, utilisez le <xref:System.AppDomain.Unload%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Lorsqu’elle est appelée à liaison tardive via des mécanismes tels que <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ResourceSets">
      <MemberSignature Language="C#" Value="protected System.Collections.Hashtable ResourceSets;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Collections.Hashtable ResourceSets" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.ResourceSets" />
      <MemberSignature Language="VB.NET" Value="Protected ResourceSets As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Collections::Hashtable ^ ResourceSets;" />
      <MemberSignature Language="F#" Value="val mutable ResourceSets : System.Collections.Hashtable" Usage="System.Resources.ResourceManager.ResourceSets" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("call InternalGetResourceSet instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contient <see cref="T:System.Collections.Hashtable" /> qui retourne un mappage des cultures aux objets <see cref="T:System.Resources.ResourceSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResourceSetType">
      <MemberSignature Language="C#" Value="public virtual Type ResourceSetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ResourceSetType" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.ResourceSetType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ResourceSetType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ResourceSetType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ResourceSetType : Type" Usage="System.Resources.ResourceManager.ResourceSetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type de l'objet d'ensemble de ressources que le gestionnaire des ressources utilise pour construire un objet <see cref="T:System.Resources.ResourceSet" />.</summary>
        <value>Type de l'objet d'ensemble de ressources que le gestionnaire des ressources utilise pour construire un objet <see cref="T:System.Resources.ResourceSet" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>