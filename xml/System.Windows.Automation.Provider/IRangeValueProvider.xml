<Type Name="IRangeValueProvider" FullName="System.Windows.Automation.Provider.IRangeValueProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a99486cf2c7dcaccd22a683e6d85f27bd710a98f" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65013098" /></Metadata><TypeSignature Language="C#" Value="public interface IRangeValueProvider" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IRangeValueProvider" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Provider.IRangeValueProvider" />
  <TypeSignature Language="VB.NET" Value="Public Interface IRangeValueProvider" />
  <TypeSignature Language="C++ CLI" Value="public interface class IRangeValueProvider" />
  <TypeSignature Language="F#" Value="type IRangeValueProvider = interface" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationProvider</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.Guid("36dc7aef-33e6-4691-afe1-2be7274b3d33")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.InterfaceType(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Expose des méthodes et des propriétés pour prendre en charge l’accès du client UI Automation aux contrôles auxquels une valeur comprise dans une plage peut être affectée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implémenté sur un fournisseur UI Automation qui doit prendre en charge la <xref:System.Windows.Automation.RangeValuePattern> modèle de contrôle.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Automation.RangeValuePattern" />
    <related type="Article" href="~/docs/framework/ui-automation/ui-automation-control-patterns-overview.md">Vue d'ensemble des modèles de contrôle UI Automation</related>
    <related type="Article" href="https://msdn.microsoft.com/library/6acc6d08-bd67-4e2e-915c-9c1d34eb86fe">Implémentation de fournisseur côté serveur UI Automation</related>
    <related type="Article" href="https://msdn.microsoft.com/library/3584c0a1-9cd0-4968-8b63-b06390890ef6">Implémentation de fournisseur côté client UI Automation</related>
    <related type="Article" href="https://msdn.microsoft.com/library/0d635c35-ffa8-4dc8-bbc9-12fcd5445776">Prendre en charge des modèles de contrôle dans un fournisseur UI Automation</related>
    <related type="Article" href="https://msdn.microsoft.com/library/225feaa4-918e-418b-938e-7389338d0a69">Implémentation du modèle de contrôle RangeValue d’UI Automation</related>
  </Docs>
  <Members>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Provider.IRangeValueProvider.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Windows.Automation.Provider.IRangeValueProvider.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui spécifie si la valeur d’un contrôle est en lecture seule.</summary>
        <value><see langword="true" /> si la valeur est en lecture seule ; <see langword="false" /> si elle peut être modifiée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant illustre une implémentation de cette méthode pour un contrôle qui n’est pas en lecture seule.  
  
 [!code-csharp[UIAIRangeValueProvider_snip#IsReadOnly](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAIRangeValueProvider_snip/CSharp/RangeValueFragment.cs#isreadonly)]
 [!code-vb[UIAIRangeValueProvider_snip#IsReadOnly](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAIRangeValueProvider_snip/visualbasic/rangevaluefragment.vb#isreadonly)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/225feaa4-918e-418b-938e-7389338d0a69">Implémentation du modèle de contrôle RangeValue d’UI Automation</related>
      </Docs>
    </Member>
    <Member MemberName="LargeChange">
      <MemberSignature Language="C#" Value="public double LargeChange { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 LargeChange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Provider.IRangeValueProvider.LargeChange" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LargeChange As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double LargeChange { double get(); };" />
      <MemberSignature Language="F#" Value="member this.LargeChange : double" Usage="System.Windows.Automation.Provider.IRangeValueProvider.LargeChange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur qui est ajoutée à ou soustraite de la <see cref="P:System.Windows.Automation.Provider.IRangeValueProvider.Value" /> propriété lorsqu’une modification majeure est effectuée, comme avec la PAGE suivante de clé.</summary>
        <value>La valeur de changement important pris en charge par le contrôle ou nul (<see langword="Nothing" /> en Visual Basic) si le contrôle ne prend pas en charge <see cref="P:System.Windows.Automation.Provider.IRangeValueProvider.LargeChange" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant illustre une implémentation de cette méthode pour un contrôle qui a une valeur de changement important de 5.0.  
  
 [!code-csharp[UIAIRangeValueProvider_snip#LargeChange](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAIRangeValueProvider_snip/CSharp/RangeValueFragment.cs#largechange)]
 [!code-vb[UIAIRangeValueProvider_snip#LargeChange](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAIRangeValueProvider_snip/visualbasic/rangevaluefragment.vb#largechange)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Automation.Provider.IRangeValueProvider.SmallChange" />
        <related type="Article" href="https://msdn.microsoft.com/library/225feaa4-918e-418b-938e-7389338d0a69">Implémentation du modèle de contrôle RangeValue d’UI Automation</related>
      </Docs>
    </Member>
    <Member MemberName="Maximum">
      <MemberSignature Language="C#" Value="public double Maximum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Maximum" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Provider.IRangeValueProvider.Maximum" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Maximum As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Maximum { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Maximum : double" Usage="System.Windows.Automation.Provider.IRangeValueProvider.Maximum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur de plage maximale prise en charge par le contrôle.</summary>
        <value>La valeur maximale prise en charge par le contrôle ou nul (<see langword="Nothing" /> en Visual Basic) si le contrôle ne prend pas en charge <see cref="P:System.Windows.Automation.Provider.IRangeValueProvider.Maximum" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant illustre une implémentation de cette méthode pour un contrôle qui a une valeur maximale 255.0.  
  
 [!code-csharp[UIAIRangeValueProvider_snip#Maximum](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAIRangeValueProvider_snip/CSharp/RangeValueFragment.cs#maximum)]
 [!code-vb[UIAIRangeValueProvider_snip#Maximum](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAIRangeValueProvider_snip/visualbasic/rangevaluefragment.vb#maximum)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Automation.Provider.IRangeValueProvider.Minimum" />
        <related type="Article" href="https://msdn.microsoft.com/library/225feaa4-918e-418b-938e-7389338d0a69">Implémentation du modèle de contrôle RangeValue d’UI Automation</related>
      </Docs>
    </Member>
    <Member MemberName="Minimum">
      <MemberSignature Language="C#" Value="public double Minimum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Minimum" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Provider.IRangeValueProvider.Minimum" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Minimum As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Minimum { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Minimum : double" Usage="System.Windows.Automation.Provider.IRangeValueProvider.Minimum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur de plage minimale prise en charge par le contrôle.</summary>
        <value>La valeur minimale prise en charge par le contrôle ou nul (<see langword="Nothing" /> en Visual Basic) si le contrôle ne prend pas en charge <see cref="P:System.Windows.Automation.Provider.IRangeValueProvider.Minimum" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant illustre une implémentation de cette méthode pour un contrôle qui a une valeur minimale de 0.0.  
  
 [!code-csharp[UIAIRangeValueProvider_snip#Minimum](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAIRangeValueProvider_snip/CSharp/RangeValueFragment.cs#minimum)]
 [!code-vb[UIAIRangeValueProvider_snip#Minimum](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAIRangeValueProvider_snip/visualbasic/rangevaluefragment.vb#minimum)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Automation.Provider.IRangeValueProvider.Maximum" />
        <related type="Article" href="https://msdn.microsoft.com/library/225feaa4-918e-418b-938e-7389338d0a69">Implémentation du modèle de contrôle RangeValue d’UI Automation</related>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.IRangeValueProvider.SetValue(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(double value);" />
      <MemberSignature Language="F#" Value="abstract member SetValue : double -&gt; unit" Usage="iRangeValueProvider.SetValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à définir.</param>
        <summary>Définit la valeur du contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ensemble de la valeur réelle dépend de l’implémentation du contrôle. Le contrôle peut arrondir demandé `value` démarré ou arrêté.  
  
   
  
## Examples  
 L’exemple suivant montre une implémentation possible de cette méthode pour un contrôle personnalisé. Le contrôle personnalisé affiche sa valeur de plage par la valeur alpha de sa couleur de base.  
  
 [!code-csharp[UIAIRangeValueProvider_snip#SetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAIRangeValueProvider_snip/CSharp/RangeValueFragment.cs#setvalue)]
 [!code-vb[UIAIRangeValueProvider_snip#SetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAIRangeValueProvider_snip/visualbasic/rangevaluefragment.vb#setvalue)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Quand <paramref name="value" /> est inférieure à la valeur minimale ou supérieure à la valeur maximale du contrôle.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/225feaa4-918e-418b-938e-7389338d0a69">Implémentation du modèle de contrôle RangeValue d’UI Automation</related>
      </Docs>
    </Member>
    <Member MemberName="SmallChange">
      <MemberSignature Language="C#" Value="public double SmallChange { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 SmallChange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Provider.IRangeValueProvider.SmallChange" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SmallChange As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double SmallChange { double get(); };" />
      <MemberSignature Language="F#" Value="member this.SmallChange : double" Usage="System.Windows.Automation.Provider.IRangeValueProvider.SmallChange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur qui est ajoutée à ou soustraite de la <see cref="P:System.Windows.Automation.Provider.IRangeValueProvider.Value" /> propriété lorsqu’une petite modification est effectuée, par exemple avec une touche de direction.</summary>
        <value>La valeur SmallChange ou null (<see langword="Nothing" /> en Visual Basic) si le contrôle ne prend pas en charge <see cref="P:System.Windows.Automation.Provider.IRangeValueProvider.SmallChange" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant illustre une implémentation de cette méthode pour un contrôle qui a une petite modification valeur de 1.0.  
  
 [!code-csharp[UIAIRangeValueProvider_snip#SmallChange](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAIRangeValueProvider_snip/CSharp/RangeValueFragment.cs#smallchange)]
 [!code-vb[UIAIRangeValueProvider_snip#SmallChange](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAIRangeValueProvider_snip/visualbasic/rangevaluefragment.vb#smallchange)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Automation.Provider.IRangeValueProvider.LargeChange" />
        <related type="Article" href="https://msdn.microsoft.com/library/225feaa4-918e-418b-938e-7389338d0a69">Implémentation du modèle de contrôle RangeValue d’UI Automation</related>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public double Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Value" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Provider.IRangeValueProvider.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Value { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : double" Usage="System.Windows.Automation.Provider.IRangeValueProvider.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du contrôle.</summary>
        <value>La valeur de contrôle ou nul (<see langword="Nothing" /> en Visual Basic) si le contrôle ne prend pas en charge <see cref="P:System.Windows.Automation.Provider.IRangeValueProvider.Value" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant illustre une implémentation de cette méthode pour un contrôle personnalisé. Dans le cadre de cet exemple, le contrôle personnalisé affiche la valeur via le paramètre alpha de sa couleur de base.  
  
 [!code-csharp[UIAIRangeValueProvider_snip#Value](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAIRangeValueProvider_snip/CSharp/RangeValueFragment.cs#value)]
 [!code-vb[UIAIRangeValueProvider_snip#Value](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAIRangeValueProvider_snip/visualbasic/rangevaluefragment.vb#value)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Automation.Provider.IRangeValueProvider.SetValue(System.Double)" />
        <related type="Article" href="https://msdn.microsoft.com/library/225feaa4-918e-418b-938e-7389338d0a69">Implémentation du modèle de contrôle RangeValue d’UI Automation</related>
      </Docs>
    </Member>
  </Members>
</Type>